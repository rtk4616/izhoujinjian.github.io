<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>๑Charles✦ˑ̫✦Vincent๑</title>
  
  <subtitle>๑Charles✦ˑ̫✦Vincent๑</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zhoujinjian.cc/"/>
  <updated>2018-07-06T12:45:35.162Z</updated>
  <id>http://zhoujinjian.cc/</id>
  
  <author>
    <name>๑Charles✦ˑ̫✦Vincent๑</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>zhoujinjian.cc-Android系列分析文档【➺置顶➺】</title>
    <link href="http://zhoujinjian.cc/2088/08/08/zhoujinjian.cc-Android%E7%B3%BB%E5%88%97%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3%E3%80%90%E2%9E%BA%E7%BD%AE%E9%A1%B6%E2%9E%BA%E3%80%91/"/>
    <id>http://zhoujinjian.cc/2088/08/08/zhoujinjian.cc-Android系列分析文档【➺置顶➺】/</id>
    <published>2088-08-08T00:08:08.080Z</published>
    <updated>2018-07-06T12:45:35.162Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Android-Multimedia-System："><a href="#Android-Multimedia-System：" class="headerlink" title="Android Multimedia System："></a>Android Multimedia System：</h4><p><a href="http://zhoujinjian.cc/2018/09/06/Android%20Video%20System%EF%BC%884%EF%BC%89%EF%BC%9AAndroid%20Multimedia%20-%20OpenMax%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/">Android Video System（4）：Android Multimedia - OpenMax实现分析</a><br><a href="http://zhoujinjian.cc/2018/06/18/Android%20Video%20System%EF%BC%883%EF%BC%89%EF%BC%9A%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6Recorder%E3%80%81%E7%BC%96%E7%A0%81Encoder%E3%80%81%E6%B7%B7%E5%90%88MediaMuxer%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Android Video System（3）：音视频录制Recorder、编码Encoder、混合MediaMuxer源码分析</a><br><a href="http://zhoujinjian.cc/2018/06/06/Android%20Video%20System%EF%BC%882%EF%BC%89%EF%BC%9A%E9%9F%B3%E8%A7%86%E9%A2%91%E5%88%86%E7%A6%BBMediaExtractor%E3%80%81%E8%A7%A3%E7%A0%81Decoder%E3%80%81%E6%B8%B2%E6%9F%93Renderer%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Android Video System（2）：音视频分离MediaExtractor、解码Decoder、渲染Renderer源码分析</a><br><a href="http://zhoujinjian.cc/2018/06/01/Android%20Video%20System%EF%BC%881%EF%BC%89%EF%BC%9AVideo%20System[%E8%A7%86%E9%A2%91%E7%B3%BB%E7%BB%9F]%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/">Android Video System（1）：Video System(视频系统)框架分析</a></p><h4 id="Android-Camera-System："><a href="#Android-Camera-System：" class="headerlink" title="Android Camera System："></a>Android Camera System：</h4><p><a href="http://zhoujinjian.cc/2018/07/10/Android%20Camera%20System%EF%BC%882%EF%BC%89%EF%BC%9ACamera%20System[Camera%20%E7%B3%BB%E7%BB%9F]startPreview%E3%80%81takePicture%E3%80%81Recorder%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/">Android Camera System（2）：Camera System(Camera 系统)startPreview、takePicture、Recorder流程分析</a><br><a href="http://zhoujinjian.cc/2018/06/30/Android%20Camera%20System%EF%BC%881%EF%BC%89%EF%BC%9ACamera%20System(Camera%20%E7%B3%BB%E7%BB%9F">Android Camera System（1）：Camera System(Camera 系统)框架、Open()过程分析</a>%E6%A1%86%E6%9E%B6%E3%80%81Open%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/)</p><h4 id="Android-Display-System："><a href="#Android-Display-System：" class="headerlink" title="Android Display System："></a>Android Display System：</h4><p><a href="http://zhoujinjian.cc/2018/08/30/Android%20Display%20System%EF%BC%885%EF%BC%89%EF%BC%9AAndroid%20Display%20System%20%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B9%8BDisplay%20Driver%20Architecture/">Android Display System（5）：Android Display System 系统分析之Display Driver Architecture</a><br><a href="http://zhoujinjian.cc/2018/08/16/Android%20Display%20System%EF%BC%884%EF%BC%89%EF%BC%9AAndroid%20Display%20System%20%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B9%8BGralloc%20&amp;&amp;%20HWComposer%E6%A8%A1%E5%9D%97%E5%88%86%E6%9E%90/">Android Display System（4）：Android Display System 系统分析之Gralloc &amp;&amp; HWComposer模块分析</a><br><a href="http://zhoujinjian.cc/2018/08/01/Android%20Display%20System%EF%BC%883%EF%BC%89%EF%BC%9AAndroid%20Display%20System%20%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B9%8BHardwareRenderer.draw%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/">Android Display System（3）：Android Display System 系统分析之HardwareRenderer.draw()绘制流程分析</a><br><a href="http://zhoujinjian.cc/2018/07/20/Android%20Display%20System%EF%BC%882%EF%BC%89%EF%BC%9AAndroid%20Display%20System%20%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B9%8BAndroid%20EGL%20&amp;&amp;%20OpenGL/">Android Display System（2）：Android Display System 系统分析之Android EGL &amp;&amp; OpenGL</a><br><a href="http://zhoujinjian.cc/2018/02/01/Android-7-1-2-Android-N-Android-Graphics-%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/">Android Display System（1）：Android 7.1.2 (Android N) Android Graphics 系统 分析</a></p><h4 id="Android-Audio-System："><a href="#Android-Audio-System：" class="headerlink" title="Android Audio System："></a>Android Audio System：</h4><p><a href="http://zhoujinjian.cc/2018/05/25/Audio%20System%EF%BC%883%EF%BC%89%EF%BC%9AAndroid%20audio%20system(%E9%9F%B3%E9%A2%91%E7%B3%BB%E7%BB%9F">Android Audio System（3）：Android audio system(音频系统)分析</a>%E5%88%86%E6%9E%90/)<br><a href="http://zhoujinjian.cc/2018/05/15/Audio%20System%EF%BC%882%EF%BC%89%EF%BC%9ALinux%20ALSA%E9%9F%B3%E9%A2%91%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/">Android Audio System（2）：Linux ALSA音频系统分析</a><br><a href="http://zhoujinjian.cc/2018/05/01/Audio%20System%EF%BC%881%EF%BC%89%EF%BC%9ALinux%20&amp;&amp;%20Android%20Audio%20%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/">Android Audio System（1）：Linux &amp;&amp; Android Audio 系统框架分析</a></p><h4 id="Android-Input-System："><a href="#Android-Input-System：" class="headerlink" title="Android Input System："></a>Android Input System：</h4><p><a href="http://zhoujinjian.cc/2017/12/01/Android-7-1-2-Android-N-Android-%E8%BE%93%E5%85%A5%E5%AD%90%E7%B3%BB%E7%BB%9F-Input-System/">Android Input System（2）：Android 7.1.2 (Android N) Android 输入子系统 - Input System 分析</a><br><a href="http://zhoujinjian.cc/2018/04/01/Linux%E5%86%85%E6%A0%B8%EF%BC%88Kernel-3-18%EF%BC%89-Input-%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90-i-wonder/">Android Input System（1）：Linux内核（Kernel-3.18） - Linux Input 子系统 分析 </a></p><h4 id="Android-基础（AMS-amp-WMS）"><a href="#Android-基础（AMS-amp-WMS）" class="headerlink" title="Android 基础（AMS &amp; WMS）"></a>Android 基础（AMS &amp; WMS）</h4><p><a href="http://zhoujinjian.cc/2018/03/01/Android-7-1-2-Android-N-Android-WindowManagerService-%E7%AA%97%E5%8F%A3%E7%AE%A1%E7%90%86%E6%9C%8D%E5%8A%A1%E5%88%86%E6%9E%90-i-wonder/">Android基础 （6）：Android 7.1.2 (Android N) Android WindowManagerService 窗口管理服务 分析</a><br><a href="http://zhoujinjian.cc/2017/11/01/Android-7-1-2-Android-N-Activity-Window%E5%8A%A0%E8%BD%BD%E6%98%BE%E7%A4%BA%E6%B5%81%E7%A8%8B/">Android基础 （5）：Android 7.1.2 (Android N) Activity - Window 加载显示流程 分析</a><br><a href="http://zhoujinjian.cc/2017/10/01/Android-7-1-2-Android-N-Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/">Android基础 （4）：Android 7.1.2 (Android N) Activity 启动流程 （AMS）分析</a><br><a href="http://zhoujinjian.cc/2017/09/01/Android-7-1-2-Android-N-Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">Android基础 （3）：Android 7.1.2 (Android N) Android 系统启动流程 分析</a><br><a href="http://zhoujinjian.cc/2018/01/01/Android-7-1-2-Android-N-Android-Binder%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/">Android基础 （2）：Android 7.1.2 (Android N) Android Binder 系统分析</a><br><a href="http://zhoujinjian.cc/2017/08/01/Android-7-1-2-Android-N-Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E2%80%93Handler%E3%80%81Looper%E3%80%81Message/">Android基础 （1）：Android 7.1.2 (Android N) Android消息机制–Handler、Looper、Message 分析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Android-Multimedia-System：&quot;&gt;&lt;a href=&quot;#Android-Multimedia-System：&quot; class=&quot;headerlink&quot; title=&quot;Android Multimedia System：&quot;&gt;&lt;/a&gt;Android 
      
    
    </summary>
    
      <category term="Android" scheme="http://zhoujinjian.cc/categories/Android/"/>
    
    
      <category term="Android" scheme="http://zhoujinjian.cc/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android Video System（4）：Android Multimedia - OpenMax实现分析</title>
    <link href="http://zhoujinjian.cc/2018/09/06/Android%20Video%20System%EF%BC%884%EF%BC%89%EF%BC%9AAndroid%20Multimedia%20-%20OpenMax%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"/>
    <id>http://zhoujinjian.cc/2018/09/06/Android Video System（4）：Android Multimedia - OpenMax实现分析/</id>
    <published>2018-09-05T16:00:00.000Z</published>
    <updated>2018-07-06T12:27:52.098Z</updated>
    
    <content type="html"><![CDATA[<hr><p>注：文章都是通过阅读各位前辈总结的资料 Android 7.1.2 &amp;&amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除，禁止转载（©Qualcomm Technologies, Inc. 版权所有），谢谢。</p><p><a href="https://github.com/izhoujinjian/zhoujinjian.cc/tree/master/video.system" target="_blank" rel="noopener">【博客原图链接】</a><br><a href="http://windrunnerlihuan.com/categories/Android%E6%8A%80%E6%9C%AF%E7%82%B9/page/2/" target="_blank" rel="noopener">【特别感谢 -  Copy Windrunnerlihuan（OpenMax分析）】</a><br><a href="https://blog.csdn.net/dfhuang09/article/details/60132620" target="_blank" rel="noopener">【特别感谢 -  Android MediaCodec ACodec】</a><br><a href="https://blog.csdn.net/dfhuang09/article/details/54926526" target="_blank" rel="noopener">【特别感谢 -  android ACodec MediaCodec NuPlayer flow】</a></p><p>Google Pixel、Pixel XL 内核代码（文章基于 Kernel-3.18）：<br> <a href="https://github.com/matthewdalex/marlin" target="_blank" rel="noopener">Kernel source for Pixel and Pixel XL - GitHub</a></p><p>AOSP 源码（文章基于 Android 7.1.2）：<br> <a href="https://testerhome.com/topics/2229" target="_blank" rel="noopener"> Android 系统全套源代码分享 (更新到 8.1.0_r1)</a></p><hr><p>☯ \hardware\qcom\media\msm8996\libstagefrighthw</p><ul><li>QComOMXPlugin.cpp</li><li>QComOMXMetadata.h</li><li>QComOMXPlugin.h</li></ul><p>☯  \hardware\qcom\media\msm8996\mm-video-v4l2\vidc</p><p>☯ \hardware\qcom\media\msm8996\mm-core</p><hr><h4 id="（一）、OpenMax简介"><a href="#（一）、OpenMax简介" class="headerlink" title="（一）、OpenMax简介"></a>（一）、OpenMax简介</h4><p>  android中的 NuPlayer就是用OpenMax来做(codec)编解码的，本节就主要科普一下OpenMax和它在Android系统中扮演的角色。</p><h5 id="1-1、-OpenMax系统的结构"><a href="#1-1、-OpenMax系统的结构" class="headerlink" title="1.1、 OpenMax系统的结构"></a>1.1、 OpenMax系统的结构</h5><h6 id="1-1-1、OpenMax总体层次结构"><a href="#1-1-1、OpenMax总体层次结构" class="headerlink" title="1.1.1、OpenMax总体层次结构"></a>1.1.1、OpenMax总体层次结构</h6><p> OpenMax是一个多媒体应用程序的框架标准，由NVIDIA公司和Khronos在2006年推出。</p><p> OpenMax是无授权费的，跨平台的应用程序接口API，通过使媒体加速组件能够在开发、集成和编程环节中实现跨多操作系统和处理器硬件平台，提供全面的流媒体编解码器和应用程序便携化。</p><p>OpenMax的官方网站如下所示：<br>       <a href="http://www.khronos.org/openmax/" target="_blank" rel="noopener">http://www.khronos.org/openmax/</a><br>OpenMax实际上分成三个层次，自上而下分别是，OpenMax DL（开发层），OpenMax IL（集成层）和OpenMax AL（应用层）。三个层次的内容分别如下所示：</p><blockquote><p>第一层：OpenMax DL（Development Layer，开发层）<br>        OpenMax DL定义了一个API，它是音频、视频和图像功能的集合。供应商能够在一个新的处理器上实现并优化，然后编解码供应商使用它来编写更广泛的编解码器功能。它包括音频信号的处理功能，如FFT和filter，图像原始处理，如颜色空间转换、视频原始处理，以实现例如MPEG-4、H.264、MP3、AAC和JPEG等编解码器的优化。</p><p>第二层：OpenMax IL（Integration Layer，集成层）<br>       OpenMax IL作为音频、视频和图像编解码器能与多媒体编解码器交互，并以统一的行为支持组件（例如，资源和皮肤）。这些编解码器或许是软硬件的混合体，对用户是透明的底层接口应用于嵌入式、移动设备。它提供了应用程序和媒体框架，透明的。编解码器供应商必须写私有的或者封闭的接口，集成进移动设备。IL的主要目的是使用特征集合为编解码器提供一个系统抽象，为解决多个不同媒体系统之间轻便性的问题。</p><p>第三层：OpenMax AL（Appliction Layer，应用层）<br>       OpenMax AL API在应用程序和多媒体中间件之间提供了一个标准化接口，多媒体中间件提供服务以实现被期待的API功能。</p></blockquote><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/VS-04-01-openmaxsystem.png" alt="Alt text | center"></p><p>OpenMax API将会与处理器一同提供，以<strong>使库和编解码器开发者能够高速有效地利用新器件的完整加速潜能，无须担心其底层的硬件结构。</strong>该标准是针对嵌入式设备和移动设备的多媒体软件架构。在架构底层上为多媒体的编解码和数据处理定义了一套统一的编程接口，对多媒体数据的处理功能进行系统级抽象，为用户屏蔽了底层的细节。因此，<strong>多媒体应用程序和多媒体框架通过OpenMax IL可以以一种统一的方式来使用编解码和其他多媒体数据处理功能，具有了跨越软硬件平台的移植性。</strong></p><p>注：在实际的应用中，OpenMax的三个层次中使用较多的是OpenMax IL集成层，由于操作系统到硬件的差异和多媒体应用的差异，OpenMax的DL和AL层使用相对较少。</p><h6 id="1-1-2、OpenMax-IL简介"><a href="#1-1-2、OpenMax-IL简介" class="headerlink" title="1.1.2、OpenMax IL简介"></a>1.1.2、OpenMax IL简介</h6><p>OpenMax IL 处在中间层的位置，OpenMAX IL 作为音频，视频和图像编解码器 能与多媒体编解码器交互，并以统一的行为支持组件（例如资源和皮肤）。这些编解码器或许是软硬件的混合体，对用户是 的底层接口应用于嵌入式或 / 和移动设备。它提供了应用程序和媒体框架， 透明的。本质上不存在这种标准化的接口，编解码器供 应商必须写私有的或者封闭的接口，集成进移动设备。 IL 的主要目的 是使用特征集合为编解码器提供一个系统抽象，为解决多个不同媒体系统之间轻便性的问题。<br>       OpenMax IL 的目的就是为硬件平台的图形及音视频提供一个抽象层，可以为上层的应用提供一个可跨平台的支撑。这一点对于跨平台的媒体应用来说十分重要。本人也接触过几家高清解码芯片，这些芯片底层的音视频接口虽然功能上大致相同，但是接口设计及用法上各有不同，而且相差很多。你要想让自己开发的媒体应用完美的运行在不同的硬件厂商平台上，就得适应不同芯片的底层解码接口。这个对于应用开发来说十分繁琐。所以就需要类似于OpenMax IL 这种接口规范。应用假如涉及到音视频相关功能时，只需调用这些标准的接口，而不需要关心接口下方硬件相关的实现。假如换了硬件平台时，只需要把接口层与硬件适配好了就行了。上层应用不需要频繁改动。<br>       你可以把OpenMax IL 看作是中间件中的porting层接口，但是现在中间件大部分都是自家定义自己的。</p><p>OpenMax 想做的就是定义一个这样的行业标准，这样媒体应用、硬件厂商都遵循这种标准。硬件厂商将OpenMax 与处理器一并提供，上层的多媒体框架想要用到硬件音视频加速功能时，只需遵循openmax的接口就可以扩平台运行。<br>       可喜的，现在越来越多的多媒体框架及多媒体应用正在遵循openmax标准，包括各种知名的媒体开源软件。越来越多的芯片厂商也在遵循openmax的标准。对于现在的音视频编解码来说，分辨率越来越高，需要芯片提供硬件加速功能是个大的趋势。我相信 接口的标准化是一定要走的。如下图所示， openmax IL在多媒体框架中的应用：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/VS-04-02-openmaxuse.png" alt="Alt text | center"></p><p><strong>OpenMax IL目前已经成为了事实上的多媒体框架标准。</strong>嵌入式处理器或者多媒体编解码模块的硬件生产者，通常提供标准的OpenMax IL层的软件接口，这样软件的开发者就可以基于这个层次的标准化接口进行多媒体程序的开发。</p><p> OpenMax IL的接口层次结构适中，既不是硬件编解码的接口，也不是应用程序层的接口，因此比较容易实现标准化。OpenMax IL的层次结构如下：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/VS-04-03-openmaxIL.png" alt="Alt text | center"></p><p>图中的虚线中的内容是OpenMax IL层的内容，其主要实现了OpenMax IL中的各个组件（Component）。<strong>对下层，OpenMax IL可以调用OpenMax DL层的接口，也可以直接调用各种Codec实现。对上层，OpenMax IL可以给OpenMax AL 层等框架层（Middleware）调用，也可以给应用程序直接调用。</strong></p><h6 id="1-1-3、OpenMax-IL结构"><a href="#1-1-3、OpenMax-IL结构" class="headerlink" title="1.1.3、OpenMax IL结构"></a>1.1.3、OpenMax IL结构</h6><p>OpenMax IL主要内容如下所示。</p><p>☯ 客户端（Client）：OpenMax IL的调用者<br>☯ 组件（Component）：OpenMax IL的单元，每一个组件实现一种功能<br>☯ 端口（Port）：组件的输入输出接口<br>☯ 隧道化（Tunneled）：让两个组件直接连接的方式<br>       OpenMax IL的基本运作过程如图所示：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/VS-04-04-openmaxilbase.png" alt="Alt text | center"></p><p>OpenMAL IL的客户端，通过调用四个OpenMAL IL组件，实现了一个功能。四个组件分别是Source组件、Host组件、Accelerator组件和Sink组件。Source组件只有一个输出端口；而Host组件有一个输入端口和一个输出端口；Accelerator组件具有一个输入端口，调用了硬件的编解码器，加速主要体现在这个环节上。Accelerator组件和Sink组件通过私有通讯方式在内部进行连接，没有经过明确的组件端口。<br>       OpenMAL IL在使用的时候，其数据流也有不同的处理方式：既可以经由客户端，也可以不经由客户端。图中Source组件到Host组件的数据流就是经过客户端的；而Host组件到Accelerator组件的数据流就没有经过客户端，使用了隧道化的方式；Accelerator组件和Sink组件甚至可以使用私有的通讯方式。</p><p>   OpenMax Core是辅助各个组件运行的部分，它通常需要完成各个组件的初始化等工作，在真正运行过程中，重点是各个OpenMax IL的组件，OpenMax Core不是重点，也不是标准。</p><p> OpenMAL IL的组件是OpenMax IL实现的核心内容，一个组件以输入、输出端口为接口，端口可以被连接到另一个组件上。外部对组件可以发送命令，还进行设置/获取参数、配置等内容。组件的端口可以包含缓冲区（Buffer）的队列。</p><p>组件的处理的核心内容是：通过输入端口消耗Buffer，通过输出端口填充Buffer，由此多组件相联接可以构成流式的处理。OpenMAL IL中一个组件的结构如下图所示：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/VS-04-05-openilinternal.jpg" alt="Alt text | center"></p><pre><code>组件的功能和其定义的端口类型密切相关，通常情况下：只有一个输出端口的，为Source组件；只有一个输入端口的，为Sink组件；有多个输入端口，一个输出端口的为Mux组件；有一个输入端口，多个输出端口的为DeMux组件；输入输出端口各一个组件的为中间处理环节，这是最常见的组件。</code></pre><p>  端口具体支持的数据也有不同的类型。例如，对于一个输入、输出端口各一个组件，其输入端口使用MP3格式的数据，输出端口使用PCM格式的数据，那么这个组件就是一个MP3解码组件。</p><p>  隧道化（Tunneled）是一个关于组件连接方式的概念。通过隧道化可以将不同的组件的一个输入端口和一个输出端口连接到一起，在这种情况下，两个组件的处理过程合并，共同处理。尤其对于单输入和单输出的组件，两个组件将作为类似一个使用。</p><h5 id="1-2、Android中的OpenMax"><a href="#1-2、Android中的OpenMax" class="headerlink" title="1.2、Android中的OpenMax"></a>1.2、Android中的OpenMax</h5><h6 id="1-2-1、OpenMax在Android中的使用情况"><a href="#1-2-1、OpenMax在Android中的使用情况" class="headerlink" title="1.2.1、OpenMax在Android中的使用情况"></a>1.2.1、OpenMax在Android中的使用情况</h6><p>  在Android中，OpenMax IL层，<strong>通常可以用于多媒体引擎的插件</strong>，Android的多媒体引擎OpenCore和StageFright都可以使用OpenMax作为插件，主要用于<strong>编解码（Codec）</strong>处理。<br>  在Android的框架层，也定义了由Android封装的OpenMax接口，和标准的接口概念基本相同，但是使用C++类型的接口，并且使用了Android的Binder IPC机制。Android封装OpenMax的接口被StageFright使用，OpenCore没有使用这个接口，而是使用其他形式对OpenMax IL层接口进行封装。Android OpenMax的基本层次结构如图：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/VS-04-06-openmaxinandroid.jpg" alt="Alt text | center"></p><p>Android系统的一些部分对OpenMax IL层进行使用，基本使用的是标准OpenMax IL层的接口，只是进行了简单的封装。标准的OpenMax IL实现很容易以插件的形式加入到Android系统中。</p><p>Android的多媒体引擎OpenCore和StageFright都可以使用OpenMax作为多媒体编解码的插件，只是没有直接使用OpenMax IL层提供的纯C接口，而是对其进行了一定的封装(C++封装)。</p><p>在Android2.x版本之后，Android的框架层也对OpenMax IL层的接口进行了封装定义，甚至使用Android中的Binder IPC机制。Stagefright使用了这个层次的接口，OpenCore没有使用。</p><p>注：OpenCore使用OpenMax IL层作为编解码插件在前，Android框架层封装OpenMax接口在后面的版本中才引入。</p><h6 id="1-2-2、Android-OpenMax实现的内容"><a href="#1-2-2、Android-OpenMax实现的内容" class="headerlink" title="1.2.2、Android OpenMax实现的内容"></a>1.2.2、Android OpenMax实现的内容</h6><p>   android中的 AwesomePlayer就是用openmax来做(Codec)编解码,其实在openmax接口设计中，他不光能用来当编解码。通过他的组件可以组成一个完整的播放器，包括sourc、demux、decode、output。但是为什么android只用他来做code呢？应该有如下方面：</p><p>☯    1.在整个播放器中，解码器不得不说是最重要的一部分，而且也是最耗资源的一块。如果全靠软解，直接通过cpu来运算，特别是高清视频。别的事你就可以啥都不干了。所以解码器是最需要硬件提供加速的部分。现在的高清解码芯片都是主芯片+DSP结构，解码的工作都是通过DSP来做，不会在过多的占用主芯片。所有将芯片中DSP硬件编解码的能力通过openmax标准接口呈现出来，提供上层播放器来用。我认为这块是openmax最重要的意义。<br>☯    2.source 主要是和协议打交道，demux 分解容器部分，大多数的容器格式的分解是不需要通过硬件来支持。只是ts流这种格式最可能用到硬件的支持。因为ts格式比较特殊，单包的大小太小了，只有188字节。所以也是为什么现在常见的解码芯片都会提供硬件ts demux 的支持。<br>☯   3.音视频输出部分video\audio output 这块和操作系统关系十分紧密。可以看看著名开源播放器vlc。vlc 在mac、linux、Windows都有，功能上差别也不大。所以说他是跨平台的，他跨平台跨在哪？主要的工作量还是在音视频解码完之后的输出模块。因为各个系统的图像渲染和音频输出实现方法不同，所以vlc需要针对每个平台实现不同的output。这部分内容放在openmax来显然不合适。<br>       Android中使用的主要是OpenMax的编解码功能。虽然OpenMax也可以生成输入、输出、文件解析-构建等组件，但是在各个系统（不仅是Android）中使用的最多的还是编解码组件。媒体的输入、输出环节和系统的关系很大，引入OpenMax标准比较麻烦；文件解析-构建环节一般不需要使用硬件加速。编解码组件也是最能体现硬件加速的环节，因此最常使用。</p><h5 id="1-3、初窥适配层接口"><a href="#1-3、初窥适配层接口" class="headerlink" title="1.3、初窥适配层接口"></a>1.3、初窥适配层接口</h5><p>在Android中实现OpenMax IL层和标准的OpenMax IL层的方式基本，一般需要实现以下两个环节：</p><p>☯    编解码驱动程序：位于Linux内核空间，需要通过Linux内核调用驱动程序，通常使用非标准的驱动程序。<br>☯   OpenMax IL层：根据OpenMax IL层的标准头文件实现不同功能的组件。<br> <strong>Android中还提供了OpenMax的适配层接口（对OpenMax IL的标准组件进行封装适配）</strong>，它作为Android本地层的接口，可以被Android的多媒体引擎调用。上一篇文章末尾，初始化解码器核心调用的两个方法就是适配层的接口。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/VS-04-07-openmaxsult.jpg" alt="Alt text | center"></p><p>☯    1.上面已经说过了，android系统中只用openmax来做Codec，所以android向上抽象了一层OMXCodec，提供给上层播放器用。播放器中音视频解码器mVideosource、mAudiosource都是OMXCodec的实例。<br>☯    2.OMXCodec通过IOMX 依赖binder机制 获得 OMX服务，OMX服务 才是openmax 在android中 实现。<br>☯    3.OMX把软编解码和硬件编解码统一看作插件的形式管理起来。</p><h4 id="（二）、Android中OpenMax的实现-preview"><a href="#（二）、Android中OpenMax的实现-preview" class="headerlink" title="（二）、Android中OpenMax的实现(preview)"></a>（二）、Android中OpenMax的实现(preview)</h4><h5 id="2-1、OpenMax的接口与实现"><a href="#2-1、OpenMax的接口与实现" class="headerlink" title="2.1、OpenMax的接口与实现"></a>2.1、OpenMax的接口与实现</h5><p>在Android中实现OpenMax IL层和标准的OpenMax IL层的方式基本，一般需要实现以下两个环节。</p><p>编解码驱动程序：位于Linux内核空间，需要通过Linux内核调用驱动程序，通常使用非标准的驱动程序。<br>OpenMax IL层：根据OpenMax IL层的标准头文件实现不同功能的组件。<br>       Android中还提供了OpenMax的适配层接口（对OpenMax IL的标准组件进行封装适配），它作为Android本地层的接口，可以被Android的多媒体引擎调用。</p><p>OpenMax IL层接口<br>       OpenMax IL层的接口定义由若干个头文件组成，这也是实现它需要实现的内容，位于frameworks/native/include/media/openmax下，它们的基本描述如下所示：</p><blockquote><p>OMX_Types.h：OpenMax Il的数据类型定义<br>OMX_Core.h：OpenMax IL核心的API<br>OMX_Component.h：OpenMax IL 组件相关的 API<br>OMX_Audio.h：音频相关的常量和数据结构<br>OMX_IVCommon.h：图像和视频公共的常量和数据结构<br>OMX_Image.h：图像相关的常量和数据结构<br>OMX_Video.h：视频相关的常量和数据结构<br>OMX_Other.h：其他数据结构（包括A/V 同步）<br>OMX_Index.h：OpenMax IL定义的数据结构索引<br>OMX_ContentPipe.h：内容的管道定义</p></blockquote><p>   <strong>提示：OpenMax标准只有头文件，没有标准的库，设置没有定义函数接口。对于实现者，需要实现的主要是包含函数指针的结构体。</strong></p><p>其中，OMX_Component.h中定义的OMX_COMPONENTTYPE结构体是OpenMax IL层的核心内容，表示一个组件，其内容如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/native/include/media/openmax/OMX_Component.h]</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">OMX_COMPONENTTYPE</span>    </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    OMX_U32 nSize;                          <span class="comment">/* 这个结构体的大小 */</span>    </span><br><span class="line">    OMX_VERSIONTYPE nVersion;           <span class="comment">/* 版本号 */</span>    </span><br><span class="line">    OMX_PTR pComponentPrivate;          <span class="comment">/* 这个组件的私有数据指针. */</span>    </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 调用者（IL client）设置的指针，用于保存它的私有数据，传回给所有的回调函数 */</span>    </span><br><span class="line">    OMX_PTR pApplicationPrivate;    </span><br><span class="line">    <span class="comment">/* 以下的函数指针返回OMX_core.h中的对应内容 */</span>    </span><br><span class="line">    OMX_ERRORTYPE (*GetComponentVersion)(<span class="comment">/* 获得组件的版本*/</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_OUT OMX_STRING pComponentName,    </span><br><span class="line">        OMX_OUT OMX_VERSIONTYPE* pComponentVersion,    </span><br><span class="line">        OMX_OUT OMX_VERSIONTYPE* pSpecVersion,    </span><br><span class="line">        OMX_OUT OMX_UUIDTYPE* pComponentUUID);    </span><br><span class="line">    OMX_ERRORTYPE (*SendCommand)(<span class="comment">/* 发送命令 */</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_IN  OMX_COMMANDTYPE Cmd,    </span><br><span class="line">        OMX_IN  OMX_U32 nParam1,    </span><br><span class="line">        OMX_IN  OMX_PTR pCmdData);    </span><br><span class="line">    OMX_ERRORTYPE (*GetParameter)(<span class="comment">/* 获得参数 */</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_IN  OMX_INDEXTYPE nParamIndex,    </span><br><span class="line">        OMX_INOUT OMX_PTR pComponentParameterStructure);    </span><br><span class="line">    OMX_ERRORTYPE (*SetParameter)(<span class="comment">/* 设置参数 */</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_IN  OMX_INDEXTYPE nIndex,    </span><br><span class="line">        OMX_IN  OMX_PTR pComponentParameterStructure);    </span><br><span class="line">    OMX_ERRORTYPE (*GetConfig)(<span class="comment">/* 获得配置 */</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_IN  OMX_INDEXTYPE nIndex,    </span><br><span class="line">        OMX_INOUT OMX_PTR pComponentConfigStructure);    </span><br><span class="line">    OMX_ERRORTYPE (*SetConfig)(<span class="comment">/* 设置配置 */</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_IN  OMX_INDEXTYPE nIndex,    </span><br><span class="line">        OMX_IN  OMX_PTR pComponentConfigStructure);    </span><br><span class="line">    OMX_ERRORTYPE (*GetExtensionIndex)(<span class="comment">/* 转换成OMX结构的索引 */</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_IN  OMX_STRING cParameterName,    </span><br><span class="line">        OMX_OUT OMX_INDEXTYPE* pIndexType);    </span><br><span class="line">    OMX_ERRORTYPE (*GetState)(<span class="comment">/* 获得组件当前的状态 */</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_OUT OMX_STATETYPE* pState);    </span><br><span class="line">    OMX_ERRORTYPE (*ComponentTunnelRequest)(<span class="comment">/* 用于连接到另一个组件*/</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComp,    </span><br><span class="line">        OMX_IN  OMX_U32 nPort,    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hTunneledComp,    </span><br><span class="line">        OMX_IN  OMX_U32 nTunneledPort,    </span><br><span class="line">        OMX_INOUT  OMX_TUNNELSETUPTYPE* pTunnelSetup);    </span><br><span class="line">    OMX_ERRORTYPE (*UseBuffer)(<span class="comment">/* 为某个端口使用Buffer */</span>    </span><br><span class="line">        OMX_IN OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_INOUT OMX_BUFFERHEADERTYPE** ppBufferHdr,    </span><br><span class="line">        OMX_IN OMX_U32 nPortIndex,    </span><br><span class="line">        OMX_IN OMX_PTR pAppPrivate,    </span><br><span class="line">        OMX_IN OMX_U32 nSizeBytes,    </span><br><span class="line">        OMX_IN OMX_U8* pBuffer);    </span><br><span class="line">    OMX_ERRORTYPE (*AllocateBuffer)(<span class="comment">/* 在某个端口分配Buffer */</span>    </span><br><span class="line">        OMX_IN OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_INOUT OMX_BUFFERHEADERTYPE** ppBuffer,    </span><br><span class="line">        OMX_IN OMX_U32 nPortIndex,    </span><br><span class="line">        OMX_IN OMX_PTR pAppPrivate,    </span><br><span class="line">        OMX_IN OMX_U32 nSizeBytes);    </span><br><span class="line">    OMX_ERRORTYPE (*FreeBuffer)(<span class="comment">/*将某个端口Buffer释放*/</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_IN  OMX_U32 nPortIndex,    </span><br><span class="line">        OMX_IN  OMX_BUFFERHEADERTYPE* pBuffer);    </span><br><span class="line">    OMX_ERRORTYPE (*EmptyThisBuffer)(<span class="comment">/* 让组件消耗这个Buffer */</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_IN  OMX_BUFFERHEADERTYPE* pBuffer);    </span><br><span class="line">    OMX_ERRORTYPE (*FillThisBuffer)(<span class="comment">/* 让组件填充这个Buffer */</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_IN  OMX_BUFFERHEADERTYPE* pBuffer);    </span><br><span class="line">    OMX_ERRORTYPE (*SetCallbacks)(<span class="comment">/* 设置回调函数 */</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_IN  OMX_CALLBACKTYPE* pCallbacks,    </span><br><span class="line">        OMX_IN  OMX_PTR pAppData);    </span><br><span class="line">    OMX_ERRORTYPE (*ComponentDeInit)(<span class="comment">/* 反初始化组件 */</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent);    </span><br><span class="line">    OMX_ERRORTYPE (*UseEGLImage)(    </span><br><span class="line">        OMX_IN OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_INOUT OMX_BUFFERHEADERTYPE** ppBufferHdr,    </span><br><span class="line">        OMX_IN OMX_U32 nPortIndex,    </span><br><span class="line">        OMX_IN OMX_PTR pAppPrivate,    </span><br><span class="line">        OMX_IN <span class="keyword">void</span>* eglImage);    </span><br><span class="line">    OMX_ERRORTYPE (*ComponentRoleEnum)(    </span><br><span class="line">        OMX_IN OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_OUT OMX_U8 *cRole,    </span><br><span class="line">        OMX_IN OMX_U32 nIndex);    </span><br><span class="line">&#125; OMX_COMPONENTTYPE;</span><br></pre></td></tr></table></figure><p>☯    1）EmptyThisBuffer和FillThisBuffer是驱动组件运行的基本的机制，前者表示让组件消耗缓冲区，表示对应组件输入的内容；后者表示让组件填充缓冲区，表示对应组件输出的内容。<br>☯    2）UseBuffer，AllocateBuffer，FreeBuffer为和端口相关的缓冲区管理函数，对于组件的端口有些可以自己分配缓冲区，有些可以使用外部的缓冲区，因此有不同的接口对其进行操作。<br>☯    3）SendCommand表示向组件发送控制类的命令。GetParameter，SetParameter，GetConfig，SetConfig几个接口用于辅助的参数和配置的设置和获取。<br>☯     4）ComponentTunnelRequest用于组件之间的隧道化连接，其中需要制定两个组件及其相连的端口。<br>☯     5）ComponentDeInit用于组件的反初始化。</p><p>OMX_COMPONENTTYPE结构体实现后，其中的各个函数指针就是调用者可以使用的内容。各个函数指针和OMX_core.h中定义的内容相对应。</p><p>提示：OpenMax函数的参数中，经常包含OMX_IN和OMX_OUT等宏，它们的实际内容为空，只是为了标记参数的方向是输入还是输出。</p><p>OMX_Component.h中端口类型的定义为OMX_PORTDOMAINTYPE枚举类型，内容如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> OMX_PORTDOMAINTYPE &#123;   </span><br><span class="line">    OMX_PortDomainAudio,        <span class="comment">/* 音频类型端口 */</span>   </span><br><span class="line">    OMX_PortDomainVideo,        <span class="comment">/* 视频类型端口 */</span>   </span><br><span class="line">    OMX_PortDomainImage,        <span class="comment">/* 图像类型端口 */</span>   </span><br><span class="line">    OMX_PortDomainOther,        <span class="comment">/* 其他类型端口 */</span>   </span><br><span class="line">    OMX_PortDomainKhronosExtensions = <span class="number">0x6F000000</span>,   <span class="comment">//为Khronos标准预留宽展</span></span><br><span class="line">    OMX_PortDomainVendorStartUnused = <span class="number">0x7F000000</span>    <span class="comment">//为厂商预留扩展</span></span><br><span class="line">    OMX_PortDomainMax = <span class="number">0x7ffffff</span>  </span><br><span class="line">&#125; OMX_PORTDOMAINTY</span><br></pre></td></tr></table></figure><p>音频类型，视频类型，图像类型，其他类型是OpenMax IL层此所定义的四种端口的类型。</p><p>端口具体内容的定义使用OMX_PARAM_PORTDEFINITIONTYPE类（也在OMX_Component.h中定义）来表示，其内容如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">OMX_PARAM_PORTDEFINITIONTYPE</span> &#123;</span>   </span><br><span class="line">    OMX_U32 nSize;                      <span class="comment">/* 结构体大小 */</span>   </span><br><span class="line">    OMX_VERSIONTYPE nVersion;           <span class="comment">/* 版本*/</span>   </span><br><span class="line">    OMX_U32 nPortIndex;             <span class="comment">/* 端口号 */</span>   </span><br><span class="line">    OMX_DIRTYPE eDir;                   <span class="comment">/* 端口的方向 */</span>   </span><br><span class="line">    OMX_U32 nBufferCountActual;         <span class="comment">/* 为这个端口实际分配的Buffer的数目 */</span>   </span><br><span class="line">    OMX_U32 nBufferCountMin;            <span class="comment">/* 这个端口最小Buffer的数目*/</span>   </span><br><span class="line">    OMX_U32 nBufferSize;                <span class="comment">/* 缓冲区的字节数 */</span>   </span><br><span class="line">    OMX_BOOL bEnabled;                  <span class="comment">/* 是否使能 */</span>   </span><br><span class="line">    OMX_BOOL bPopulated;                <span class="comment">/* 是否在填充 */</span>   </span><br><span class="line">    OMX_PORTDOMAINTYPE eDomain;         <span class="comment">/* 端口的类型 */</span>   </span><br><span class="line">    <span class="keyword">union</span> &#123;                         <span class="comment">/* 端口实际的内容，由类型确定具体结构 */</span>   </span><br><span class="line">        OMX_AUDIO_PORTDEFINITIONTYPE audio;   </span><br><span class="line">        OMX_VIDEO_PORTDEFINITIONTYPE video;   </span><br><span class="line">        OMX_IMAGE_PORTDEFINITIONTYPE image;   </span><br><span class="line">        OMX_OTHER_PORTDEFINITIONTYPE other;   </span><br><span class="line">    &#125; format;   </span><br><span class="line">    OMX_BOOL bBuffersContiguous;   </span><br><span class="line">    OMX_U32 nBufferAlignment;   </span><br><span class="line">&#125; OMX_PARAM_PORTDEFINITIONTYPE;</span><br></pre></td></tr></table></figure><p>对于一个端口，其重点的内容如下:</p><p>☯    端口的方向（OMX_DIRTYPE）：包含OMX_DirInput（输入）和OMX_DirOutput（输出）两种<br>☯    端口分配的缓冲区数目和最小缓冲区数目<br>☯    端口的类型（OMX_PORTDOMAINTYPE）：可以是四种类型<br>☯    端口格式的数据结构：使用format联合体来表示，具体由四种不同类型来表示，与端口的类型相对应<br>☯    OMX_AUDIO_PORTDEFINITIONTYPE，OMX_VIDEO_PORTDEFINITIONTYPE，OMX_IMAGE_PORTDEFINITIONTYPE和OMX_OTHER_PORTDEFINITIONTYPE等几个具体的格式类型，分别在OMX_Audio.h，OMX_Video.h，OMX_Image.h和OMX_Other.h这四个头文件中定义。<br>       OMX_Core.h中定义的枚举类型OMX_STATETYPE命令表示OpenMax的状态机，内容如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> OMX_STATETYPE   </span><br><span class="line">&#123;   </span><br><span class="line">    OMX_StateInvalid,                   <span class="comment">/* 组件监测到内部的数据结构被破坏 */</span>   </span><br><span class="line">    OMX_StateLoaded,                    <span class="comment">/* 组件被加载但是没有完成初始化 */</span>   </span><br><span class="line">    OMX_StateIdle,                      <span class="comment">/* 组件初始化完成，准备开始 */</span>   </span><br><span class="line">    OMX_StateExecuting,             <span class="comment">/* 组件接受了开始命令，正在树立数据 */</span>   </span><br><span class="line">    OMX_StatePause,                     <span class="comment">/* 组件接受暂停命令*/</span>   </span><br><span class="line">    OMX_StateWaitForResources,      <span class="comment">/* 组件正在等待资源 */</span>   </span><br><span class="line">    OMX_StateKhronosExtensions = <span class="number">0x6F000000</span>, <span class="comment">/* 保留for Khronos */</span>   </span><br><span class="line">    OMX_StateVendorStartUnused = <span class="number">0x7F000000</span>, <span class="comment">/* 保留for厂商 */</span>   </span><br><span class="line">    OMX_StateMax = <span class="number">0X7FFFFFFF</span>  </span><br><span class="line">&#125; OMX_STATETYPE;</span><br></pre></td></tr></table></figure><p>OpenMax组件的状态机可以由外部的命令改变，也可以由内部发生的情况改变。OpenMax IL组件的状态机的迁移关系如图所示：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/VS-04-08-OMXstate.png" alt="Alt text | center"></p><p> OMX_Core.h中定义的枚举类型OMX_COMMANDTYPE表示对组件的命令类型，内容如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> OMX_COMMANDTYPE   </span><br><span class="line">&#123;   </span><br><span class="line">    OMX_CommandStateSet,                <span class="comment">/* 改变状态机器 */</span>   </span><br><span class="line">    OMX_CommandFlush,                   <span class="comment">/* 刷新数据队列 */</span>   </span><br><span class="line">    OMX_CommandPortDisable,             <span class="comment">/* 禁止端口 */</span>   </span><br><span class="line">    OMX_CommandPortEnable,              <span class="comment">/* 使能端口 */</span>   </span><br><span class="line">    OMX_CommandMarkBuffer,              <span class="comment">/* 标记组件或Buffer用于观察 */</span>   </span><br><span class="line">    OMX_CommandKhronosExtensions = <span class="number">0x6F000000</span>, <span class="comment">/* 保留for Khronos */</span>   </span><br><span class="line">    OMX_CommandVendorStartUnused = <span class="number">0x7F000000</span>, <span class="comment">/* 保留for厂商 */</span>   </span><br><span class="line">    OMX_CommandMax = <span class="number">0X7FFFFFFF</span>  </span><br><span class="line">&#125; OMX_COMMANDTYPE;</span><br></pre></td></tr></table></figure><p>OMX_COMMANDTYPE类型在SendCommand调用中作为参数被使用，其中OMX_CommandStateSet就是改变状态机的命令。</p><h6 id="2-1-2、OpenMax-IL实现的内容"><a href="#2-1-2、OpenMax-IL实现的内容" class="headerlink" title="2.1.2、OpenMax IL实现的内容"></a>2.1.2、OpenMax IL实现的内容</h6><p>  对于OpenMax IL层的实现，一般的方式并不调用OpenMax DL层。具体实现的内容就是各个不同的组件。<br>       OpenMax IL组件的实现包含以下两个步骤：</p><p>☯    组件的初始化函数：硬件和OpenMax数据结构的初始化，一般分成函数指针初始化、私有数据结构的初始化、端口的初始化等几个步骤，使用OMX_Component.h其中的pComponentPrivate成员保留本组件的私有数据为上下文，最后获得填充完成OMX_COMPONENTTYPE类型的结构体。<br>☯    OMX_COMPONENTTYPE类型结构体的各个指针：实现其中的各个函数指针，需要使用私有数据的时候，从其中的pComponentPrivate得到指针，转化成实际的数据结构使用。</p><p>端口的定义是OpenMax IL组件对外部的接口。OpenMax IL常用的组件大都是输入和输出端口各一个。对于最常用的编解码（Codec）组件，通常需要在每个组件的实现过程中，调用硬件的编解码接口来实现。在组件的内部处理中，可以建立线程来处理。OpenMax的组件的端口有默认参数，但也可以在运行时设置，因此一个端口也可以支持不同的编码格式。音频编码组件的输出和音频编码组件的输入通常是原始数据格式（PCM格式），视频编码组件的输出和视频编码组件的输入通常是原始数据格式（YUV格式）。<br>       提示：在一种特定的硬件实现中，编解码部分具有相似性，因此通常可以构建一个OpenMax组件的”基类”或者公共函数，来完成公共性的操作。</p><h5 id="2-2、Android中OpenMax的适配层"><a href="#2-2、Android中OpenMax的适配层" class="headerlink" title="2.2、Android中OpenMax的适配层"></a>2.2、Android中OpenMax的适配层</h5><p>  Android中的OpenMax适配层的接口在frameworks/av/include/media/IOMX.h文件定义，其内容如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IOMX</span> :</span> <span class="keyword">public</span> IInterface &#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    DECLARE_META_INTERFACE(OMX);    </span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">void</span> *buffer_id;    </span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">void</span> *node_id;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">livesLocally</span><span class="params">(<span class="keyword">pid_t</span> pid)</span> </span>= <span class="number">0</span>;    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ComponentInfo</span> &#123;</span><span class="comment">// 组件的信息    </span></span><br><span class="line">        String8 mName;    </span><br><span class="line">        List&lt;String8&gt; mRoles;    </span><br><span class="line">    &#125;;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">listNodes</span><span class="params">(List&lt;ComponentInfo&gt; *<span class="built_in">list</span>)</span> </span>= <span class="number">0</span>;  <span class="comment">// 节点列表    </span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">allocateNode</span><span class="params">(    </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> sp&lt;IOMXObserver&gt; &amp;observer,  <span class="comment">// 分配节点    </span></span></span></span><br><span class="line"><span class="function"><span class="params">        node_id *node)</span> </span>= <span class="number">0</span>;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">freeNode</span><span class="params">(node_id node)</span> </span>= <span class="number">0</span>; <span class="comment">// 找到节点    </span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">sendCommand</span><span class="params">(<span class="comment">// 发送命令    </span></span></span></span><br><span class="line"><span class="function"><span class="params">        node_id node, OMX_COMMANDTYPE cmd, OMX_S32 param)</span> </span>= <span class="number">0</span>;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">getParameter</span><span class="params">(<span class="comment">// 获得参数    </span></span></span></span><br><span class="line"><span class="function"><span class="params">        node_id node, OMX_INDEXTYPE index,    </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">void</span> *params, <span class="keyword">size_t</span> size)</span> </span>= <span class="number">0</span>;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">setParameter</span><span class="params">(<span class="comment">// 设置参数    </span></span></span></span><br><span class="line"><span class="function"><span class="params">        node_id node, OMX_INDEXTYPE index,    </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">void</span> *params, <span class="keyword">size_t</span> size)</span> </span>= <span class="number">0</span>;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">getConfig</span><span class="params">(<span class="comment">// 获得配置    </span></span></span></span><br><span class="line"><span class="function"><span class="params">        node_id node, OMX_INDEXTYPE index,    </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">void</span> *params, <span class="keyword">size_t</span> size)</span> </span>= <span class="number">0</span>;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">setConfig</span><span class="params">(<span class="comment">// 设置配置    </span></span></span></span><br><span class="line"><span class="function"><span class="params">        node_id node, OMX_INDEXTYPE index,    </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">void</span> *params, <span class="keyword">size_t</span> size)</span> </span>= <span class="number">0</span>;   </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">useBuffer</span><span class="params">(<span class="comment">// 使用缓冲区    </span></span></span></span><br><span class="line"><span class="function"><span class="params">        node_id node, OMX_U32 port_index, <span class="keyword">const</span> sp&lt;IMemory&gt; ¶ms,    </span></span></span><br><span class="line"><span class="function"><span class="params">        buffer_id *buffer)</span> </span>= <span class="number">0</span>;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">allocateBuffer</span><span class="params">(<span class="comment">// 分配缓冲区    </span></span></span></span><br><span class="line"><span class="function"><span class="params">        node_id node, OMX_U32 port_index, <span class="keyword">size_t</span> size,    </span></span></span><br><span class="line"><span class="function"><span class="params">        buffer_id *buffer, <span class="keyword">void</span> **buffer_data)</span> </span>= <span class="number">0</span>;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">allocateBufferWithBackup</span><span class="params">(<span class="comment">// 分配带后备缓冲区    </span></span></span></span><br><span class="line"><span class="function"><span class="params">        node_id node, OMX_U32 port_index, <span class="keyword">const</span> sp&lt;IMemory&gt; ¶ms,    </span></span></span><br><span class="line"><span class="function"><span class="params">        buffer_id *buffer)</span> </span>= <span class="number">0</span>;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">freeBuffer</span><span class="params">(<span class="comment">// 释放缓冲区    </span></span></span></span><br><span class="line"><span class="function"><span class="params">        node_id node, OMX_U32 port_index, buffer_id buffer)</span> </span>= <span class="number">0</span>;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">fillBuffer</span><span class="params">(node_id node, buffer_id buffer)</span> </span>= <span class="number">0</span>; <span class="comment">// 填充缓冲区    </span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">emptyBuffer</span><span class="params">(<span class="comment">// 消耗缓冲区    </span></span></span></span><br><span class="line"><span class="function"><span class="params">        node_id node,    </span></span></span><br><span class="line"><span class="function"><span class="params">        buffer_id buffer,    </span></span></span><br><span class="line"><span class="function"><span class="params">        OMX_U32 range_offset, OMX_U32 range_length,    </span></span></span><br><span class="line"><span class="function"><span class="params">        OMX_U32 flags, OMX_TICKS timestamp)</span> </span>= <span class="number">0</span>;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">getExtensionIndex</span><span class="params">(    </span></span></span><br><span class="line"><span class="function"><span class="params">        node_id node,    </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">char</span> *parameter_name,    </span></span></span><br><span class="line"><span class="function"><span class="params">        OMX_INDEXTYPE *index)</span> </span>= <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">virtual</span> sp&lt;IOMXRenderer&gt; createRenderer(<span class="comment">// 创建渲染器（从ISurface）    </span></span><br><span class="line">        <span class="keyword">const</span> sp&lt;ISurface&gt; &amp;surface,    </span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *componentName,    </span><br><span class="line">        OMX_COLOR_FORMATTYPE colorFormat,    </span><br><span class="line">        <span class="keyword">size_t</span> encodedWidth, <span class="keyword">size_t</span> encodedHeight,    </span><br><span class="line">        <span class="keyword">size_t</span> displayWidth, <span class="keyword">size_t</span> displayHeight) = <span class="number">0</span>;    </span><br><span class="line">    </span><br><span class="line">    ......   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> IOMX表示的是OpenMax的一个组件，根据Android的Binder IPC机制，BnOMX继承IOMX，实现者需要继承实现BnOMX。IOMX类中，有标准的OpenMax的GetParameter，SetParameter，GetConfig，SetConfig，SendCommand，UseBuffer，AllocateBuffer，FreeBuffer，FillThisBuffer和EmptyThisBuffer等接口。<br>       在IOMX.h文件中，另有表示观察器类的IOMXObserver，这个类表示OpenMax的观察者，其中只包含一个onMessage()函数，其参数为omx_message接口体，其中包含Event事件类型、FillThisBuffer完成和EmptyThisBuffer完成几种类型。<br>       提示：Android中OpenMax的适配层是OpenMAX IL层至上的封装层，在Android系统中被StageFright调用，也可以被其他部分调用。</p><h4 id="2-3、TI-Texas-Instruments-德州仪器-OpenMax-IL的硬件实现"><a href="#2-3、TI-Texas-Instruments-德州仪器-OpenMax-IL的硬件实现" class="headerlink" title="2.3、TI(Texas Instruments 德州仪器) OpenMax IL的硬件实现"></a>2.3、TI(Texas Instruments 德州仪器) OpenMax IL的硬件实现</h4><h5 id="2-3-1、TI-OpenMax-IL实现的结构和机制"><a href="#2-3-1、TI-OpenMax-IL实现的结构和机制" class="headerlink" title="2.3.1、TI OpenMax IL实现的结构和机制"></a>2.3.1、TI OpenMax IL实现的结构和机制</h5><p> Android的开源代码中，已经包含了TI的OpenMax IL层的实现代码，其路径如hardware/ti/omap3/omx下。其中包含的主要目录如下所示：</p><p>☯    system：OpenMax核心和公共部分<br>☯    audio：音频处理部分的OpenMax IL组件<br>☯    video：视频处理部分OpenMax IL组件<br>☯    image：图像处理部分OpenMax IL组件<br>       TI OpenMax IL实现的结构如图所示:</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/VS-04-09-tiopenmaxil.png" alt="Alt text | center"></p><p> 在TI OpenMax IL实现中，最上面的内容是OpenMax的管理者用于管理和初始化，中间层是各个编解码单元的OpenMax IL标准组件，下层是LCML层，供各个OpenMax IL标准组件所调用。<br>       （1）TI OpenMax IL实现的公共部分在system/src/openmax_il/目录中，主要的内容如下所示。</p><p>☯ omx_core/src：OpenMax IL的核心，生成动态库libOMX_Core.so<br>☯ lcml/：LCML的工具库，生成动态库libLCML.so<br>       （2）I OpenMax IL的视频（Video）相关的组件在video/src/openmax_il/目录中，主要的内容如下所示。</p><p>☯ prepost_processor：Video数据的前处理和后处理，生成动态库libOMX.TI.VPP.so<br>☯ video_decode：Video解码器，生成动态库libOMX.TI.Video.Decoder.so<br>☯ video_encode：Video编码器，生成动态库libOMX.TI.Video.encoder.so<br>       （3）TI OpenMax IL的音频（Audio）相关的组件在audio/src/openmax_il/目录中，主要的内容如下所示。</p><p>☯ g711_dec：G711解码器，生成动态库libOMX.TI.G711.decode.so<br>☯ g711_enc：G711编码器，生成动态库libOMX.TI.G711.encode.so<br>☯ g722_dec：G722解码器，生成动态库libOMX.TI.G722.decode.so<br>☯ g722_enc：G722编码器，生成动态库libOMX.TI.G722.encode.so<br>☯ g726_dec：G726解码器，生成动态库libOMX.TI.G726.decode.so<br>☯ g726_enc：G726编码器，生成动态库libOMX.TI.G726.encode.so<br>☯ g729_dec：G729解码器，生成动态库libOMX.TI.G729.decode.so<br>☯ g729_enc：G720编码器，生成动态库libOMX.TI.G729.encode.so<br>☯ nbamr_dec：AMR窄带解码器，生成动态库libOMX.TI.AMR.decode.so<br>☯ nbamr_enc：AMR窄带编码器，生成动态库libOMX.TI.AMR.encode.so<br>☯ wbamr_dec：AMR宽带解码器，生成动态库libOMX.TI.WBAMR.decode.so<br>☯ wbamr_enc：AMR宽带编码器，生成动态库libOMX.TI.WBAMR.encode.so<br>☯ mp3_dec：MP3解码器，生成动态库libOMX.TI.MP3.decode.so<br>☯ aac_dec：AAC解码器，生成动态库libOMX.TI.AAC.decode.so<br>☯ aac_enc：AAC编码器，生成动态库libOMX.TI.AAC.encode.so<br>☯ wma_dec：WMA解码器，生成动态库libOMX.TI.WMA.decode.so<br>       （4）TI OpenMax IL的图像（Image）相关的组件在image/src/openmax_il/目录中，主要的内容如下所示。</p><p>☯ jpeg_enc：JPEG编码器，生成动态库libOMX.TI.JPEG.Encoder.so<br>☯ jpeg_dec：JPEG解码器，生成动态库libOMX.TI.JPEG.decoder.so</p><h5 id="2-3-2、TI-OpenMax-IL的核心和公共内容"><a href="#2-3-2、TI-OpenMax-IL的核心和公共内容" class="headerlink" title="2.3.2、TI OpenMax IL的核心和公共内容"></a>2.3.2、TI OpenMax IL的核心和公共内容</h5><p> LCML的全称是”Linux Common Multimedia Layer“，是TI的Linux公共多媒体层。在OpenMax IL的实现中，这个内容在system/src/openmax_il/lcml/目录中，主要文件是子目录src中的LCML_DspCodec.c文件。通过调用DSPBridge的内容， 让ARM和DSP进行通信，然DSP进行编解码方面的处理。DSP的运行还需要固件的支持。</p><p> TI OpenMax IL的核心实现在system/src/openmax_il/omx_core/目录中，生成TI OpenMax IL的核心库libOMX_Core.so。</p><p>其中子目录src中的OMX_Core.c为主要文件，其中定义了编解码器的名称等，其片断如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *tComponentName[MAXCOMP][<span class="number">2</span>] = &#123;    </span><br><span class="line">    &#123;<span class="string">"OMX.TI.JPEG.decoder"</span>, <span class="string">"image_decoder.jpeg"</span>&#125;,<span class="comment">/* 图像和视频编解码器 */</span>    </span><br><span class="line">    &#123;<span class="string">"OMX.TI.JPEG.Encoder"</span>, <span class="string">"image_encoder.jpeg"</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">"OMX.TI.Video.Decoder"</span>, <span class="string">"video_decoder.avc"</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">"OMX.TI.Video.Decoder"</span>, <span class="string">"video_decoder.mpeg4"</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">"OMX.TI.Video.Decoder"</span>, <span class="string">"video_decoder.wmv"</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">"OMX.TI.Video.encoder"</span>, <span class="string">"video_encoder.mpeg4"</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">"OMX.TI.Video.encoder"</span>, <span class="string">"video_encoder.h263"</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">"OMX.TI.Video.encoder"</span>, <span class="string">"video_encoder.avc"</span>&#125;,    </span><br><span class="line">     <span class="comment">/* ......省略 ，语音相关组件*/</span>    </span><br><span class="line">#ifdef BUILD_WITH_TI_AUDIO <span class="comment">/* 音频编解码器 */</span>    </span><br><span class="line">    &#123;<span class="string">"OMX.TI.MP3.decode"</span>, <span class="string">"audio_decoder.mp3"</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">"OMX.TI.AAC.encode"</span>, <span class="string">"audio_encoder.aac"</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">"OMX.TI.AAC.decode"</span>, <span class="string">"audio_decoder.aac"</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">"OMX.TI.WMA.decode"</span>, <span class="string">"audio_decoder.wma"</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">"OMX.TI.WBAMR.decode"</span>, <span class="string">"audio_decoder.amrwb"</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">"OMX.TI.AMR.decode"</span>, <span class="string">"audio_decoder.amrnb"</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">"OMX.TI.AMR.encode"</span>, <span class="string">"audio_encoder.amrnb"</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">"OMX.TI.WBAMR.encode"</span>, <span class="string">"audio_encoder.amrwb"</span>&#125;,    </span><br><span class="line">#endif    </span><br><span class="line">    &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;,    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  tComponentName数组的各个项中，第一个表示<strong>编解码库内容</strong>，第二个表示<strong>库所实现的功能</strong>。<br>       其中，TIOMX_GetHandle()函数用于获得各个组件的句柄，其实现的主要片断如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">OMX_ERRORTYPE <span class="title">TIOMX_GetHandle</span><span class="params">( OMX_HANDLETYPE* pHandle, OMX_STRING cComponentName,    </span></span></span><br><span class="line"><span class="function"><span class="params">    OMX_PTR pAppData, OMX_CALLBACKTYPE* pCallBacks)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> prefix[] = <span class="string">"lib"</span>;    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> postfix[] = <span class="string">".so"</span>;    </span><br><span class="line">    OMX_ERRORTYPE (*pComponentInit)(OMX_HANDLETYPE*);    </span><br><span class="line">    OMX_ERRORTYPE err = OMX_ErrorNone;    </span><br><span class="line">    OMX_COMPONENTTYPE *componentType;    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* pErr = dlerror();    </span><br><span class="line">    <span class="comment">// ...... 省略错误处理内容    </span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt; COUNTOF(pModules); i++) &#123;       <span class="comment">// 循环查找    </span></span><br><span class="line">        <span class="keyword">if</span>(pModules[i] == <span class="literal">NULL</span>) <span class="keyword">break</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">// ...... 省略错误处理内容    </span></span><br><span class="line">    <span class="keyword">int</span> refIndex = <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">for</span> (refIndex=<span class="number">0</span>; refIndex &lt; MAX_TABLE_SIZE; refIndex++) &#123;    </span><br><span class="line">    <span class="comment">// 循环查找组件列表    </span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(componentTable[refIndex].name, cComponentName) == <span class="number">0</span>) &#123;    </span><br><span class="line">            <span class="keyword">if</span> (componentTable[refIndex].refCount&gt;= MAX_CONCURRENT_INSTANCES) &#123;    </span><br><span class="line">            <span class="comment">// ...... 省略错误处理内容    </span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;    </span><br><span class="line">                <span class="keyword">char</span> buf[<span class="keyword">sizeof</span>(prefix) + MAXNAMESIZE+ <span class="keyword">sizeof</span>(postfix)];    </span><br><span class="line">                <span class="built_in">strcpy</span>(buf, prefix);    </span><br><span class="line">                <span class="built_in">strcat</span>(buf, cComponentName);    </span><br><span class="line">                <span class="built_in">strcat</span>(buf, postfix);    </span><br><span class="line">                pModules[i] = dlopen(buf, RTLD_LAZY | RTLD_GLOBAL);    </span><br><span class="line">                <span class="comment">// ...... 省略错误处理内容    </span></span><br><span class="line">                <span class="comment">// 动态取出初始化的符号    </span></span><br><span class="line">                pComponentInit = dlsym(pModules[i], <span class="string">"OMX_ComponentInit"</span>);    </span><br><span class="line">                pErr = dlerror();    </span><br><span class="line">                <span class="comment">// ...... 省略错误处理内容    </span></span><br><span class="line">                *pHandle = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(OMX_COMPONENTTYPE));    </span><br><span class="line">                <span class="comment">// ...... 省略错误处理内容    </span></span><br><span class="line">                pComponents[i] = *pHandle;    </span><br><span class="line">                componentType = (OMX_COMPONENTTYPE*) *pHandle;    </span><br><span class="line">                componentType-&gt;nSize = <span class="keyword">sizeof</span>(OMX_COMPONENTTYPE);    </span><br><span class="line">                err = (*pComponentInit)(*pHandle);   <span class="comment">// 执行初始化工作    </span></span><br><span class="line">                <span class="comment">// ...... 省略部分内容    </span></span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">    err = OMX_ErrorComponentNotFound;    </span><br><span class="line">    <span class="keyword">goto</span> UNLOCK_MUTEX;    </span><br><span class="line">    <span class="comment">// ...... 省略部分内容    </span></span><br><span class="line">     <span class="keyword">return</span> (err);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 在TIOMX_GetHandle()函数中，根据tComponentName数组中动态库的名称，动态打开各个编解码实现的动态库，取出其中的<strong>OMX_ComponentInit</strong>符号来执行各个组件的初始化。</p><h5 id="2-3-3、一个TI-OpenMax-IL组件的实现"><a href="#2-3-3、一个TI-OpenMax-IL组件的实现" class="headerlink" title="2.3.3、一个TI OpenMax IL组件的实现"></a>2.3.3、一个TI OpenMax IL组件的实现</h5><p>  TI OpenMax IL中各个组件都是通过调用LCML来实现的，实现的方式基本类似。主要都是实现了名称为OMX_ComponentInit的初始化函数，实现OMX_COMPONENTTYPE类型的结构体中的各个成员。各个组件其目录结构和文件结构也类似。</p><p>以MP3解码器的实现为例，在audio/src/openmax_il/mp3_dec/src目录中，主要包含以下文件：</p><p>☯ OMX_Mp3Decoder.c：MP3解码器组件实现<br>☯ OMX_Mp3Dec_CompThread.c：MP3解码器组件的线程循环<br>☯ OMX_Mp3Dec_Utils.c：MP3解码器的相关工具，调用LCML实现真正的MP3解码的功能<br>       OMX_Mp3Decoder.c中的OMX_ComponentInit()函数负责组件的初始化，返回的内容再从参数中得到，这个函数的主要片断如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">OMX_ERRORTYPE <span class="title">OMX_ComponentInit</span> <span class="params">(OMX_HANDLETYPE hComp)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    OMX_ERRORTYPE eError = OMX_ErrorNone;    </span><br><span class="line">    OMX_COMPONENTTYPE *pHandle = (OMX_COMPONENTTYPE*) hComp;    </span><br><span class="line">    OMX_PARAM_PORTDEFINITIONTYPE *pPortDef_ip = <span class="literal">NULL</span>, *pPortDef_op = <span class="literal">NULL</span>;    </span><br><span class="line">    OMX_AUDIO_PARAM_PORTFORMATTYPE *pPortFormat = <span class="literal">NULL</span>;    </span><br><span class="line">    OMX_AUDIO_PARAM_MP3TYPE *mp3_ip = <span class="literal">NULL</span>;    </span><br><span class="line">    OMX_AUDIO_PARAM_PCMMODETYPE *mp3_op = <span class="literal">NULL</span>;    </span><br><span class="line">    MP3DEC_COMPONENT_PRIVATE *pComponentPrivate = <span class="literal">NULL</span>;    </span><br><span class="line">    MP3D_AUDIODEC_PORT_TYPE *pCompPort = <span class="literal">NULL</span>;    </span><br><span class="line">    MP3D_BUFFERLIST *pTemp = <span class="literal">NULL</span>;    </span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;    </span><br><span class="line">  </span><br><span class="line">    MP3D_OMX_CONF_CHECK_CMD(pHandle,<span class="number">1</span>,<span class="number">1</span>);    </span><br><span class="line">    <span class="comment">/* ......省略，初始化OMX_COMPONENTTYPE类型的指针pHandle */</span>    </span><br><span class="line">    OMX_MALLOC_GENERIC(pHandle-&gt;pComponentPrivate, MP3DEC_COMPONENT_PRIVATE);    </span><br><span class="line">    pComponentPrivate = pHandle-&gt;pComponentPrivate; <span class="comment">/* 私有指针互相指向 */</span>    </span><br><span class="line">    pComponentPrivate-&gt;pHandlepHandle = pHandle;    </span><br><span class="line">    <span class="comment">/* ......略，初始化似有数据指针pComponentPrivate */</span>    </span><br><span class="line">    <span class="comment">/* 设置输入端口（OMX_PARAM_PORTDEFINITIONTYPE类型）的默认值 */</span>    </span><br><span class="line">    pPortDef_ip-&gt;nSize                   = <span class="keyword">sizeof</span>(OMX_PARAM_PORTDEFINITIONTYPE);    </span><br><span class="line">    pPortDef_ip-&gt;nPortIndex             = MP3D_INPUT_PORT;    </span><br><span class="line">    pPortDef_ip-&gt;eDir                    = OMX_DirInput;    </span><br><span class="line">    pPortDef_ip-&gt;nBufferCountActual    = MP3D_NUM_INPUT_BUFFERS;    </span><br><span class="line">    pPortDef_ip-&gt;nBufferCountMin        = MP3D_NUM_INPUT_BUFFERS;    </span><br><span class="line">    pPortDef_ip-&gt;nBufferSize             = MP3D_INPUT_BUFFER_SIZE;    </span><br><span class="line">    pPortDef_ip-&gt;nBufferAlignment       = DSP_CACHE_ALIGNMENT;    </span><br><span class="line">    pPortDef_ip-&gt;bEnabled                 = OMX_TRUE;    </span><br><span class="line">    pPortDef_ip-&gt;bPopulated               = OMX_FALSE;    </span><br><span class="line">    pPortDef_ip-&gt;eDomain                   = OMX_PortDomainAudio;    </span><br><span class="line">    pPortDef_ip-&gt;format.audio.eEncoding = OMX_AUDIO_CodingMP3;    </span><br><span class="line">    pPortDef_ip-&gt;format.audio.cMIMEType = <span class="literal">NULL</span>;    </span><br><span class="line">    pPortDef_ip-&gt;format.audio.pNativeRender           = <span class="literal">NULL</span>;    </span><br><span class="line">    pPortDef_ip-&gt;format.audio.bFlagErrorConcealment = OMX_FALSE;    </span><br><span class="line">    <span class="comment">/* 设置输出端口（OMX_PARAM_PORTDEFINITIONTYPE类型）的默认值 */</span>    </span><br><span class="line">    pPortDef_op-&gt;nSize                 = <span class="keyword">sizeof</span>(OMX_PARAM_PORTDEFINITIONTYPE);    </span><br><span class="line">    pPortDef_op-&gt;nPortIndex           = MP3D_OUTPUT_PORT;    </span><br><span class="line">    pPortDef_op-&gt;eDir                  = OMX_DirOutput;    </span><br><span class="line">    pPortDef_op-&gt;nBufferCountMin     = MP3D_NUM_OUTPUT_BUFFERS;    </span><br><span class="line">    pPortDef_op-&gt;nBufferCountActual  = MP3D_NUM_OUTPUT_BUFFERS;    </span><br><span class="line">    pPortDef_op-&gt;nBufferSize          = MP3D_OUTPUT_BUFFER_SIZE;    </span><br><span class="line">    pPortDef_op-&gt;nBufferAlignment    = DSP_CACHE_ALIGNMENT;    </span><br><span class="line">    pPortDef_op-&gt;bEnabled              = OMX_TRUE;    </span><br><span class="line">    pPortDef_op-&gt;bPopulated            = OMX_FALSE;    </span><br><span class="line">    pPortDef_op-&gt;eDomain               = OMX_PortDomainAudio;    </span><br><span class="line">    pPortDef_op-&gt;format.audio.eEncoding      = OMX_AUDIO_CodingPCM;    </span><br><span class="line">    pPortDef_op-&gt;format.audio.cMIMEType      = <span class="literal">NULL</span>;    </span><br><span class="line">    pPortDef_op-&gt;format.audio.pNativeRender = <span class="literal">NULL</span>;    </span><br><span class="line">    pPortDef_op-&gt;format.audio.bFlagErrorConcealment = OMX_FALSE;    </span><br><span class="line">    <span class="comment">/* ......省略，分配端口 */</span>    </span><br><span class="line">    <span class="comment">/* 设置输入端口的默认格式 */</span>    </span><br><span class="line">    pPortFormat = pComponentPrivate-&gt;pCompPort[MP3D_INPUT_PORT]-&gt;pPortFormat;    </span><br><span class="line">    OMX_CONF_INIT_STRUCT(pPortFormat, OMX_AUDIO_PARAM_PORTFORMATTYPE);    </span><br><span class="line">    pPortFormat-&gt;nPortIndex         = MP3D_INPUT_PORT;    </span><br><span class="line">    pPortFormat-&gt;nIndex             = OMX_IndexParamAudioMp3;    </span><br><span class="line">    pPortFormat-&gt;eEncoding          = OMX_AUDIO_CodingMP3;    </span><br><span class="line">    <span class="comment">/* 设置输出端口的默认格式 */</span>    </span><br><span class="line">    pPortFormat = pComponentPrivate-&gt;pCompPort[MP3D_OUTPUT_PORT]-&gt;pPortFormat;    </span><br><span class="line">    OMX_CONF_INIT_STRUCT(pPortFormat, OMX_AUDIO_PARAM_PORTFORMATTYPE);    </span><br><span class="line">        pPortFormat-&gt;nPortIndex         = MP3D_OUTPUT_PORT;    </span><br><span class="line">        pPortFormat-&gt;nIndex             = OMX_IndexParamAudioPcm;    </span><br><span class="line">        pPortFormat-&gt;eEncoding          = OMX_AUDIO_CodingPCM;    </span><br><span class="line">    <span class="comment">/* ......省略部分内容 */</span>    </span><br><span class="line">    eError = Mp3Dec_StartCompThread(pHandle);   <span class="comment">// 启动MP3解码线程    </span></span><br><span class="line">    <span class="comment">/* ......省略部分内容 */</span>    </span><br><span class="line">    <span class="keyword">return</span> eError;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这个组件是OpenMax的标准实现方式，对外的接口的内容只有一个初始化函数。完成OMX_COMPONENTTYPE类型的初始化。输入端口的编号为MP3D_INPUT_PORT（==0），类型为OMX_PortDomainAudio，格式为OMX_AUDIO_CodingMP3。输出端口的编号是MP3D_OUTPUT_PORT（==1），类型为OMX_PortDomainAudio，格式为OMXAUDIO CodingPCM。</p><p>  OMX_Mp3Dec_CompThread.c中定义了MP3DEC_ComponentThread()函数，用于创建MP3解码的线程的执行函数。<br>  OMX_Mp3Dec_Utils.c中的Mp3Dec_StartCompThread()函数，调用了POSIX的线程库建立MP3解码的线程，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nRet = pthread_create (&amp;(pComponentPrivate-&gt;ComponentThread), <span class="literal">NULL</span>,    </span><br><span class="line">    MP3DEC_ComponentThread, pComponentPrivate);</span><br></pre></td></tr></table></figure><p> Mp3Dec_StartCompThread()函数就是在组件初始化函数OMX_ComponentInit()最后调用的内容。MP3线程的开始并不表示解码过程开始，线程需要等待通过pipe机制获得命令和数据（cmdPipe和dataPipe），在适当的时候开始工作。这个pipe在MP3解码组件的SendCommand等实现写操作，在线程中读取其内容。</p><h5 id="2-4、Qualcomm-高通-OpenMax-IL的硬件实现"><a href="#2-4、Qualcomm-高通-OpenMax-IL的硬件实现" class="headerlink" title="2.4、Qualcomm(高通) OpenMax IL的硬件实现"></a>2.4、Qualcomm(高通) OpenMax IL的硬件实现</h5><h6 id="2-4-1、qcom-OpenMax-IL实现的结构和机制"><a href="#2-4-1、qcom-OpenMax-IL实现的结构和机制" class="headerlink" title="2.4.1、qcom OpenMax IL实现的结构和机制"></a>2.4.1、qcom OpenMax IL实现的结构和机制</h6><p>（1）在AOSP中依然有对高通平台的OpenMax IL层实现代码，位于hardware/qcom/media/mm-core下。这一部分是OpenMax核心和公共部分，主要编译为libOmxCore.so。</p><p>（2）e.g. 继续在hardware/qcom/media下，选取mm-video-v4l2目录。即Video4linux2（简称V4L2),是linux中关于视频设备的内核驱动。再次进入vidc，（DivxDrmDecrypt为DRM数字版权相关）主要目录如下：</p><p>☯ vdec：视频解码处理，编译成libOmxVdec.so/libOmxVdecHevc.so<br>☯ venc：视频编码处理，编译成libOmxVenc.so<br>qcom OpenMax IL的核心和公共内容<br>       类似于前面介绍的TI，高通平台在OpenMax IL实现也是大同小异，位于hardware/qcom/media/mm-core，生成libOmxCore.so库。<br>       其中qc_omx_core为主要文件，位于hardware/qcom/media/mm-core/omxcore/src/common/下面。和TI的差不多，OMX_GetHandle()函数用户获取各个组件的句柄，其实现的主要片断如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编解码器组件集合数组</span></span><br><span class="line"><span class="keyword">extern</span> omx_core_cb_type core[];</span><br><span class="line"></span><br><span class="line"> OMX_API OMX_ERRORTYPE OMX_APIENTRY</span><br><span class="line">OMX_GetHandle(OMX_OUT OMX_HANDLETYPE*     handle,</span><br><span class="line">              OMX_IN OMX_STRING    componentName,</span><br><span class="line">              OMX_IN OMX_PTR             appData,</span><br><span class="line">              OMX_IN OMX_CALLBACKTYPE* callBacks)</span><br><span class="line">&#123;</span><br><span class="line">  OMX_ERRORTYPE  eRet = OMX_ErrorNone;</span><br><span class="line">  <span class="keyword">int</span> cmp_index = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">int</span> hnd_index = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  DEBUG_PRINT(<span class="string">"OMXCORE API :  Get Handle %p %s %p\n"</span>, handle,</span><br><span class="line">                                                     componentName,</span><br><span class="line">                                                     appData);</span><br><span class="line">  pthread_mutex_lock(&amp;lock_core);</span><br><span class="line">  <span class="keyword">if</span>(handle)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sd</span>;</span></span><br><span class="line"><span class="comment">//组件句柄</span></span><br><span class="line">    *handle = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//获取根据组件名获取相应index</span></span><br><span class="line">    cmp_index = get_cmp_index(componentName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(cmp_index &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       DEBUG_PRINT(<span class="string">"getting fn pointer\n"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// dynamically load the so 动态加载组件的so库</span></span><br><span class="line">      core[cmp_index].fn_ptr =</span><br><span class="line">        omx_core_load_cmp_library(core[cmp_index].so_lib_name,</span><br><span class="line">                                  &amp;core[cmp_index].so_lib_handle);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(core[cmp_index].fn_ptr)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// Construct the component requested</span></span><br><span class="line">        <span class="comment">// Function returns the opaque handle</span></span><br><span class="line">        <span class="comment">//根据获取的组件句柄初始化它</span></span><br><span class="line">        <span class="keyword">void</span>* pThis = (*(core[cmp_index].fn_ptr))();</span><br><span class="line">        <span class="keyword">if</span>(pThis)</span><br><span class="line">        &#123;</span><br><span class="line">      <span class="comment">//包装一层，忽略</span></span><br><span class="line">          <span class="keyword">void</span> *hComp = <span class="literal">NULL</span>;</span><br><span class="line">          hComp = qc_omx_create_component_wrapper((OMX_PTR)pThis);</span><br><span class="line">          <span class="keyword">if</span>((eRet = qc_omx_component_init(hComp, core[cmp_index].name)) !=</span><br><span class="line">                           OMX_ErrorNone)</span><br><span class="line">          &#123;</span><br><span class="line">              DEBUG_PRINT(<span class="string">"Component not created succesfully\n"</span>);</span><br><span class="line">              pthread_mutex_unlock(&amp;lock_core);</span><br><span class="line">              <span class="keyword">return</span> eRet;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//设置回调</span></span><br><span class="line">          qc_omx_component_set_callbacks(hComp,callBacks,appData);</span><br><span class="line">          hnd_index = get_comp_handle_index(componentName);</span><br><span class="line"> </span><br><span class="line">          <span class="keyword">if</span>(hnd_index &gt;= <span class="number">0</span>)</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="comment">//保存这个组件句柄</span></span><br><span class="line">            core[cmp_index].inst[hnd_index]= *handle = (OMX_HANDLETYPE) hComp;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">          <span class="comment">/*-------下面全是错误处理，忽略------*/</span></span><br><span class="line">            DEBUG_PRINT(<span class="string">"OMX_GetHandle:NO free slot available to store Component Handle\n"</span>);</span><br><span class="line">            pthread_mutex_unlock(&amp;lock_core);</span><br><span class="line">            <span class="keyword">return</span> OMX_ErrorInsufficientResources;</span><br><span class="line">          &#125;</span><br><span class="line">          DEBUG_PRINT(<span class="string">"Component %p Successfully created\n"</span>,*handle);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          eRet = OMX_ErrorInsufficientResources;</span><br><span class="line">          DEBUG_PRINT(<span class="string">"Component Creation failed\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        eRet = OMX_ErrorNotImplemented;</span><br><span class="line">        DEBUG_PRINT(<span class="string">"library couldnt return create instance fn\n"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      eRet = OMX_ErrorNotImplemented;</span><br><span class="line">      DEBUG_PRINT(<span class="string">"ERROR: Already another instance active  ;rejecting \n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    eRet =  OMX_ErrorBadParameter;</span><br><span class="line">    DEBUG_PRINT(<span class="string">"\n OMX_GetHandle: NULL handle \n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_mutex_unlock(&amp;lock_core);</span><br><span class="line">  <span class="keyword">return</span> eRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这里的有个数组：extern omx_core_cb_type core[]，是从别的文件中声明过来的全局变量，其中包含了各种编解码器的名称和一些属性的结构体。结构体定义位于hardware/qcom/media/mm-core/omxcore/src/common/qc_omx_core.h：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">omx_core_cb_type</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">char</span>*                         name;<span class="comment">// Component name 组件名</span></span><br><span class="line">  create_qc_omx_component     fn_ptr;<span class="comment">// create instance fn ptr 创建实例函数指针</span></span><br><span class="line">  <span class="keyword">void</span>*                         inst[OMX_COMP_MAX_INST];<span class="comment">// Instance handle 实例句柄</span></span><br><span class="line">  <span class="keyword">void</span>*                so_lib_handle;<span class="comment">// So Library handle so库句柄</span></span><br><span class="line">  <span class="keyword">char</span>*                  so_lib_name;<span class="comment">// so directory so名</span></span><br><span class="line">  <span class="keyword">char</span>* roles[OMX_CORE_MAX_CMP_ROLES];<span class="comment">// roles played 组件扮演的角色</span></span><br><span class="line">&#125;omx_core_cb_type;</span><br></pre></td></tr></table></figure><p>  但是给omx_core_cb_type core[]这个结构体数组复制的地方要根据不同型号进行选取，我们进入hardware/qcom/media/mm-core/src下面，会看到有许多型号，7627A、7630、8084、8226、8610、8660等等。比如这个8974的，位于hardware/qcom/media/mm-core/src/8974/qc_registry_table_android.c中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">omx_core_cb_type core[] =</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//avc/h264解码器</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"OMX.qcom.video.decoder.avc"</span>,</span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">// Create instance function</span></span><br><span class="line">    <span class="comment">// Unique instance handle</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="literal">NULL</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="literal">NULL</span>,   <span class="comment">// Shared object library handle</span></span><br><span class="line">    <span class="string">"libOmxVdec.so"</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"video_decoder.avc"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//mpeg4解码器</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"OMX.qcom.video.decoder.mpeg4"</span>,</span><br><span class="line">    <span class="literal">NULL</span>,   <span class="comment">// Create instance function</span></span><br><span class="line">    <span class="comment">// Unique instance handle</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="literal">NULL</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="literal">NULL</span>,   <span class="comment">// Shared object library handle</span></span><br><span class="line">    <span class="string">"libOmxVdec.so"</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"video_decoder.mpeg4"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">    <span class="comment">//wmv解码器</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"OMX.qcom.video.decoder.wmv"</span>,</span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">// Create instance function</span></span><br><span class="line">    <span class="comment">// Unique instance handle</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="literal">NULL</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="literal">NULL</span>,   <span class="comment">// Shared object library handle</span></span><br><span class="line">    <span class="string">"libOmxVdec.so"</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"video_decoder.vc1"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">    <span class="comment">//hevc/h265编码器</span></span><br><span class="line">   &#123;</span><br><span class="line">    <span class="string">"OMX.qcom.video.encoder.hevc"</span>,</span><br><span class="line">    <span class="literal">NULL</span>,   <span class="comment">// Create instance function</span></span><br><span class="line">    <span class="comment">// Unique instance handle</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="literal">NULL</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="literal">NULL</span>,   <span class="comment">// Shared object library handle</span></span><br><span class="line">    <span class="string">"libOmxVencHevc.so"</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"video_encoder.hevc"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  ...太多了，省略...</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>上面就是对编解码器相关信息的注册。</p><p>在OMX_GetHandle()函数中，根据omx_core_cb_type core[]数组中动态库的名称，动态打开各个编解码实现的动态库,然后进行初始化。</p><h6 id="2-4-1、一个qcom-OpenMax-IL组件的实现"><a href="#2-4-1、一个qcom-OpenMax-IL组件的实现" class="headerlink" title="2.4.1、一个qcom OpenMax IL组件的实现"></a>2.4.1、一个qcom OpenMax IL组件的实现</h6><p> 高通平台对于编解码组件的处理都比较集中，不像TI那么分散和细致。一个组件实现都要包含Qc_omx_component.h头文件，位于很多地方，如hardware/qcom/media/mm-core/inc，要实现里面相关纯虚函数。当一个组件被创建后要初始化，就要实现component_init(OMX_IN OMX_STRING componentName)方法。</p><p>举个例子，依然以Video4linux2平台，进入hardware/qcom/media/mm-video-v4l2/vidc/vdec/src查看视频解码相关组件。比如我们看看解码组件omx_vdec_hevc.cpp，查看component_init方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> VENUS_HEVC</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVICE_NAME <span class="meta-string">"/dev/video/venus_dec"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVICE_NAME <span class="meta-string">"/dev/video/q6_dec"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ======================================================================</span></span><br><span class="line"><span class="comment">   FUNCTION</span></span><br><span class="line"><span class="comment">   omx_vdec::ComponentInit</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   DESCRIPTION</span></span><br><span class="line"><span class="comment">   Initialize the component.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   PARAMETERS</span></span><br><span class="line"><span class="comment">   ctxt -- Context information related to the self.</span></span><br><span class="line"><span class="comment">   id   -- Event identifier. This could be any of the following:</span></span><br><span class="line"><span class="comment">   1. Command completion event</span></span><br><span class="line"><span class="comment">   2. Buffer done callback event</span></span><br><span class="line"><span class="comment">   3. Frame done callback event</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   RETURN VALUE</span></span><br><span class="line"><span class="comment">   None.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   ========================================================================== */</span></span><br><span class="line">OMX_ERRORTYPE omx_vdec::component_init(OMX_STRING role)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    OMX_ERRORTYPE eRet = OMX_ErrorNone;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_fmtdesc</span> <span class="title">fdesc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_format</span> <span class="title">fmt</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_requestbuffers</span> <span class="title">bufreq</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_control</span> <span class="title">control</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>   alignment = <span class="number">0</span>,buffer_size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> fds[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> r,ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> codec_ambiguous = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//打开设备文件"/dev/video/venus_dec"或"/dev/video/q6_dec"</span></span><br><span class="line">    OMX_STRING device_name = (OMX_STRING)DEVICE_NAME;</span><br><span class="line">    ......</span><br><span class="line">    drv_ctx.video_driver_fd = open(device_name, O_RDWR);</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"><span class="comment">//如果是一个打开成功后，为什么要再次打开？？excuse me ？</span></span><br><span class="line">    <span class="keyword">if</span> (drv_ctx.video_driver_fd == <span class="number">0</span>) &#123;</span><br><span class="line">        drv_ctx.video_driver_fd = open(device_name, O_RDWR);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//打开设备文件失败</span></span><br><span class="line">    <span class="keyword">if</span> (drv_ctx.video_driver_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        DEBUG_PRINT_ERROR(<span class="string">"Omx_vdec::Comp Init Returning failure, errno %d"</span>, errno);</span><br><span class="line">        <span class="keyword">return</span> OMX_ErrorInsufficientResources;</span><br><span class="line">    &#125;</span><br><span class="line">    drv_ctx.frame_rate.fps_numerator = DEFAULT_FPS;<span class="comment">//帧率分子</span></span><br><span class="line">    drv_ctx.frame_rate.fps_denominator = <span class="number">1</span>;<span class="comment">//帧率分母</span></span><br><span class="line"><span class="comment">//创建一个异步线程，执行async_message_thread函数，对输入端进行设置</span></span><br><span class="line">    ret = pthread_create(&amp;async_thread_id,<span class="number">0</span>,async_message_thread,<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//创建线程失败，则关闭设备文件</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        close(drv_ctx.video_driver_fd);</span><br><span class="line">        DEBUG_PRINT_ERROR(<span class="string">"Failed to create async_message_thread"</span>);</span><br><span class="line">        <span class="keyword">return</span> OMX_ErrorInsufficientResources;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy the role information which provides the decoder kind</span></span><br><span class="line">    <span class="comment">//将组建角色名字copy进设备驱动上下文结构体的kind属性</span></span><br><span class="line">    strlcpy(drv_ctx.kind,role,<span class="number">128</span>);</span><br><span class="line"><span class="comment">//如果是mpeg4解码组件</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(drv_ctx.kind,<span class="string">"OMX.qcom.video.decoder.mpeg4"</span>,\</span><br><span class="line">                OMX_MAX_STRINGNAME_SIZE)) &#123;</span><br><span class="line">        strlcpy((<span class="keyword">char</span> *)m_cRole, <span class="string">"video_decoder.mpeg4"</span>,\</span><br><span class="line">                OMX_MAX_STRINGNAME_SIZE);</span><br><span class="line">        drv_ctx.timestamp_adjust = <span class="literal">true</span>;</span><br><span class="line">        drv_ctx.decoder_format = VDEC_CODECTYPE_MPEG4;</span><br><span class="line">        eCompressionFormat = OMX_VIDEO_CodingMPEG4;</span><br><span class="line">        output_capability=V4L2_PIX_FMT_MPEG4;</span><br><span class="line">        <span class="comment">/*Initialize Start Code for MPEG4*/</span></span><br><span class="line">        codec_type_parse = CODEC_TYPE_MPEG4;</span><br><span class="line">        m_frame_parser.init_start_codes (codec_type_parse);</span><br><span class="line">......</span><br><span class="line"><span class="comment">//如果是mpeg2解码组件</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(drv_ctx.kind,<span class="string">"OMX.qcom.video.decoder.mpeg2"</span>,\</span><br><span class="line">                OMX_MAX_STRINGNAME_SIZE)) &#123;</span><br><span class="line">        strlcpy((<span class="keyword">char</span> *)m_cRole, <span class="string">"video_decoder.mpeg2"</span>,\</span><br><span class="line">                OMX_MAX_STRINGNAME_SIZE);</span><br><span class="line">        drv_ctx.decoder_format = VDEC_CODECTYPE_MPEG2;</span><br><span class="line">        output_capability = V4L2_PIX_FMT_MPEG2;</span><br><span class="line">        eCompressionFormat = OMX_VIDEO_CodingMPEG2;</span><br><span class="line">        <span class="comment">/*Initialize Start Code for MPEG2*/</span></span><br><span class="line">        codec_type_parse = CODEC_TYPE_MPEG2;</span><br><span class="line">        m_frame_parser.init_start_codes (codec_type_parse);</span><br><span class="line">......</span><br><span class="line"><span class="comment">//如果是h263解码组件</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(drv_ctx.kind, <span class="string">"OMX.qcom.video.decoder.h263"</span>,\</span><br><span class="line">                OMX_MAX_STRINGNAME_SIZE)) &#123;</span><br><span class="line">        strlcpy((<span class="keyword">char</span> *)m_cRole, <span class="string">"video_decoder.h263"</span>,OMX_MAX_STRINGNAME_SIZE);</span><br><span class="line">        DEBUG_PRINT_LOW(<span class="string">"H263 Decoder selected"</span>);</span><br><span class="line">        drv_ctx.decoder_format = VDEC_CODECTYPE_H263;</span><br><span class="line">        eCompressionFormat = OMX_VIDEO_CodingH263;</span><br><span class="line">        output_capability = V4L2_PIX_FMT_H263;</span><br><span class="line">        codec_type_parse = CODEC_TYPE_H263;</span><br><span class="line">        m_frame_parser.init_start_codes (codec_type_parse);</span><br><span class="line">......</span><br><span class="line"><span class="comment">//如果是divx311...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(drv_ctx.kind, <span class="string">"OMX.qcom.video.decoder.divx311"</span>,\</span><br><span class="line">                OMX_MAX_STRINGNAME_SIZE)) &#123;</span><br><span class="line">        strlcpy((<span class="keyword">char</span> *)m_cRole, <span class="string">"video_decoder.divx"</span>,OMX_MAX_STRINGNAME_SIZE);</span><br><span class="line">        DEBUG_PRINT_LOW (<span class="string">"DIVX 311 Decoder selected"</span>);</span><br><span class="line">        drv_ctx.decoder_format = VDEC_CODECTYPE_DIVX_3;</span><br><span class="line">        output_capability = V4L2_PIX_FMT_DIVX_311;</span><br><span class="line">        eCompressionFormat = (OMX_VIDEO_CODINGTYPE)QOMX_VIDEO_CodingDivx;</span><br><span class="line">        codec_type_parse = CODEC_TYPE_DIVX;</span><br><span class="line">        m_frame_parser.init_start_codes (codec_type_parse);</span><br><span class="line"></span><br><span class="line">        eRet = createDivxDrmContext();</span><br><span class="line">        <span class="keyword">if</span> (eRet != OMX_ErrorNone) &#123;</span><br><span class="line">            DEBUG_PRINT_ERROR(<span class="string">"createDivxDrmContext Failed"</span>);</span><br><span class="line">            <span class="keyword">return</span> eRet;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果是divx4...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(drv_ctx.kind, <span class="string">"OMX.qcom.video.decoder.divx4"</span>,\</span><br><span class="line">                OMX_MAX_STRINGNAME_SIZE)) &#123;</span><br><span class="line">        strlcpy((<span class="keyword">char</span> *)m_cRole, <span class="string">"video_decoder.divx"</span>,OMX_MAX_STRINGNAME_SIZE);</span><br><span class="line">        DEBUG_PRINT_ERROR (<span class="string">"DIVX 4 Decoder selected"</span>);</span><br><span class="line">        drv_ctx.decoder_format = VDEC_CODECTYPE_DIVX_4;</span><br><span class="line">        output_capability = V4L2_PIX_FMT_DIVX;</span><br><span class="line">        eCompressionFormat = (OMX_VIDEO_CODINGTYPE)QOMX_VIDEO_CodingDivx;</span><br><span class="line">        codec_type_parse = CODEC_TYPE_DIVX;</span><br><span class="line">        codec_ambiguous = <span class="literal">true</span>;</span><br><span class="line">        m_frame_parser.init_start_codes (codec_type_parse);</span><br><span class="line"></span><br><span class="line">        eRet = createDivxDrmContext();</span><br><span class="line">        <span class="keyword">if</span> (eRet != OMX_ErrorNone) &#123;</span><br><span class="line">            DEBUG_PRINT_ERROR(<span class="string">"createDivxDrmContext Failed"</span>);</span><br><span class="line">            <span class="keyword">return</span> eRet;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果是divx...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(drv_ctx.kind, <span class="string">"OMX.qcom.video.decoder.divx"</span>,\</span><br><span class="line">                OMX_MAX_STRINGNAME_SIZE)) &#123;</span><br><span class="line">        strlcpy((<span class="keyword">char</span> *)m_cRole, <span class="string">"video_decoder.divx"</span>,OMX_MAX_STRINGNAME_SIZE);</span><br><span class="line">        DEBUG_PRINT_ERROR (<span class="string">"DIVX 5/6 Decoder selected"</span>);</span><br><span class="line">        drv_ctx.decoder_format = VDEC_CODECTYPE_DIVX_6;</span><br><span class="line">        output_capability = V4L2_PIX_FMT_DIVX;</span><br><span class="line">        eCompressionFormat = (OMX_VIDEO_CODINGTYPE)QOMX_VIDEO_CodingDivx;</span><br><span class="line">        codec_type_parse = CODEC_TYPE_DIVX;</span><br><span class="line">        codec_ambiguous = <span class="literal">true</span>;</span><br><span class="line">        m_frame_parser.init_start_codes (codec_type_parse);</span><br><span class="line"></span><br><span class="line">        eRet = createDivxDrmContext();</span><br><span class="line">        <span class="keyword">if</span> (eRet != OMX_ErrorNone) &#123;</span><br><span class="line">            DEBUG_PRINT_ERROR(<span class="string">"createDivxDrmContext Failed"</span>);</span><br><span class="line">            <span class="keyword">return</span> eRet;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//如果是avc/h264...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(drv_ctx.kind, <span class="string">"OMX.qcom.video.decoder.avc"</span>,\</span><br><span class="line">                OMX_MAX_STRINGNAME_SIZE)) &#123;</span><br><span class="line">        strlcpy((<span class="keyword">char</span> *)m_cRole, <span class="string">"video_decoder.avc"</span>,OMX_MAX_STRINGNAME_SIZE);</span><br><span class="line">        drv_ctx.decoder_format = VDEC_CODECTYPE_H264;</span><br><span class="line">        output_capability=V4L2_PIX_FMT_H264;</span><br><span class="line">        eCompressionFormat = OMX_VIDEO_CodingAVC;</span><br><span class="line">        codec_type_parse = CODEC_TYPE_H264;</span><br><span class="line">        m_frame_parser.init_start_codes (codec_type_parse);</span><br><span class="line">        m_frame_parser.init_nal_length(nal_length);</span><br><span class="line">......</span><br><span class="line"><span class="comment">//如果是hevc/h265...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(drv_ctx.kind, <span class="string">"OMX.qcom.video.decoder.hevc"</span>,\</span><br><span class="line">                OMX_MAX_STRINGNAME_SIZE)) &#123;</span><br><span class="line">        strlcpy((<span class="keyword">char</span> *)m_cRole, <span class="string">"video_decoder.hevc"</span>,OMX_MAX_STRINGNAME_SIZE);</span><br><span class="line">        drv_ctx.decoder_format = VDEC_CODECTYPE_HEVC;</span><br><span class="line">        output_capability=V4L2_PIX_FMT_HEVC;</span><br><span class="line">        eCompressionFormat = (OMX_VIDEO_CODINGTYPE)QOMX_VIDEO_CodingHevc;</span><br><span class="line">        codec_type_parse = CODEC_TYPE_HEVC;</span><br><span class="line">        m_frame_parser.init_start_codes (codec_type_parse);</span><br><span class="line">        m_frame_parser.init_nal_length(nal_length);</span><br><span class="line">...</span><br><span class="line"><span class="comment">//如果是vc1...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(drv_ctx.kind, <span class="string">"OMX.qcom.video.decoder.vc1"</span>,\</span><br><span class="line">                OMX_MAX_STRINGNAME_SIZE)) &#123;</span><br><span class="line">        strlcpy((<span class="keyword">char</span> *)m_cRole, <span class="string">"video_decoder.vc1"</span>,OMX_MAX_STRINGNAME_SIZE);</span><br><span class="line">        drv_ctx.decoder_format = VDEC_CODECTYPE_VC1;</span><br><span class="line">        eCompressionFormat = OMX_VIDEO_CodingWMV;</span><br><span class="line">        codec_type_parse = CODEC_TYPE_VC1;</span><br><span class="line">        output_capability = V4L2_PIX_FMT_VC1_ANNEX_G;</span><br><span class="line">        m_frame_parser.init_start_codes (codec_type_parse);</span><br><span class="line"><span class="comment">//如果是wmv...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(drv_ctx.kind, <span class="string">"OMX.qcom.video.decoder.wmv"</span>,\</span><br><span class="line">                OMX_MAX_STRINGNAME_SIZE)) &#123;</span><br><span class="line">        strlcpy((<span class="keyword">char</span> *)m_cRole, <span class="string">"video_decoder.vc1"</span>,OMX_MAX_STRINGNAME_SIZE);</span><br><span class="line">        drv_ctx.decoder_format = VDEC_CODECTYPE_VC1_RCV;</span><br><span class="line">        eCompressionFormat = OMX_VIDEO_CodingWMV;</span><br><span class="line">        codec_type_parse = CODEC_TYPE_VC1;</span><br><span class="line">        output_capability = V4L2_PIX_FMT_VC1_ANNEX_L;</span><br><span class="line">        m_frame_parser.init_start_codes (codec_type_parse);</span><br><span class="line"><span class="comment">//如果是vp8...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(drv_ctx.kind, <span class="string">"OMX.qcom.video.decoder.vp8"</span>,\</span><br><span class="line">                OMX_MAX_STRINGNAME_SIZE)) &#123;</span><br><span class="line">        strlcpy((<span class="keyword">char</span> *)m_cRole, <span class="string">"video_decoder.vp8"</span>,OMX_MAX_STRINGNAME_SIZE);</span><br><span class="line">        output_capability=V4L2_PIX_FMT_VP8;</span><br><span class="line">        eCompressionFormat = OMX_VIDEO_CodingVPX;</span><br><span class="line">        codec_type_parse = CODEC_TYPE_VP8;</span><br><span class="line">        arbitrary_bytes = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 如果是不认识的解码组件，则报错</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        DEBUG_PRINT_ERROR(<span class="string">"ERROR:Unknown Component"</span>);</span><br><span class="line">        eRet = OMX_ErrorInvalidComponentName;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//如果错误</span></span><br><span class="line">    <span class="keyword">if</span> (eRet == OMX_ErrorNone) &#123;</span><br><span class="line"><span class="comment">//设置视频输出编码格式为YUV的一种</span></span><br><span class="line">        drv_ctx.output_format = VDEC_YUV_FORMAT_NV12;</span><br><span class="line">        <span class="comment">//设置颜色编码</span></span><br><span class="line">        OMX_COLOR_FORMATTYPE dest_color_format = (OMX_COLOR_FORMATTYPE)</span><br><span class="line">            QOMX_COLOR_FORMATYUV420PackedSemiPlanar32m;</span><br><span class="line">        <span class="keyword">if</span> (!client_buffers.set_color_format(dest_color_format)) &#123;</span><br><span class="line">            DEBUG_PRINT_ERROR(<span class="string">"Setting color format failed"</span>);</span><br><span class="line">            eRet = OMX_ErrorInsufficientResources;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//订阅事件</span></span><br><span class="line">        capture_capability= V4L2_PIX_FMT_NV12;</span><br><span class="line">        ret = subscribe_to_events(drv_ctx.video_driver_fd);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            DEBUG_PRINT_ERROR(<span class="string">"Subscribe Event Failed"</span>);</span><br><span class="line">            <span class="keyword">return</span> OMX_ErrorInsufficientResources;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_capability</span> <span class="title">cap</span>;</span></span><br><span class="line">        <span class="comment">//设置查询能力标志位</span></span><br><span class="line">        ret = ioctl(drv_ctx.video_driver_fd, VIDIOC_QUERYCAP, &amp;cap);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            DEBUG_PRINT_ERROR(<span class="string">"Failed to query capabilities"</span>);</span><br><span class="line">            <span class="comment">/*<span class="doctag">TODO:</span> How to handle this case */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            DEBUG_PRINT_HIGH(<span class="string">"Capabilities: driver_name = %s, card = %s, bus_info = %s,"</span></span><br><span class="line">                    <span class="string">" version = %d, capabilities = %x"</span>, cap.driver, cap.card,</span><br><span class="line">                    cap.bus_info, cap.version, cap.capabilities);</span><br><span class="line">        &#125;</span><br><span class="line">        ret=<span class="number">0</span>;</span><br><span class="line">        fdesc.type=V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;</span><br><span class="line">        fdesc.index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (ioctl(drv_ctx.video_driver_fd, VIDIOC_ENUM_FMT, &amp;fdesc) == <span class="number">0</span>) &#123;</span><br><span class="line">            DEBUG_PRINT_HIGH(<span class="string">"fmt: description: %s, fmt: %x, flags = %x"</span>, fdesc.description,</span><br><span class="line">                    fdesc.pixelformat, fdesc.flags);</span><br><span class="line">            fdesc.index++;</span><br><span class="line">        &#125;</span><br><span class="line">        fdesc.type=V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;</span><br><span class="line">        fdesc.index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (ioctl(drv_ctx.video_driver_fd, VIDIOC_ENUM_FMT, &amp;fdesc) == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            DEBUG_PRINT_HIGH(<span class="string">"fmt: description: %s, fmt: %x, flags = %x"</span>, fdesc.description,</span><br><span class="line">                    fdesc.pixelformat, fdesc.flags);</span><br><span class="line">            fdesc.index++;</span><br><span class="line">        &#125;</span><br><span class="line">        update_resolution(<span class="number">320</span>, <span class="number">240</span>);</span><br><span class="line">        fmt.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;</span><br><span class="line">        fmt.fmt.pix_mp.height = drv_ctx.video_resolution.frame_height;</span><br><span class="line">        fmt.fmt.pix_mp.width = drv_ctx.video_resolution.frame_width;</span><br><span class="line">        fmt.fmt.pix_mp.pixelformat = output_capability;</span><br><span class="line">        ret = ioctl(drv_ctx.video_driver_fd, VIDIOC_S_FMT, &amp;fmt);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            <span class="comment">/*<span class="doctag">TODO:</span> How to handle this case */</span></span><br><span class="line">            DEBUG_PRINT_ERROR(<span class="string">"Failed to set format on output port"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        DEBUG_PRINT_HIGH(<span class="string">"Set Format was successful"</span>);</span><br><span class="line">        <span class="comment">//如果有歧义的解码组件</span></span><br><span class="line">        <span class="keyword">if</span> (codec_ambiguous) &#123;</span><br><span class="line">            <span class="keyword">if</span> (output_capability == V4L2_PIX_FMT_DIVX) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_control</span> <span class="title">divx_ctrl</span>;</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (drv_ctx.decoder_format == VDEC_CODECTYPE_DIVX_4) &#123;</span><br><span class="line">                    divx_ctrl.value = V4L2_MPEG_VIDC_VIDEO_DIVX_FORMAT_4;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (drv_ctx.decoder_format == VDEC_CODECTYPE_DIVX_5) &#123;</span><br><span class="line">                    divx_ctrl.value = V4L2_MPEG_VIDC_VIDEO_DIVX_FORMAT_5;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    divx_ctrl.value = V4L2_MPEG_VIDC_VIDEO_DIVX_FORMAT_6;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                divx_ctrl.id = V4L2_CID_MPEG_VIDC_VIDEO_DIVX_FORMAT;</span><br><span class="line">                ret = ioctl(drv_ctx.video_driver_fd, VIDIOC_S_CTRL, &amp;divx_ctrl);</span><br><span class="line">                <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">                    DEBUG_PRINT_ERROR(<span class="string">"Failed to set divx version"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                DEBUG_PRINT_ERROR(<span class="string">"Codec should not be ambiguous"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//解码相关参数设置</span></span><br><span class="line">        fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;</span><br><span class="line">        fmt.fmt.pix_mp.height = drv_ctx.video_resolution.frame_height;</span><br><span class="line">        fmt.fmt.pix_mp.width = drv_ctx.video_resolution.frame_width;</span><br><span class="line">        fmt.fmt.pix_mp.pixelformat = capture_capability;</span><br><span class="line">        ret = ioctl(drv_ctx.video_driver_fd, VIDIOC_S_FMT, &amp;fmt);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            <span class="comment">/*<span class="doctag">TODO:</span> How to handle this case */</span></span><br><span class="line">            DEBUG_PRINT_ERROR(<span class="string">"Failed to set format on capture port"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        DEBUG_PRINT_HIGH(<span class="string">"Set Format was successful"</span>);</span><br><span class="line">        <span class="keyword">if</span> (secure_mode) &#123;</span><br><span class="line">            control.id = V4L2_CID_MPEG_VIDC_VIDEO_SECURE;</span><br><span class="line">            control.value = <span class="number">1</span>;</span><br><span class="line">            DEBUG_PRINT_LOW(<span class="string">"Omx_vdec:: calling to open secure device %d"</span>, ret);</span><br><span class="line">            ret=ioctl(drv_ctx.video_driver_fd, VIDIOC_S_CTRL,&amp;control);</span><br><span class="line">            <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">                DEBUG_PRINT_ERROR(<span class="string">"Omx_vdec:: Unable to open secure device %d"</span>, ret);</span><br><span class="line">                close(drv_ctx.video_driver_fd);</span><br><span class="line">                <span class="keyword">return</span> OMX_ErrorInsufficientResources;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*Get the Buffer requirements for input and output ports*/</span></span><br><span class="line">        <span class="comment">//获得输入和输出的缓冲条件</span></span><br><span class="line">        drv_ctx.ip_buf.buffer_type = VDEC_BUFFER_TYPE_INPUT;</span><br><span class="line">        drv_ctx.op_buf.buffer_type = VDEC_BUFFER_TYPE_OUTPUT;</span><br><span class="line">        <span class="keyword">if</span> (secure_mode) &#123;</span><br><span class="line">            drv_ctx.op_buf.alignment=SZ_1M;</span><br><span class="line">            drv_ctx.ip_buf.alignment=SZ_1M;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            drv_ctx.op_buf.alignment=SZ_4K;</span><br><span class="line">            drv_ctx.ip_buf.alignment=SZ_4K;</span><br><span class="line">        &#125;</span><br><span class="line">        drv_ctx.interlace = VDEC_InterlaceFrameProgressive;</span><br><span class="line">        drv_ctx.extradata = <span class="number">0</span>;</span><br><span class="line">        drv_ctx.picture_order = VDEC_ORDER_DISPLAY;</span><br><span class="line">        control.id = V4L2_CID_MPEG_VIDC_VIDEO_OUTPUT_ORDER;</span><br><span class="line">        control.value = V4L2_MPEG_VIDC_VIDEO_OUTPUT_ORDER_DISPLAY;</span><br><span class="line">        ret = ioctl(drv_ctx.video_driver_fd, VIDIOC_S_CTRL, &amp;control);</span><br><span class="line">        drv_ctx.idr_only_decoding = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        m_state = OMX_StateLoaded;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEFAULT_EXTRADATA</span></span><br><span class="line">        <span class="keyword">if</span> (eRet == OMX_ErrorNone &amp;&amp; !secure_mode)</span><br><span class="line">            enable_extradata(DEFAULT_EXTRADATA, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        eRet=get_buffer_req(&amp;drv_ctx.ip_buf);</span><br><span class="line">        DEBUG_PRINT_HIGH(<span class="string">"Input Buffer Size =%d"</span>,drv_ctx.ip_buf.buffer_size);</span><br><span class="line">        get_buffer_req(&amp;drv_ctx.op_buf);</span><br><span class="line">        <span class="comment">//如果解码器格式是h264或者hevc/h265</span></span><br><span class="line">        <span class="keyword">if</span> (drv_ctx.decoder_format == VDEC_CODECTYPE_H264 ||</span><br><span class="line">                drv_ctx.decoder_format == VDEC_CODECTYPE_HEVC) &#123;</span><br><span class="line">            h264_scratch.nAllocLen = drv_ctx.ip_buf.buffer_size;</span><br><span class="line">            h264_scratch.pBuffer = (OMX_U8 *)<span class="built_in">malloc</span> (drv_ctx.ip_buf.buffer_size);</span><br><span class="line">            h264_scratch.nFilledLen = <span class="number">0</span>;</span><br><span class="line">            h264_scratch.nOffset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (h264_scratch.pBuffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                DEBUG_PRINT_ERROR(<span class="string">"h264_scratch.pBuffer Allocation failed "</span>);</span><br><span class="line">                <span class="keyword">return</span> OMX_ErrorInsufficientResources;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//如果解码器格式是h264</span></span><br><span class="line">        <span class="keyword">if</span> (drv_ctx.decoder_format == VDEC_CODECTYPE_H264) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_frame_parser.mutils == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                m_frame_parser.mutils = <span class="keyword">new</span> H264_Utils();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (m_frame_parser.mutils == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    DEBUG_PRINT_ERROR(<span class="string">"parser utils Allocation failed "</span>);</span><br><span class="line">                    eRet = OMX_ErrorInsufficientResources;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    m_frame_parser.mutils-&gt;initialize_frame_checking_environment();</span><br><span class="line">                    m_frame_parser.mutils-&gt;allocate_rbsp_buffer (drv_ctx.ip_buf.buffer_size);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//创建一个h264流的解析器</span></span><br><span class="line">            h264_parser = <span class="keyword">new</span> h264_stream_parser();</span><br><span class="line">            <span class="keyword">if</span> (!h264_parser) &#123;</span><br><span class="line">                DEBUG_PRINT_ERROR(<span class="string">"ERROR: H264 parser allocation failed!"</span>);</span><br><span class="line">                eRet = OMX_ErrorInsufficientResources;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//打开一个管道，读写端保存进fds数组</span></span><br><span class="line">        <span class="keyword">if</span> (pipe(fds)) &#123;</span><br><span class="line">            DEBUG_PRINT_ERROR(<span class="string">"pipe creation failed"</span>);</span><br><span class="line">            eRet = OMX_ErrorInsufficientResources;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> temp1[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (fds[<span class="number">0</span>] == <span class="number">0</span> || fds[<span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pipe (temp1)) &#123;</span><br><span class="line">                    DEBUG_PRINT_ERROR(<span class="string">"pipe creation failed"</span>);</span><br><span class="line">                    <span class="keyword">return</span> OMX_ErrorInsufficientResources;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//close (fds[0]);</span></span><br><span class="line">                <span class="comment">//close (fds[1]);</span></span><br><span class="line">                fds[<span class="number">0</span>] = temp1 [<span class="number">0</span>];</span><br><span class="line">                fds[<span class="number">1</span>] = temp1 [<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//输入/读</span></span><br><span class="line">            m_pipe_in = fds[<span class="number">0</span>];</span><br><span class="line">            <span class="comment">//输出/写</span></span><br><span class="line">            m_pipe_out = fds[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//创建一个工作线程，调用omx开始处理解码，并进行i/o操作</span></span><br><span class="line">            r = pthread_create(&amp;msg_thread_id,<span class="number">0</span>,message_thread,<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                DEBUG_PRINT_ERROR(<span class="string">"component_init(): message_thread creation failed"</span>);</span><br><span class="line">                eRet = OMX_ErrorInsufficientResources;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//没有错误，然后收尾</span></span><br><span class="line">    <span class="keyword">if</span> (eRet != OMX_ErrorNone) &#123;</span><br><span class="line">        DEBUG_PRINT_ERROR(<span class="string">"Component Init Failed"</span>);</span><br><span class="line">        DEBUG_PRINT_HIGH(<span class="string">"Calling VDEC_IOCTL_STOP_NEXT_MSG"</span>);</span><br><span class="line">        (<span class="keyword">void</span>)ioctl(drv_ctx.video_driver_fd, VDEC_IOCTL_STOP_NEXT_MSG,</span><br><span class="line">                <span class="literal">NULL</span>);</span><br><span class="line">        DEBUG_PRINT_HIGH(<span class="string">"Calling close() on Video Driver"</span>);</span><br><span class="line">        close (drv_ctx.video_driver_fd);</span><br><span class="line">        drv_ctx.video_driver_fd = <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        DEBUG_PRINT_HIGH(<span class="string">"omx_vdec::component_init() success"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//memset(&amp;h264_mv_buff,0,sizeof(struct h264_mv_buffer));</span></span><br><span class="line">    <span class="keyword">return</span> eRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这个是解码组件的初始化实现。我们能够看出和TI的差距挺大的。步骤大概如下（maybe wrong）：</p><p>☯ 打开media相关设备文件<br>☯ 创建一个异步线程，执行async_message_thread函数，对输入端进行设置<br>☯ 根据解码器role名配置相关属性<br>☯ 对视频解码相关基本配置进行设置<br>☯ 创建一个管道，然后再开一个个工作线程，调用omx开始处理解码，并进行i/o操作</p><h4 id="（三）、Android中OpenMax的实现"><a href="#（三）、Android中OpenMax的实现" class="headerlink" title="（三）、Android中OpenMax的实现"></a>（三）、Android中OpenMax的实现</h4><h5 id="3-1、android-MediaCodec-ACodec"><a href="#3-1、android-MediaCodec-ACodec" class="headerlink" title="3.1、android MediaCodec ACodec"></a>3.1、android MediaCodec ACodec</h5><h5 id="3-1-1、MediaCodec"><a href="#3-1-1、MediaCodec" class="headerlink" title="3.1.1、MediaCodec"></a>3.1.1、MediaCodec</h5><p>MediaCodec类可用于访问Android底层的媒体编解码器，例如，编码/解码组件。它是Android为多媒体支持提供的底层接口的一部分（通常与MediaExtractor, MediaSync, MediaMuxer, MediaCrypto, MediaDrm, Image, Surface, 以及AudioTrack一起使用）。<br>从广义上讲，一个编解码器通过处理输入数据来产生输出数据。它通过异步方式处理数据，并且使用了一组输入输出buffers。在简单层面，请求（或接收）到一个空的输入buffer，向里面填满数据并将它传递给编解码器处理。这个编解码器将使用完这些数据并向所有空的输出buffer中的一个填充这些数据。最终，请求（或接受）到一个填充了数据的buffer,可以使用其中的数据内容，并且在使用完后将其释放回编解码器。</p><p>1、    Data Types<br>编解码器处理三种类型的数据：压缩数据，原始音频数据，原始视频数据。上述三种数据都可以通过ByteBuffers进行处理，但需要为原始视频数据提供一个Surface来提高编解码性能。<br>    压缩缓存（Compressed Buffers）：输入缓冲区(解码器)和输出缓冲区(编码器)包含压缩数据格式的类型。<br>    原始音频缓存（Raw Audio Buffers）：原始音频缓冲区包含整个PCM音频帧数据。<br>    原始视频缓存（Raw Video Buffers）：ByteBuffer模式视频缓冲区根据他们的颜色格式布局。视频编解码器可能支持三种类型的色彩格式：1)、native raw video format：被COLOR_FormatSurface标记，其可与输入或输出Surface一起使用；2)、flexible YUV buffers（如COLOR_FormatYUV420Flexible），可以与输入/输出Surface一起使用, ByteBuffer模式下可以通过调用getInput/OutputImage(int)方法进行使用；3)、通常只在ByteBuffer模式下被支持。由供应商指定，可以使用 getInput/OutputImage(int)方法。</p><p>2、States<br>在编解码器的生命周期内有三种理论状态：停止态-Stopped、执行态-Executing、释放态-Released。停止状态（Stopped）包括了三种子状态：未初始化（Uninitialized）、配置（Configured）、错误（Error）。执行状态（Executing）在概念上会经历三种子状态：刷新（Flushed）、运行（Running）、流结束（End-of-Stream）。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/VS-04-10-MediaCodec-states.png" alt="Alt text | center"></p><p>使用工厂方法之一创建一个编解码器的时候，是处于Uninitialized状态。首先，需要通过configure(…)方法配置它，以此进入Configured 状态。然后，通过调用start()方法转入Executing 状态。在这个状态下可以通过上述buffer队列操作过程数据。<br>调用start()方法后立即进入Flushed状态，此时编解码器拥有所有的缓存。一旦第一个输入缓存被移出队列，编解码器就转入运行子状态，这种状态占据了编解码器的大部分生命周期。当将一个带有end-of-stream marker标记的输入缓存入队列时，编解码器将转入流结束子状态。可在Executing状态的任何时候通过调用flush()。<br>调用stop()方法返回编解码器的Uninitialized 状态，因此这个编解码器需要再次configured 。当使用完编解码器后，必须调用release()方法释放其资源。</p><p>3、Data Processing<br>每一个编解码器包含一组输入和输出缓存，这些缓存在API调用中通过buffer-ID进行引用。当成功调用start()方法后客户端将不会拥有输入或输出buffers。在同步模式下，通过调用dequeueInput/OutputBuffer(…) 方法从编解码器获得一个输入或输出buffer；在异步模式下，可以通过MediaCodec.Callback.onInput/OutputBufferAvailable(…)的回调方法自动地获得可用的buffers。<br>在获得一个输入buffe后，填充数据，利用queueInputBuffer/queueSecureInputBuffer方法将其提交给编解码器，不要提交多个具有相同时间戳的输入bufers（除非它是也被同样标记的codec-specific data，因为codec-specific data缓冲的时间戳无意义）。<br>a.    Asynchronous Processing using Buffers<br>    从Android 5.0开始，首选的方法是调用configure之前通过设置回调异步地处理数据。异步模式稍微改变了状态转换方式，因为必须在调用flush()方法后再调用start()方法才能使编解码器的状态转换为Running子状态并开始接收输入buffers。同样，初始调用start方法将编解码器的状态直接变化为Running 子状态并通过回调方法开始传递可用的输入buufers。<br>b.    Synchronous Processing using Buffers<br>从Android 5.0开始，即使在同步模式下使用编解码器，也应该通过getInput/OutputBuffer(int) 和/或 getInput/OutputImage(int) 方法检索输入和输出buffers。</p><h5 id="3-1-2、ACodec"><a href="#3-1-2、ACodec" class="headerlink" title="3.1.2、ACodec"></a>3.1.2、ACodec</h5><p>1、ACodec消息机制：<br>    ACodec有一个BaseState和派生出来的其他State，如 UninitializedState, LoadedToIdleState, ExecutingState等。当有消息过来时，如果派生类有重写的方法，则会调到重写的方法，如果没有，则会调到BaseState的<br>    ACodec继承自AHierarchicalStateMachine类，该类用于将收到的消息传递给哪个state。<br>    ACodec收到的消息分两种，一种是MediaCodec传过来的，对应onMessageReceived方法；另一种是OMX Component传过来的，对应onOMXMessage方法。而onOMXMessage里面又分了4种情况来调用不同的方法。（EVENT、EMPTY_BUFFER_DONE、FILL_BUFFER_DONE和FRAME_RENDERED）</p><p>2、MediaCodec与ACodec的通知：<br>    OMX的组件解码之后，ACodec::BaseState:: onOMXFillBufferDone (…)会被回调，去取得解码后的数据。然后会在onOMXFillBufferDone中调用notify通知MediaCodec，发给MediaCodec的消息形如notify-&gt;setInt32(“what”, CodecBase::kWhatDrainThisBuffer);<br>    MediaCodec收到ACodec发的消息之后会updateBuffers(kPortIndexOutput, msg) 进行更新，同时调用onOutputBufferAvailable()中通知NuPlayer::Decoder有可用的output buffer。</p><p>3、ACodec有三种端口模式状态，其会根据当前处于哪个状态来决定buffer如何处理：<br>    KEEP_BUFFERS：当ACodec处于BaseState或者收到OnInputBufferFilled消息但是buffer里面没有填充有效的数据时，ACodec握有的buffer不会送到OMX 组件；<br>    RESUBMIT_BUFFERS：当ACodec处于ExecutingState或者处于OutputPortSettingChangedState但是当前是input口的buffer时，ACodec将握有的buffer送给OMX 组件；<br>    FREE_BUFFERS：当ACodec处于OutputPortSettingChangedState并且当前是output口的buffer时，ACodec将握有的buffer free。</p><p>4、stagefright类的调用关系：<br>    OMXNodeInstance负责创建并维护不同的实例，这些实例以node作为唯一标识。这样播放器中每个ACodec在OMX服务端都对应有了自己的OMXNodeInstance实例。<br>    OMXMaster用来维护底层软硬件解码库，根据OMXNodeInstance中想要的解码器来创建解码实体组件。<br>    OMXPluginBase负责加载组件库，创建组件实例，由OMXMaster管理。Android原生提供的组件都是由SoftOMXPlugin类来管理，这个类就是继承自OMXPluginBase。（Android源码提供了一些软件解码和编码的组件，它们被抽象为SoftOMXComponent）<br>    OMXClient是客户端用来与OMX IL进行通信的。<br>    内部结构CallbackDispatcher作用是用来接收回调函数的消息<br>    OMXNodeInstance + CallbackDispatcher = 合作完成不同实例的消息处理任务</p><p>5、ACodec同OMXNodeInstance的消息传递：<br>    ACodec将CodecObserver observer对象通过omx-&gt;allocateNode()传递到OMXNodeInstance。<br>    OMXNodeInstance将kCallbacks(OnEvent,OnEmptyBufferDone,OnFillBufferDone)传递给OMX Component<br>    当OMX Component有消息notify上来时，OMXNodeInstance最先收到，然后调用OMX.cpp。将消息在OMX.cpp里面将OMX Component thread转换到CallbackDispatcher线程中处理。CallbackDispatcher又将消息反调到OMXNodeInstance. 最后调用CodecObserver 的onMessage()回到ACodec中</p><p>6、    ACodec与OMX组件的关系<br>    ACodec ，CodecObserver和OMXNodeInstance是一一对应的，简单的可以理解它们3个构成了OpenMAX IL的一个Component，每一个node就是一个codec在OMX服务端的标识。当然还有CallbackDispatcher，用于处理codec过来的消息，通过它的post/loop/dispatch来发起接收，从OMX.cpp发送消息，最终通过OMXNodeInstance::onMessage -&gt; CodecObserver::onMessage -&gt; ACodec::onMessage一路往上，当然消息的来源是因为我们有向codec注册OMXNodeInstance::kCallbacks。<br>    而在OMXPluginBase创建组件实例的时候，需要传递一个callback给组件，这个callback用于接收组件的消息，它的实现是在OMXNodeInstance.cpp中。而kcallbacks是OMXNodeInstance的静态成员变量，它内部的三个函数指针分别指向了OMXNodeInstance的三个静态方法，也即是这三个方法与组件进行着消息传递</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/VS-04-11-OMX-allocateNode.png" alt="Alt text | center"></p><p>    对于NuPlayer来说，它并不直接接触解码组件，而是通过创建ACodec来和组件交互。ACode内部有一个id，这个id对应于一个OMXNodeInstance。OMX对象中会对产生的每一个OMXNodeInstance分配一个唯一的node_id。每一个OMXNodeInstance内部又保存着组件实例的指针【OMX_HANDLETYPE mHandle;】，通过这个指针就可以和组件进行交互。交互的流程为：ACodec → OMX → OMXNodeInstance → COMPONENT。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/VS-04-12-NuPlayer-libstagefrighthw.png" alt="Alt text | center"></p><p>8、组件的管理<br>    对组件的管理可以总结为：通过OMXMaster加载libstagefrighthw.so库文件，创建OMXPluginBase【即创建继承此类的组件对象】，通过这个类来管理组件。<br>    Android源码提供了一些软件解码和编码的组件，它们被抽象为SoftOMXComponent。OMXPluginBase扮演者组件的管理者。它负责加载组件库，创建组件实例。而OMXMaster则管理着OMXPluginBase，Android原生提供的组件都是由SoftOMXPlugin类来管理，这个类就是继承自OMXPluginBase。<br>    对于厂商来说，如果要实现自己的组件管理模块，需要通过继承实现OMXPluginBase，并将之编译为libstagefrighthw.so。在OMXMaster中会加载这个库文件，然后调用其createOMXPlugin方法获得一个OMXPluginBase指针，然后将其加入OMXPluginBase列表以及与组件名相关的map 【mPluginByComponentName】中，后续都会通过OMXPluginBase来管理组件。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/VS-04-13-OMXMaster-addPlugin.png" alt="Alt text | center"></p><h5 id="3-2、音视频解码数据处理"><a href="#3-2、音视频解码数据处理" class="headerlink" title="3.2、音视频解码数据处理"></a>3.2、音视频解码数据处理</h5><p>数据处理请参考： <a href="http://zhoujinjian.cc/2018/06/06/Android%20Video%20System%EF%BC%882%EF%BC%89%EF%BC%9A%E9%9F%B3%E8%A7%86%E9%A2%91%E5%88%86%E7%A6%BBMediaExtractor%E3%80%81%E8%A7%A3%E7%A0%81Decoder%E3%80%81%E6%B8%B2%E6%9F%93Renderer%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#%EF%BC%88%E4%B8%89%EF%BC%89%E3%80%81%E9%9F%B3%E8%A7%86%E9%A2%91%E8%A7%A3%E7%A0%81%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86">音视频解码数据处理</a></p><h5 id="3-3、高通实现（参考高通文档）"><a href="#3-3、高通实现（参考高通文档）" class="headerlink" title="3.3、高通实现（参考高通文档）"></a>3.3、高通实现（参考高通文档）</h5><p><a href="https://createpoint.qti.qualcomm.com" target="_blank" rel="noopener">OpenMAX Integration Layer Video Encoder for Linux Android（高通文档）</a><br><a href="https://createpoint.qti.qualcomm.com" target="_blank" rel="noopener">OpenMAX Integration Layer Video Decoder for Linux Android（高通文档）</a></p><h4 id="（四）、参考资料-特别感谢各位前辈的分析和图示-："><a href="#（四）、参考资料-特别感谢各位前辈的分析和图示-：" class="headerlink" title="（四）、参考资料(特别感谢各位前辈的分析和图示)："></a>（四）、参考资料(特别感谢各位前辈的分析和图示)：</h4><p><a href="http://windrunnerlihuan.com/2016/12/15/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91-%E4%BA%94-OpenMax%E7%AE%80%E4%BB%8B/" target="_blank" rel="noopener">Android多媒体开发(五)—-OpenMax简介</a><br><a href="http://windrunnerlihuan.com/2016/12/26/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91-%E5%85%AD-Android%E4%B8%ADOpenMax%E7%9A%84%E5%AE%9E%E7%8E%B0-preview/" target="_blank" rel="noopener">Android多媒体开发(六)—-Android中OpenMax的实现(preview)</a><br><a href="http://windrunnerlihuan.com/2016/12/29/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91-%E4%B8%83-Android%E4%B8%ADOpenMax%E7%9A%84%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">Android多媒体开发(七)—-Android中OpenMax的实现</a><br><a href="https://blog.csdn.net/dfhuang09/article/details/54926526" target="_blank" rel="noopener">android ACodec MediaCodec NuPlayer flow - CSDN博客</a><br><a href="https://blog.csdn.net/dfhuang09/article/details/60132620" target="_blank" rel="noopener">android MediaCodec ACodec - CSDN博客</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;注：文章都是通过阅读各位前辈总结的资料 Android 7.1.2 &amp;amp;&amp;amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内
      
    
    </summary>
    
      <category term="Android" scheme="http://zhoujinjian.cc/categories/Android/"/>
    
    
      <category term="Android" scheme="http://zhoujinjian.cc/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android Display System（5）：Android Display System 系统分析之Display Driver Architecture</title>
    <link href="http://zhoujinjian.cc/2018/08/30/Android%20Display%20System%EF%BC%885%EF%BC%89%EF%BC%9AAndroid%20Display%20System%20%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B9%8BDisplay%20Driver%20Architecture/"/>
    <id>http://zhoujinjian.cc/2018/08/30/Android Display System（5）：Android Display System 系统分析之Display Driver Architecture/</id>
    <published>2018-08-29T16:00:00.000Z</published>
    <updated>2018-06-20T15:15:33.034Z</updated>
    
    <content type="html"><![CDATA[<hr><p>注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;&amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除，禁止转载（©Qualcomm Technologies, Inc. 版权所有），谢谢。</p><p><a href="https://github.com/izhoujinjian/zhoujinjian.cc/tree/master/display.system" target="_blank" rel="noopener">【博客原图链接】</a></p><p><a href="https://blog.csdn.net/eliot_shao/article/details/74926010" target="_blank" rel="noopener">【特别感谢 - 高通Android平台-应用空间操作framebuffer dump LCD总结】</a><br><a href="https://blog.csdn.net/u012719256/article/details/52096727" target="_blank" rel="noopener">【特别感谢 -  linux qcom LCD framwork】</a><br><a href="https://blog.csdn.net/ic_soc_arm_robin/article/details/12949347" target="_blank" rel="noopener">【特别感谢 -  msm8610 lcd driver code analysis】</a></p><p>Google Pixel、Pixel XL 内核代码（文章基于 Kernel-3.18）：<br> <a href="https://github.com/matthewdalex/marlin" target="_blank" rel="noopener">Kernel source for Pixel and Pixel XL - GitHub</a></p><p>AOSP 源码（文章基于 Android 7.1.2）：<br> <a href="https://testerhome.com/topics/2229" target="_blank" rel="noopener"> Android 系统全套源代码分享 (更新到 8.1.0_r1)</a></p><p> 🌀🌀：专注于Linux &amp;&amp; Android Multimedia（Camera、Video、Audio、Display）系统分析与研究</p><p>【Android Display System 系统分析系列】：<br>【Android Display System（1）：Android 7.1.2 (Android N) Android Graphics 系统 分析】<br>【Android Display System（2）：Android Display System 系统分析之Android EGL &amp;&amp; OpenGL】<br>【Android Display System（3）：Android Display System 系统分析之HardwareRenderer.draw()绘制流程分析】<br>【Android Display System（4）：Android Display System 系统分析之Gralloc &amp;&amp; HWComposer模块分析】<br>【Android Display System（5）：Android Display System 系统分析之Display Driver Architecture】 </p><hr><p>路径：<br>kernel\msm-3.18\drivers\video\msm\mdss</p><p> MDSS driver software block diagram</p><ul><li>mdss_fb → Top-level IOCTL/native framebufferinterface</li><li>mdss_mdp.c → MDP resources(clocks/irq/bus-bw/power)</li><li>mdss_mdp_overlay → Overlay/DMA top-levelAPI</li><li>mdss_mdp_ctl → Controls the hardware abstraction to club the (LM + DSPP + Ping-pong +<br>interface)</li><li>mdss_mdp_pipe → SRC pipe related handling</li><li>mdss_mdp_intf_cmd/mdss_mdp_intf_video/mdss_mdp_intf_writeback → MDP panel<br>interface relatedhandling</li><li>mdss_mdp_pp → Postprocessing related implementation</li><li>mdss_mdp_rotator → Rotator APIs (overlay_set/overlay_playinterface)</li><li>mdss_mdp_pp.c → Postprocessing relatedmaterial</li></ul><hr><p><strong>注：</strong>首先说明，由于博主不是kernel开发方向的，可能理解不够透彻，还请看官见谅，主要是为了理解Kernel Display原理。为了加深对显示屏工作原理的理解，首先先看两个操作LCD显示屏的例子<br>绪论（总体架构图）：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS05-01-Display-Architecture.png" alt="Alt text | center"></p><h4 id="（一）、直接操作framebuffer显示图像"><a href="#（一）、直接操作framebuffer显示图像" class="headerlink" title="（一）、直接操作framebuffer显示图像"></a>（一）、直接操作framebuffer显示图像</h4><h5 id="1-1、直接操作framebuffer显示图像"><a href="#1-1、直接操作framebuffer显示图像" class="headerlink" title="1.1、直接操作framebuffer显示图像"></a>1.1、直接操作framebuffer显示图像</h5><h5 id="1-1-1、源代码"><a href="#1-1-1、源代码" class="headerlink" title="1.1.1、源代码"></a>1.1.1、源代码</h5><p><strong>panel_test.c</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fb.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"yellow_face.zif"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> fbfd = <span class="number">0</span>;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fb_var_screeninfo</span> <span class="title">vinfo</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fb_fix_screeninfo</span> <span class="title">finfo</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fb_cmap</span> <span class="title">cmapinfo</span>;</span>  </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> screensize = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">char</span> *fbp = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> location = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">int</span> b,g,r;  </span><br><span class="line">    <span class="comment">// Open the file for reading and writing  </span></span><br><span class="line">    fbfd = open(<span class="string">"/dev/graphics/fb0"</span>, O_RDWR,<span class="number">0</span>);                    <span class="comment">// 打开Frame Buffer设备  </span></span><br><span class="line">    <span class="keyword">if</span> (fbfd &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Error: cannot open framebuffer device.%x\n"</span>,fbfd);  </span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The framebuffer device was opened successfully.\n"</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Get fixed screen information  </span></span><br><span class="line">    <span class="keyword">if</span> (ioctl(fbfd, FBIOGET_FSCREENINFO, &amp;finfo)) &#123;            <span class="comment">// 获取设备固有信息  </span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Error reading fixed information.\n"</span>);  </span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">2</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\ntype:0x%x\n"</span>, finfo.type );                            <span class="comment">// FrameBuffer 类型,如0为象素  </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"visual:%d\n"</span>, finfo.visual );                        <span class="comment">// 视觉类型：如真彩2，伪彩3   </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"line_length:%d\n"</span>, finfo.line_length );        <span class="comment">// 每行长度  </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\nsmem_start:0x%lx,smem_len:%u\n"</span>, finfo.smem_start, finfo.smem_len ); <span class="comment">// 映象RAM的参数  </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"mmio_start:0x%lx ,mmio_len:%u\n"</span>, finfo.mmio_start, finfo.mmio_len );  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// Get variable screen information  </span></span><br><span class="line">    <span class="keyword">if</span> (ioctl(fbfd, FBIOGET_VSCREENINFO, &amp;vinfo)) &#123;            <span class="comment">// 获取设备可变信息  </span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Error reading variable information.\n"</span>);  </span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">3</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%dx%d, %dbpp,xres_virtual=%d,yres_virtual=%dvinfo.xoffset=%d,vinfo.yoffset=%d\n"</span>, vinfo.xres, vinfo.yres, vinfo.bits_per_pixel,vinfo.xres_virtual,vinfo.yres_virtual,vinfo.xoffset,vinfo.yoffset);  </span><br><span class="line"></span><br><span class="line">screensize = finfo.line_length * vinfo.yres_virtual;</span><br><span class="line">    <span class="comment">// Map the device to memory 通过mmap系统调用将framebuffer内存映射到用户空间,并返回映射后的起始地址  </span></span><br><span class="line">    fbp = (<span class="keyword">char</span> *)mmap(<span class="number">0</span>, screensize, PROT_READ | PROT_WRITE, MAP_SHARED,fbfd, <span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">int</span>)fbp == <span class="number">-1</span>) &#123;  </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Error: failed to map framebuffer device to memory.\n"</span>);  </span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">4</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The framebuffer device was mapped to memory successfully.\n"</span>);  </span><br><span class="line"><span class="comment">/***************exampel 1**********************/</span></span><br><span class="line">b = <span class="number">10</span>;</span><br><span class="line">g = <span class="number">100</span>;</span><br><span class="line">r = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">for</span> ( y = <span class="number">0</span>; y &lt; <span class="number">340</span>; y++ )</span><br><span class="line">        <span class="keyword">for</span> ( x = <span class="number">0</span>; x &lt; <span class="number">420</span>; x++ ) &#123; </span><br><span class="line">      </span><br><span class="line">         location = (x+<span class="number">100</span>) * (vinfo.bits_per_pixel/<span class="number">8</span>) + </span><br><span class="line">             (y+<span class="number">100</span>) * finfo.line_length; </span><br><span class="line">      </span><br><span class="line">         <span class="keyword">if</span> ( vinfo.bits_per_pixel == <span class="number">32</span> ) &#123;        <span class="comment">//          </span></span><br><span class="line">                        *(fbp + location) = b; <span class="comment">// Some blue  </span></span><br><span class="line">                        *(fbp + location + <span class="number">1</span>) = g;             <span class="comment">// A little green  </span></span><br><span class="line">                        *(fbp + location + <span class="number">2</span>) = r;             <span class="comment">// A lot of red  </span></span><br><span class="line">                        *(fbp + location + <span class="number">3</span>) = <span class="number">0</span>;     <span class="comment">// No transparency  </span></span><br><span class="line">         &#125;</span><br><span class="line">      </span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">/*****************exampel 1********************/</span></span><br><span class="line"><span class="comment">/*****************exampel 2********************/</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> *pTemp = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)fbp;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="comment">//起始坐标(x,y),终点坐标(right,bottom)</span></span><br><span class="line">x = <span class="number">400</span>;</span><br><span class="line">y = <span class="number">400</span>;</span><br><span class="line"><span class="keyword">int</span> right = <span class="number">700</span>;<span class="comment">//vinfo.xres;</span></span><br><span class="line"><span class="keyword">int</span> bottom = <span class="number">1000</span>;<span class="comment">//vinfo.yres;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=y; i&lt; bottom; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=x; j&lt;right; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> data = yellow_face_data[(((i-y)  % <span class="number">128</span>) * <span class="number">128</span>) + ((j-x) %<span class="number">128</span>)];</span><br><span class="line">pTemp[i*finfo.line_length + (j*<span class="number">4</span>) + <span class="number">2</span>] = (<span class="keyword">unsigned</span> <span class="keyword">char</span>)((data &amp; <span class="number">0xF800</span>) &gt;&gt; <span class="number">11</span> &lt;&lt; <span class="number">3</span>);</span><br><span class="line">pTemp[i*finfo.line_length + (j*<span class="number">4</span>) + <span class="number">1</span>] = (<span class="keyword">unsigned</span> <span class="keyword">char</span>)((data &amp; <span class="number">0x7E0</span>) &gt;&gt; <span class="number">5</span> &lt;&lt; <span class="number">2</span>);</span><br><span class="line">pTemp[i*finfo.line_length + (j*<span class="number">4</span>) + <span class="number">0</span>] = (<span class="keyword">unsigned</span> <span class="keyword">char</span>)((data &amp; <span class="number">0x1F</span>) &lt;&lt; <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/*****************exampel 2********************/</span></span><br><span class="line"><span class="comment">//note：vinfo.xoffset =0 vinfo.yoffset =0 否则FBIOPAN_DISPLAY不成功</span></span><br><span class="line"><span class="keyword">if</span> (ioctl(fbfd, FBIOPAN_DISPLAY, &amp;vinfo)) &#123;    </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Error FBIOPAN_DISPLAY information.\n"</span>);  </span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">5</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">sleep(<span class="number">10</span>);</span><br><span class="line">munmap(fbp,finfo.smem_len);<span class="comment">//finfo.smem_len == screensize == finfo.line_length * vinfo.yres_virtual </span></span><br><span class="line">    close(fbfd);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Android.mk</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># Copyright 2006-2014 The Android Open Source Project</span><br><span class="line"></span><br><span class="line">LOCAL_PATH:= $(call my-dir)</span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line"></span><br><span class="line">LOCAL_SRC_FILES:= panel_test.c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LOCAL_SHARED_LIBRARIES        := $(common_libs) libqdutils libdl liblog libbase libcutils</span><br><span class="line">LOCAL_C_INCLUDES              := $(common_includes) $(kernel_includes)</span><br><span class="line">LOCAL_ADDITIONAL_DEPENDENCIES := $(common_deps) $(kernel_deps)</span><br><span class="line"></span><br><span class="line">LOCAL_MODULE := panel_test</span><br><span class="line"></span><br><span class="line">LOCAL_CFLAGS := -Werror</span><br><span class="line"></span><br><span class="line">include $(BUILD_EXECUTABLE)</span><br><span class="line"></span><br><span class="line">include $(call first-makefiles-under,$(LOCAL_PATH))</span><br></pre></td></tr></table></figure><p><strong>yellow_face.zif</strong><br><a href="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS05-yellow_face.zif" target="_blank" rel="noopener">yellow_face.zif</a></p><h5 id="1-1-2、编译测试"><a href="#1-1-2、编译测试" class="headerlink" title="1.1.2、编译测试"></a>1.1.2、编译测试</h5><p>编译会生成panel_test，然后进行测试。</p><blockquote><p>注意事项：<br>1、adb shell stop 杀掉surfaceflinger 之后在测试；<br>2、设置背光 echo 255 &gt; /sys/class/leds/lcd-backlight/brightness</p><p>1、连接adb<br>2、adb push panel_test system/bin<br>3、进入adb shell<br>4、stop<br>5、echo 255 &gt; /sys/class/leds/lcd-backlight/brightness<br>6、system/bin/panel_test</p></blockquote><h5 id="1-1-3、显示效果"><a href="#1-1-3、显示效果" class="headerlink" title="1.1.3、显示效果"></a>1.1.3、显示效果</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS05-02-Qcom_FrameBuffer_test_.gif" alt="Alt text | center"></p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS05-03-yellow_face_zif_test.jpg" alt="Alt text | center"></p><h5 id="1-1-4、视频（加深理解、自☯备☯梯☯子）"><a href="#1-1-4、视频（加深理解、自☯备☯梯☯子）" class="headerlink" title="1.1.4、视频（加深理解、自☯备☯梯☯子）"></a>1.1.4、视频（加深理解、自☯备☯梯☯子）</h5><p><a href="https://www.youtube.com/watch?v=BUPPyR6VasI" target="_blank" rel="noopener">Android Frame Buffer and Screen Shots Tutorial</a><br><a href="https://www.youtube.com/watch?v=7n_hDZ6kHjc" target="_blank" rel="noopener">Mplayer on Android Through Chroot and Frame Buffer</a></p><h5 id="1-1-5、驱动总体概览图"><a href="#1-1-5、驱动总体概览图" class="headerlink" title="1.1.5、驱动总体概览图"></a>1.1.5、驱动总体概览图</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS05-04-msm8x25-display-overview.png" alt="Alt text | center"></p><h4 id="（二）、FrameBuffer驱动程序分析"><a href="#（二）、FrameBuffer驱动程序分析" class="headerlink" title="（二）、FrameBuffer驱动程序分析"></a>（二）、FrameBuffer驱动程序分析</h4><p>FrameBuffer通常作为LCD控制器或者其他显示设备的驱动，FrameBuffer驱动是一个字符设备，设备节点是/dev/fbX（Android 设备为/dev/graphics/fb0），主设备号为29，次设备号递增，用户可以将Framebuffer看成是显示内存的一个映像，将其映射到进程地址空间之后，就可以直接进行读写操作，而写操作可以立即反应在屏幕上。这种操作是抽象的，统一的。用户不必关心物理显存的位置、换页机制等等具体细节。这些都是由Framebuffer设备驱动来完成的。Framebuffer设备为上层应用程序提供系统调用，也为下一层的特定硬件驱动提供接口；那些底层硬件驱动需要用到这儿的接口来向系统内核注册它们自己。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS05-05-mdss-driver-architecture.png" alt="Alt text | center"></p><p>Linux中的PCI设备可以将其控制寄存器映射到物理内存空间，而后，对这些控制寄存器的访问变成了对理内存的访问，因此，这些寄存器又被称为”memio”。一旦被映射到物理内存，Linux的普通进程就可以通过mmap将这些内存I/O映射到进程地址空间，这样就可以直接访问这些寄存器了。</p><p>FrameBuffer设备属于字符设备，采用了文件层—驱动层的接口方式，Linux为帧缓冲设备定义了驱动层的接口fb_info结构，在文件层上，用户调用file_operations的函数操作，间接调用fb_info中的fb_ops函数集来操作硬件。</p><h5 id="2-1、-Framebuffer数据结构"><a href="#2-1、-Framebuffer数据结构" class="headerlink" title="2.1、 Framebuffer数据结构"></a>2.1、 Framebuffer数据结构</h5><h5 id="2-1-1、-fb-info"><a href="#2-1-1、-fb-info" class="headerlink" title="2.1.1、 fb_info"></a>2.1.1、 fb_info</h5><p>fb_info是Linux为帧缓冲设备定义的驱动层接口。它不仅包含了底层函数，而且还有记录设备状态的数据。每个帧缓冲设备都与一个fb_info结构相对应。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;kernel\include\linux\fb.h]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_info</span> &#123;</span></span><br><span class="line"><span class="keyword">atomic_t</span> count;</span><br><span class="line"><span class="keyword">int</span> node;</span><br><span class="line"><span class="keyword">int</span> flags;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">lock</span>;</span><span class="comment">/* Lock for open/release/ioctl funcs */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mm_lock</span>;</span><span class="comment">/* Lock for fb_mmap and smem_* fields */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_var_screeninfo</span> <span class="title">var</span>;</span><span class="comment">/* Current var */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_fix_screeninfo</span> <span class="title">fix</span>;</span><span class="comment">/* Current fix */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_monspecs</span> <span class="title">monspecs</span>;</span><span class="comment">/* Current Monitor specs */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">queue</span>;</span><span class="comment">/* Framebuffer event queue */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_pixmap</span> <span class="title">pixmap</span>;</span><span class="comment">/* Image hardware mapper */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_pixmap</span> <span class="title">sprite</span>;</span><span class="comment">/* Cursor hardware mapper */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_cmap</span> <span class="title">cmap</span>;</span><span class="comment">/* Current cmap */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">modelist</span>;</span>      <span class="comment">/* mode list */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_videomode</span> *<span class="title">mode</span>;</span><span class="comment">/* current mode */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span><span class="comment">/* current file node */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FB_DEFERRED_IO</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">delayed_work</span> <span class="title">deferred_work</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_deferred_io</span> *<span class="title">fbdefio</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_ops</span> *<span class="title">fbops</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span><span class="comment">/* This is the parent */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span><span class="comment">/* This is this fb device */</span></span><br><span class="line"><span class="keyword">int</span> class_flag;                    <span class="comment">/* private sysfs flags */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FB_TILEBLITTING</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_tile_ops</span> *<span class="title">tileops</span>;</span>    <span class="comment">/* Tile Blitting */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">char</span> __iomem *screen_base;<span class="comment">/* Virtual address */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> screen_size;<span class="comment">/* Amount of ioremapped VRAM or 0 */</span> </span><br><span class="line"><span class="keyword">void</span> *pseudo_palette;<span class="comment">/* Fake palette of 16 colors */</span> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FBINFO_STATE_RUNNING0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FBINFO_STATE_SUSPENDED1</span></span><br><span class="line">u32 state;<span class="comment">/* Hardware state i.e suspend */</span></span><br><span class="line"><span class="keyword">void</span> *fbcon_par;                <span class="comment">/* fbcon use-only private area */</span></span><br><span class="line"><span class="comment">/* From here on everything is device dependent */</span></span><br><span class="line"><span class="keyword">void</span> *par;</span><br><span class="line"><span class="comment">/* we need the PCI or similar aperture base/size not</span></span><br><span class="line"><span class="comment">   smem_start/size as smem_start may just be an object</span></span><br><span class="line"><span class="comment">   allocated inside the aperture so may not actually overlap */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">apertures_struct</span> &#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> count;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">aperture</span> &#123;</span></span><br><span class="line"><span class="keyword">resource_size_t</span> base;</span><br><span class="line"><span class="keyword">resource_size_t</span> size;</span><br><span class="line">&#125; ranges[<span class="number">0</span>];</span><br><span class="line">&#125; *apertures;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> skip_vt_switch; <span class="comment">/* no VT switch on suspend/resume required */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="2-1-2、fb-var-screeninfo"><a href="#2-1-2、fb-var-screeninfo" class="headerlink" title="2.1.2、fb_var_screeninfo"></a>2.1.2、fb_var_screeninfo</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS05-06-xres-yres.png" alt="Alt text | center"></p><p>fb_var_screeninfo：用于记录用户可修改的显示控制器参数，包括屏幕分辨率、每个像素点的比特数等</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\include\uapi\linux\fb.h]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_var_screeninfo</span> &#123;</span>  </span><br><span class="line">    __u32 xres;         <span class="comment">/* 行可见像素*/</span>  </span><br><span class="line">    __u32 yres;         <span class="comment">/* 列可见像素*/</span>  </span><br><span class="line">    __u32 xres_virtual; <span class="comment">/* 行虚拟像素*/</span>  </span><br><span class="line">    __u32 yres_virtual; <span class="comment">/* 列虚拟像素*/</span>  </span><br><span class="line">    __u32 xoffset;      <span class="comment">/* 水平偏移量*/</span>  </span><br><span class="line">    __u32 yoffset;      <span class="comment">/* 垂直偏移量*/</span>  </span><br><span class="line">    __u32 bits_per_pixel;<span class="comment">/*每个像素所占bit位数*/</span>  </span><br><span class="line">    __u32 grayscale;    <span class="comment">/* 灰色刻度*/</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fb_bitfield</span> <span class="title">red</span>;</span> <span class="comment">/* bitfield in fb mem if true color, */</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fb_bitfield</span> <span class="title">green</span>;</span>   <span class="comment">/* else only length is significant */</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fb_bitfield</span> <span class="title">blue</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fb_bitfield</span> <span class="title">transp</span>;</span>  <span class="comment">/* transparency         */</span>    </span><br><span class="line">    __u32 nonstd;           <span class="comment">/* != 0 Non standard pixel format */</span>  </span><br><span class="line">    __u32 activate;         <span class="comment">/* see FB_ACTIVATE_*        */</span>  </span><br><span class="line">    __u32 height;           <span class="comment">/* 图像高度*/</span>  </span><br><span class="line">    __u32 width;            <span class="comment">/* 图像宽度*/</span>  </span><br><span class="line">    __u32 accel_flags;      <span class="comment">/* (OBSOLETE) see fb_info.flags */</span>  </span><br><span class="line">    __u32 pixclock;         <span class="comment">/* pixel clock in ps (pico seconds) */</span>  </span><br><span class="line">    __u32 left_margin;      <span class="comment">/* time from sync to picture    */</span>  </span><br><span class="line">    __u32 right_margin;     <span class="comment">/* time from picture to sync    */</span>  </span><br><span class="line">    __u32 upper_margin;     <span class="comment">/* time from sync to picture    */</span>  </span><br><span class="line">    __u32 lower_margin;  </span><br><span class="line">    __u32 hsync_len;        <span class="comment">/* length of horizontal sync    */</span>  </span><br><span class="line">    __u32 vsync_len;        <span class="comment">/* length of vertical sync  */</span>  </span><br><span class="line">    __u32 sync;         <span class="comment">/* see FB_SYNC_*        */</span>  </span><br><span class="line">    __u32 vmode;            <span class="comment">/* see FB_VMODE_*       */</span>  </span><br><span class="line">    __u32 rotate;           <span class="comment">/* angle we rotate counter clockwise */</span>  </span><br><span class="line">    __u32 reserved[<span class="number">5</span>];      <span class="comment">/* Reserved for future compatibility */</span>  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="2-1-3、fb-fix-screeninfo"><a href="#2-1-3、fb-fix-screeninfo" class="headerlink" title="2.1.3、fb_fix_screeninfo"></a>2.1.3、fb_fix_screeninfo</h5><p>fb_fix_screeninfo：记录了用户不能修改的显示控制器的参数，这些参数是在驱动初始化时设置的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\include\uapi\linux\fb.h]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_fix_screeninfo</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> id[<span class="number">16</span>];<span class="comment">/* identification string eg "TT Builtin" */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> smem_start;<span class="comment">/* Start of frame buffer mem */</span></span><br><span class="line"><span class="comment">/* (physical address) */</span></span><br><span class="line">__u32 smem_len;<span class="comment">/* Length of frame buffer mem */</span></span><br><span class="line">__u32 type;<span class="comment">/* see FB_TYPE_**/</span></span><br><span class="line">__u32 type_aux;<span class="comment">/* Interleave for interleaved Planes */</span></span><br><span class="line">__u32 visual;<span class="comment">/* see FB_VISUAL_**/</span> </span><br><span class="line">__u16 xpanstep;<span class="comment">/* zero if no hardware panning  */</span></span><br><span class="line">__u16 ypanstep;<span class="comment">/* zero if no hardware panning  */</span></span><br><span class="line">__u16 ywrapstep;<span class="comment">/* zero if no hardware ywrap    */</span></span><br><span class="line">__u32 line_length;<span class="comment">/* length of a line in bytes    */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> mmio_start;<span class="comment">/* Start of Memory Mapped I/O   */</span></span><br><span class="line"><span class="comment">/* (physical address) */</span></span><br><span class="line">__u32 mmio_len;<span class="comment">/* Length of Memory Mapped I/O  */</span></span><br><span class="line">__u32 accel;<span class="comment">/* Indicate to driver which*/</span></span><br><span class="line"><span class="comment">/*  specific chip/card we have*/</span></span><br><span class="line">__u16 capabilities;<span class="comment">/* see FB_CAP_**/</span></span><br><span class="line">__u16 reserved[<span class="number">2</span>];<span class="comment">/* Reserved for future compatibility */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>fb_ops是提供给底层设备驱动的一个接口。当我们编写一个FrameBuffer的时候，就要依照Linux FrameBuffer编程的套路，填写fb_ops结构体。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\include\linux\fb.h]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_ops</span> &#123;</span></span><br><span class="line"><span class="comment">/* open/release and usage marking */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line"><span class="keyword">int</span> (*fb_open)(struct fb_info *info, <span class="keyword">int</span> user);</span><br><span class="line"><span class="keyword">int</span> (*fb_release)(struct fb_info *info, <span class="keyword">int</span> user);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* For framebuffers with strange non linear layouts or that do not</span></span><br><span class="line"><span class="comment"> * work with normal memory mapped access</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">ssize_t</span> (*fb_read)(struct fb_info *info, <span class="keyword">char</span> __user *buf,</span><br><span class="line">   <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *ppos);</span><br><span class="line"><span class="keyword">ssize_t</span> (*fb_write)(struct fb_info *info, <span class="keyword">const</span> <span class="keyword">char</span> __user *buf,</span><br><span class="line">    <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *ppos);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* checks var and eventually tweaks it to something supported,</span></span><br><span class="line"><span class="comment"> * DO NOT MODIFY PAR */</span></span><br><span class="line"><span class="keyword">int</span> (*fb_check_var)(struct fb_var_screeninfo *var, struct fb_info *info);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* set the video mode according to info-&gt;var */</span></span><br><span class="line"><span class="keyword">int</span> (*fb_set_par)(struct fb_info *info);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* set color register */</span></span><br><span class="line"><span class="keyword">int</span> (*fb_setcolreg)(<span class="keyword">unsigned</span> regno, <span class="keyword">unsigned</span> red, <span class="keyword">unsigned</span> green,</span><br><span class="line">    <span class="keyword">unsigned</span> blue, <span class="keyword">unsigned</span> transp, struct fb_info *info);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* set color registers in batch */</span></span><br><span class="line"><span class="keyword">int</span> (*fb_setcmap)(struct fb_cmap *cmap, struct fb_info *info);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* blank display */</span></span><br><span class="line"><span class="keyword">int</span> (*fb_blank)(<span class="keyword">int</span> blank, struct fb_info *info);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* pan display */</span></span><br><span class="line"><span class="keyword">int</span> (*fb_pan_display)(struct fb_var_screeninfo *var, struct fb_info *info);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Draws a rectangle */</span></span><br><span class="line"><span class="keyword">void</span> (*fb_fillrect) (struct fb_info *info, <span class="keyword">const</span> struct fb_fillrect *rect);</span><br><span class="line"><span class="comment">/* Copy data from area to another */</span></span><br><span class="line"><span class="keyword">void</span> (*fb_copyarea) (struct fb_info *info, <span class="keyword">const</span> struct fb_copyarea *region);</span><br><span class="line"><span class="comment">/* Draws a image to the display */</span></span><br><span class="line"><span class="keyword">void</span> (*fb_imageblit) (struct fb_info *info, <span class="keyword">const</span> struct fb_image *image);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Draws cursor */</span></span><br><span class="line"><span class="keyword">int</span> (*fb_cursor) (struct fb_info *info, struct fb_cursor *cursor);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Rotates the display */</span></span><br><span class="line"><span class="keyword">void</span> (*fb_rotate)(struct fb_info *info, <span class="keyword">int</span> angle);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* wait for blit idle, optional */</span></span><br><span class="line"><span class="keyword">int</span> (*fb_sync)(struct fb_info *info);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* perform fb specific ioctl (optional) */</span></span><br><span class="line"><span class="keyword">int</span> (*fb_ioctl)(struct fb_info *info, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd,</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> arg);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* perform fb specific ioctl v2 (optional) - provides file param */</span></span><br><span class="line"><span class="keyword">int</span> (*fb_ioctl_v2)(struct fb_info *info, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd,</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> arg, struct file *file);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Handle 32bit compat ioctl (optional) */</span></span><br><span class="line"><span class="keyword">int</span> (*fb_compat_ioctl)(struct fb_info *info, <span class="keyword">unsigned</span> cmd,</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> arg);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Handle 32bit compat ioctl (optional) */</span></span><br><span class="line"><span class="keyword">int</span> (*fb_compat_ioctl_v2)(struct fb_info *info, <span class="keyword">unsigned</span> cmd,</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> arg, struct file *file);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* perform fb specific mmap */</span></span><br><span class="line"><span class="keyword">int</span> (*fb_mmap)(struct fb_info *info, struct vm_area_struct *vma);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* get capability given var */</span></span><br><span class="line"><span class="keyword">void</span> (*fb_get_caps)(struct fb_info *info, struct fb_blit_caps *caps,</span><br><span class="line">    struct fb_var_screeninfo *var);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* teardown any resources to do with this framebuffer */</span></span><br><span class="line"><span class="keyword">void</span> (*fb_destroy)(struct fb_info *info);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* called at KDB enter and leave time to prepare the console */</span></span><br><span class="line"><span class="keyword">int</span> (*fb_debug_enter)(struct fb_info *info);</span><br><span class="line"><span class="keyword">int</span> (*fb_debug_leave)(struct fb_info *info);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="2-2、Framebuffer驱动注册过程"><a href="#2-2、Framebuffer驱动注册过程" class="headerlink" title="2.2、Framebuffer驱动注册过程"></a>2.2、Framebuffer驱动注册过程</h5><p>在系统启动时，内核调用所有注册驱动程序的驱动程序初始化函数。 为了帧缓冲区驱动程序，调用mdss_fb_init。 mdss_fb_init注册mdss_fb_driver。驱动在mdss_fb.c文件中注册。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[-\drivers\video\msm\mdss\mdss_fb.c]</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">mdss_fb_driver</span> = &#123;</span></span><br><span class="line">.probe = mdss_fb_probe,</span><br><span class="line">.remove = mdss_fb_remove,</span><br><span class="line">.suspend = mdss_fb_suspend,</span><br><span class="line">.resume = mdss_fb_resume,</span><br><span class="line">.shutdown = mdss_fb_shutdown,</span><br><span class="line">.driver = &#123;</span><br><span class="line">.name = <span class="string">"mdss_fb"</span>,</span><br><span class="line">.of_match_table = mdss_fb_dt_match,</span><br><span class="line">.pm = &amp;mdss_fb_pm_ops,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在调用init之后，内核调用每个平台驱动程序的探测函数。 在调用mdss_fb_probe时，函数执行资源分配并调用mdss_fb_register。 可以有多个帧缓冲区（fb）设备（节点）。 该驱动程序通过调用mdss_fb_register来注册各个fb设备，后者又调用register_framebuffer。 HDMI和主显示器是各个fb设备的例子。 以下操作已注册：</p><p>首先看一下mdss_fb_probe()函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\drivers\video\msm\mdss\mdss_fb.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mdss_fb_probe</span><span class="params">(struct platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msm_fb_data_type</span> *<span class="title">mfd</span> = <span class="title">NULL</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mdss_panel_data</span> *<span class="title">pdata</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_info</span> *<span class="title">fbi</span>;</span></span><br><span class="line"><span class="keyword">int</span> rc;</span><br><span class="line"></span><br><span class="line">pdata = dev_get_platdata(&amp;pdev-&gt;dev);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * alloc framebuffer info + par data</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">fbi = framebuffer_alloc(<span class="keyword">sizeof</span>(struct msm_fb_data_type), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">mfd = (struct msm_fb_data_type *)fbi-&gt;par;</span><br><span class="line">mfd-&gt;key = MFD_KEY;</span><br><span class="line">mfd-&gt;fbi = fbi;</span><br><span class="line">mfd-&gt;panel_info = &amp;pdata-&gt;panel_info;</span><br><span class="line">mfd-&gt;panel.type = pdata-&gt;panel_info.type;</span><br><span class="line">mfd-&gt;panel.id = mfd-&gt;index;</span><br><span class="line">mfd-&gt;fb_page = MDSS_FB_NUM;</span><br><span class="line">mfd-&gt;index = fbi_list_index;</span><br><span class="line">mfd-&gt;mdp_fb_page_protection = MDP_FB_PAGE_PROTECTION_WRITECOMBINE;</span><br><span class="line"></span><br><span class="line">mfd-&gt;ext_ad_ctrl = <span class="number">-1</span>;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">platform_set_drvdata(pdev, mfd);</span><br><span class="line"></span><br><span class="line">rc = mdss_fb_register(mfd);</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先调用framebuffer_alloc()函数返回一个fb_info 结构体，然后调用mdss_fb_register(mfd)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\drivers\video\msm\mdss\mdss_fb.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mdss_fb_register</span><span class="params">(struct msm_fb_data_type *mfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = -ENODEV;</span><br><span class="line"><span class="keyword">int</span> bpp;</span><br><span class="line"><span class="keyword">char</span> panel_name[<span class="number">20</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mdss_panel_info</span> *<span class="title">panel_info</span> = <span class="title">mfd</span>-&gt;<span class="title">panel_info</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_info</span> *<span class="title">fbi</span> = <span class="title">mfd</span>-&gt;<span class="title">fbi</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_fix_screeninfo</span> *<span class="title">fix</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_var_screeninfo</span> *<span class="title">var</span>;</span></span><br><span class="line"><span class="keyword">int</span> *id;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * fb info initialization</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">fix = &amp;fbi-&gt;fix;</span><br><span class="line">var = &amp;fbi-&gt;var;</span><br><span class="line"></span><br><span class="line">fix-&gt;type_aux = <span class="number">0</span>;<span class="comment">/* if type == FB_TYPE_INTERLEAVED_PLANES */</span></span><br><span class="line">fix-&gt;visual = FB_VISUAL_TRUECOLOR;<span class="comment">/* True Color */</span></span><br><span class="line">fix-&gt;ywrapstep = <span class="number">0</span>;<span class="comment">/* No support */</span></span><br><span class="line">fix-&gt;mmio_start = <span class="number">0</span>;<span class="comment">/* No MMIO Address */</span></span><br><span class="line">fix-&gt;mmio_len = <span class="number">0</span>;<span class="comment">/* No MMIO Address */</span></span><br><span class="line">fix-&gt;accel = FB_ACCEL_NONE;<span class="comment">/* FB_ACCEL_MSM needes to be added in fb.h */</span></span><br><span class="line"></span><br><span class="line">var-&gt;xoffset = <span class="number">0</span>,<span class="comment">/* Offset from virtual to visible */</span></span><br><span class="line">var-&gt;yoffset = <span class="number">0</span>,<span class="comment">/* resolution */</span></span><br><span class="line">var-&gt;grayscale = <span class="number">0</span>,<span class="comment">/* No graylevels */</span></span><br><span class="line">var-&gt;nonstd = <span class="number">0</span>,<span class="comment">/* standard pixel format */</span></span><br><span class="line">var-&gt;activate = FB_ACTIVATE_VBL,<span class="comment">/* activate it at vsync */</span></span><br><span class="line">var-&gt;height = <span class="number">-1</span>,<span class="comment">/* height of picture in mm */</span></span><br><span class="line">var-&gt;width = <span class="number">-1</span>,<span class="comment">/* width of picture in mm */</span></span><br><span class="line">var-&gt;accel_flags = <span class="number">0</span>,<span class="comment">/* acceleration flags */</span></span><br><span class="line">var-&gt;sync = <span class="number">0</span>,<span class="comment">/* see FB_SYNC_* */</span></span><br><span class="line">var-&gt;rotate = <span class="number">0</span>,<span class="comment">/* angle we rotate counter clockwise */</span></span><br><span class="line">mfd-&gt;op_enable = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (mfd-&gt;fb_imgType) &#123;</span><br><span class="line"><span class="keyword">case</span> MDP_RGB_565:</span><br><span class="line">......</span><br><span class="line">var-&gt;transp.offset = <span class="number">0</span>;</span><br><span class="line">var-&gt;transp.length = <span class="number">0</span>;</span><br><span class="line">bpp = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> MDP_RGB_888:</span><br><span class="line">......</span><br><span class="line">var-&gt;transp.offset = <span class="number">0</span>;</span><br><span class="line">var-&gt;transp.length = <span class="number">0</span>;</span><br><span class="line">bpp = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> MDP_ARGB_8888:</span><br><span class="line">......</span><br><span class="line">var-&gt;transp.offset = <span class="number">0</span>;</span><br><span class="line">var-&gt;transp.length = <span class="number">8</span>;</span><br><span class="line">bpp = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> MDP_RGBA_8888:</span><br><span class="line">......</span><br><span class="line">var-&gt;transp.offset = <span class="number">24</span>;</span><br><span class="line">var-&gt;transp.length = <span class="number">8</span>;</span><br><span class="line">bpp = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> MDP_YCRYCB_H2V1:</span><br><span class="line">......</span><br><span class="line">var-&gt;transp.offset = <span class="number">0</span>;</span><br><span class="line">var-&gt;transp.length = <span class="number">0</span>;</span><br><span class="line">bpp = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mdss_panelinfo_to_fb_var(panel_info, var);</span><br><span class="line"></span><br><span class="line">fix-&gt;type = panel_info-&gt;is_3d_panel;</span><br><span class="line"><span class="keyword">if</span> (mfd-&gt;mdp.fb_stride)</span><br><span class="line">fix-&gt;line_length = mfd-&gt;mdp.fb_stride(mfd-&gt;index, var-&gt;xres,</span><br><span class="line">bpp);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">fix-&gt;line_length = var-&gt;xres * bpp;</span><br><span class="line"></span><br><span class="line">var-&gt;xres_virtual = var-&gt;xres;</span><br><span class="line">var-&gt;yres_virtual = panel_info-&gt;yres * mfd-&gt;fb_page;</span><br><span class="line">var-&gt;bits_per_pixel = bpp * <span class="number">8</span>;<span class="comment">/* FrameBuffer color depth */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Populate smem length here for uspace to get the</span></span><br><span class="line"><span class="comment"> * Framebuffer size when FBIO_FSCREENINFO ioctl is called.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">fix-&gt;smem_len = PAGE_ALIGN(fix-&gt;line_length * var-&gt;yres) * mfd-&gt;fb_page;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* id field for fb app  */</span></span><br><span class="line">id = (<span class="keyword">int</span> *)&amp;mfd-&gt;panel;</span><br><span class="line"></span><br><span class="line"><span class="built_in">snprintf</span>(fix-&gt;id, <span class="keyword">sizeof</span>(fix-&gt;id), <span class="string">"mdssfb_%x"</span>, (u32) *id);</span><br><span class="line"></span><br><span class="line">fbi-&gt;fbops = &amp;mdss_fb_ops;</span><br><span class="line">fbi-&gt;flags = FBINFO_FLAG_DEFAULT;</span><br><span class="line">fbi-&gt;pseudo_palette = mdss_fb_pseudo_palette;</span><br><span class="line"></span><br><span class="line">mfd-&gt;ref_cnt = <span class="number">0</span>;</span><br><span class="line">mfd-&gt;panel_power_state = MDSS_PANEL_POWER_OFF;</span><br><span class="line">mfd-&gt;dcm_state = DCM_UNINIT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mdss_fb_alloc_fbmem(mfd))</span><br><span class="line">pr_warn(<span class="string">"unable to allocate fb memory in fb register\n"</span>);</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">ret = fb_alloc_cmap(&amp;fbi-&gt;cmap, <span class="number">256</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">pr_err(<span class="string">"fb_alloc_cmap() failed!\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (register_framebuffer(fbi) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">fb_dealloc_cmap(&amp;fbi-&gt;cmap);</span><br><span class="line">mfd-&gt;op_enable = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> -EPERM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">snprintf</span>(panel_name, ARRAY_SIZE(panel_name), <span class="string">"mdss_panel_fb%d"</span>,</span><br><span class="line">mfd-&gt;index);</span><br><span class="line">mdss_panel_debugfs_init(panel_info, panel_name);</span><br><span class="line">pr_info(<span class="string">"FrameBuffer[%d] %dx%d registered successfully!\n"</span>, mfd-&gt;index,</span><br><span class="line">fbi-&gt;var.xres, fbi-&gt;var.yres);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>任何一个特定硬件Framebuffer驱动在初始化时都必须向fbmem.c注册，FrameBuffer模块提供了驱动注册接口函数register_framebuffer：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\drivers\video\fbdev\core\fbmem.c]</span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">register_framebuffer(struct fb_info *fb_info)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">mutex_lock(&amp;registration_lock);</span><br><span class="line">ret = do_register_framebuffer(fb_info);</span><br><span class="line">mutex_unlock(&amp;registration_lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数fb_info描述特定硬件的FrameBuffer驱动信息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\drivers\video\fbdev\core\fbmem.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_register_framebuffer</span><span class="params">(struct fb_info *fb_info)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fb_event</span> <span class="title">event</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fb_videomode</span> <span class="title">mode</span>;</span>  </span><br><span class="line">    <span class="keyword">if</span> (fb_check_foreignness(fb_info))  </span><br><span class="line">        <span class="keyword">return</span> -ENOSYS;  </span><br><span class="line">    <span class="comment">//根据当前注册的fb_info的apertures属性从FrameBuffer驱动数组registered_fb中查询是否存在冲突  </span></span><br><span class="line">    do_remove_conflicting_framebuffers(fb_info-&gt;apertures, fb_info-&gt;fix.id,  </span><br><span class="line">                     fb_is_primary_device(fb_info));  </span><br><span class="line">    <span class="comment">//判断已注册的驱动是否超过32个FrameBuffer驱动  </span></span><br><span class="line">    <span class="keyword">if</span> (num_registered_fb == FB_MAX)  </span><br><span class="line">        <span class="keyword">return</span> -ENXIO;  </span><br><span class="line">    <span class="comment">//增加已注册的驱动个数  </span></span><br><span class="line">    num_registered_fb++;  </span><br><span class="line">    <span class="comment">//从数组registered_fb中查找空闲元素，用于存储当前注册的fb_info  </span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; FB_MAX; i++)  </span><br><span class="line">        <span class="keyword">if</span> (!registered_fb[i])  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">    <span class="comment">//将当前注册的fb_info在数组registered_fb中的索引位置保存到fb_info-&gt;node  </span></span><br><span class="line">    fb_info-&gt;node = i;  </span><br><span class="line">    <span class="comment">//初始化当前注册的fb_info的成员信息  </span></span><br><span class="line">    atomic_set(&amp;fb_info-&gt;count, <span class="number">1</span>);  </span><br><span class="line">    mutex_init(&amp;fb_info-&gt;lock);  </span><br><span class="line">    mutex_init(&amp;fb_info-&gt;mm_lock);  </span><br><span class="line">    <span class="comment">//在/dev目录下创建一个fbx的设备文件，次设备号就是该fb_info在数组registered_fb中的索引  </span></span><br><span class="line">    fb_info-&gt;dev = device_create(fb_class, fb_info-&gt;device,MKDEV(FB_MAJOR, i), <span class="literal">NULL</span>, <span class="string">"fb%d"</span>, i);  </span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(fb_info-&gt;dev)) &#123;  </span><br><span class="line">        printk(KERN_WARNING <span class="string">"Unable to create device for framebuffer %d; errno = %ld\n"</span>, i, PTR_ERR(fb_info-&gt;dev));  </span><br><span class="line">        fb_info-&gt;dev = <span class="literal">NULL</span>;  </span><br><span class="line">    &#125; <span class="keyword">else</span>  </span><br><span class="line">        <span class="comment">//初始化fb_info  </span></span><br><span class="line">        fb_init_device(fb_info);  </span><br><span class="line">    <span class="keyword">if</span> (fb_info-&gt;pixmap.addr == <span class="literal">NULL</span>) &#123;  </span><br><span class="line">        fb_info-&gt;pixmap.addr = kmalloc(FBPIXMAPSIZE, GFP_KERNEL);  </span><br><span class="line">        <span class="keyword">if</span> (fb_info-&gt;pixmap.addr) &#123;  </span><br><span class="line">            fb_info-&gt;pixmap.size = FBPIXMAPSIZE;  </span><br><span class="line">            fb_info-&gt;pixmap.buf_align = <span class="number">1</span>;  </span><br><span class="line">            fb_info-&gt;pixmap.scan_align = <span class="number">1</span>;  </span><br><span class="line">            fb_info-&gt;pixmap.access_align = <span class="number">32</span>;  </span><br><span class="line">            fb_info-&gt;pixmap.flags = FB_PIXMAP_DEFAULT;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;     </span><br><span class="line">    fb_info-&gt;pixmap.offset = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">if</span> (!fb_info-&gt;pixmap.blit_x)  </span><br><span class="line">        fb_info-&gt;pixmap.blit_x = ~(u32)<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">if</span> (!fb_info-&gt;pixmap.blit_y)  </span><br><span class="line">        fb_info-&gt;pixmap.blit_y = ~(u32)<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">if</span> (!fb_info-&gt;modelist.prev || !fb_info-&gt;modelist.next)  </span><br><span class="line">        INIT_LIST_HEAD(&amp;fb_info-&gt;modelist);  </span><br><span class="line">    fb_var_to_videomode(&amp;mode, &amp;fb_info-&gt;var);  </span><br><span class="line">    fb_add_videomode(&amp;mode, &amp;fb_info-&gt;modelist);  </span><br><span class="line">    <span class="comment">//将特定硬件对应的fb_info注册到registered_fb数组中  </span></span><br><span class="line">    registered_fb[i] = fb_info;  </span><br><span class="line">    event.info = fb_info;  </span><br><span class="line">    <span class="keyword">if</span> (!lock_fb_info(fb_info))  </span><br><span class="line">        <span class="keyword">return</span> -ENODEV;  </span><br><span class="line">    <span class="comment">//使用Linux事件通知机制发送一个FrameBuffer注册事件FB_EVENT_FB_REGISTERED  </span></span><br><span class="line">    fb_notifier_call_chain(FB_EVENT_FB_REGISTERED, &amp;event);  </span><br><span class="line">    unlock_fb_info(fb_info);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册过程就是将指定的设备驱动信息fb_info存放到registered_fb数组中。因此在注册具体的fb_info时，首先要构造一个fb_info数据结构，并初始化该数据结构，该结构用于描述一个特定的FrameBuffer驱动。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS05-07-fb-device-create.jpg" alt="Alt text | center"></p><h4 id="（三）、MDP-driver"><a href="#（三）、MDP-driver" class="headerlink" title="（三）、MDP driver"></a>（三）、MDP driver</h4><p>MDP也被注册为平台驱动程序。 mdp3_driver_init执行驱动程序init。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\drivers\video\msm\mdss\mdp3.c]</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">mdp3_driver</span> = &#123;</span></span><br><span class="line">.probe = mdp3_probe,</span><br><span class="line">.remove = mdp3_remove,</span><br><span class="line">.suspend = mdp3_suspend,</span><br><span class="line">.resume = mdp3_resume,</span><br><span class="line">.shutdown = <span class="literal">NULL</span>,</span><br><span class="line">.driver = &#123;</span><br><span class="line">.name = <span class="string">"mdp3"</span>,</span><br><span class="line">.of_match_table = mdp3_dt_match,</span><br><span class="line">.pm             = &amp;mdp3_pm_ops,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">mdp3_driver_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">ret = platform_driver_register(&amp;mdp3_driver);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">pr_err(<span class="string">"register mdp3 driver failed!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mdp3_probe</span><span class="params">(struct platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> rc;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">msm_mdp_interface</span> <span class="title">mdp3_interface</span> = &#123;</span></span><br><span class="line">.init_fnc = mdp3_init,</span><br><span class="line">.fb_mem_get_iommu_domain = mdp3_fb_mem_get_iommu_domain,</span><br><span class="line">.panel_register_done = mdp3_panel_register_done,</span><br><span class="line">.fb_stride = mdp3_fb_stride,</span><br><span class="line">.check_dsi_status = mdp3_check_dsi_ctrl_status,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mdp3_intr_cb</span> <span class="title">underrun_cb</span> = &#123;</span></span><br><span class="line">.cb = mdp3_dma_underrun_intr_handler,</span><br><span class="line">.data = <span class="literal">NULL</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">pr_debug(<span class="string">"%s: START\n"</span>, __func__);</span><br><span class="line"><span class="keyword">if</span> (!pdev-&gt;dev.of_node) &#123;</span><br><span class="line">pr_err(<span class="string">"MDP driver only supports device tree probe\n"</span>);</span><br><span class="line"><span class="keyword">return</span> -ENOTSUPP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mdp3_res) &#123;</span><br><span class="line">pr_err(<span class="string">"MDP already initialized\n"</span>);</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mdp3_res = devm_kzalloc(&amp;pdev-&gt;dev, <span class="keyword">sizeof</span>(struct mdp3_hw_resource),</span><br><span class="line">GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (mdp3_res == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">pdev-&gt;id = <span class="number">0</span>;</span><br><span class="line">mdp3_res-&gt;pdev = pdev;</span><br><span class="line">mutex_init(&amp;mdp3_res-&gt;res_mutex);</span><br><span class="line">spin_lock_init(&amp;mdp3_res-&gt;irq_lock);</span><br><span class="line">platform_set_drvdata(pdev, mdp3_res);</span><br><span class="line">atomic_set(&amp;mdp3_res-&gt;active_intf_cnt, <span class="number">0</span>);</span><br><span class="line">mutex_init(&amp;mdp3_res-&gt;reg_bus_lock);</span><br><span class="line">INIT_LIST_HEAD(&amp;mdp3_res-&gt;reg_bus_clist);</span><br><span class="line"></span><br><span class="line">mdp3_res-&gt;mdss_util = mdss_get_util_intf();</span><br><span class="line"><span class="keyword">if</span> (mdp3_res-&gt;mdss_util == <span class="literal">NULL</span>) &#123;</span><br><span class="line">pr_err(<span class="string">"Failed to get mdss utility functions\n"</span>);</span><br><span class="line">rc =  -ENODEV;</span><br><span class="line"><span class="keyword">goto</span> get_util_fail;</span><br><span class="line">&#125;</span><br><span class="line">mdp3_res-&gt;mdss_util-&gt;get_iommu_domain = mdp3_get_iommu_domain;</span><br><span class="line">mdp3_res-&gt;mdss_util-&gt;iommu_attached = is_mdss_iommu_attached;</span><br><span class="line">mdp3_res-&gt;mdss_util-&gt;iommu_ctrl = mdp3_iommu_ctrl;</span><br><span class="line">mdp3_res-&gt;mdss_util-&gt;bus_scale_set_quota = mdp3_bus_scale_set_quota;</span><br><span class="line">mdp3_res-&gt;mdss_util-&gt;panel_intf_type = mdp3_panel_intf_type;</span><br><span class="line">mdp3_res-&gt;mdss_util-&gt;dyn_clk_gating_ctrl =</span><br><span class="line">mdp3_dynamic_clock_gating_ctrl;</span><br><span class="line">mdp3_res-&gt;mdss_util-&gt;panel_intf_type = mdp3_panel_intf_type;</span><br><span class="line">mdp3_res-&gt;mdss_util-&gt;panel_intf_status = mdp3_panel_get_intf_status;</span><br><span class="line">rc = mdp3_parse_dt(pdev);</span><br><span class="line"><span class="keyword">if</span> (rc)</span><br><span class="line"><span class="keyword">goto</span> probe_done;</span><br><span class="line"></span><br><span class="line">rc = mdp3_res_init();</span><br><span class="line"><span class="keyword">if</span> (rc) &#123;</span><br><span class="line">pr_err(<span class="string">"unable to initialize mdp3 resources\n"</span>);</span><br><span class="line"><span class="keyword">goto</span> probe_done;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mdp3_res-&gt;fs_ena = <span class="literal">false</span>;</span><br><span class="line">mdp3_res-&gt;fs = devm_regulator_get(&amp;pdev-&gt;dev, <span class="string">"vdd"</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR_OR_NULL(mdp3_res-&gt;fs)) &#123;</span><br><span class="line">pr_err(<span class="string">"unable to get mdss gdsc regulator\n"</span>);</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rc = mdp3_debug_init(pdev);</span><br><span class="line"><span class="keyword">if</span> (rc) &#123;</span><br><span class="line">pr_err(<span class="string">"unable to initialize mdp debugging\n"</span>);</span><br><span class="line"><span class="keyword">goto</span> probe_done;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pm_runtime_set_autosuspend_delay(&amp;pdev-&gt;dev, AUTOSUSPEND_TIMEOUT_MS);</span><br><span class="line"><span class="keyword">if</span> (mdp3_res-&gt;idle_pc_enabled) &#123;</span><br><span class="line">pr_debug(<span class="string">"%s: Enabling autosuspend\n"</span>, __func__);</span><br><span class="line">pm_runtime_use_autosuspend(&amp;pdev-&gt;dev);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Enable PM runtime */</span></span><br><span class="line">pm_runtime_set_suspended(&amp;pdev-&gt;dev);</span><br><span class="line">pm_runtime_enable(&amp;pdev-&gt;dev);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!pm_runtime_enabled(&amp;pdev-&gt;dev)) &#123;</span><br><span class="line">rc = mdp3_footswitch_ctrl(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (rc) &#123;</span><br><span class="line">pr_err(<span class="string">"unable to turn on FS\n"</span>);</span><br><span class="line"><span class="keyword">goto</span> probe_done;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rc = mdp3_check_version();</span><br><span class="line"><span class="keyword">if</span> (rc) &#123;</span><br><span class="line">pr_err(<span class="string">"mdp3 check version failed\n"</span>);</span><br><span class="line"><span class="keyword">goto</span> probe_done;</span><br><span class="line">&#125;</span><br><span class="line">rc = mdp3_register_sysfs(pdev);</span><br><span class="line"><span class="keyword">if</span> (rc)</span><br><span class="line">pr_err(<span class="string">"unable to register mdp sysfs nodes\n"</span>);</span><br><span class="line"></span><br><span class="line">rc = mdss_fb_register_mdp_instance(&amp;mdp3_interface);</span><br><span class="line"><span class="keyword">if</span> (rc)</span><br><span class="line">pr_err(<span class="string">"unable to register mdp instance\n"</span>);</span><br><span class="line"></span><br><span class="line">rc = mdp3_set_intr_callback(MDP3_INTR_LCDC_UNDERFLOW,</span><br><span class="line">&amp;underrun_cb);</span><br><span class="line"><span class="keyword">if</span> (rc)</span><br><span class="line">pr_err(<span class="string">"unable to configure interrupt callback\n"</span>);</span><br><span class="line"></span><br><span class="line">rc = mdss_smmu_init(mdss_res, &amp;pdev-&gt;dev);</span><br><span class="line"><span class="keyword">if</span> (rc)</span><br><span class="line">pr_err(<span class="string">"mdss smmu init failed\n"</span>);</span><br><span class="line"></span><br><span class="line">mdp3_res-&gt;mdss_util-&gt;mdp_probe_done = <span class="literal">true</span>;</span><br><span class="line">pr_debug(<span class="string">"%s: END\n"</span>, __func__);</span><br><span class="line"><span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内核调用MDP探测函数mdp3_probe。 在探测器上，驱动程序从设备树中获取面板信息，并通过调用mdp3_parse_dt来解析信息。 在mdp3_ctrl_on期间，MDP驱动程序调用mdp3_ctrl_res_req_clk并请求MDP和Vsync时钟。 在mdp3_ctrl_off期间，驱动程序请求关闭MDP和Vsync时钟。</p><h4 id="（四）、DSI-controller-driver-（lcd驱动-dsi）"><a href="#（四）、DSI-controller-driver-（lcd驱动-dsi）" class="headerlink" title="（四）、DSI controller driver （lcd驱动 dsi）"></a>（四）、DSI controller driver （lcd驱动 dsi）</h4><p>msm_dsi_v2_driver_init执行驱动程序初始化。 msm_dsi_v2_driver_init调用 msm_dsi_v2_register_driver注册驱动程序。<br>总体时序图：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS05-08-dsi-host-v2.png" alt="Alt text | center"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\drivers\video\msm\mdss\dsi_host_v2.c]</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">msm_dsi_v2_driver</span> = &#123;</span></span><br><span class="line">.probe = msm_dsi_probe,</span><br><span class="line">.remove = msm_dsi_remove,</span><br><span class="line">.shutdown = <span class="literal">NULL</span>,</span><br><span class="line">.driver = &#123;</span><br><span class="line">.name = <span class="string">"msm_dsi_v2"</span>,</span><br><span class="line">.of_match_table = msm_dsi_v2_dt_match,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">msm_dsi_v2_register_driver</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> platform_driver_register(&amp;msm_dsi_v2_driver);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">msm_dsi_probe</span><span class="params">(struct platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dsi_interface</span> <span class="title">intf</span>;</span></span><br><span class="line"><span class="keyword">char</span> panel_cfg[MDSS_MAX_PANEL_LEN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mdss_dsi_ctrl_pdata</span> *<span class="title">ctrl_pdata</span> = <span class="title">NULL</span>;</span></span><br><span class="line"><span class="keyword">int</span> rc = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">dsi_pan_node</span> = <span class="title">NULL</span>;</span></span><br><span class="line"><span class="keyword">bool</span> cmd_cfg_cont_splash = <span class="literal">false</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">mdss_dsi_mres</span>;</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">pr_debug(<span class="string">"%s\n"</span>, __func__);</span><br><span class="line"></span><br><span class="line">rc = msm_dsi_init();</span><br><span class="line"></span><br><span class="line">pdev-&gt;id = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">ctrl_pdata = platform_get_drvdata(pdev);</span><br><span class="line"><span class="keyword">if</span> (!ctrl_pdata) &#123;</span><br><span class="line">ctrl_pdata = devm_kzalloc(&amp;pdev-&gt;dev,</span><br><span class="line"><span class="keyword">sizeof</span>(struct mdss_dsi_ctrl_pdata), GFP_KERNEL);</span><br><span class="line">platform_set_drvdata(pdev, ctrl_pdata);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ctrl_pdata-&gt;mdss_util = mdss_get_util_intf();</span><br><span class="line"><span class="keyword">if</span> (mdp3_res-&gt;mdss_util == <span class="literal">NULL</span>) &#123;</span><br><span class="line">pr_err(<span class="string">"Failed to get mdss utility functions\n"</span>);</span><br><span class="line"><span class="keyword">return</span> -ENODEV;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mdss_dsi_mres = platform_get_resource(pdev, IORESOURCE_MEM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!mdss_dsi_mres) &#123;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dsi_host_private-&gt;dsi_reg_size = resource_size(mdss_dsi_mres);</span><br><span class="line">dsi_host_private-&gt;dsi_base = ioremap(mdss_dsi_mres-&gt;start,</span><br><span class="line">dsi_host_private-&gt;dsi_reg_size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mdss_dsi_mres = platform_get_resource(pdev, IORESOURCE_IRQ, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">rc = of_platform_populate(pdev-&gt;dev.of_node, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;pdev-&gt;dev);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* DSI panels can be different between controllers */</span></span><br><span class="line">rc = dsi_get_panel_cfg(panel_cfg);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* find panel device node */</span></span><br><span class="line">dsi_pan_node = dsi_find_panel_of_node(pdev, panel_cfg);</span><br><span class="line"></span><br><span class="line">cmd_cfg_cont_splash = mdp3_panel_get_boot_cfg() ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">rc = mdss_dsi_panel_init(dsi_pan_node, ctrl_pdata, cmd_cfg_cont_splash);</span><br><span class="line"></span><br><span class="line">rc = dsi_ctrl_config_init(pdev, ctrl_pdata);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">msm_dsi_parse_lane_swap(pdev-&gt;dev.of_node, &amp;(ctrl_pdata-&gt;dlane_swap));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>;  i &lt; DSI_MAX_PM; i++) &#123;</span><br><span class="line">rc = msm_dsi_io_init(pdev, &amp;(ctrl_pdata-&gt;power_data[i]));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pr_debug(<span class="string">"%s: Dsi Ctrl-&gt;0 initialized\n"</span>, __func__);</span><br><span class="line"></span><br><span class="line">dsi_host_private-&gt;dis_dev = pdev-&gt;dev;</span><br><span class="line">intf.on = msm_dsi_on;</span><br><span class="line">intf.off = msm_dsi_off;</span><br><span class="line">intf.cont_on = msm_dsi_cont_on;</span><br><span class="line">intf.clk_ctrl = msm_dsi_clk_ctrl;</span><br><span class="line">intf.op_mode_config = msm_dsi_op_mode_config;</span><br><span class="line">intf.index = <span class="number">0</span>;</span><br><span class="line">intf.<span class="keyword">private</span> = <span class="literal">NULL</span>;</span><br><span class="line">dsi_register_interface(&amp;intf);</span><br><span class="line"></span><br><span class="line">msm_dsi_debug_init();</span><br><span class="line"></span><br><span class="line">msm_dsi_ctrl_init(ctrl_pdata);</span><br><span class="line"></span><br><span class="line">rc = msm_dsi_irq_init(&amp;pdev-&gt;dev, mdss_dsi_mres-&gt;start,</span><br><span class="line">   ctrl_pdata);</span><br><span class="line"></span><br><span class="line">rc = dsi_panel_device_register_v2(pdev, ctrl_pdata);</span><br><span class="line"></span><br><span class="line">pr_debug(<span class="string">"%s success\n"</span>, __func__);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内核调用msm_dsi_probe。 面板被检测到。 msm_dsi_probe调用mdss_dsi_panel_init函数。 mdss_dsi_panel_init调用mdss_panel_parse_dt来获取面板参数。<br>MDP驱动程序使用该事件与DSI驱动程序进行通信。 DSI驱动程序具有mdss_dsi_event_handler，这是MDP核心事件的回调处理程序。 mdss_panel.h定义了MDP核心事件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\drivers\video\msm\mdss\mdss_panel.h]</span><br><span class="line"><span class="keyword">enum</span> mdss_intf_events &#123;</span><br><span class="line">MDSS_EVENT_RESET = <span class="number">1</span>,</span><br><span class="line">MDSS_EVENT_LINK_READY,</span><br><span class="line">MDSS_EVENT_UNBLANK,</span><br><span class="line">MDSS_EVENT_PANEL_ON,</span><br><span class="line">MDSS_EVENT_POST_PANEL_ON,</span><br><span class="line">MDSS_EVENT_BLANK,</span><br><span class="line">MDSS_EVENT_PANEL_OFF,</span><br><span class="line">MDSS_EVENT_CLOSE,</span><br><span class="line">MDSS_EVENT_SUSPEND,</span><br><span class="line">MDSS_EVENT_RESUME,</span><br><span class="line">MDSS_EVENT_CHECK_PARAMS,</span><br><span class="line">MDSS_EVENT_CONT_SPLASH_BEGIN,</span><br><span class="line">MDSS_EVENT_CONT_SPLASH_FINISH,</span><br><span class="line">MDSS_EVENT_PANEL_UPDATE_FPS,</span><br><span class="line">MDSS_EVENT_FB_REGISTERED,</span><br><span class="line">MDSS_EVENT_PANEL_CLK_CTRL,</span><br><span class="line">MDSS_EVENT_DSI_CMDLIST_KOFF,</span><br><span class="line">MDSS_EVENT_ENABLE_PARTIAL_ROI,</span><br><span class="line">MDSS_EVENT_DSC_PPS_SEND,</span><br><span class="line">MDSS_EVENT_DSI_STREAM_SIZE,</span><br><span class="line">MDSS_EVENT_DSI_UPDATE_PANEL_DATA,</span><br><span class="line">MDSS_EVENT_REGISTER_RECOVERY_HANDLER,</span><br><span class="line">MDSS_EVENT_REGISTER_MDP_CALLBACK,</span><br><span class="line">MDSS_EVENT_DSI_PANEL_STATUS,</span><br><span class="line">MDSS_EVENT_DSI_DYNAMIC_SWITCH,</span><br><span class="line">MDSS_EVENT_DSI_RECONFIG_CMD,</span><br><span class="line">MDSS_EVENT_DSI_RESET_WRITE_PTR,</span><br><span class="line">MDSS_EVENT_PANEL_TIMING_SWITCH,</span><br><span class="line">MDSS_EVENT_MAX,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在msm_dsi_on期间，通过调用msm_dsi_clk_enable打开DSI时钟。 在msm_dsi_off期间，通过调用msm_dsi_clk_disable关闭clks。</p><h4 id="（五）、-Panel-driver-（面板-dsi）"><a href="#（五）、-Panel-driver-（面板-dsi）" class="headerlink" title="（五）、 Panel driver （面板 dsi）"></a>（五）、 Panel driver （面板 dsi）</h4><p>MDSS : Multimedia Display sub system<br>DSI: Display Serial Interface</p><blockquote><p>qcom,mdss-dsi-force-clock-lane-hs;          // faulse ：clock每帧回lp11<br>ture: clock不回 qcom,mdss-dsi-hfp-power-mode;               // data 每行回lp11,对应的hfp要修改成300以上</p></blockquote><p>面板信息位于kernel\arch\arm\boot\dts\中的.dtsi文件中。 这包含所有面板特定的命令，例如on，off和reset（mdss-dsi-on-command，mdss-dsi-off-command，mdss-dsi-reset-sequence），BL控制和其他面板 独立参数。<br>例如：<br>msm8610-mdss.dtsi （文件名通常为 msmxxx-mdss.dtsi 指定了mdss 的 mdp 和 dsi）</p><h5 id="5-1、-dtsi文件解析"><a href="#5-1、-dtsi文件解析" class="headerlink" title="5.1、.dtsi文件解析"></a>5.1、.dtsi文件解析</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mdss_mdp: qcom,mdss_mdp@fd900000 &#123;</span><br><span class="line">            compatible = <span class="string">"qcom,mdss_mdp3"</span>;  <span class="comment">// 对应mdss驱动 mdss_mdp.c</span></span><br><span class="line">----------</span><br><span class="line">  mdss_dsi0: qcom,mdss_dsi@fdd00000 &#123;</span><br><span class="line">        compatible = <span class="string">"qcom,msm-dsi-v2"</span>;      <span class="comment">// 对应dsi解析驱动 dsi_host_v2.c</span></span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">  mdss_dsi0: qcom,mdss_dsi_ctrl0@<span class="number">1</span>a94000 &#123;</span><br><span class="line">        compatible = <span class="string">"qcom,mdss-dsi-ctrl"</span>;  <span class="comment">// 对应dsi解析驱动 mdss_dsi.c</span></span><br></pre></td></tr></table></figure><p>通过下面函数向 mdss_fb.c 注册了fb_info结构  (包含在mdss_dsi_ctrl_pdata结构中)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">drivers\video\msm\mdss\dsi_host_v2.c （lcd驱动 dsi）</span><br><span class="line">dsi_panel_device_register_v2(struct platform_device *dev,struct mdss_dsi_ctrl_pdata *ctrl_pdata)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static const struct of_device_id msm_dsi_v2_dt_match[] = &#123;</span><br><span class="line">    &#123;.compatible = &quot;qcom,msm-dsi-v2&quot;&#125;,</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">或者 </span><br><span class="line">drivers\video\msm\mdss\mdss_dsi.c</span><br></pre></td></tr></table></figure><p>msm8610-asus.dts （指定mdp中的哪一个配置）<br>通常在dts文件的 mdss_dsi0 lab里面通过 qcom,dsi-pref-prim-pan 属性 指定使用哪一个lcd配置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;mdss_dsi0 &#123;</span><br><span class="line">        qcom,dsi-pref-prim-pan = &lt;&amp;dsi_fl10802_fwvga_vid&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>dsi-panel-fl10802-fwvga-video.dtsi</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&amp;mdss_mdp &#123;</span><br><span class="line">    dsi_fl10802_fwvga_vid: qcom,mdss_dsi_fl10802_fwvga_video &#123;</span><br><span class="line">        qcom,mdss-dsi-panel-name = &quot;fl10802 fwvga video mode dsi panel&quot;;</span><br><span class="line">        qcom,mdss-dsi-drive-ic = &quot;fl10802&quot;;</span><br><span class="line">        qcom,mdss-dsi-panel-controller = &lt;&amp;mdss_dsi0&gt;;</span><br><span class="line">        qcom,mdss-dsi-panel-type = &quot;dsi_video_mode&quot;;</span><br><span class="line">        qcom,mdss-dsi-panel-destination = &quot;display_1&quot;;</span><br><span class="line">        ...</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h5 id="5-2、mdss-mdp-和-mdss-dsi0-的关系"><a href="#5-2、mdss-mdp-和-mdss-dsi0-的关系" class="headerlink" title="5.2、mdss_mdp 和 mdss_dsi0 的关系"></a>5.2、mdss_mdp 和 mdss_dsi0 的关系</h5><p>mdss_mdp 相当于一个数组，里面定义了很多不同lcd显示屏的配置项包括分辨率等等</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS05-09-mdss_mdp-mdss_dsi0.jpg" alt="Alt text | center"></p><p>面板驱动程序可以根据连接的实际面板数量具有多个节点。<br>mdss_register_panel注册面板驱动程序：<br>msm_dsi_probe→dsi_panel_device_register_v2→mdss_register_panel→<br>of_platform_device_create<br>以下面板控制功能可用并在mdss_dsi_panel_init中初始化：<br>ctrl_pdata→on = mdss_dsi_panel_on;<br>ctrl_pdata→off = mdss_dsi_panel_off;<br>ctrl_pdata→panel_data.set_backlight = mdss_dsi_panel_bl_ctrl;<br>  例如，在mdp3_ctrl.c中，函数mdp3_ctrl_on（）会调用以下DSI处理程序<br>MDSS_EVENT_UNBLANK和MDSS_EVENT_PANEL_ON事件如下所示：<br>rc = panel→event_handler（panel，MDSS_EVENT_UNBLANK，NULL）;<br>rc | =面板→event_handler（面板，MDSS_EVENT_PANEL_ON，NULL）;</p><h5 id="5-3、通过内核接口打开和关闭显示器"><a href="#5-3、通过内核接口打开和关闭显示器" class="headerlink" title="5.3、通过内核接口打开和关闭显示器"></a>5.3、通过内核接口打开和关闭显示器</h5><h5 id="5-3-1、启动"><a href="#5-3-1、启动" class="headerlink" title="5.3.1、启动"></a>5.3.1、启动</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS05-10-display-subsystem-on-bootup.png" alt="Alt text | center"></p><p>按照上面的部分所述注册设备后：<br>mdss_fb_open→mdss_fb_blank_sub→pdata→on（面板ON功能）<br>注意：对于命令模式面板，如果面板在启动时已打开，则会跳过该启动序列 以避免关闭/ -on的文物。</p><h5 id="5-3-2、暂停-恢复"><a href="#5-3-2、暂停-恢复" class="headerlink" title="5.3.2、暂停/恢复"></a>5.3.2、暂停/恢复</h5><p>挂起/恢复时，调用fb驱动程序挂起/恢复和MDP驱动程序挂起/恢复。 fb驱动程序依次调用面板驱动程序的开/关功能。</p><h5 id="5-3-2-1、暂停序列"><a href="#5-3-2-1、暂停序列" class="headerlink" title="5.3.2.1、暂停序列"></a>5.3.2.1、暂停序列</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS05-11-suspend sequence.png" alt="Alt text | center"></p><p>Kernelcall→mdss_fb_release_all→mdss_fb_blank→mdss_fb_blank_sub→mdp3_ctrl_off→<br>mdp3_ctrl_off发送两个事件：</p><ol><li>MDSS_EVENT_PANEL_OFF - dsi_event_handler接收事件。 当事件发生时<br>接收到时，调用小组关闭序列。</li><li>MDSS_EVENT_BLANK - 该事件由调用的dsi_event_handler处理<br>mdss_dsi_off。</li></ol><ul><li>Kernelcall→mdp3_suspend - 未使用<h5 id="5-3-2-2、恢复序列"><a href="#5-3-2-2、恢复序列" class="headerlink" title="5.3.2.2、恢复序列"></a>5.3.2.2、恢复序列</h5></li></ul><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS05-12-resume sequence.png" alt="Alt text | center"></p><p>Kernelcall→mdss_fb_blank→mdss_fb_blank_sub→mdp3_ctrl_on→<br>mdp3_ctrl_on发送两个事件：</p><ol><li>MDSS_EVENT_UNBLANK - dsi_event_handler接收事件。 当事件发生时<br>收到，DSI-on被调用。</li><li>MDSS_EVENT_PANEL_ON - 事件由dsi_event_handler处理，dsi_event_handler发送<br>面板上的序列。<br>Kernelcall→mdp3_resume - 未使用</li></ol><h5 id="5-4、图像更新到面板"><a href="#5-4、图像更新到面板" class="headerlink" title="5.4、图像更新到面板"></a>5.4、图像更新到面板</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS05-13-flow for display subsystem commit.png" alt="Alt text | center"></p><p> 用户必须确保MSMFB_OVERLAY_SET IOCTL在呼叫之前至少被调用一次 到MSMFB_OVERLAY_PLAY IOCLT（例如ioctl(fd, MSMFB_OVERLAY_PLAY, &amp;od)）。MSMFB_OVERLAY_PLAY队列缓冲区 显示在面板上。 用户使用MSMFB_DISPLAY_COMMIT调用fb IOCLT。这会启动一个呼叫<br> mdss_fb_display_commit 并安排工作队列。此工作队列处理程序调用<br> msm_fb_pan_display_ex，然后调用mdp3_ctrl_pan_display。<br> mdss_fb_ioctl→（MSMFB_DISPLAY_COMMIT）→mdss_fb_display_commit→<br> mdss_fb_pan_display_ex→计划工作mdss_fb_commit_wq_handler<br> msm_fb_commit_wq_handler→mdp3_ctrl_display_commit_kickoff→mdp3_dmap_update<br>一次呼叫后，可以有多个对PLAY和COMMIT IOCLT的呼叫 MSMFB_OVERLAY_SET IOCTL。面板更新完成并且设备完成后<br>需要进入挂起或关闭状态，用户可以调用MSMFB_OVERLAY_UNSET。</p><p>注意：工作队列架构正在被即将发布的线程取代，<br>这些文件未被捕获。视频和命令模式面板的面板更新略有不同。为了在命令模式面板中，mdp3_dmap_update函数会等待，直到前一个图像更新为止完成使用MDP DMA开始新帧更新</p><p>if（dma-&gt; output_config.out_sel == MDP3_DMA_OUTPUT_SEL_DSI_CMD）{<br>cb_type = MDP3_DMA_CALLBACK_TYPE_DMA_DONE;<br>如果（intf-&gt; active）<br>wait_for_completion_killable（DMA-&gt; dma_comp）;</p><p>对于视频面板，在DMA触发后，mdp3_dmap_update等待vsync。</p><h4 id="（六）、Msm8610-lcd-driver-内核初始化分析"><a href="#（六）、Msm8610-lcd-driver-内核初始化分析" class="headerlink" title="（六）、Msm8610  lcd driver 内核初始化分析"></a>（六）、Msm8610  lcd driver 内核初始化分析</h4><p>请参考<a href="https://blog.csdn.net/ic_soc_arm_robin/article/details/12949347" target="_blank" rel="noopener">【msm8610 lcd driver code analysis】</a></p><h4 id="（七）、参考资料-特别感谢各位前辈的分析和图示-："><a href="#（七）、参考资料-特别感谢各位前辈的分析和图示-：" class="headerlink" title="（七）、参考资料(特别感谢各位前辈的分析和图示)："></a>（七）、参考资料(特别感谢各位前辈的分析和图示)：</h4><p><strong>(๑乛◡乛๑) 、（ ͡° ͜ʖ ͡°）、（ಡωಡ）！！！累~~~</strong><br><strong>时至今日，终于完整的分析了Android Display System 总体框架流程，不禁感叹计算机世界的博大精深，在这个系列的分析中历练了如何拆解分析一个庞大复杂的模块、学习收获良多，同时也了解了自身知识的欠缺，由于涉及知识较多较广，博主也未能完全吃透，其中分析有误的地方还请各位见谅。所谓路漫漫其修远兮，吾将上下而求索。</strong><br><strong>Todo：专注于Linux &amp;&amp; Android Multimedia（Camera、Video、Audio、Display）系统分析与研究，Multimedia System 任还有许多未解之惑，需恶补Linux内核知识，少年，加油（➽➽➽）</strong></p><h4 id="（八）、参考资料-特别感谢各位前辈的分析和图示-："><a href="#（八）、参考资料-特别感谢各位前辈的分析和图示-：" class="headerlink" title="（八）、参考资料(特别感谢各位前辈的分析和图示)："></a>（八）、参考资料(特别感谢各位前辈的分析和图示)：</h4><p><a href="https://s3.amazonaws.com/connect.linaro.org/bkk16/Presentations/Wednesday/BKK16-315.pdf" target="_blank" rel="noopener">Graphics Stack Update</a><br><a href="https://blog.csdn.net/eliot_shao/article/details/74926010" target="_blank" rel="noopener">高通Android平台-应用空间操作framebuffer dump LCD总结</a><br><a href="https://blog.csdn.net/ic_soc_arm_robin/article/details/12949347" target="_blank" rel="noopener">msm8610 lcd driver code analysis</a><br><a href="https://blog.csdn.net/u012719256/article/details/52096727" target="_blank" rel="noopener">linux qcom LCD framwork</a><br><a href="https://blog.csdn.net/weijory/article/details/69391838" target="_blank" rel="noopener">Qualcomm平台 display bring up 过程详解</a><br><a href="https://blog.csdn.net/wlwl0071986/article/details/8247443" target="_blank" rel="noopener">高通8x25平台display模块总结</a><br><a href="https://blog.csdn.net/sfrysh/article/details/7305253" target="_blank" rel="noopener">Android 中的 framebuffer</a><br><a href="https://blog.csdn.net/yangwen123/article/details/12096483" target="_blank" rel="noopener">FrameBuffer驱动程序分析</a><br><a href="http://www.wxtlife.com/2017/06/07/Android-framebuffer/" target="_blank" rel="noopener">Android Framebuffer介绍及使用</a><br><a href="https://www.wolfcstech.com/categories/Android-%E5%9B%BE%E5%BD%A2%E7%B3%BB%E7%BB%9F/" target="_blank" rel="noopener">Android 图形系统</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;amp;&amp;amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内
      
    
    </summary>
    
      <category term="Android" scheme="http://zhoujinjian.cc/categories/Android/"/>
    
    
      <category term="Android" scheme="http://zhoujinjian.cc/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android Display System（4）：Android Display System 系统分析之Gralloc &amp;&amp; HWComposer模块分析</title>
    <link href="http://zhoujinjian.cc/2018/08/16/Android%20Display%20System%EF%BC%884%EF%BC%89%EF%BC%9AAndroid%20Display%20System%20%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B9%8BGralloc%20&amp;&amp;%20HWComposer%E6%A8%A1%E5%9D%97%E5%88%86%E6%9E%90/"/>
    <id>http://zhoujinjian.cc/2018/08/16/Android Display System（4）：Android Display System 系统分析之Gralloc &amp;&amp; HWComposer模块分析/</id>
    <published>2018-08-15T16:00:00.000Z</published>
    <updated>2018-06-20T15:16:27.801Z</updated>
    
    <content type="html"><![CDATA[<hr><p>注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;&amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除，禁止转载（©Qualcomm Technologies, Inc. 版权所有），谢谢。</p><p><a href="https://github.com/izhoujinjian/zhoujinjian.cc/tree/master/display.system" target="_blank" rel="noopener">【博客原图链接】</a></p><p><a href="https://blog.csdn.net/putiancaijunyu/article/category/2558539" target="_blank" rel="noopener">【特别感谢 -  Android研究 Gralloc &amp;&amp; HWComposer系列分析】</a><br><a href="https://blog.csdn.net/jinzhuojun/article/details/54234354" target="_blank" rel="noopener">【特别感谢 -  Android display 系列分析】</a><br><a href="https://blog.csdn.net/yangwen123/article/details/12192401" target="_blank" rel="noopener">【特别感谢 -  Android图形显示之硬件抽象层Gralloc】</a></p><p>Google Pixel、Pixel XL 内核代码（文章基于 Kernel-3.18）：<br> <a href="https://github.com/matthewdalex/marlin" target="_blank" rel="noopener">Kernel source for Pixel and Pixel XL - GitHub</a></p><p>AOSP 源码（文章基于 Android 7.1.2）：<br> <a href="https://testerhome.com/topics/2229" target="_blank" rel="noopener"> Android 系统全套源代码分享 (更新到 8.1.0_r1)</a></p><p> 🌀🌀：专注于Linux &amp;&amp; Android Multimedia（Camera、Video、Audio、Display）系统分析与研究</p><p>【Android Display System 系统分析系列】：<br>【Android Display System（1）：Android 7.1.2 (Android N) Android Graphics 系统 分析】<br>【Android Display System（2）：Android Display System 系统分析之Android EGL &amp;&amp; OpenGL】<br>【Android Display System（3）：Android Display System 系统分析之HardwareRenderer.draw()绘制流程分析】<br>【Android Display System（4）：Android Display System 系统分析之Gralloc &amp;&amp; HWComposer模块分析】<br>【Android Display System（5）：Android Display System 系统分析之Display Driver Architecture】</p><hr><p>\hardware\libhardware\include\hardware</p><ul><li>fb.h</li></ul><p>\hardware\libhardware\modules\gralloc</p><ul><li>framebuffer.cpp</li><li>gralloc.cpp</li><li>gralloc_priv.h</li><li>gr.h</li><li>mapper.cpp</li></ul><p>\hardware\qcom\display\msm8996\libgralloc</p><ul><li>alloc_controller.cpp</li><li>framebuffer.cpp</li><li>gpu.cpp</li><li>gralloc.cpp</li><li>ionalloc.cpp</li><li>mapper.cpp</li></ul><p>\hardware\qcom\display\msm8996\libgralloc1</p><ul><li>gr_adreno_info.cpp</li><li>gr_allocator.cpp</li><li>gr_buf_mgr.cpp</li><li>gr_device_impl.cpp</li><li>gr_ion_alloc.cpp</li><li>gr_utils.cpp</li></ul><p>\frameworks\native\services\surfaceflinger</p><ul><li>DisplayDevice.cpp</li><li>SurfaceFlinger.cpp</li><li>MonitoredProducer.cpp</li><li>SurfaceFlingerConsumer.cpp</li><li>SurfaceFlinger_hwc1.cpp</li><li>Client.cpp</li><li>DispSync.cpp</li><li>EventControlThread.cpp</li><li>EventThread.cpp</li><li>Layer.cpp</li><li>MessageQueue.cpp</li></ul><p>\frameworks\native\services\surfaceflinger\DisplayHardware</p><ul><li>FramebufferSurface.cpp</li><li>HWC2.cpp</li><li>HWC2On1Adapter.cpp</li><li>HWComposer.cpp</li><li>HWComposer_hwc1.cpp</li></ul><hr><p>Linux系统下的显示驱动框架，每个显示屏被抽象为一个帧缓冲区，注册到FrameBuffer模块中，并在/dev/graphics目录下创建对应的fbX设备。Android系统在硬件抽象层中提供了一个Gralloc模块，封装了对帧缓冲区的所有访问操作。用户空间的应用程序在使用帧缓冲区之间，首先要加载Gralloc模块，并且获得一个gralloc设备和一个fb设备。有了gralloc设备之后，用户空间中的应用程序就可以申请分配一块图形缓冲区，并且将这块图形缓冲区映射到应用程序的地址空间来，以便可以向里面写入要绘制的画面的内容。最后，用户空间中的应用程序就通过fb设备来将已经准备好了的图形缓冲区渲染到帧缓冲区中去，即将图形缓冲区的内容绘制到显示屏中去。相应地，当用户空间中的应用程序不再需要使用一块图形缓冲区的时候，就可以通过gralloc设备来释放它，并且将它从地址空间中解除映射。</p><p>高通MSM8996 <a href="Android 图形系统之gralloc">Gralloc模块</a> 实现源码位于：<br>\hardware\qcom\display\msm8996\libgralloc<br>每个硬件抽象层模块都必须定义HAL_MODULE_INFO_SYM符号，并且有自己唯一的ID，Gralloc也不例外，Gralloc模块ID定义为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/hardware/libhardware/include/hardware/gralloc.h]</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The id of this module</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GRALLOC_HARDWARE_MODULE_ID <span class="meta-string">"gralloc"</span></span></span><br></pre></td></tr></table></figure><p>同时定义了以HAL_MODULE_INFO_SYM为符号的类型为 private_module_t的结构体：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">hardware\libhardware\modules\gralloc\gralloc.cpp</span><br><span class="line"><span class="comment">// HAL module methods</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">hw_module_methods_t</span> <span class="title">gralloc_module_methods</span> = &#123;</span></span><br><span class="line">    .open = gralloc_device_open</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HAL module initialize</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">private_module_t</span> <span class="title">HAL_MODULE_INFO_SYM</span> = &#123;</span></span><br><span class="line">    .base = &#123;</span><br><span class="line">        .common = &#123;</span><br><span class="line">            .tag = HARDWARE_MODULE_TAG,</span><br><span class="line">            .version_major = <span class="number">1</span>,</span><br><span class="line">            .version_minor = <span class="number">0</span>,</span><br><span class="line">            .id = GRALLOC_HARDWARE_MODULE_ID,</span><br><span class="line">            .name = <span class="string">"Graphics Memory Allocator Module"</span>,</span><br><span class="line">            .author = <span class="string">"The Android Open Source Project"</span>,</span><br><span class="line">            .methods = &amp;gralloc_module_methods,</span><br><span class="line">            .dso = <span class="number">0</span>,</span><br><span class="line">            .reserved = &#123;<span class="number">0</span>&#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        .registerBuffer = gralloc_register_buffer,</span><br><span class="line">        .unregisterBuffer = gralloc_unregister_buffer,</span><br><span class="line">        .lock = gralloc_lock,</span><br><span class="line">        .unlock = gralloc_unlock,</span><br><span class="line">        .perform = gralloc_perform,</span><br><span class="line">        .lock_ycbcr = gralloc_lock_ycbcr,</span><br><span class="line">    &#125;,</span><br><span class="line">    .framebuffer = <span class="number">0</span>,</span><br><span class="line">    .fbFormat = <span class="number">0</span>,</span><br><span class="line">    .flags = <span class="number">0</span>,</span><br><span class="line">    .numBuffers = <span class="number">0</span>,</span><br><span class="line">    .bufferMask = <span class="number">0</span>,</span><br><span class="line">    .lock = PTHREAD_MUTEX_INITIALIZER,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过<a href="Android 图形系统之gralloc">Gralloc模块加载</a> 分析的方法将Gralloc模块加载到内存中来之后，就可以调用函数dlsym来获得它所导出的符号HMI，得到private_module_t的首地址后，由于private_module_t的第一个成员变量的类型为gralloc_module_t，因此也是gralloc_module_t的首地址，由于gralloc_module_t的第一个成员变量类型为hw_module_t，因此也是hw_module_t的首地址，因此只要得到这三种类型中其中一种类型变量的地址，就可以相互转换为其他两种类型的指针。</p><h4 id="（一）、Gralloc模块-数据结构"><a href="#（一）、Gralloc模块-数据结构" class="headerlink" title="（一）、Gralloc模块 数据结构"></a>（一）、Gralloc模块 数据结构</h4><p>在分析Gralloc模块之前，首先介绍Gralloc模块定义的一些数据结构。private_module_t用于描述Gralloc模块下的系统帧缓冲区信息<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\qcom\display\msm8996\libgralloc\fb_priv.h]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">private_module_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">gralloc_module_t</span> base;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">private_handle_t</span>* <span class="title">framebuffer</span>;</span><span class="comment">//指向系统帧缓冲区的句柄  </span></span><br><span class="line">    <span class="keyword">uint32_t</span> fbFormat;</span><br><span class="line">    <span class="keyword">uint32_t</span> flags;<span class="comment">//用来标志系统帧缓冲区是否支持双缓冲</span></span><br><span class="line">    <span class="keyword">uint32_t</span> numBuffers;<span class="comment">//表示系统帧缓冲区包含有多少个图形缓冲区  </span></span><br><span class="line">    <span class="keyword">uint32_t</span> bufferMask;<span class="comment">//记录系统帧缓冲区中的图形缓冲区的使用情况 </span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> lock;<span class="comment">//一个互斥锁，用来保护结构体private_module_t的并行访问</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fb_var_screeninfo</span> <span class="title">info</span>;</span><span class="comment">//保存设备显示屏的动态属性信息  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fb_fix_screeninfo</span> <span class="title">finfo</span>;</span><span class="comment">//保存设备显示屏的固定属性信息</span></span><br><span class="line">    <span class="keyword">float</span> xdpi;<span class="comment">//描述设备显示屏在宽度  </span></span><br><span class="line">    <span class="keyword">float</span> ydpi;<span class="comment">//描述设备显示屏在高度  </span></span><br><span class="line">    <span class="keyword">float</span> fps;<span class="comment">//用来描述显示屏的刷新频率  </span></span><br><span class="line">    <span class="keyword">uint32_t</span> swapInterval;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>framebuffer_device_t用来描述系统帧缓冲区设备的信息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/hardware/libhardware/include/hardware/fb.h]</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">framebuffer_device_t</span> &#123;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Common methods of the framebuffer device.  This *must* be the first member of</span></span><br><span class="line"><span class="comment">     * framebuffer_device_t as users of this structure will cast a hw_device_t to</span></span><br><span class="line"><span class="comment">     * framebuffer_device_t pointer in contexts where it's known the hw_device_t references a</span></span><br><span class="line"><span class="comment">     * framebuffer_device_t.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hw_device_t</span> <span class="title">common</span>;</span></span><br><span class="line">    <span class="comment">//用来记录系统帧缓冲区的标志</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span>  flags;</span><br><span class="line">    <span class="comment">//用来描述设备显示屏的宽度、高度 </span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span>  width;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span>  height;</span><br><span class="line">    <span class="comment">//用来描述设备显示屏的一行有多少个像素点  </span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>       stride;</span><br><span class="line">    <span class="comment">//用来描述系统帧缓冲区的像素格式</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>       format;</span><br><span class="line">    <span class="comment">//用来描述设备显示屏在宽度上的密度、密度</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span>     xdpi;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span>     ydpi;</span><br><span class="line">    <span class="comment">//用来描述设备显示屏的刷新频率  </span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span>     fps;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用来设置帧缓冲区交换前后两个图形缓冲区的最小和最大时间间隔 </span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>       minSwapInterval;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>       maxSwapInterval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Number of framebuffers supported*/</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>       numFramebuffers;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> reserved[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用来设置帧缓冲区交换前后两个图形缓冲区的最小和最大时间间隔</span></span><br><span class="line">    <span class="keyword">int</span> (*setSwapInterval)(struct <span class="keyword">framebuffer_device_t</span>* window,</span><br><span class="line">            <span class="keyword">int</span> interval);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用来设置帧缓冲区的更新区域</span></span><br><span class="line">    <span class="keyword">int</span> (*setUpdateRect)(struct <span class="keyword">framebuffer_device_t</span>* window,</span><br><span class="line">            <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> width, <span class="keyword">int</span> height);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用来将图形缓冲区buffer的内容渲染到帧缓冲区中去</span></span><br><span class="line">    <span class="keyword">int</span> (*post)(struct <span class="keyword">framebuffer_device_t</span>* dev, <span class="keyword">buffer_handle_t</span> buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用来通知fb设备，图形缓冲区的组合工作已经完成</span></span><br><span class="line">    <span class="keyword">int</span> (*compositionComplete)(struct <span class="keyword">framebuffer_device_t</span>* dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*dump)(struct <span class="keyword">framebuffer_device_t</span>* dev, <span class="keyword">char</span> *buff, <span class="keyword">int</span> buff_len);</span><br><span class="line">    <span class="keyword">int</span> (*enableScreen)(struct <span class="keyword">framebuffer_device_t</span>* dev, <span class="keyword">int</span> enable);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>* reserved_proc[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">framebuffer_device_t</span>;</span><br></pre></td></tr></table></figure><p>gralloc_module_t用于描述gralloc模块信息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\libhardware\include\hardware\gralloc.h]</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">gralloc_module_t</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hw_module_t</span> <span class="title">common</span>;</span></span><br><span class="line">    <span class="comment">//映射一块图形缓冲区到一个进程的地址空间去 </span></span><br><span class="line">    <span class="keyword">int</span> (*registerBuffer)(struct <span class="keyword">gralloc_module_t</span> <span class="keyword">const</span>* <span class="keyword">module</span>,</span><br><span class="line">            <span class="keyword">buffer_handle_t</span> handle);</span><br><span class="line">    <span class="comment">//取消映射一块图形缓冲区到一个进程的地址空间去</span></span><br><span class="line">    <span class="keyword">int</span> (*unregisterBuffer)(struct <span class="keyword">gralloc_module_t</span> <span class="keyword">const</span>* <span class="keyword">module</span>,</span><br><span class="line">            <span class="keyword">buffer_handle_t</span> handle);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> (*lock)(struct <span class="keyword">gralloc_module_t</span> <span class="keyword">const</span>* <span class="keyword">module</span>,</span><br><span class="line">            <span class="keyword">buffer_handle_t</span> handle, <span class="keyword">int</span> usage,</span><br><span class="line">            <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> w, <span class="keyword">int</span> h,</span><br><span class="line">            <span class="keyword">void</span>** vaddr);</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">int</span> (*unlock)(struct <span class="keyword">gralloc_module_t</span> <span class="keyword">const</span>* <span class="keyword">module</span>,</span><br><span class="line">            <span class="keyword">buffer_handle_t</span> handle);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/* reserved for future use */</span></span><br><span class="line">    <span class="keyword">void</span>* reserved_proc[<span class="number">3</span>];</span><br><span class="line">&#125; <span class="keyword">gralloc_module_t</span>;</span><br></pre></td></tr></table></figure><p>alloc_device_t用于描述gralloc设备的信息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\libhardware\include\hardware\gralloc.h]</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">alloc_device_t</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hw_device_t</span> <span class="title">common</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> (*alloc)(struct <span class="keyword">alloc_device_t</span>* dev,</span><br><span class="line">            <span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> format, <span class="keyword">int</span> usage,</span><br><span class="line">            <span class="keyword">buffer_handle_t</span>* handle, <span class="keyword">int</span>* stride);</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">int</span> (*<span class="built_in">free</span>)(struct <span class="keyword">alloc_device_t</span>* dev,</span><br><span class="line">            <span class="keyword">buffer_handle_t</span> handle);</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">void</span> (*dump)(struct <span class="keyword">alloc_device_t</span> *dev, <span class="keyword">char</span> *buff, <span class="keyword">int</span> buff_len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>* reserved_proc[<span class="number">7</span>];</span><br><span class="line">&#125; <span class="keyword">alloc_device_t</span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/hardware/libhardware/include/hardware/hardware.h]</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hw_module_t</span> &#123;</span>  </span><br><span class="line">    <span class="keyword">uint32_t</span> tag;<span class="comment">//标签  </span></span><br><span class="line">　　<span class="keyword">uint16_t</span> version_major;<span class="comment">//模块主设备号  </span></span><br><span class="line">　　<span class="keyword">uint16_t</span> version_minor;<span class="comment">//模块次设备号  </span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *id;<span class="comment">//模块ID  </span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;<span class="comment">//模块名称  </span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *author;<span class="comment">//模块作者  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hw_module_methods_t</span>* <span class="title">methods</span>;</span><span class="comment">//模块操作方法  </span></span><br><span class="line">    <span class="keyword">void</span>* dso;<span class="comment">//保存模块首地址  </span></span><br><span class="line">    <span class="keyword">uint32_t</span> reserved[<span class="number">32</span><span class="number">-7</span>];<span class="comment">//保留位  </span></span><br><span class="line">&#125; <span class="keyword">hw_module_t</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">模块</th><th style="text-align:right">设备</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:left">private_module_t</td><td style="text-align:right">framebuffer_device_t</td><td style="text-align:center">将图形缓冲器映射到帧缓冲区</td></tr><tr><td style="text-align:left">gralloc_module_t</td><td style="text-align:right">alloc_module_t</td><td style="text-align:center">分配或释放图形缓冲区</td></tr><tr><td style="text-align:left">hw_module_t</td><td style="text-align:right">hw_module_t</td><td style="text-align:center">关联设备和模块</td></tr></tbody></table><p>硬件抽象层Gralloc模块定义了设备fb和设备gpu：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\libhardware\include\hardware\fb.h]</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GRALLOC_HARDWARE_FB0 <span class="meta-string">"fb0"</span></span></span><br><span class="line">[-&gt;/hardware/libhardware/include/hardware/gralloc.h]</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GRALLOC_HARDWARE_GPU0 <span class="meta-string">"gpu0"</span></span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-04-01-GRALLOC_HARDWARE_.png" alt="Alt text | center"></p><p>设备gpu用于分配图形缓冲区，而设备fb用于渲染图形缓冲区；hw_module_t用于描述硬件抽象层Gralloc模块，而hw_device_t则用于描述硬件抽象层Gralloc设备，通过硬件抽象层设备可以找到对应的硬件抽象层模块。在Gralloc模块中，无论是定义fb设备还是gpu设备，都是用来处理图形缓冲区，以下是关于缓冲区的数据结构 定义：<br>private_handle_t用来描述一块缓冲区，Android对缓冲区的定义提供了C和C++两种方式，C++：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\qcom\display\msm8996\libgralloc\gralloc_priv.h]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">private_handle_t</span> :</span> <span class="keyword">public</span> native_handle &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">private_handle_t</span> &#123;</span></span><br><span class="line">        <span class="keyword">native_handle_t</span> nativeHandle;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">enum</span> &#123;</span><br><span class="line">            PRIV_FLAGS_FRAMEBUFFER        = <span class="number">0x00000001</span>,</span><br><span class="line">            ......</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// file-descriptors</span></span><br><span class="line">        <span class="keyword">int</span>     fd;</span><br><span class="line">        <span class="keyword">int</span>     fd_metadata;          <span class="comment">// fd for the meta-data</span></span><br><span class="line">        <span class="comment">// ints</span></span><br><span class="line">        <span class="keyword">int</span>     magic;</span><br><span class="line">        <span class="keyword">int</span>     flags;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span>  size;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span>  offset;</span><br><span class="line">        <span class="keyword">int</span>     bufferType;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">int</span>     format;</span><br><span class="line">        <span class="keyword">int</span>     width;</span><br><span class="line">        <span class="keyword">int</span>     height;</span><br><span class="line">        ......</span><br></pre></td></tr></table></figure></p><p>两种编译器下的private_handle_t定义都继承于native_handle，native_handle的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/system/core/include/cutils/native_handle.h]</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">native_handle</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    <span class="keyword">int</span> version; <span class="comment">//设置为结构体native_handle_t的大小，用来标识结构体native_handle_t的版本  </span></span><br><span class="line">    <span class="keyword">int</span> numFds;  <span class="comment">//表示结构体native_handle_t所包含的文件描述符的个数，这些文件描述符保存在成员变量data所指向的一块缓冲区中。  </span></span><br><span class="line">    <span class="keyword">int</span> numInts; <span class="comment">//表示结构体native_handle_t所包含的整数值的个数，这些整数保存在成员变量data所指向的一块缓冲区中。  </span></span><br><span class="line">    <span class="keyword">int</span> data[<span class="number">0</span>]; <span class="comment">//指向的一块缓冲区中  </span></span><br><span class="line">&#125; <span class="keyword">native_handle_t</span>;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> <span class="keyword">native_handle_t</span>* <span class="keyword">buffer_handle_t</span>;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-04-02-gralloc-hwt.png" alt="Alt text | center"></p><p>  下面就分析Gralloc模块中定义了两种设备的打开过程。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-04-03-GRALLOC_HARDWARE.png" alt="Alt text | center"></p><h4 id="（二）、Fb设备打开过程"><a href="#（二）、Fb设备打开过程" class="headerlink" title="（二）、Fb设备打开过程"></a>（二）、Fb设备打开过程</h4><p>Fb设备打开过程是从SurfaceFlinger.init()函数通过HWComposer对象初始化过程中打开的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\native\services\surfaceflinger\SurfaceFlinger_hwc1.cpp]</span><br><span class="line"><span class="keyword">void</span> SurfaceFlinger::init() &#123;</span><br><span class="line">    <span class="comment">// initialize EGL for the default display</span></span><br><span class="line">    mEGLDisplay = eglGetDisplay(EGL_DEFAULT_DISPLAY);</span><br><span class="line">    eglInitialize(mEGLDisplay, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// start the EventThread</span></span><br><span class="line">    sp&lt;VSyncSource&gt; vsyncSrc = <span class="keyword">new</span> DispSyncSource(&amp;mPrimaryDispSync,</span><br><span class="line">            vsyncPhaseOffsetNs, <span class="literal">true</span>, <span class="string">"app"</span>);</span><br><span class="line">    mEventThread = <span class="keyword">new</span> EventThread(vsyncSrc, *<span class="keyword">this</span>);</span><br><span class="line">    sp&lt;VSyncSource&gt; sfVsyncSrc = <span class="keyword">new</span> DispSyncSource(&amp;mPrimaryDispSync,</span><br><span class="line">            sfVsyncPhaseOffsetNs, <span class="literal">true</span>, <span class="string">"sf"</span>);</span><br><span class="line">    mSFEventThread = <span class="keyword">new</span> EventThread(sfVsyncSrc, *<span class="keyword">this</span>);</span><br><span class="line">    mEventQueue.setEventThread(mSFEventThread);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// Initialize the H/W composer object.  There may or may not be an</span></span><br><span class="line">    <span class="comment">// actual hardware composer underneath.</span></span><br><span class="line">    mHwc = <span class="keyword">new</span> HWComposer(<span class="keyword">this</span>,</span><br><span class="line">            *<span class="keyword">static_cast</span>&lt;HWComposer::EventHandler *&gt;(<span class="keyword">this</span>));</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><p>看看HWComposer构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">HWComposer::HWComposer(</span><br><span class="line">        const sp&lt;SurfaceFlinger&gt;&amp; flinger,</span><br><span class="line">        EventHandler&amp; handler)</span><br><span class="line">    : mFlinger(flinger),</span><br><span class="line">      mFbDev(0), mHwc(0), mNumDisplays(1),</span><br><span class="line">      mCBContext(new cb_context),</span><br><span class="line">      mEventHandler(handler),</span><br><span class="line">      mDebugForceFakeVSync(false)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    // Note: some devices may insist that the FB HAL be opened before HWC.</span><br><span class="line">    int fberr = loadFbHalModule();</span><br><span class="line">    loadHwcModule();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line">int HWComposer::loadFbHalModule()</span><br><span class="line">&#123;</span><br><span class="line">    hw_module_t const* module;</span><br><span class="line"></span><br><span class="line">    int err = hw_get_module(GRALLOC_HARDWARE_MODULE_ID, &amp;module);</span><br><span class="line">    ......</span><br><span class="line">    return framebuffer_open(module, &amp;mFbDev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Android系统在硬件抽象层中提供了一个Gralloc模块，封装了对framebuffer的所有访问操作。Gralloc模块符合Android标准的HAL架构设计。Gralloc对应的hardware id为：GRALLOC_HARDWARE_MODULE_ID</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\libhardware\include\hardware\fb.h]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">framebuffer_open</span><span class="params">(<span class="keyword">const</span> struct <span class="keyword">hw_module_t</span>* <span class="keyword">module</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        struct <span class="keyword">framebuffer_device_t</span>** device)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">module</span>-&gt;methods-&gt;open(<span class="keyword">module</span>,</span><br><span class="line">            GRALLOC_HARDWARE_FB0, (struct <span class="keyword">hw_device_t</span>**)device);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户空间的应用程序在使用帧缓冲区之前，首先要加载Gralloc模块，并且获得一个gpu0设备(gralloc_device, modulename:GRALLOC_HARDWARE_GPU0)和一个fb0设备(modulename:GRALLOC_HARDWARE_FB0)。</p><p>有了alloc设备之后，用户空间中的应用程序就可以申请分配一块图形缓冲区，并且将这块图形缓冲区映射到应用程序的地址空间来，以便可以向里面写入要绘制的画面的内容。最后，用户空间中的应用程序就通过fb0设备来将已经准备好了的图形缓冲区渲染到帧缓冲区中去，即将图形缓冲区的内容绘制到显示屏中去。相应地，当用户空间中的应用程序不再需要使用一块图形缓冲区的时候，就可以通过alloc设备来释放它，并且将它从地址空间中解除映射。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\qcom\display\msm8996\libgralloc\gralloc.cpp]</span><br><span class="line"><span class="comment">// Open Gralloc device</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gralloc_device_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">hw_module_t</span>* <span class="keyword">module</span>, <span class="keyword">const</span> <span class="keyword">char</span>* name,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">hw_device_t</span>** device)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status = -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, GRALLOC_HARDWARE_GPU0)) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">private_module_t</span>* m = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">private_module_t</span>*&gt;(</span><br><span class="line">            <span class="keyword">module</span>);</span><br><span class="line">        <span class="keyword">gpu_context_t</span> *dev;</span><br><span class="line">        IAllocController* alloc_ctrl = IAllocController::getInstance();</span><br><span class="line">        dev = <span class="keyword">new</span> <span class="keyword">gpu_context_t</span>(m, alloc_ctrl);</span><br><span class="line">        <span class="keyword">if</span>(!dev)</span><br><span class="line">            <span class="keyword">return</span> status;</span><br><span class="line"></span><br><span class="line">        *device = &amp;dev-&gt;common;</span><br><span class="line">        status = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//GRALLOC_HARDWARE_FB0,</span></span><br><span class="line">        status = fb_device_open(<span class="keyword">module</span>, name, device);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-1、Fb设备打开过程fb-device-open"><a href="#2-1、Fb设备打开过程fb-device-open" class="headerlink" title="2.1、Fb设备打开过程fb_device_open()"></a>2.1、Fb设备打开过程fb_device_open()</h5><p>看下fb_device_open()函数实现过程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\qcom\display\msm8996\libgralloc\framebuffer.cpp]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fb_device_open</span><span class="params">(<span class="keyword">hw_module_t</span> <span class="keyword">const</span>* <span class="keyword">module</span>, <span class="keyword">const</span> <span class="keyword">char</span>* name,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">hw_device_t</span>** device)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status = -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, GRALLOC_HARDWARE_FB0)) &#123;</span><br><span class="line">        <span class="keyword">alloc_device_t</span>* gralloc_device;</span><br><span class="line">        <span class="comment">// 打开gralloc_device设备。GRALLOC_HARDWARE_GPU0</span></span><br><span class="line">        status = gralloc_open(<span class="keyword">module</span>, &amp;gralloc_device);</span><br><span class="line">        <span class="keyword">if</span> (status &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> status;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个fb_context_t对象，用来描述fb设备上下文  </span></span><br><span class="line">        <span class="keyword">fb_context_t</span> *dev = (<span class="keyword">fb_context_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*dev));</span><br><span class="line">        ......</span><br><span class="line">        <span class="built_in">memset</span>(dev, <span class="number">0</span>, <span class="keyword">sizeof</span>(*dev));</span><br><span class="line">        <span class="comment">//初始化fb_context_t对象  </span></span><br><span class="line">        <span class="comment">/* initialize the procs */</span></span><br><span class="line">        dev-&gt;device.common.tag      = HARDWARE_DEVICE_TAG;</span><br><span class="line">        dev-&gt;device.common.version  = <span class="number">0</span>;</span><br><span class="line">        dev-&gt;device.common.<span class="keyword">module</span>   = <span class="keyword">const_cast</span>&lt;<span class="keyword">hw_module_t</span>*&gt;(<span class="keyword">module</span>);</span><br><span class="line">        <span class="comment">//注册fb设备的操作函数</span></span><br><span class="line">        dev-&gt;device.common.close    = fb_close;</span><br><span class="line">        dev-&gt;device.setSwapInterval = fb_setSwapInterval;</span><br><span class="line">        dev-&gt;device.post            = fb_post;</span><br><span class="line">        dev-&gt;device.setUpdateRect   = <span class="number">0</span>;</span><br><span class="line">        dev-&gt;device.compositionComplete = fb_compositionComplete;</span><br><span class="line">        <span class="comment">//将fb映射到当前进程地址空间 </span></span><br><span class="line">        status = mapFrameBuffer((<span class="keyword">framebuffer_device_t</span>*)dev);</span><br><span class="line">        <span class="keyword">private_module_t</span>* m = (<span class="keyword">private_module_t</span>*)dev-&gt;device.common.<span class="keyword">module</span>;</span><br><span class="line">        <span class="keyword">if</span> (status &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> stride = m-&gt;finfo.line_length / (m-&gt;info.bits_per_pixel &gt;&gt; <span class="number">3</span>);</span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">uint32_t</span>&amp;&gt;(dev-&gt;device.flags) = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">uint32_t</span>&amp;&gt;(dev-&gt;device.width) = m-&gt;info.xres;</span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">uint32_t</span>&amp;&gt;(dev-&gt;device.height) = m-&gt;info.yres;</span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(dev-&gt;device.stride) = stride;</span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(dev-&gt;device.format) = m-&gt;fbFormat;</span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">float</span>&amp;&gt;(dev-&gt;device.xdpi) = m-&gt;xdpi;</span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">float</span>&amp;&gt;(dev-&gt;device.ydpi) = m-&gt;ydpi;</span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">float</span>&amp;&gt;(dev-&gt;device.fps) = m-&gt;fps;</span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(dev-&gt;device.minSwapInterval) =</span><br><span class="line">                                                        PRIV_MIN_SWAP_INTERVAL;</span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(dev-&gt;device.maxSwapInterval) =</span><br><span class="line">                                                        PRIV_MAX_SWAP_INTERVAL;</span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(dev-&gt;device.numFramebuffers) = m-&gt;numBuffers;</span><br><span class="line">            dev-&gt;device.setUpdateRect = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            *device = &amp;dev-&gt;device.common;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Close the gralloc module</span></span><br><span class="line">        gralloc_close(gralloc_device);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数主要是用来创建一个fb_context_t结构体，并且对它的成员变量device进行初始化。结构体fb_context_t的成员变量device的类型为framebuffer_device_t，它是用来描述fb设备的。fb设备主要是用来渲染图形缓冲区的，这是通过调用它的成员函数post来实现的。函数fb_device_open所打开的fb设备的成员函数post被设置为Gralloc模块中的函数fb_post。函数mapFrameBuffer除了用来获得系统帧缓冲区的信息之外，还会将系统帧缓冲区映射到当前进程的地址空间来。line_length用来描述显示屏一行像素总共所占用的字节数，bits_per_pixel用来描述显示屏每一个像素所占用的位数，bits_per_pixel的值向右移3位，就可以得到显示屏每一个像素所占用的字节数。用显示屏像素总共所占用的字节数line_length除以每一个像素所占用的字节数就可以得到显示屏一行有多少个像素点，并保存在stride中。</p><h5 id="2-2、Fb设备地址空间映射mapFrameBuffer"><a href="#2-2、Fb设备地址空间映射mapFrameBuffer" class="headerlink" title="2.2、Fb设备地址空间映射mapFrameBuffer()"></a>2.2、Fb设备地址空间映射mapFrameBuffer()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\qcom\display\msm8996\libgralloc\framebuffer.cpp]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mapFrameBuffer</span><span class="params">(<span class="keyword">framebuffer_device_t</span> *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> err = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">char</span> property[PROPERTY_VALUE_MAX];</span><br><span class="line">    <span class="keyword">if</span>((property_get(<span class="string">"debug.gralloc.map_fb_memory"</span>, property, <span class="literal">NULL</span>) &gt; <span class="number">0</span>) &amp;&amp;</span><br><span class="line">       (!<span class="built_in">strncmp</span>(property, <span class="string">"1"</span>, PROPERTY_VALUE_MAX ) ||</span><br><span class="line">        (!strncasecmp(property,<span class="string">"true"</span>, PROPERTY_VALUE_MAX )))) &#123;</span><br><span class="line">        <span class="keyword">private_module_t</span>* <span class="keyword">module</span> =</span><br><span class="line">            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">private_module_t</span>*&gt;(dev-&gt;common.<span class="keyword">module</span>);</span><br><span class="line">        pthread_mutex_lock(&amp;<span class="keyword">module</span>-&gt;lock);</span><br><span class="line">        err = mapFrameBufferLocked(dev);</span><br><span class="line">        pthread_mutex_unlock(&amp;<span class="keyword">module</span>-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用mapFrameBufferLocked函数执行映射过程，该函数在线程保护下完成。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\qcom\display\msm8996\libgralloc\framebuffer.cpp]</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mapFrameBufferLocked</span><span class="params">(<span class="keyword">framebuffer_device_t</span> *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">private_module_t</span>* <span class="keyword">module</span> =</span><br><span class="line">        <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">private_module_t</span>*&gt;(dev-&gt;common.<span class="keyword">module</span>);</span><br><span class="line">    <span class="keyword">fb_context_t</span> *ctx = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">fb_context_t</span>*&gt;(dev);</span><br><span class="line">    <span class="comment">// already initialized...</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">module</span>-&gt;framebuffer) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> <span class="keyword">const</span> * <span class="keyword">const</span> device_template[] = &#123;</span><br><span class="line">        <span class="string">"/dev/graphics/fb%u"</span>,</span><br><span class="line">        <span class="string">"/dev/fb%u"</span>,</span><br><span class="line">        <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">char</span> property[PROPERTY_VALUE_MAX];</span><br><span class="line">    <span class="comment">//检查是否存在设备文件/dev/graphics/fb0或者/dev/fb0。如果存在的话，那么就调用函数open来打开它，并且将得到的文件描述符保存在变量fd中 </span></span><br><span class="line">    <span class="keyword">while</span> ((fd==<span class="number">-1</span>) &amp;&amp; device_template[i]) &#123;</span><br><span class="line">        <span class="built_in">snprintf</span>(name, <span class="number">64</span>, device_template[i], <span class="number">0</span>);</span><br><span class="line">        fd = open(name, O_RDWR, <span class="number">0</span>);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//通过IO控制命令FBIOGET_FSCREENINFO来获得系统帧缓冲区的固定信息，保存在fb_fix_screeninfo结构体finfo中  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fb_fix_screeninfo</span> <span class="title">finfo</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (ioctl(fd, FBIOGET_FSCREENINFO, &amp;finfo) == <span class="number">-1</span>) &#123;</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> -errno;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过IO控制命令FBIOGET_VSCREENINFO来获得系统帧缓冲区的可变信息，保存在fb_var_screeninfo结构体info中 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fb_var_screeninfo</span> <span class="title">info</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (ioctl(fd, FBIOGET_VSCREENINFO, &amp;info) == <span class="number">-1</span>) &#123;</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> -errno;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化info  </span></span><br><span class="line">    info.reserved[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    info.reserved[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    info.reserved[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    info.xoffset = <span class="number">0</span>;</span><br><span class="line">    info.yoffset = <span class="number">0</span>;</span><br><span class="line">    info.activate = FB_ACTIVATE_NOW;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Interpretation of offset for color fields: All offsets are from the</span></span><br><span class="line"><span class="comment">     * right, inside a "pixel" value, which is exactly 'bits_per_pixel' wide</span></span><br><span class="line"><span class="comment">     * (means: you can use the offset as right argument to &lt;&lt;). A pixel</span></span><br><span class="line"><span class="comment">     * afterwards is a bit stream and is written to video memory as that</span></span><br><span class="line"><span class="comment">     * unmodified. This implies big-endian byte order if bits_per_pixel is</span></span><br><span class="line"><span class="comment">     * greater than 8.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(info.bits_per_pixel == <span class="number">32</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Explicitly request RGBA_8888</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        info.bits_per_pixel = <span class="number">32</span>;</span><br><span class="line">        info.red.offset     = <span class="number">24</span>;</span><br><span class="line">        info.red.length     = <span class="number">8</span>;</span><br><span class="line">        info.green.offset   = <span class="number">16</span>;</span><br><span class="line">        info.green.length   = <span class="number">8</span>;</span><br><span class="line">        info.blue.offset    = <span class="number">8</span>;</span><br><span class="line">        info.blue.length    = <span class="number">8</span>;</span><br><span class="line">        info.transp.offset  = <span class="number">0</span>;</span><br><span class="line">        info.transp.length  = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Note: the GL driver does not have a r=8 g=8 b=8 a=0 config, so if we</span></span><br><span class="line"><span class="comment">         * do not use the MDP for composition (i.e. hw composition == 0), ask</span></span><br><span class="line"><span class="comment">         * for RGBA instead of RGBX. */</span></span><br><span class="line">        <span class="keyword">if</span> (property_get(<span class="string">"debug.sf.hw"</span>, property, <span class="literal">NULL</span>) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                                                           atoi(property) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">module</span>-&gt;fbFormat = HAL_PIXEL_FORMAT_RGBX_8888;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(property_get(<span class="string">"debug.composition.type"</span>, property, <span class="literal">NULL</span>) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                (<span class="built_in">strncmp</span>(property, <span class="string">"mdp"</span>, <span class="number">3</span>) == <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">module</span>-&gt;fbFormat = HAL_PIXEL_FORMAT_RGBX_8888;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">module</span>-&gt;fbFormat = HAL_PIXEL_FORMAT_RGBA_8888;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Explicitly request 5/6/5</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        info.bits_per_pixel = <span class="number">16</span>;</span><br><span class="line">        info.red.offset     = <span class="number">11</span>;</span><br><span class="line">        info.red.length     = <span class="number">5</span>;</span><br><span class="line">        info.green.offset   = <span class="number">5</span>;</span><br><span class="line">        info.green.length   = <span class="number">6</span>;</span><br><span class="line">        info.blue.offset    = <span class="number">0</span>;</span><br><span class="line">        info.blue.length    = <span class="number">5</span>;</span><br><span class="line">        info.transp.offset  = <span class="number">0</span>;</span><br><span class="line">        info.transp.length  = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">module</span>-&gt;fbFormat = HAL_PIXEL_FORMAT_RGB_565;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//adreno needs 4k aligned offsets. Max hole size is 4096-1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size = roundUpToPageSize(info.yres * info.xres *</span><br><span class="line">                                               (info.bits_per_pixel/<span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Request NUM_BUFFERS screens (at least 2 for page flipping)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> numberOfBuffers = (<span class="keyword">int</span>)(finfo.smem_len/size);</span><br><span class="line">    ALOGV(<span class="string">"num supported framebuffers in kernel = %d"</span>, numberOfBuffers);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (property_get(<span class="string">"debug.gr.numframebuffers"</span>, property, <span class="literal">NULL</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = atoi(property);</span><br><span class="line">        <span class="keyword">if</span> ((num &gt;= NUM_FRAMEBUFFERS_MIN) &amp;&amp; (num &lt;= NUM_FRAMEBUFFERS_MAX)) &#123;</span><br><span class="line">            numberOfBuffers = num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (numberOfBuffers &gt; NUM_FRAMEBUFFERS_MAX)</span><br><span class="line">        numberOfBuffers = NUM_FRAMEBUFFERS_MAX;</span><br><span class="line"></span><br><span class="line">    ALOGV(<span class="string">"We support %d buffers"</span>, numberOfBuffers);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//consider the included hole by 4k alignment</span></span><br><span class="line">    <span class="keyword">uint32_t</span> line_length = (info.xres * info.bits_per_pixel / <span class="number">8</span>);</span><br><span class="line">    info.yres_virtual = (<span class="keyword">uint32_t</span>) ((size * numberOfBuffers) / line_length);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> flags = PAGE_FLIP;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (info.yres_virtual &lt; ((size * <span class="number">2</span>) / line_length) ) &#123;</span><br><span class="line">        <span class="comment">// we need at least 2 for page-flipping</span></span><br><span class="line">        info.yres_virtual = (<span class="keyword">int</span>)(size / line_length);</span><br><span class="line">        flags &amp;= ~PAGE_FLIP;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ioctl(fd, FBIOGET_VSCREENINFO, &amp;info) == <span class="number">-1</span>) &#123;</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> -errno;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">int</span>(info.width) &lt;= <span class="number">0</span> || <span class="keyword">int</span>(info.height) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        info.width  = (<span class="keyword">uint32_t</span>)(((<span class="keyword">float</span>)(info.xres) * <span class="number">25.4f</span>)/<span class="number">160.0f</span> + <span class="number">0.5f</span>);</span><br><span class="line">        info.height = (<span class="keyword">uint32_t</span>)(((<span class="keyword">float</span>)(info.yres) * <span class="number">25.4f</span>)/<span class="number">160.0f</span> + <span class="number">0.5f</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> xdpi = ((<span class="keyword">float</span>)(info.xres) * <span class="number">25.4f</span>) / (<span class="keyword">float</span>)info.width;</span><br><span class="line">    <span class="keyword">float</span> ydpi = ((<span class="keyword">float</span>)(info.yres) * <span class="number">25.4f</span>) / (<span class="keyword">float</span>)info.height;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过IO控制命令FBIOGET_VSCREENINFO来重新获得系统帧缓冲区的可变信息  </span></span><br><span class="line">    <span class="keyword">if</span> (ioctl(fd, FBIOGET_FSCREENINFO, &amp;finfo) == <span class="number">-1</span>) &#123;</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> -errno;</span><br><span class="line">    &#125;......</span><br><span class="line">    <span class="keyword">module</span>-&gt;flags = flags;</span><br><span class="line">    <span class="keyword">module</span>-&gt;info = info;</span><br><span class="line">    <span class="keyword">module</span>-&gt;finfo = finfo;</span><br><span class="line">    <span class="keyword">module</span>-&gt;xdpi = xdpi;</span><br><span class="line">    <span class="keyword">module</span>-&gt;ydpi = ydpi;</span><br><span class="line">    <span class="keyword">module</span>-&gt;fps = fps;</span><br><span class="line">    <span class="keyword">module</span>-&gt;swapInterval = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * map the framebuffer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">module</span>-&gt;numBuffers = info.yres_virtual / info.yres;</span><br><span class="line">    <span class="keyword">module</span>-&gt;bufferMask = <span class="number">0</span>;</span><br><span class="line">   <span class="comment">//整个系统帧缓冲区的大小=虚拟分辨率的高度值info.yres_virtual * 每一行所占用的字节数finfo.line_length,并将整个系统帧缓冲区的大小对齐到页面边界  </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> fbSize = roundUpToPageSize(finfo.line_length * info.yres)*</span><br><span class="line">                    <span class="keyword">module</span>-&gt;numBuffers;</span><br><span class="line">   <span class="comment">//系统帧缓冲区在当前进程的地址空间中的起始地址保存到private_handle_t的域base中  </span></span><br><span class="line">    <span class="keyword">void</span>* vaddr = mmap(<span class="number">0</span>, fbSize, PROT_READ|PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//store the framebuffer fd in the ctx</span></span><br><span class="line">    ctx-&gt;fbFd = fd;</span><br><span class="line">   ......</span><br><span class="line">   <span class="comment">//创建一个private_handle_t，用来描述整个系统帧缓冲区的信息</span></span><br><span class="line">    <span class="comment">// Create framebuffer handle using the ION fd</span></span><br><span class="line">    <span class="keyword">module</span>-&gt;framebuffer = <span class="keyword">new</span> <span class="keyword">private_handle_t</span>(fd, fbSize,</span><br><span class="line">                                        <span class="keyword">private_handle_t</span>::PRIV_FLAGS_USES_ION,</span><br><span class="line">                                        BUFFER_TYPE_UI,</span><br><span class="line">                                        <span class="keyword">module</span>-&gt;fbFormat, info.xres, info.yres);</span><br><span class="line">    <span class="comment">//以读写共享方式将帧缓冲区映射到当前进程地址空间中 </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">module</span>-&gt;framebuffer-&gt;base = <span class="keyword">uint64_t</span>(vaddr);</span><br><span class="line">    <span class="built_in">memset</span>(vaddr, <span class="number">0</span>, fbSize);</span><br><span class="line">    <span class="comment">//Enable vsync</span></span><br><span class="line">    <span class="keyword">int</span> enable = <span class="number">1</span>;</span><br><span class="line">    ioctl(ctx-&gt;fbFd, MSMFB_OVERLAY_VSYNC_CTRL, &amp;enable);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3、GPU设备打开过程gralloc-open"><a href="#2-3、GPU设备打开过程gralloc-open" class="headerlink" title="2.3、GPU设备打开过程gralloc_open()"></a>2.3、GPU设备打开过程gralloc_open()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\libhardware\include\hardware\gralloc.h]</span><br><span class="line"><span class="comment">/** convenience API for opening and closing a supported device */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">gralloc_open</span><span class="params">(<span class="keyword">const</span> struct <span class="keyword">hw_module_t</span>* <span class="keyword">module</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">        struct <span class="keyword">alloc_device_t</span>** device)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">module</span>-&gt;methods-&gt;open(<span class="keyword">module</span>, </span><br><span class="line">            GRALLOC_HARDWARE_GPU0, (struct <span class="keyword">hw_device_t</span>**)device);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终会走到gralloc_device_open()函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\libhardware\include\hardware\gralloc.cpp]</span><br><span class="line"></span><br><span class="line"><span class="comment">// HAL module methods</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">hw_module_methods_t</span> <span class="title">gralloc_module_methods</span> = &#123;</span></span><br><span class="line">    .open = gralloc_device_open</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Open Gralloc device</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gralloc_device_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">hw_module_t</span>* <span class="keyword">module</span>, <span class="keyword">const</span> <span class="keyword">char</span>* name,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">hw_device_t</span>** device)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status = -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, GRALLOC_HARDWARE_GPU0)) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">private_module_t</span>* m = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">private_module_t</span>*&gt;(</span><br><span class="line">            <span class="keyword">module</span>);</span><br><span class="line">        <span class="keyword">gpu_context_t</span> *dev;</span><br><span class="line">        IAllocController* alloc_ctrl = IAllocController::getInstance();</span><br><span class="line">        dev = <span class="keyword">new</span> <span class="keyword">gpu_context_t</span>(m, alloc_ctrl);</span><br><span class="line">        ......</span><br><span class="line">        *device = &amp;dev-&gt;common;</span><br><span class="line">        status = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        status = fb_device_open(<span class="keyword">module</span>, name, device);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个函数主要是用来创建一个gpu_context_t 结构体，并且对它的成员变量device进行初始化。gpu_context_t类继承了alloc_device_t，并实现了alloc_device_t中的alloc，free等方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\qcom\display\msm8996\libgralloc\gpu.cpp]</span><br><span class="line"><span class="keyword">gpu_context_t</span>::<span class="keyword">gpu_context_t</span>(<span class="keyword">const</span> <span class="keyword">private_module_t</span>* <span class="keyword">module</span>,</span><br><span class="line">                             IAllocController* alloc_ctrl ) :</span><br><span class="line">    mAllocCtrl(alloc_ctrl)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Zero out the alloc_device_t</span></span><br><span class="line">    <span class="built_in">memset</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">alloc_device_t</span>*&gt;(<span class="keyword">this</span>), <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">alloc_device_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the procs</span></span><br><span class="line">    common.tag     = HARDWARE_DEVICE_TAG;</span><br><span class="line">    common.version = <span class="number">0</span>;</span><br><span class="line">    common.<span class="keyword">module</span>  = <span class="keyword">const_cast</span>&lt;<span class="keyword">hw_module_t</span>*&gt;(&amp;<span class="keyword">module</span>-&gt;base.common);</span><br><span class="line">    common.close   = gralloc_close;</span><br><span class="line">    alloc          = gralloc_alloc;</span><br><span class="line">    <span class="built_in">free</span>           = gralloc_free;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要是完成alloc_device_t参数的初始化。其成员函数alloc，free被设置成gralloc_alloc &amp; gralloc_free。自此，alloc设备的打开过程就分析完成了。<br>接下来，我们重点分析alloc_device_t中提供的几个关键函数。</p><h4 id="（三）、-Gralloc分配和释放Buffer"><a href="#（三）、-Gralloc分配和释放Buffer" class="headerlink" title="（三）、 Gralloc分配和释放Buffer"></a>（三）、 Gralloc分配和释放Buffer</h4><h5 id="3-1、Gralloc分配buffer"><a href="#3-1、Gralloc分配buffer" class="headerlink" title="3.1、Gralloc分配buffer"></a>3.1、Gralloc分配buffer</h5><p>先来回忆一下SurfacFlinger图形缓冲区创建过程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GraphicBuffer::GraphicBuffer </span><br><span class="line">  -&gt; initSize </span><br><span class="line">    -&gt; GraphicBufferAllocator::alloc </span><br><span class="line">      -&gt; <span class="keyword">alloc_device_t</span>::alloc </span><br><span class="line">        -&gt; gralloc_alloc</span><br></pre></td></tr></table></figure><p>用户空间的应用程序用到的图形缓冲区是由Gralloc模块中的函数gralloc_alloc来分配的，这个函数实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\qcom\display\msm8996\libgralloc\gpu.cpp]</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">gpu_context_t</span>::gralloc_alloc(<span class="keyword">alloc_device_t</span>* dev, <span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> format,</span><br><span class="line">                                 <span class="keyword">int</span> usage, <span class="keyword">buffer_handle_t</span>* pHandle,</span><br><span class="line">                                 <span class="keyword">int</span>* pStride)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">gpu_context_t</span>* gpu = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">gpu_context_t</span>*&gt;(dev);</span><br><span class="line">    <span class="keyword">return</span> gpu-&gt;alloc_impl(w, h, format, usage, pHandle, pStride, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">gpu_context_t</span>::alloc_impl(<span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> format, <span class="keyword">int</span> usage,</span><br><span class="line">                              <span class="keyword">buffer_handle_t</span>* pHandle, <span class="keyword">int</span>* pStride,</span><br><span class="line">                              <span class="keyword">unsigned</span> <span class="keyword">int</span> bufferSize) &#123;</span><br><span class="line">   </span><br><span class="line">    ......</span><br><span class="line">     <span class="comment">// 参数format用来描述要分配的图形缓冲区的颜色格式。这些格式定义在system/core/include/system/graphic.h中</span></span><br><span class="line">    <span class="keyword">if</span>(format == HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED ||</span><br><span class="line">       format == HAL_PIXEL_FORMAT_YCbCr_420_888) &#123;</span><br><span class="line">        <span class="keyword">if</span> (usage &amp; GRALLOC_USAGE_PRIVATE_ALLOC_UBWC)</span><br><span class="line">            grallocFormat = HAL_PIXEL_FORMAT_YCbCr_420_SP_VENUS_UBWC;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(usage &amp; GRALLOC_USAGE_HW_VIDEO_ENCODER)</span><br><span class="line">            grallocFormat = HAL_PIXEL_FORMAT_NV12_ENCODEABLE; <span class="comment">//NV12</span></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置buffertype，BUFFER_TYPE_UI: RGB formats &amp; HAL_PIXEL_FORMAT_R_8 &amp;HAL_PIXEL_FORMAT_RG_88。其他的都为BUFFER_TYPE_VIDEO</span></span><br><span class="line">    getGrallocInformationFromFormat(grallocFormat, &amp;bufferType);</span><br><span class="line">    <span class="comment">// 根据formate &amp; w，h算出buffersize</span></span><br><span class="line">    size = getBufferSizeAndDimensions(w, h, grallocFormat, usage, alignedw,</span><br><span class="line">                   alignedh);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    size = (bufferSize &gt;= size)? bufferSize : size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> err = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(useFbMem) &#123;</span><br><span class="line">        err = gralloc_alloc_framebuffer(usage, pHandle);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        err = gralloc_alloc_buffer(size, usage, pHandle, bufferType,</span><br><span class="line">                                   grallocFormat, alignedw, alignedh);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    *pStride = alignedw;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后根据memory alloc出处，区别调用gralloc_alloc_framebuffer&amp;  gralloc_alloc_buffer函数。</p><p>首先来看看 gralloc_alloc_framebuffer的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\qcom\display\msm8996\libgralloc\gpu.cpp]</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">gpu_context_t</span>::gralloc_alloc_framebuffer_locked(<span class="keyword">int</span> usage,</span><br><span class="line">                                                    <span class="keyword">buffer_handle_t</span>* pHandle)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 变量bufferMask用来描述系统帧缓冲区的使用情况</span></span><br><span class="line">    <span class="comment">// 变量numBuffers用来描述系统帧缓冲区可以划分为多少个图形缓冲区来使用</span></span><br><span class="line">    <span class="comment">// 变量bufferSize用来描述设备显示屏一屏内容所占用的内存的大小,同时高通的硬件要求4K对齐。</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> bufferMask = m-&gt;bufferMask;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> numBuffers = m-&gt;numBuffers;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> bufferSize = m-&gt;finfo.line_length * m-&gt;info.yres;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//adreno needs FB size to be page aligned</span></span><br><span class="line">    bufferSize = roundUpToPageSize(bufferSize);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 假设此时系统帧缓冲区中尚有空闲的图形缓冲区的，接下来函数就会创建一个private_handle_t结构体hnd来描述这个即将要分配出去的图形缓冲区。注意，这个图形缓冲区的标志值等于PRIV_FLAGS_FRAMEBUFFER，即表示这是一块在系统帧缓冲区中分配的图形缓冲区。</span></span><br><span class="line">    <span class="keyword">uint64_t</span> vaddr = <span class="keyword">uint64_t</span>(m-&gt;framebuffer-&gt;base);</span><br><span class="line">    <span class="comment">// As GPU needs ION FD, the private handle is created</span></span><br><span class="line">    <span class="comment">// using ION fd and ION flags are set</span></span><br><span class="line">    <span class="keyword">private_handle_t</span>* hnd = <span class="keyword">new</span> <span class="keyword">private_handle_t</span>(</span><br><span class="line">        dup(m-&gt;framebuffer-&gt;fd), bufferSize,</span><br><span class="line">        <span class="keyword">private_handle_t</span>::PRIV_FLAGS_USES_ION |</span><br><span class="line">        <span class="keyword">private_handle_t</span>::PRIV_FLAGS_FRAMEBUFFER,</span><br><span class="line">        BUFFER_TYPE_UI, m-&gt;fbFormat, m-&gt;info.xres,</span><br><span class="line">        m-&gt;info.yres);</span><br><span class="line">    <span class="comment">//  接下来的for循环从低位到高位检查变量bufferMask的值，并且找到第一个值等于0的位，这样就可以知道在系统帧缓冲区中，第几个图形缓冲区的是空闲的。注意，变量vadrr的值开始的时候指向系统帧缓冲区的基地址，在下面的for循环中，每循环一次它的值都会增加bufferSize。从这里就可以看出，每次从系统帧缓冲区中分配出去的图形缓冲区的大小都是刚好等于显示屏一屏内容大小的。</span></span><br><span class="line">    <span class="comment">// find a free slot</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i=<span class="number">0</span> ; i&lt;numBuffers ; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((bufferMask &amp; (<span class="number">1L</span>U&lt;&lt;i)) == <span class="number">0</span>) &#123;</span><br><span class="line">            m-&gt;bufferMask |= (<span class="keyword">uint32_t</span>)(<span class="number">1L</span>U&lt;&lt;i);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vaddr += bufferSize;</span><br><span class="line">    &#125;</span><br><span class="line">    / 将分配的缓冲区的开始地址保存到变量base中，这样用户控件的应用程序可以直接将需要渲染的图形内容拷贝到这个地址上。这样，就相当于是直接将图形渲染到系统帧缓冲区中去。</span><br><span class="line"><span class="comment">// offset表示分配到的图形缓冲区的起始地址正对于系统帧缓冲区基地址的偏移量。</span></span><br><span class="line">    hnd-&gt;base = vaddr;</span><br><span class="line">    hnd-&gt;offset = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(vaddr - m-&gt;framebuffer-&gt;base);</span><br><span class="line">    *pHandle = hnd;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">gpu_context_t</span>::gralloc_alloc_framebuffer(<span class="keyword">int</span> usage,</span><br><span class="line">                                             <span class="keyword">buffer_handle_t</span>* pHandle)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private_module_t</span>* m = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">private_module_t</span>*&gt;(common.<span class="keyword">module</span>);</span><br><span class="line">    pthread_mutex_lock(&amp;m-&gt;lock);</span><br><span class="line">    <span class="keyword">int</span> err = gralloc_alloc_framebuffer_locked(usage, pHandle);</span><br><span class="line">    pthread_mutex_unlock(&amp;m-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面分析了从framebuffer中分配图形缓冲区的过程。总结下这块buffer的来历。首先在fb设备open的时候，通过mmap从fb0中映射一块内存到用户空间，即一个内存池（module-&gt;framebuffer)，通过bufferMask来表示该池中内存的使用情况。而alloc做的事情，就是从这个内存池中找到一个空闲的区块，然后返回该区块的hanlder指针pHandle。</p><p>我们现在来看看从内存中分配图形缓冲区的情况。从Android 4.0开始，Android启动新的内存管理方式ION，以取代PMEM。PMEM需要一个连续的物理内存，同时需要在系统启动的时候，就完成分配。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\qcom\display\msm8996\libgralloc\gpu.cpp]</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">gpu_context_t</span>::gralloc_alloc_buffer(<span class="keyword">unsigned</span> <span class="keyword">int</span> size, <span class="keyword">int</span> usage,</span><br><span class="line">                                        <span class="keyword">buffer_handle_t</span>* pHandle, <span class="keyword">int</span> bufferType,</span><br><span class="line">                                        <span class="keyword">int</span> format, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> err = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> flags = <span class="number">0</span>;</span><br><span class="line">    size = roundUpToPageSize(size);</span><br><span class="line">    <span class="comment">// 首先分配一个data区域</span></span><br><span class="line">    alloc_data data;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 追查代码可以知道mallocCtrl指向IonController对象，关键代码可以参考hardware/qrom/display/msm8974/libgralloc/alloc_controller.cpp。具体怎么从ion中分配buffer</span></span><br><span class="line">    data.size = size;</span><br><span class="line">    data.pHandle = (<span class="keyword">uintptr_t</span>) pHandle;</span><br><span class="line">    err = mAllocCtrl-&gt;allocate(data, usage);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!err) &#123;</span><br><span class="line">        <span class="comment">/* allocate memory for enhancement data */</span></span><br><span class="line">        alloc_data eData;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">int</span> eDataErr = mAllocCtrl-&gt;allocate(eData, eDataUsage);</span><br><span class="line">        ......</span><br><span class="line">        flags |= data.allocType;</span><br><span class="line">        <span class="keyword">uint64_t</span> eBaseAddr = (<span class="keyword">uint64_t</span>)(eData.base) + eData.offset;</span><br><span class="line">        <span class="keyword">private_handle_t</span> *hnd = <span class="keyword">new</span> <span class="keyword">private_handle_t</span>(data.fd, size, flags,</span><br><span class="line">                bufferType, format, width, height, eData.fd, eData.offset,</span><br><span class="line">                eBaseAddr);</span><br><span class="line"></span><br><span class="line">        hnd-&gt;offset = data.offset;</span><br><span class="line">        hnd-&gt;base = (<span class="keyword">uint64_t</span>)(data.base) + data.offset;</span><br><span class="line">        hnd-&gt;gpuaddr = <span class="number">0</span>;</span><br><span class="line">        ColorSpace_t colorSpace = ITU_R_601;</span><br><span class="line">        setMetaData(hnd, UPDATE_COLOR_SPACE, (<span class="keyword">void</span>*) &amp;colorSpace);</span><br><span class="line"></span><br><span class="line">        *pHandle = hnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ALOGE_IF(err, <span class="string">"gralloc failed err=%s"</span>, strerror(-err));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-2、Gralloc释放buffer"><a href="#3-2、Gralloc释放buffer" class="headerlink" title="3.2、Gralloc释放buffer"></a>3.2、Gralloc释放buffer</h5><p>释放buffer本质是调用gralloc_free函数，该函数又调用了free_impl函数。在处理free buffer的时候，也是按照两种情况来分别处理的。如果之前这个buffer是从framebuffer分配的话，就只要把bufferMask中设置成0即可。而对应从内存中申请的，则是调用allocCtrl（ion）中的free_buffer来完成释放。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\qcom\display\msm8996\libgralloc\framebuffer.cpp]</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">gpu_context_t</span>::free_impl(<span class="keyword">private_handle_t</span> <span class="keyword">const</span>* hnd) &#123;</span><br><span class="line">    <span class="keyword">private_module_t</span>* m = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">private_module_t</span>*&gt;(common.<span class="keyword">module</span>);</span><br><span class="line">    <span class="keyword">if</span> (hnd-&gt;flags &amp; <span class="keyword">private_handle_t</span>::PRIV_FLAGS_FRAMEBUFFER) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> bufferSize = m-&gt;finfo.line_length * m-&gt;info.yres;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> index = (<span class="keyword">unsigned</span> <span class="keyword">int</span>) ((hnd-&gt;base - m-&gt;framebuffer-&gt;base)</span><br><span class="line">                / bufferSize);</span><br><span class="line">        m-&gt;bufferMask &amp;= (<span class="keyword">uint32_t</span>)~(<span class="number">1L</span>U&lt;&lt;index);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        terminateBuffer(&amp;m-&gt;base, <span class="keyword">const_cast</span>&lt;<span class="keyword">private_handle_t</span>*&gt;(hnd));</span><br><span class="line">        IMemAlloc* memalloc = mAllocCtrl-&gt;getAllocator(hnd-&gt;flags);</span><br><span class="line">        <span class="keyword">int</span> err = memalloc-&gt;free_buffer((<span class="keyword">void</span>*)hnd-&gt;base, hnd-&gt;size,</span><br><span class="line">                                        hnd-&gt;offset, hnd-&gt;fd);</span><br><span class="line">        <span class="keyword">if</span>(err)</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line">        <span class="comment">// free the metadata space</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> size = ROUND_UP_PAGESIZE(<span class="keyword">sizeof</span>(MetaData_t));</span><br><span class="line">        err = memalloc-&gt;free_buffer((<span class="keyword">void</span>*)hnd-&gt;base_metadata,</span><br><span class="line">                                    size, hnd-&gt;offset_metadata,</span><br><span class="line">                                    hnd-&gt;fd_metadata);</span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> hnd;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（四）、图形缓冲区映射过程"><a href="#（四）、图形缓冲区映射过程" class="headerlink" title="（四）、图形缓冲区映射过程"></a>（四）、图形缓冲区映射过程</h4><p> 图形缓冲区可以从系统帧缓冲区分配也可以从内存中分配，分配一个图形缓冲区后还需要将该图形缓冲区映射到分配该buffer的进程地址空间来，在Android系统中，图形缓冲区的管理由SurfaceFlinger服务来负责。在系统帧缓冲区中分配的图形缓冲区是在SurfaceFlinger服务中使用，而在内存中分配的图形缓冲区既可以在SurfaceFlinger服务中使用，也可以在其它的应用程序中使用。当其它的应用程序需要使用图形缓冲区的时候，它们就会请求SurfaceFlinger服务为它们分配并将SurfaceFlinger服务返回来的图形缓冲区映射到应用程序进程地址空间。在从内存中分配buffer时，已经将分配的buffer映射到了SurfaceFlinger服务进程地址空间，如果该buffer是应用程序请求SurfaceFlinger服务为它们分配的，那么还需要将SurfaceFlinger服务返回来的图形缓冲区映射到应用程序进程地址空间。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-04-04-grallocbuffer.jpg" alt="Alt text | center"></p><p>一个对象要在进程间传输必须继承于Flattenable类，并且实现flatten和unflatten方法，flatten方法用于序列化该对象，unflatten方法用于反序列化对象。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-04-05-graphicbuffer-flatten.jpg" alt="Alt text | center"></p><p>GraphicBuffer类从模板类Flattenable派生，这个派生类可以通过Parcel传递，通常派生类需要重载flatten和unflatten方法，用于对象的序列化和反序列化。</p><p>1）将一个对象写入到Parcel中，需要使用flatten函数序列化该对象，我们先来看下flatten函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\native\libs\ui\GraphicBuffer.cpp]</span><br><span class="line"><span class="keyword">status_t</span> GraphicBuffer::flatten(<span class="keyword">void</span>*&amp; buffer, <span class="keyword">size_t</span>&amp; size, <span class="keyword">int</span>*&amp; fds, <span class="keyword">size_t</span>&amp; count) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">size_t</span> sizeNeeded = GraphicBuffer::getFlattenedSize();</span><br><span class="line">    <span class="keyword">if</span> (size &lt; sizeNeeded) <span class="keyword">return</span> NO_MEMORY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> fdCountNeeded = GraphicBuffer::getFdCount();</span><br><span class="line">    <span class="keyword">if</span> (count &lt; fdCountNeeded) <span class="keyword">return</span> NO_MEMORY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int32_t</span>* buf = <span class="keyword">static_cast</span>&lt;<span class="keyword">int32_t</span>*&gt;(buffer);</span><br><span class="line">    buf[0] = 'GBFR';</span><br><span class="line">    buf[<span class="number">1</span>] = width;</span><br><span class="line">    buf[<span class="number">2</span>] = height;</span><br><span class="line">    buf[<span class="number">3</span>] = stride;</span><br><span class="line">    buf[<span class="number">4</span>] = format;</span><br><span class="line">    buf[<span class="number">5</span>] = usage;</span><br><span class="line">    buf[<span class="number">6</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">int32_t</span>&gt;(mId &gt;&gt; <span class="number">32</span>);</span><br><span class="line">    buf[<span class="number">7</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">int32_t</span>&gt;(mId &amp; <span class="number">0xFFFFFFFF</span>ull);</span><br><span class="line">    buf[<span class="number">8</span>] = <span class="number">0</span>;</span><br><span class="line">    buf[<span class="number">9</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (handle) &#123;</span><br><span class="line">        buf[<span class="number">8</span>] = handle-&gt;numFds;</span><br><span class="line">        buf[<span class="number">9</span>] = handle-&gt;numInts;</span><br><span class="line">        <span class="keyword">native_handle_t</span> <span class="keyword">const</span>* <span class="keyword">const</span> h = handle;</span><br><span class="line">        <span class="comment">//把handle中的data复制到fds中 </span></span><br><span class="line">        <span class="built_in">memcpy</span>(fds,     h-&gt;data,             h-&gt;numFds*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;buf[<span class="number">10</span>], h-&gt;data + h-&gt;numFds, h-&gt;numInts*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buffer = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>*&gt;(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>*&gt;(buffer) + sizeNeeded);</span><br><span class="line">    size -= sizeNeeded;</span><br><span class="line">    <span class="keyword">if</span> (handle) &#123;</span><br><span class="line">        fds += handle-&gt;numFds;</span><br><span class="line">        count -= handle-&gt;numFds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个handle类型为native_handle_t ，且typedef成了buffer_handle_t，我们贴一下它的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/system/core/include/cutils/native_handle.h]</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">native_handle</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    <span class="keyword">int</span> version; <span class="comment">//设置为结构体native_handle_t的大小，用来标识结构体native_handle_t的版本  </span></span><br><span class="line">    <span class="keyword">int</span> numFds;  <span class="comment">//表示结构体native_handle_t所包含的文件描述符的个数，这些文件描述符保存在成员变量data所指向的一块缓冲区中。  </span></span><br><span class="line">    <span class="keyword">int</span> numInts; <span class="comment">//表示结构体native_handle_t所包含的整数值的个数，这些整数保存在成员变量data所指向的一块缓冲区中。  </span></span><br><span class="line">    <span class="keyword">int</span> data[<span class="number">0</span>]; <span class="comment">//指向的一块缓冲区中  </span></span><br><span class="line">&#125; <span class="keyword">native_handle_t</span>;</span><br></pre></td></tr></table></figure><p> 所以我们回到flatten函数中，fds参数用来传递文件句柄，函数把handle中的表示指向图形缓冲区文件描述符句柄复制到fds中，因此这些句柄就能通过binder传递到目标进程中去。</p><p>2）在应用程序读取来自服务进程的GraphicBuffer对象时，也就是result = reply.read(*p)，会调用GraphicBuffer类的unflatten函数进行反序列化过程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\native\libs\ui\GraphicBuffer.cpp]</span><br><span class="line"><span class="keyword">status_t</span> GraphicBuffer::unflatten(</span><br><span class="line">        <span class="keyword">void</span> <span class="keyword">const</span>*&amp; buffer, <span class="keyword">size_t</span>&amp; size, <span class="keyword">int</span> <span class="keyword">const</span>*&amp; fds, <span class="keyword">size_t</span>&amp; count) &#123;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="number">8</span>*<span class="keyword">sizeof</span>(<span class="keyword">int</span>)) <span class="keyword">return</span> NO_MEMORY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">const</span>* buf = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span> <span class="keyword">const</span>*&gt;(buffer);</span><br><span class="line">    if (buf[0] != 'GBFR') return BAD_TYPE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> numFds  = buf[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> numInts = buf[<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> sizeNeeded = (<span class="number">10</span> + numInts) * <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">if</span> (size &lt; sizeNeeded) <span class="keyword">return</span> NO_MEMORY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> fdCountNeeded = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; fdCountNeeded) <span class="keyword">return</span> NO_MEMORY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (handle) &#123;</span><br><span class="line">        <span class="comment">// free previous handle if any</span></span><br><span class="line">        free_handle();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (numFds || numInts) &#123;</span><br><span class="line">        width  = buf[<span class="number">1</span>];</span><br><span class="line">        height = buf[<span class="number">2</span>];</span><br><span class="line">        stride = buf[<span class="number">3</span>];</span><br><span class="line">        format = buf[<span class="number">4</span>];</span><br><span class="line">        usage  = buf[<span class="number">5</span>];</span><br><span class="line">        <span class="comment">//创建一个native_handle对象</span></span><br><span class="line">        native_handle* h = native_handle_create(numFds, numInts);</span><br><span class="line">        <span class="comment">//将fds复制到native_handle对象的data中，和flatten操作相反</span></span><br><span class="line">        <span class="built_in">memcpy</span>(h-&gt;data,          fds,     numFds*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">        <span class="built_in">memcpy</span>(h-&gt;data + numFds, &amp;buf[<span class="number">10</span>], numInts*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">        handle = h;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        width = height = stride = format = usage = <span class="number">0</span>;</span><br><span class="line">        handle = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mId = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint64_t</span>&gt;(buf[<span class="number">6</span>]) &lt;&lt; <span class="number">32</span>;</span><br><span class="line">    mId |= <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(buf[<span class="number">7</span>]);</span><br><span class="line"></span><br><span class="line">    mOwner = ownHandle;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (handle != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//使用GraphicBufferMapper将服务端创建的图形缓冲区映射到当前进程地址空间  </span></span><br><span class="line">        <span class="keyword">status_t</span> err = mBufferMapper.registerBuffer(handle);</span><br><span class="line">        <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">            width = height = stride = format = usage = <span class="number">0</span>;</span><br><span class="line">            handle = <span class="literal">NULL</span>;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buffer = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span> <span class="keyword">const</span>*&gt;(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span> <span class="keyword">const</span>*&gt;(buffer) + sizeNeeded);</span><br><span class="line">    size -= sizeNeeded;</span><br><span class="line">    fds += numFds;</span><br><span class="line">    count -= numFds;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用unflatten函数时，共享区的文件句柄已经准备好了，但是内存还没有进行映射，调用了mBufferMapper.registerBuffer函数来进行内存映射。</p><h5 id="4-1、图形缓冲区的注册过程"><a href="#4-1、图形缓冲区的注册过程" class="headerlink" title="4.1、图形缓冲区的注册过程"></a>4.1、图形缓冲区的注册过程</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> GraphicBufferMapper::registerBuffer(<span class="keyword">const</span> GraphicBuffer* buffer)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">gralloc1_error_t</span> error = mDevice-&gt;retain(buffer);</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用了mDevice-&gt;retain(buffer)函数，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\native\libs\ui\Gralloc1On0Adapter.cpp]</span><br><span class="line"><span class="keyword">gralloc1_error_t</span> Gralloc1On0Adapter::retain(</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Buffer&gt;&amp; buffer)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(mBufferMutex);</span><br><span class="line">    buffer-&gt;retain();</span><br><span class="line">    <span class="keyword">return</span> GRALLOC1_ERROR_NONE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">gralloc1_error_t</span> Gralloc1On0Adapter::retain(</span><br><span class="line">        <span class="keyword">const</span> android::GraphicBuffer* graphicBuffer)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">buffer_handle_t</span> handle = graphicBuffer-&gt;getNativeBuffer()-&gt;handle;</span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(mBufferMutex);</span><br><span class="line"></span><br><span class="line">    ALOGV(<span class="string">"Calling registerBuffer(%p)"</span>, handle);</span><br><span class="line">    <span class="keyword">int</span> result = mModule-&gt;registerBuffer(mModule, handle);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过一系列步骤的调用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/hardware/qcom/display/msm8996/libgralloc/mapper.cpp]</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gralloc_register_buffer</span><span class="params">(<span class="keyword">gralloc_module_t</span> <span class="keyword">const</span>* <span class="keyword">module</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">buffer_handle_t</span> handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">int</span> err =  gralloc_map(<span class="keyword">module</span>, handle);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gralloc_map</span><span class="params">(<span class="keyword">gralloc_module_t</span> <span class="keyword">const</span>* <span class="keyword">module</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">buffer_handle_t</span> handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">private_handle_t</span>* hnd = (<span class="keyword">private_handle_t</span>*)handle;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> err = <span class="number">0</span>;</span><br><span class="line">    IMemAlloc* memalloc = getAllocator(hnd-&gt;flags) ;</span><br><span class="line">    <span class="keyword">void</span> *mappedAddress = MAP_FAILED;</span><br><span class="line">    hnd-&gt;base = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dont map framebuffer and secure buffers</span></span><br><span class="line">    <span class="keyword">if</span> (!(hnd-&gt;flags &amp; <span class="keyword">private_handle_t</span>::PRIV_FLAGS_FRAMEBUFFER) &amp;&amp;</span><br><span class="line">        !(hnd-&gt;flags &amp; <span class="keyword">private_handle_t</span>::PRIV_FLAGS_SECURE_BUFFER)) &#123;</span><br><span class="line">        size = hnd-&gt;size;</span><br><span class="line">        err = memalloc-&gt;map_buffer(&amp;mappedAddress, size,</span><br><span class="line">                                       hnd-&gt;offset, hnd-&gt;fd);</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        hnd-&gt;base = <span class="keyword">uint64_t</span>(mappedAddress) + hnd-&gt;offset;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        err = -EACCES;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Allow mapping of metadata for all buffers including secure ones, but not</span></span><br><span class="line">    <span class="comment">//of framebuffer</span></span><br><span class="line">    <span class="keyword">int</span> metadata_err = gralloc_map_metadata(handle);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进一步调用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/hardware/qcom/display/msm8996/libgralloc/ionalloc.cpp]</span><br><span class="line"><span class="keyword">int</span> IonAlloc::map_buffer(<span class="keyword">void</span> **pBase, <span class="keyword">unsigned</span> <span class="keyword">int</span> size, <span class="keyword">unsigned</span> <span class="keyword">int</span> offset,</span><br><span class="line">        <span class="keyword">int</span> fd)</span><br><span class="line">&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    <span class="keyword">int</span> err = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">void</span> *base = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// It is a (quirky) requirement of ION to have opened the</span></span><br><span class="line">    <span class="comment">// ion fd in the process that is doing the mapping</span></span><br><span class="line">    err = open_device(); </span><br><span class="line">    ......</span><br><span class="line">    base = mmap(<span class="number">0</span>, size, PROT_READ| PROT_WRITE,</span><br><span class="line">                MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    *pBase = base;</span><br><span class="line">    .......</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数就是调用了mmap来进行共享内存的映射。</p><h5 id="4-2、图形缓冲区的释放过程"><a href="#4-2、图形缓冲区的释放过程" class="headerlink" title="4.2、图形缓冲区的释放过程"></a>4.2、图形缓冲区的释放过程</h5><p>释放过程调用流程类似，最后会调用unmap_buffer()释放图像缓冲区。</p><h5 id="4-3、小结"><a href="#4-3、小结" class="headerlink" title="4.3、小结"></a>4.3、小结</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-04-06-sf-app-dup-mmap.png" alt="Alt text | center"></p><h4 id="（五）HWComposer模块"><a href="#（五）HWComposer模块" class="headerlink" title="（五）HWComposer模块"></a>（五）HWComposer模块</h4><p>前面分析HWComposer构造函数没有分析loadHwcModule()函数，<br>loadHwcModule()函数用来加载HWC模块，我们继续查看：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">[E-&gt;\frameworks\native\services\surfaceflinger\DisplayHardware\HWComposer_hwc1.cpp]</span><br><span class="line">HWComposer::HWComposer(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;SurfaceFlinger&gt;&amp; flinger,</span><br><span class="line">        EventHandler&amp; handler)</span><br><span class="line">    : mFlinger(flinger),</span><br><span class="line">      mFbDev(<span class="number">0</span>), mHwc(<span class="number">0</span>), mNumDisplays(<span class="number">1</span>),</span><br><span class="line">      mCBContext(<span class="keyword">new</span> cb_context),<span class="comment">//这里直接new了一个设备上下文对象</span></span><br><span class="line">      mEventHandler(handler),</span><br><span class="line">      mDebugForceFakeVSync(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//装载HWComposer的硬件模块,这个函数中会将mHwc置为true</span></span><br><span class="line">    loadHwcModule();</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//硬件vsync信号</span></span><br><span class="line">    <span class="keyword">if</span> (mHwc) &#123;</span><br><span class="line">        ALOGI(<span class="string">"Using %s version %u.%u"</span>, HWC_HARDWARE_COMPOSER,</span><br><span class="line">              (hwcApiVersion(mHwc) &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>,</span><br><span class="line">              (hwcApiVersion(mHwc) &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">        <span class="keyword">if</span> (mHwc-&gt;registerProcs) &#123;</span><br><span class="line">            <span class="comment">//HWComposer设备上下文变量mCBContext赋值</span></span><br><span class="line">            mCBContext-&gt;hwc = <span class="keyword">this</span>;</span><br><span class="line">            <span class="comment">//函数指针钩子函数hook_invalidate放入上下文</span></span><br><span class="line">            mCBContext-&gt;procs.invalidate = &amp;hook_invalidate;</span><br><span class="line">            <span class="comment">//vsync钩子函数放入上下文</span></span><br><span class="line">            mCBContext-&gt;procs.vsync = &amp;hook_vsync;</span><br><span class="line">            <span class="keyword">if</span> (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1))</span><br><span class="line">                <span class="comment">//hotplug狗子函数放入上下文</span></span><br><span class="line">                mCBContext-&gt;procs.hotplug = &amp;hook_hotplug;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                mCBContext-&gt;procs.hotplug = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">memset</span>(mCBContext-&gt;procs.zero, <span class="number">0</span>, <span class="keyword">sizeof</span>(mCBContext-&gt;procs.zero));</span><br><span class="line">            <span class="comment">//将钩子函数注册进硬件设备，硬件驱动回调这些钩子函数</span></span><br><span class="line">            mHwc-&gt;registerProcs(mHwc, &amp;mCBContext-&gt;procs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// don't need a vsync thread if we have a hardware composer</span></span><br><span class="line">        <span class="comment">//如果有硬件vsync信号， 则不需要软件vsync实现</span></span><br><span class="line">        needVSyncThread = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Load and prepare the hardware composer module.  Sets mHwc.</span></span><br><span class="line"><span class="keyword">void</span> HWComposer::loadHwcModule()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">hw_module_t</span> <span class="keyword">const</span>* <span class="keyword">module</span>;</span><br><span class="line">    <span class="comment">//同样是HAL层封装的函数，参数是HWC_HARDWARE_MODULE_ID，加载hwc模块</span></span><br><span class="line">    <span class="keyword">if</span> (hw_get_module(HWC_HARDWARE_MODULE_ID, &amp;<span class="keyword">module</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打开hwc设备</span></span><br><span class="line">    <span class="keyword">int</span> err = hwc_open_1(<span class="keyword">module</span>, &amp;mHwc);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果硬件设备打开成功，则将钩子函数hook_invalidate、hook_vsync和hook_hotplug注册进硬件设备，作为回调函数。这三个都是硬件产生事件信号，通知上层SurfaceFlinger的回调函数，用于处理这个信号。</p><p>因为我们本节是Vsync信号相关，所以我们只看看hook_vsync钩子函数。这里指定了vsync的回调函数是hook_vsync，如果硬件中产生了VSync信号，将通过这个函数来通知上层，看看它的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[E-&gt;\frameworks\native\services\surfaceflinger\DisplayHardware\HWComposer_hwc1.cpp]</span><br><span class="line"><span class="keyword">void</span> HWComposer::hook_vsync(<span class="keyword">const</span> struct hwc_procs* procs, <span class="keyword">int</span> disp,</span><br><span class="line">        <span class="keyword">int64_t</span> timestamp) &#123;</span><br><span class="line">    cb_context* ctx = <span class="keyword">reinterpret_cast</span>&lt;cb_context*&gt;(</span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">hwc_procs_t</span>*&gt;(procs));</span><br><span class="line">    ctx-&gt;hwc-&gt;vsync(disp, timestamp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  hook_vsync钩子函数会调用vsync函数，我们继续看：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[E-&gt;\frameworks\native\services\surfaceflinger\DisplayHardware\HWComposer_hwc1.cpp]</span><br><span class="line"><span class="keyword">void</span> HWComposer::vsync(<span class="keyword">int</span> disp, <span class="keyword">int64_t</span> timestamp) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">uint32_t</span>(disp) &lt; HWC_NUM_PHYSICAL_DISPLAY_TYPES) &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            Mutex::Autolock _l(mLock);</span><br><span class="line">            mLastHwVSync[disp] = timestamp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> tag[<span class="number">16</span>];</span><br><span class="line">        <span class="built_in">snprintf</span>(tag, <span class="keyword">sizeof</span>(tag), <span class="string">"HW_VSYNC_%1u"</span>, disp);</span><br><span class="line">        ATRACE_INT(tag, ++mVSyncCounts[disp] &amp; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//这里调用EventHandler类型变量mEventHandler就是SurfaceFlinger，</span></span><br><span class="line">        <span class="comment">//所以调用了SurfaceFlinger的onVSyncReceived函数</span></span><br><span class="line">        mEventHandler.onVSyncReceived(disp, timestamp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mEventHandler对象类型为EventHandler，我们在SurfaceFlinger的init函数创建HWComposer类实例时候讲SurfaceFlinger强转为EventHandler作为构造函数的参数传入其中。再者SurfaceFlinger继承HWComposer::EventHandler，所以最终会调用SurfaceFlinger的onVSyncReceived函数，这就是硬件vsync信号的产生。</p><h5 id="5-1、HWC设备打开过程"><a href="#5-1、HWC设备打开过程" class="headerlink" title="5.1、HWC设备打开过程"></a>5.1、HWC设备打开过程</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/hardware/libhardware/include/hardware/hwcomposer.h]</span><br><span class="line"><span class="comment">/** convenience API for opening and closing a device */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">hwc_open_1</span><span class="params">(<span class="keyword">const</span> struct <span class="keyword">hw_module_t</span>* <span class="keyword">module</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">hwc_composer_device_1_t</span>** device)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">module</span>-&gt;methods-&gt;open(<span class="keyword">module</span>,</span><br><span class="line">            HWC_HARDWARE_COMPOSER, (struct <span class="keyword">hw_device_t</span>**)device);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体实现/hardware/qcom/display/msm8996/sdm/libs/hwc/ or /hardware/qcom/display/msm8996/sdm/libs/hwc2/。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/hardware/qcom/display/msm8996/sdm/libs/hwc/hwc_session.h]</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">HWCModuleMethods</span> :</span> <span class="keyword">public</span> <span class="keyword">hw_module_methods_t</span> &#123;</span><br><span class="line">    HWCModuleMethods() &#123;</span><br><span class="line">      <span class="keyword">hw_module_methods_t</span>::open = HWCSession::Open;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">[-&gt;/hardware/qcom/display/msm8996/sdm/libs/hwc/hwc_session.cpp]</span><br><span class="line"><span class="keyword">int</span> HWCSession::Open(<span class="keyword">const</span> <span class="keyword">hw_module_t</span> *<span class="keyword">module</span>, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">hw_device_t</span> **device) &#123;</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, HWC_HARDWARE_COMPOSER)) &#123;</span><br><span class="line">    HWCSession *hwc_session = <span class="keyword">new</span> HWCSession(<span class="keyword">module</span>);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> status = hwc_session-&gt;Init();</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">hwc_composer_device_1_t</span> *composer_device = hwc_session;</span><br><span class="line">    *device = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">hw_device_t</span> *&gt;(composer_device);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HWCSession::HWCSession(<span class="keyword">const</span> <span class="keyword">hw_module_t</span> *<span class="keyword">module</span>) &#123;</span><br><span class="line">  <span class="comment">// By default, drop any events. Calls will be routed to SurfaceFlinger after registerProcs.</span></span><br><span class="line">  hwc_procs_default_.invalidate = Invalidate;</span><br><span class="line">  hwc_procs_default_.vsync = VSync;</span><br><span class="line">  hwc_procs_default_.hotplug = Hotplug;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">hwc_composer_device_1_t</span>::common.tag = HARDWARE_DEVICE_TAG;</span><br><span class="line">  <span class="keyword">hwc_composer_device_1_t</span>::common.version = HWC_DEVICE_API_VERSION_1_5;</span><br><span class="line">  <span class="keyword">hwc_composer_device_1_t</span>::common.<span class="keyword">module</span> = <span class="keyword">const_cast</span>&lt;<span class="keyword">hw_module_t</span>*&gt;(<span class="keyword">module</span>);</span><br><span class="line">  <span class="keyword">hwc_composer_device_1_t</span>::common.close = Close;</span><br><span class="line">  <span class="keyword">hwc_composer_device_1_t</span>::prepare = Prepare;</span><br><span class="line">  <span class="keyword">hwc_composer_device_1_t</span>::<span class="built_in">set</span> = Set;</span><br><span class="line">  <span class="keyword">hwc_composer_device_1_t</span>::eventControl = EventControl;</span><br><span class="line">  <span class="keyword">hwc_composer_device_1_t</span>::setPowerMode = SetPowerMode;</span><br><span class="line">  <span class="keyword">hwc_composer_device_1_t</span>::query = Query;</span><br><span class="line">  <span class="keyword">hwc_composer_device_1_t</span>::registerProcs = RegisterProcs;</span><br><span class="line">  <span class="keyword">hwc_composer_device_1_t</span>::dump = Dump;</span><br><span class="line">  <span class="keyword">hwc_composer_device_1_t</span>::getDisplayConfigs = GetDisplayConfigs;</span><br><span class="line">  <span class="keyword">hwc_composer_device_1_t</span>::getDisplayAttributes = GetDisplayAttributes;</span><br><span class="line">  <span class="keyword">hwc_composer_device_1_t</span>::getActiveConfig = GetActiveConfig;</span><br><span class="line">  <span class="keyword">hwc_composer_device_1_t</span>::setActiveConfig = SetActiveConfig;</span><br><span class="line">  <span class="keyword">hwc_composer_device_1_t</span>::setCursorPositionAsync = SetCursorPositionAsync;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（六）、参考资料-特别感谢各位前辈的分析和图示-："><a href="#（六）、参考资料-特别感谢各位前辈的分析和图示-：" class="headerlink" title="（六）、参考资料(特别感谢各位前辈的分析和图示)："></a>（六）、参考资料(特别感谢各位前辈的分析和图示)：</h4><p><a href="https://blog.csdn.net/putiancaijunyu/article/category/2558539" target="_blank" rel="noopener"> Android研究 Gralloc &amp;&amp; HWComposer系列分析</a><br><a href="https://blog.csdn.net/jinzhuojun/article/details/54234354" target="_blank" rel="noopener">Android Display 系列分析</a><br><a href="https://blog.csdn.net/honour2sword/article/details/12004289" target="_blank" rel="noopener">Android display: framebuffer 映射关系</a><br><a href="https://blog.csdn.net/honour2sword/article/details/38265879" target="_blank" rel="noopener">Android display框架与数据流</a><br><a href="https://blog.csdn.net/yangwen123/article/details/12192401" target="_blank" rel="noopener">Android图形显示之硬件抽象层Gralloc</a><br><a href="https://www.jianshu.com/p/af5858c06d5d" target="_blank" rel="noopener">SurfaceFlinger中Buffer的创建与显示</a><br><a href="https://www.wolfcstech.com/2017/09/21/android_graphics_gralloc/" target="_blank" rel="noopener">Android 图形系统之gralloc</a><br><a href="https://blog.csdn.net/yangwen123/article/category/1647761" target="_blank" rel="noopener">深入剖析Android系统 显示模块</a><br><a href="http://windrunnerlihuan.com/" target="_blank" rel="noopener">Android SurfaceFlinger 学习之路</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;amp;&amp;amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内
      
    
    </summary>
    
      <category term="Android" scheme="http://zhoujinjian.cc/categories/Android/"/>
    
    
      <category term="Android" scheme="http://zhoujinjian.cc/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android Display System（3）：Android Display System 系统分析 之  HardwareRenderer.draw()绘制流程分析</title>
    <link href="http://zhoujinjian.cc/2018/08/01/Android%20Display%20System%EF%BC%883%EF%BC%89%EF%BC%9AAndroid%20Display%20System%20%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B9%8BHardwareRenderer.draw%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <id>http://zhoujinjian.cc/2018/08/01/Android Display System（3）：Android Display System 系统分析之HardwareRenderer.draw绘制流程分析/</id>
    <published>2018-07-31T16:00:00.000Z</published>
    <updated>2018-06-20T15:11:18.995Z</updated>
    
    <content type="html"><![CDATA[<hr><p>注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;&amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除，禁止转载（©Qualcomm Technologies, Inc. 版权所有），谢谢。</p><p><a href="https://github.com/izhoujinjian/zhoujinjian.cc/tree/master/display.system" target="_blank" rel="noopener">【博客原图链接】</a></p><p><a href="https://blog.csdn.net/luoshengyang/article/details/45601143" target="_blank" rel="noopener">【特别感谢 - Android应用程序UI硬件加速渲染技术简要介绍和学习计划】</a><br><a href="https://blog.csdn.net/jinzhuojun/article/details/54234354" target="_blank" rel="noopener">【特别感谢 - Android N中UI硬件渲染（hwui）的HWUI_NEW_OPS(基于Android 7.1)】</a><br><a href="https://www.jianshu.com/p/7bf306c09c7e" target="_blank" rel="noopener">【特别感谢 - Android DisplayList 构建过程】</a></p><p>Google Pixel、Pixel XL 内核代码（文章基于 Kernel-3.18）：<br> <a href="https://github.com/matthewdalex/marlin" target="_blank" rel="noopener">Kernel source for Pixel and Pixel XL - GitHub</a></p><p>AOSP 源码（文章基于 Android 7.1.2）：<br> <a href="https://testerhome.com/topics/2229" target="_blank" rel="noopener"> Android 系统全套源代码分享 (更新到 8.1.0_r1)</a></p><p> 🌀🌀：专注于Linux &amp;&amp; Android Multimedia（Camera、Video、Audio、Display）系统分析与研究</p><p>【Android Display System 系统分析系列】：<br>【Android Display System（1）：Android 7.1.2 (Android N) Android Graphics 系统 分析】<br>【Android Display System（2）：Android Display System 系统分析之Android EGL &amp;&amp; OpenGL】<br>【Android Display System（3）：Android Display System 系统分析之HardwareRenderer.draw()绘制流程分析】<br>【Android Display System（4）：Android Display System 系统分析之Gralloc &amp;&amp; HWComposer模块分析】<br>【Android Display System（5）：Android Display System 系统分析之Display Driver Architecture】 </p><hr><p>\frameworks\base\core\java\android\view\</p><ul><li>ViewRootImpl.java</li><li>RenderNode.java</li><li>View.java</li><li>DisplayListCanvas.java</li></ul><p>\frameworks\base\core\jni\</p><ul><li>android_view_DisplayListCanvas.cpp</li><li>android_view_RenderNode.cpp</li><li>android_view_ThreadedRenderer.cpp</li><li>android_view_Surface.cpp</li><li>android_server_AssetAtlasService.cpp</li></ul><p>\frameworks\base\core\jni\android\graphics\</p><ul><li>Graphics.cpp</li><li>Bitmap.cpp</li></ul><p>\frameworks\base\libs\hwui\</p><ul><li>AssetAtlas.cpp</li><li>BakedOpDispatcher.cpp</li><li>BakedOpRenderer.cpp</li><li>DeferredDisplayList.cpp</li><li>DeferredLayerUpdater.cpp</li><li>DisplayList.cpp</li><li>DisplayListCanvas.cpp</li><li>LayerBuilder.cpp</li><li>LayerRenderer.cpp</li><li>LayerUpdateQueue.cpp</li><li>Patch.cpp</li><li>RecordingCanvas.cpp</li><li>RenderNode.cpp</li></ul><p>\frameworks\base\libs\hwui\hwui\</p><ul><li>Canvas.cpp</li></ul><p>\frameworks\base\libs\hwui\renderthread\</p><ul><li>EglManager.cpp</li><li>CanvasContext.cpp</li><li>DrawFrameTask.cpp</li><li>RenderProxy.cpp</li><li>RenderTask.cpp</li><li>RenderThread.cpp</li></ul><hr><p>UI作为用户体验的核心之一，始终是Android每次升级中的重点。从Androd 3.0(Honeycomb)开始，Android开始支持hwui（UI硬件加速）。到Android 4.0（ICS）时，硬件加速被默认开启。同时ICS还引入了DisplayList的概念（不是OpenGL里的那个），它相当于是从View的绘制命令到GL命令之间的“中间语言”。它记录了绘制该View所需的全部信息，之后只要重放（replay）即可完成内容的绘制。这样如果View没有改动或只部分改动，便可重用或修改DisplayList，从而避免调用了一些上层代码，提高了效率。Android 4.3（JB）中引入了DisplayList的defer操作，它主要用于对DisplayList中命令进行Batch（批次）和Merge（合并）。这样可以减少GL draw call和context切换以提高效率。之后，在Android 5.0（Lollipop）中又引入了RenderNode（渲染节点）的概念，它是对DisplayList及一些View显示属性的进一步封装。代码上，一个View对应一个RenderNode（Native层对应同名类），其中管理着对应的DisplayList和OffscreenBuffer（如果该View为硬件绘制层）。每个向WindowManagerService注册的窗口对应一个RootRenderNode，通过它可以找到View层次结构中所有View的DisplayList信息。在Java层的DisplayListCanvas用于生成DisplayList，其在native层的对应类为RecordingCanvas（在Android N前为DisplayListCanvas）。另外Android L中还引入了RenderThread（渲染线程）。所有的GL命令执行都放到这个线程上。渲染线程在RenderNode中存有渲染帧的所有信息，且还监听VSync信号，因此可以独立做一些属性动画。这样即便主线程block也可以保证动画流畅。引入渲染线程后ThreadedRenderer替代了Gl20Renderer，作为proxy用于主线程（UI线程）把渲染任务交给渲染线程。近期，在Android 7.0（Nougat）中又对hwui进行了小规模重构，引入了BakedOpRenderer, FrameBuilder, LayerBuilder, RecordingCanvas等类，用宏HWUI_NEW_OPS管理。下面简单介绍下这些新成员：</p><p>☯ <strong>RecordingCanvas</strong>: 之前Java层的DisplayListCanvas对应native层的DisplayListCanvas。引入RecordingCanvas后，其在native层的对应物就变成了RecordingCanvas。和DisplayListCanvas类似，画在RecordingCanvas上的内容都会被记录在RenderNode的DisplayList中。</p><p>☯ <strong>BakedOpRenderer</strong>: 顾名思义，就是用于绘制batch/merge好的操作。用于替代之前的OpenGLRenderer。它是真正用GL绘制到on-screen surface上的。</p><p>☯ <strong>BakedOpDispatcher</strong>: 提供一系列onXXX（如onBitmapOp）和onMergedXXX（如onMergedBitmapOps）静态函数供replay时调用。这些dispatch函数最后一般都会通过GlopBuilder来构造Glop然后通过BakedOpRenderer的renderGlop()函数来用OpenGL绘制。</p><p>☯ <strong>LayerBuilder</strong>: 用于存储绘制某一层的操作和状态。替代了部分原DeferredDisplayList的工作。对于所有View通用，即如果View有render layer，它对应一个FBO；如果对于普通View，它对应的是SurfaceFlinger提供的surface。 其中的mBatches存储了当前层defer后（即batch/merge好）的绘制操作。</p><p>☯ <strong>FrameBuilder</strong>: 管理某一帧的构建，用于处理，优化和存储从RenderNode和LayerUpdateQueue中来的渲染命令，同时它的replayBakedOps()方法还用于该帧的绘制命令重放。一帧中可能需要绘制多个层，每一层的上下文都会存在相应的LayerBuilder中。在FrameBuilder中通过mLayerBuilders和mLayerStack存储一个layer stack。它替代了原Snapshot类的一部分功能。</p><p>☯ <strong>OffscreenBuffer</strong>: 用于替代Layer类，但是设计上更轻量，而且自带内存池（通过OffscreenBufferPool）。</p><p>☯ <strong>LayerUpdateQueue</strong>：用于记录类型为硬件绘制层的RenderNode的更新操作。之后会通过FrameBuilder将该layer对应的RenderNode通过deferNodeOps()方法进行处理。</p><p>☯ <strong>RecordedOp</strong>: 由RecordedCanvas将View中的绘制命令转化为RecordedOp。RecordedOp也是DisplayList中的基本元素，用于替代Android N之前的DisplayListOp。它有一坨各式各样的继承类代表各种各样的绘制操作。BakedOpState是RecordedOp和相应的状态的自包含封装（封装的过程称为bake）。</p><p>☯ <strong>BatchBase</strong>: LayerBuilder中对DisplayList进行batch/merge处理后的结果以BatchBase形式保存在LayerBuilder的mBatches成员中。它有两个继承类分别为OpBatch和MergingOpBatch，分别用于不可合并和可合并操作。</p><p>概括下它们和相关类的关系图如下，接下来从DisplayList(RenderNode)的构建和绘制两个阶段分析下具体有哪些改动。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-03-01-android-hw-ops.png" alt="Alt text | center"></p><p>首先看看总体时序图：然后一步一步分析：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-03-02-HW.Draw.png" alt="Alt text | center"></p><h4 id="（一）、Android硬件渲染环境初始化ViewRootImpl-enableHardwareAcceleration"><a href="#（一）、Android硬件渲染环境初始化ViewRootImpl-enableHardwareAcceleration" class="headerlink" title="（一）、Android硬件渲染环境初始化ViewRootImpl.enableHardwareAcceleration()"></a>（一）、Android硬件渲染环境初始化ViewRootImpl.enableHardwareAcceleration()</h4><p>在ViewRootImpl.java的setView里，会去enable硬件加速功能。如果当前创建的窗口支持硬件加速渲染，那么就会创建一个HardwareRenderer对象，这个HardwareRenderer对象以后将负责执行窗口硬件加速渲染的相关操作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\core\java\android\view\ViewRootImpl.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enableHardwareAcceleration</span><span class="params">(WindowManager.LayoutParams attrs)</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (hardwareAccelerated) &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">if</span> (fakeHwAccelerated) &#123;</span><br><span class="line">                ......</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!ThreadedRenderer.sRendererDisabled</span><br><span class="line">                    || (ThreadedRenderer.sSystemRendererDisabled &amp;&amp; forceHwAccelerated)) &#123;</span><br><span class="line">                ......</span><br><span class="line">                mAttachInfo.mHardwareRenderer = ThreadedRenderer.create(mContext, translucent);</span><br><span class="line">                ......</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>ThreadedRenderer类的静态成员函数create的实现如下所示：</p><h5 id="1-1、ThreadedRenderer创建过程"><a href="#1-1、ThreadedRenderer创建过程" class="headerlink" title="1.1、ThreadedRenderer创建过程"></a>1.1、ThreadedRenderer创建过程</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks\base\core\java\android\view\ThreadedRenderer.java]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadedRenderer <span class="title">create</span><span class="params">(Context context, <span class="keyword">boolean</span> translucent)</span> </span>&#123;</span><br><span class="line">        ThreadedRenderer renderer = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (DisplayListCanvas.isAvailable()) &#123;</span><br><span class="line">            renderer = <span class="keyword">new</span> ThreadedRenderer(context, translucent);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> renderer;</span><br><span class="line">    &#125;</span><br><span class="line">    ThreadedRenderer(Context context, <span class="keyword">boolean</span> translucent) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//1、nCreateRootRenderNode在Native层创建了一个Render Node</span></span><br><span class="line">        <span class="keyword">long</span> rootNodePtr = nCreateRootRenderNode();</span><br><span class="line">        mRootNode = RenderNode.adopt(rootNodePtr);</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//2、nCreateProxy在Native层创建了一个Render Proxy对象</span></span><br><span class="line">        mNativeProxy = nCreateProxy(translucent, rootNodePtr);</span><br><span class="line">        <span class="comment">//3、初始化一个系统预加载资源的地图集,优化资源的内存使用</span></span><br><span class="line">        ProcessInitializer.sInstance.init(context, mNativeProxy);</span><br><span class="line"></span><br><span class="line">        loadSystemProperties();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="1-1-1、创建RenderNode"><a href="#1-1-1、创建RenderNode" class="headerlink" title="1.1.1、创建RenderNode"></a>1.1.1、创建RenderNode</h5><p>nCreateRootRenderNode在Native层创建了一个Render Node。 从这里就可以看出，窗口在Native层的Root Render Node实际上是一个RootRenderNode对象。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\core\jni\android_view_ThreadedRenderer.cpp]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RootRenderNode</span> :</span> <span class="keyword">public</span> RenderNode, ErrorHandler &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    RootRenderNode(JNIEnv* env) : RenderNode() &#123;</span><br><span class="line">        mLooper = Looper::getForThread();</span><br><span class="line">        env-&gt;GetJavaVM(&amp;mVm);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">android_view_ThreadedRenderer_createRootRenderNode</span><span class="params">(JNIEnv* env, jobject clazz)</span> </span>&#123;</span><br><span class="line">    RootRenderNode* node = <span class="keyword">new</span> RootRenderNode(env);</span><br><span class="line">    node-&gt;incStrong(<span class="number">0</span>);</span><br><span class="line">    node-&gt;setName(<span class="string">"RootRenderNode"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出会创建一个C++层的RootRenderNode对象，RootRenderNode继承自RenderNode，去看看RenderNode构造函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\libs\hwui\RenderNode.cpp]</span><br><span class="line">RenderNode::RenderNode()</span><br><span class="line">        : mDirtyPropertyFields(<span class="number">0</span>)</span><br><span class="line">        , mNeedsDisplayListSync(<span class="literal">false</span>)</span><br><span class="line">        , mDisplayList(<span class="literal">nullptr</span>)</span><br><span class="line">        , mStagingDisplayList(<span class="literal">nullptr</span>)</span><br><span class="line">        , mAnimatorManager(*<span class="keyword">this</span>)</span><br><span class="line">        , mParentCount(<span class="number">0</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了这个RootRenderNode对象之后，函数android_view_ThreadedRenderer_createProxy就创建了一个RenderProxy对象。</p><h5 id="1-1-2、创建RenderProxy"><a href="#1-1-2、创建RenderProxy" class="headerlink" title="1.1.2、创建RenderProxy"></a>1.1.2、创建RenderProxy</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\core\jni\android_view_ThreadedRenderer.cpp]</span><br><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">android_view_ThreadedRenderer_createProxy</span><span class="params">(JNIEnv* env, jobject clazz,</span></span></span><br><span class="line"><span class="function"><span class="params">        jboolean translucent, jlong rootRenderNodePtr)</span> </span>&#123;</span><br><span class="line">    RootRenderNode* rootRenderNode = <span class="keyword">reinterpret_cast</span>&lt;RootRenderNode*&gt;(rootRenderNodePtr);</span><br><span class="line">    <span class="function">ContextFactoryImpl <span class="title">factory</span><span class="params">(rootRenderNode)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> (jlong) <span class="keyword">new</span> RenderProxy(translucent, rootRenderNode, &amp;factory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RenderProxy对象的创建过程如下所示</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> [-&gt;\frameworks\base\libs\hwui\renderthread\RenderProxy.cpp]</span><br><span class="line"> RenderProxy::RenderProxy(<span class="keyword">bool</span> translucent, RenderNode* rootRenderNode, IContextFactory* contextFactory)</span><br><span class="line">        : mRenderThread(RenderThread::getInstance())</span><br><span class="line">        , mContext(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">    SETUP_TASK(createContext);</span><br><span class="line">    args-&gt;translucent = translucent;</span><br><span class="line">    args-&gt;rootRenderNode = rootRenderNode;</span><br><span class="line">    args-&gt;thread = &amp;mRenderThread;</span><br><span class="line">    args-&gt;contextFactory = contextFactory;</span><br><span class="line">    mContext = (CanvasContext*) postAndWait(task);</span><br><span class="line">    mDrawFrameTask.setContext(&amp;mRenderThread, mContext, rootRenderNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RenderProxy类有三个重要的成员变量mRenderThread、mContext和mDrawFrameTask，mRenderThread描述的就是Render Thread，mContext描述的是一个画布上下文，mDrawFrameTask描述的是一个用来执行渲染任务的Task</p><h5 id="1-1-2-1、RenderThread-实例化"><a href="#1-1-2-1、RenderThread-实例化" class="headerlink" title="1.1.2.1、RenderThread 实例化"></a>1.1.2.1、RenderThread 实例化</h5><p>来看看RenderThread::getInstance()实例化过程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\libs\hwui\renderthread\RenderThread.cpp]</span><br><span class="line">RenderThread&amp; RenderThread::getInstance() &#123;</span><br><span class="line">    <span class="keyword">static</span> RenderThread* sInstance = <span class="keyword">new</span> RenderThread();</span><br><span class="line">    gHasRenderThreadInstance = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> *sInstance;</span><br><span class="line">&#125;</span><br><span class="line">RenderThread::RenderThread() : Thread(<span class="literal">true</span>)</span><br><span class="line">        , mNextWakeup(LLONG_MAX)</span><br><span class="line">        , mDisplayEventReceiver(<span class="literal">nullptr</span>)</span><br><span class="line">        , mVsyncRequested(<span class="literal">false</span>)</span><br><span class="line">        , mFrameCallbackTaskPending(<span class="literal">false</span>)</span><br><span class="line">        , mFrameCallbackTask(<span class="literal">nullptr</span>)</span><br><span class="line">        , mRenderState(<span class="literal">nullptr</span>)</span><br><span class="line">        , mEglManager(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">    Properties::load();</span><br><span class="line">    mFrameCallbackTask = <span class="keyword">new</span> DispatchFrameCallbacks(<span class="keyword">this</span>);</span><br><span class="line">    mLooper = <span class="keyword">new</span> Looper(<span class="literal">false</span>);</span><br><span class="line">    run(<span class="string">"RenderThread"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RenderThread类的成员变量mFrameCallbackTask描述的Task是用来做什么的呢？原来就是用来显示动画的。当Java层注册一个动画</span></span><br><span class="line"><span class="comment">//类型的Render Node到Render Thread时，一个类型为IFrameCallback的回调接口就会通过RenderThread类的成员函数</span></span><br><span class="line"><span class="comment">//postFrameCallback注册到Render Thread的一个Pending Registration Frame Callbacks列表中</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DispatchFrameCallbacks</span> :</span> <span class="keyword">public</span> RenderTask &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    RenderThread* mRenderThread;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DispatchFrameCallbacks(RenderThread* rt) : mRenderThread(rt) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">        mRenderThread-&gt;dispatchFrameCallbacks();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> RenderThread::dispatchFrameCallbacks() &#123;</span><br><span class="line">   ......</span><br><span class="line">    <span class="keyword">if</span> (callbacks.size()) &#123;</span><br><span class="line">        ......</span><br><span class="line">        requestVsync();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">set</span>&lt;IFrameCallback*&gt;::iterator it = callbacks.begin(); it != callbacks.end(); it++) &#123;</span><br><span class="line">            (*it)-&gt;doFrame();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、mFrameCallbackTask指向一个DispatchFrameCallbacks对象，用来描述一个帧绘制任务<br>2、mLooper指向一个Looper对象，消息驱动模型<br>3、RenderThread类是从Thread类继承下来的，当我们调用它的成员函数run的时候，就会创建一个新的线程。这个新的线程的入口点函数为RenderThread类的成员函数threadLoop，它的实现如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\libs\hwui\renderthread\RenderThread.cpp]</span><br><span class="line">bool RenderThread::threadLoop() &#123;</span><br><span class="line">    setpriority(PRIO_PROCESS, 0, PRIORITY_DISPLAY);</span><br><span class="line">    initThreadLocals();</span><br><span class="line"></span><br><span class="line">    int timeoutMillis = -1;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int result = mLooper-&gt;pollOnce(timeoutMillis);</span><br><span class="line"></span><br><span class="line">        nsecs_t nextWakeup;</span><br><span class="line">        // Process our queue, if we have anything</span><br><span class="line">        while (RenderTask* task = nextTask(&amp;nextWakeup)) &#123;</span><br><span class="line">            task-&gt;run();</span><br><span class="line">            // task may have deleted itself, do not reference it again</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        if (mPendingRegistrationFrameCallbacks.size() &amp;&amp; !mFrameCallbackTaskPending) &#123;</span><br><span class="line">            drainDisplayEventQueue();</span><br><span class="line">            mFrameCallbacks.insert(</span><br><span class="line">                    mPendingRegistrationFrameCallbacks.begin(), mPendingRegistrationFrameCallbacks.end());</span><br><span class="line">            mPendingRegistrationFrameCallbacks.clear();</span><br><span class="line">            requestVsync();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!mFrameCallbackTaskPending &amp;&amp; !mVsyncRequested &amp;&amp; mFrameCallbacks.size()) &#123;</span><br><span class="line">            requestVsync();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们就可以看到Render Thread的运行模型：<br>1、空闲的时候，Render Thread就睡眠在成员变量mLooper指向的一个Looper对象的成员函数pollOnce中。<br>2、当其它线程需要调度Render Thread，就会向它的任务队列增加一个任务，然后唤醒Render Thread进行处理。Render Thread通过成员函数nextTask获得需要处理的任务，并且调用它的成员函数run进行处理。<br>RenderThread类的成员函数nextTask的实现如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\libs\hwui\renderthread\RenderThread.cpp]</span><br><span class="line">RenderTask* RenderThread::nextTask(nsecs_t* nextWakeup) &#123;</span><br><span class="line">    AutoMutex _lock(mLock);</span><br><span class="line">    RenderTask* next = mQueue.peek();</span><br><span class="line">    if (!next) &#123;</span><br><span class="line">        mNextWakeup = LLONG_MAX;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ......</span><br><span class="line">        if (next-&gt;mRunAt &lt;= 0 || next-&gt;mRunAt &lt;= systemTime(SYSTEM_TIME_MONOTONIC)) &#123;</span><br><span class="line">            next = mQueue.next();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            next = nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    return next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 注意，如果没有下一个任务可以执行，那么RenderThread类的成员函数nextTask通过参数nextWakeup返回的值为LLONG_MAX，表示Render Thread接下来无限期进入睡眠状态，直到被其它线程唤醒为止。<br> RenderThread类提供了queue、queueAndWait、queueAtFront和queueAt四个成员函数向Task Queue增加一个Task，它们的实现如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\libs\hwui\renderthread\RenderThread.cpp]</span><br><span class="line"><span class="keyword">void</span> RenderThread::<span class="built_in">queue</span>(RenderTask* task) &#123;</span><br><span class="line">    AutoMutex _lock(mLock);</span><br><span class="line">    mQueue.<span class="built_in">queue</span>(task);</span><br><span class="line">    <span class="keyword">if</span> (mNextWakeup &amp;&amp; task-&gt;mRunAt &lt; mNextWakeup) &#123;</span><br><span class="line">        mNextWakeup = <span class="number">0</span>;</span><br><span class="line">        mLooper-&gt;wake();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> RenderThread::queueAndWait(RenderTask* task) &#123;</span><br><span class="line">    Mutex mutex;</span><br><span class="line">    Condition condition;</span><br><span class="line">    <span class="function">SignalingRenderTask <span class="title">syncTask</span><span class="params">(task, &amp;mutex, &amp;condition)</span></span>;</span><br><span class="line"></span><br><span class="line">    AutoMutex _lock(mutex);</span><br><span class="line">    <span class="built_in">queue</span>(&amp;syncTask);</span><br><span class="line">    condition.wait(mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> RenderThread::queueAtFront(RenderTask* task) &#123;</span><br><span class="line">    AutoMutex _lock(mLock);</span><br><span class="line">    mQueue.queueAtFront(task);</span><br><span class="line">    mLooper-&gt;wake();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> RenderThread::queueAt(RenderTask* task, <span class="keyword">nsecs_t</span> runAtNs) &#123;</span><br><span class="line">    task-&gt;mRunAt = runAtNs;</span><br><span class="line">    <span class="built_in">queue</span>(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看Render Thread在进入无限循环之前调用的initThreadLocals()函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\libs\hwui\renderthread\RenderThread.cpp]</span><br><span class="line"><span class="keyword">void</span> RenderThread::initThreadLocals() &#123;</span><br><span class="line">    sp&lt;IBinder&gt; dtoken(SurfaceComposerClient::getBuiltInDisplay(</span><br><span class="line">            ISurfaceComposer::eDisplayIdMain));</span><br><span class="line">    <span class="keyword">status_t</span> status = SurfaceComposerClient::getDisplayInfo(dtoken, &amp;mDisplayInfo);</span><br><span class="line">    ......</span><br><span class="line">    initializeDisplayEventReceiver();</span><br><span class="line">    mEglManager = <span class="keyword">new</span> EglManager(*<span class="keyword">this</span>);</span><br><span class="line">    mRenderState = <span class="keyword">new</span> RenderState(*<span class="keyword">this</span>);</span><br><span class="line">    mJankTracker = <span class="keyword">new</span> JankTracker(mDisplayInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、initializeDisplayEventReceiver创建和初始化一个DisplayEventReceiver对象，用来接收Vsync信号。<br>产生Vsync信号时，SurfaceFlinger服务（Vsync信号由SurfaceFlinger服务进行管理和分发）会通过上述文件描述符号唤醒Render Thread。这时候Render Thread就会调用RenderThread类的静态成员函数displayEventReceiverCallback()-&gt;drainDisplayEventQueue()-&gt;<br>2、创建一个EglManager对象，之后会调用EglManager::initialize() Open GL ES环境初始化<br>3、创建一个RenderState对象（记录Render Thread当前的一些渲染状态）</p><h5 id="1-1-2-2、CanvasContext-画布上下文-的初始化过程"><a href="#1-1-2-2、CanvasContext-画布上下文-的初始化过程" class="headerlink" title="1.1.2.2、CanvasContext(画布上下文)的初始化过程"></a>1.1.2.2、CanvasContext(画布上下文)的初始化过程</h5><p>了解了Render Thread的创建过程之后，回到RenderProxy类的构造函数中，接下来我们继续分析它的成员变量mContext的初始化过程，也就是画布上下文的初始化过程。这是通过向Render Thread发送一个createContext命令来完成的。为了方便描述，我们将相关的代码列出来，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\libs\hwui\renderthread\RenderProxy.cpp]</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARGS(method) method ## Args  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CREATE_BRIDGE4(name, a1, a2, a3, a4) CREATE_BRIDGE(name, a1,a2,a3,a4,,,,)  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CREATE_BRIDGE(name, a1, a2, a3, a4, a5, a6, a7, a8) \  </span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> \  </span><br><span class="line">        a1; a2; a3; a4; a5; a6; a7; a8; \  </span><br><span class="line">    &#125; ARGS(name); \  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span>* Bridge_ #<span class="meta"># name(ARGS(name)* args)  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SETUP_TASK(method) \  </span></span><br><span class="line">    .......  </span><br><span class="line">    MethodInvokeRenderTask* task = <span class="keyword">new</span> MethodInvokeRenderTask((RunnableMethod) Bridge_ ## method); \  </span><br><span class="line">    ARGS(method) *args = (ARGS(method) *) task-&gt;payload()  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">CREATE_BRIDGE4(createContext, RenderThread* thread, <span class="keyword">bool</span> translucent,  </span><br><span class="line">        RenderNode* rootRenderNode, IContextFactory* contextFactory) &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CanvasContext(*args-&gt;thread, args-&gt;translucent,  </span><br><span class="line">            args-&gt;rootRenderNode, args-&gt;contextFactory);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 我们首先看宏SETUP_TASK，它需要一个函数作为参数。这个函数通过CREATE_BRIDGEX来声明，其中X是一个数字，数字的大小就等于函数需要的参数的个数。例如，通过CREATE_BRIDGE4声明的函数有4个参数。在上面的代码段中，我们通过CREATE_BRIDGE4宏声明了一个createContext函数。</p><p>宏SETUP_TASK的作用创建一个类型MethodInvokeRenderTask的Task。这个Task关联有一个由CREATE_BRIDGEX宏声明的函数。例如，SETUP_TASK(createContext)创建的MethodInvokeRenderTask关联的函数是由CREATE_BRIDGE4声明的函数createContext。这个Task最终会通过RenderProxy类的成员函数postAndWait添加到Render Thread的Task Queue中，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\libs\hwui\renderthread\RenderProxy.cpp]</span><br><span class="line"><span class="keyword">void</span>* RenderProxy::postAndWait(MethodInvokeRenderTask* task) &#123;</span><br><span class="line">    <span class="keyword">void</span>* retval;</span><br><span class="line">    task-&gt;setReturnPtr(&amp;retval);</span><br><span class="line">    <span class="function">SignalingRenderTask <span class="title">syncTask</span><span class="params">(task, &amp;mSyncMutex, &amp;mSyncCondition)</span></span>;</span><br><span class="line">    AutoMutex _lock(mSyncMutex);</span><br><span class="line">    mRenderThread.<span class="built_in">queue</span>(&amp;syncTask);</span><br><span class="line">    mSyncCondition.wait(mSyncMutex);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RenderProxy对象的创建过程就分析完成了，从中我们也看到Render Thread的创建过程和运行模型，以及Render Proxy与Render Thread的交互模型，总结来说：</p><p>1、RenderProxy内部有一个成员变量mRenderThread，它指向的是一个RenderThread对象，通过它可以向Render Thread线程发送命令。</p><p>2、 RenderProxy内部有一个成员变量mContext，它指向的是一个CanvasContext对象，Render Thread的渲染工作就是通过它来完成的。</p><p>3、RenderProxy内部有一个成员变量mDrawFrameTask，它指向的是一个DrawFrameTask对象，Main Thread通过它向Render Thread线程发送渲染下一帧的命令。</p><h4 id="（二）、Open-GL-ES环境初始化-绑定窗口到Render-Thread中"><a href="#（二）、Open-GL-ES环境初始化-绑定窗口到Render-Thread中" class="headerlink" title="（二）、Open GL ES环境初始化 (绑定窗口到Render Thread中)"></a>（二）、Open GL ES环境初始化 (绑定窗口到Render Thread中)</h4><p>Activity窗口的绘制流程是在ViewRoot(Impl)类的成员函数performTraversals发起的。在绘制之前，首先要获得一个Surface。这个Surface描述的就是一个窗口。因此，一旦获得了对应的Surface，就需要将它绑定到Render Thread中，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/base/core/java/android/view/ViewRootImpl.java]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewRootImpl</span> <span class="keyword">implements</span> <span class="title">ViewParent</span>,  </span></span><br><span class="line"><span class="class">        <span class="title">View</span>.<span class="title">AttachInfo</span>.<span class="title">Callbacks</span>, <span class="title">HardwareRenderer</span>.<span class="title">HardwareDrawCallbacks</span> </span>&#123;  </span><br><span class="line">    ......  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        ......</span><br><span class="line">        hwInitialized = mAttachInfo.mHardwareRenderer.initialize(  </span><br><span class="line">                                        mSurface);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mHardwareRenderer对象，它的成员函数initialize的实现如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\core\java\android\view\ThreadedRenderer.java]</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">initialize</span><span class="params">(Surface surface)</span> <span class="keyword">throws</span> OutOfResourcesException </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> status = !mInitialized;</span><br><span class="line">        mInitialized = <span class="keyword">true</span>;</span><br><span class="line">        updateEnabledState(surface);</span><br><span class="line">        nInitialize(mNativeProxy, surface);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>nInitialize是一个JNI函数，由Native层的函数android_view_ThreadedRenderer_initialize实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\core\jni\android_view_ThreadedRenderer.cpp]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_view_ThreadedRenderer_initialize</span><span class="params">(JNIEnv* env, jobject clazz,</span></span></span><br><span class="line"><span class="function"><span class="params">        jlong proxyPtr, jobject jsurface)</span> </span>&#123;</span><br><span class="line">    RenderProxy* proxy = <span class="keyword">reinterpret_cast</span>&lt;RenderProxy*&gt;(proxyPtr);</span><br><span class="line">    sp&lt;Surface&gt; surface = android_view_Surface_getSurface(env, jsurface);</span><br><span class="line">    proxy-&gt;initialize(surface);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java层的Surface在Native层对应的是一个ANativeWindow。我们可以通过函数android_view_Surface_getNativeWindow来获得一个Java层的Surface在Native层对应的ANativeWindow<br>RenderProxy-&gt;initialize()函数实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE_BRIDGE2(initialize, CanvasContext* context, Surface* surface) &#123;</span><br><span class="line">    args-&gt;context-&gt;initialize(args-&gt;surface);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> RenderProxy::initialize(<span class="keyword">const</span> sp&lt;Surface&gt;&amp; surface) &#123;</span><br><span class="line">    SETUP_TASK(initialize);</span><br><span class="line">    args-&gt;context = mContext;</span><br><span class="line">    args-&gt;surface = surface.get();</span><br><span class="line">    post(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当这个Task在Render Thread中执行时，由宏CREATE_BRIDGE2声明的函数initialize就会被执行。</p><p>在由宏CREATE_BRIDGE2声明的函数initialize中，参数context指向的是RenderProxy类的成员变量mContext指向的一个CanvasContext对象，而参数window指向的ANativeWindow就是要绑定到Render Thread的ANativeWindow。</p><p>由宏CREATE_BRIDGE2声明的函数initialize通过调用参数context指向的CanvasContext对象的成员函数initialize来绑定参数window指向的ANativeWindow，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\libs\hwui\renderthread\CanvasContext.cpp]</span><br><span class="line"><span class="keyword">void</span> CanvasContext::initialize(Surface* surface) &#123;</span><br><span class="line">    setSurface(surface);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !HWUI_NEW_OPS</span></span><br><span class="line">    <span class="keyword">if</span> (mCanvas) <span class="keyword">return</span>;</span><br><span class="line">    mCanvas = <span class="keyword">new</span> OpenGLRenderer(mRenderThread.renderState());</span><br><span class="line">    mCanvas-&gt;initProperties();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CanvasContext::setSurface(Surface* surface) &#123;</span><br><span class="line">    mNativeSurface = surface;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (surface) &#123;</span><br><span class="line">        mEglSurface = mEglManager.createSurface(surface);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mEglSurface != EGL_NO_SURFACE) &#123;</span><br><span class="line">        ......</span><br><span class="line">        mHaveNewSurface = <span class="literal">true</span>;</span><br><span class="line">        .....</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mRenderThread.removeFrameCallback(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一个Open GL渲染上下文都需要关联有一个EGL Surface。这个EGL Surface描述的是一个绘图表面，它封装的实际上是一个ANativeWindow。有了这个EGL Surface之后，我们在执行Open GL命令的时候，才能确定这些命令是作用在哪个窗口上。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\libs\hwui\renderthread\EglManager.cpp]</span><br><span class="line">EGLSurface EglManager::createSurface(EGLNativeWindowType window) &#123;</span><br><span class="line">    initialize();</span><br><span class="line">    EGLSurface surface = eglCreateWindowSurface(mEglDisplay, mEglConfig, window, <span class="literal">nullptr</span>);</span><br><span class="line">    ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> surface;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> EglManager::initialize() &#123;</span><br><span class="line">    ......</span><br><span class="line">    loadConfig();<span class="comment">//</span></span><br><span class="line">    createContext();<span class="comment">//</span></span><br><span class="line">    createPBufferSurface();<span class="comment">//</span></span><br><span class="line">    makeCurrent(mPBufferSurface);<span class="comment">//</span></span><br><span class="line">    DeviceInfo::initialize();</span><br><span class="line">    mRenderThread.renderState().onGLContextCreated();</span><br><span class="line">    initAtlas();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用EGL的绘图的一般步骤：<br>1、获取 EGL Display 对象：eglGetDisplay()<br>2、初始化与 EGLDisplay 之间的连接：eglInitialize()<br>3、获取 EGLConfig 对象：eglChooseConfig()<br>4、创建 EGLContext 实例：eglCreateContext()<br>5、创建 EGLSurface 实例：eglCreateWindowSurface()<br>6、连接 EGLContext 和 EGLSurface：eglMakeCurrent()<br>7、使用 OpenGL ES API 绘制图形：gl_*()<br>8、切换 front buffer 和 back buffer 送显：eglSwapBuffer()<br>9、断开并释放与 EGLSurface 关联的 EGLContext 对象：eglRelease()<br>10、删除 EGLSurface 对象<br>11、删除 EGLContext 对象<br>12、终止与 EGLDisplay 之间的连接</p></blockquote><p>Android EGL &amp;&amp; OpenGL分析请参考【Android Display System（2）：Android Display System 系统分析 之 Android EGL &amp;&amp; OpenGL】</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-03-03-UIThread-ThreadRenderer.png" alt="Alt text | center"></p><p>至此，将当前窗口绑定到Render Thread的过程就分析完成了，整个Android应用程序UI硬件加速渲染环境的初始化过程也分析完成了。</p><h4 id="（三）、RenderNode构建"><a href="#（三）、RenderNode构建" class="headerlink" title="（三）、RenderNode构建"></a>（三）、RenderNode构建</h4><p>我们知道，通常情况下，App要完成一帧渲染，是通过ViewRootImpl的performTraversals()函数来实现。而它又可分为measure, layout, draw三个阶段。上面这些改动主要影响的是最后这步，因此我们就主要focus在draw这个阶段的流程。首先看DisplayList是怎么录制的。在ViewRootImpl::performDraw()中会调用draw()函数。当判断需要进行绘制时（比如有脏区域，或在动画中时），又如果硬件加速可用（通过ThreadedRenderer的isEnabled()），会进行下面的重绘动作。接下来根据是否有相关请求（如resize时）或offset是否有变化来判断是否要调用ThreadedRenderer的invalidRoot()来标记更新RootRenderNode。</p><p>扯个题外话。和Android M相比，N中UI子系统中加入了不少对用户进行窗口resize的处理，主要应该是为了Android N新增加的多窗口分屏模式。比如当用户拖拽分屏窗口边缘时，onWindowDragResizeStart()被调用。它其中会创建BackdropFrameRenderer。BackdropFrameRenderer本身运行单独的线程，它负责在resize窗口而窗口绘制来不及的情况下填充背景。它会通过addRenderNode()加入专用的RenderNode。同时，Android N中将DecorView从PhoneWindow中分离成一个单独的文件，并实现新加的WindowCallbacks接口。它主要用于当用户变化窗口大小时ViewRootImpl对DecorView的回调。因为ViewRootImpl和WindowManagerService通信，它会被通知到窗口变化，然后回调到DecorView中。而DecorView中的相应回调会和BackupdropFrameRenderer交互。如updateContentDrawBounds()中最后会调用到了BackupdropFrmeRenderer的onContentDrawn()函数，其返回值代表在下面的内容绘制后是否需要再发起一次绘制。如果需要，之后会调用requestDrawWindow()。</p><p>回到ViewRootImpl::performDraw()函数，接下来，最重要的就是通过ThreadedRenderer的draw()来进行绘制。在这个draw()函数中，比较重要的一步是通过updateRootDisplayList()函数来更新根结点的DisplayList。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\core\java\android\view\ThreadedRenderer.java]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateViewTreeDisplayList</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        view.mPrivateFlags |= View.PFLAG_DRAWN;</span><br><span class="line">        view.mRecreateDisplayList = (view.mPrivateFlags &amp; View.PFLAG_INVALIDATED)</span><br><span class="line">                == View.PFLAG_INVALIDATED;</span><br><span class="line">        view.mPrivateFlags &amp;= ~View.PFLAG_INVALIDATED;</span><br><span class="line">        view.updateDisplayListIfDirty();</span><br><span class="line">        view.mRecreateDisplayList = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateRootDisplayList</span><span class="params">(View view, HardwareDrawCallbacks callbacks)</span> </span>&#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"Record View#draw()"</span>);</span><br><span class="line">        updateViewTreeDisplayList(view);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mRootNodeNeedsUpdate || !mRootNode.isValid()) &#123;</span><br><span class="line">            DisplayListCanvas canvas = mRootNode.start(mSurfaceWidth, mSurfaceHeight);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> saveCount = canvas.save();</span><br><span class="line">                canvas.translate(mInsetLeft, mInsetTop);</span><br><span class="line">                callbacks.onHardwarePreDraw(canvas);</span><br><span class="line"></span><br><span class="line">                canvas.insertReorderBarrier();</span><br><span class="line">                canvas.drawRenderNode(view.updateDisplayListIfDirty());</span><br><span class="line">                canvas.insertInorderBarrier();</span><br><span class="line"></span><br><span class="line">                callbacks.onHardwarePostDraw(canvas);</span><br><span class="line">                canvas.restoreToCount(saveCount);</span><br><span class="line">                mRootNodeNeedsUpdate = <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mRootNode.end(canvas);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>函数updateRootDisplayList()中的updateViewTreeDisplayList()会调到DecorView的updateDisplayListIfDirty()函数。这个函数主要功能是更新DecorView对应的RenderNode中的DisplayList。它返回的RenderNode会通过RecordingCanvas::drawRenderNode()函数将之作为RenderNodeOp加入到RootRenderNode的DisplayList中。函数updateDisplayListIfDirty()中首先判断当前View是否需要更新。如果不需要就调用dispatchGetDisplayList()让子View更新，然后直接返回。否则就是当前View的DisplayList需要更新。这里我们假设是第一次绘制，更新DisplayList的流程首先通过RenderNode的start()来获得一个用于记录绘制操作的Canvas，即DisplayListCanvas（在Android M中Java层由GLES20RecordingCanvas改为DisplayListCanvas，native层中的DisplayListRenderer改为DisplayListCanvas，Android N中native层中的DisplayListCanvas改为RecordingCanvas）。</p><p>接下去就是比较关键的步骤了。这里就要分几种情况了，一个View可以为三种类型（LAYER_TYPE_NONE, LAYER_TYPE_SOFTWARE, LAYER_TYPE_HARDWARE）中的一种。LAYER_TYPE_NONE为默认值，代表没有layer。LAYER_TYPE_SOFTWARE代表该View有软件层，以bitmap为back，内容用软件渲染。LAYER_TYPE_HARDWARE和LAYER_TYPE_SOFTWARE类似，区别在于其有硬件层，以FBO（Framebuffer object）为back，内容使用硬件渲染。如果硬件加速没有打开，它的行为和LAYER_TYPE_SOFTWARE是一样的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\core\java\android\view\ThreadedRenderer.java]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RenderNode <span class="title">updateDisplayListIfDirty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        final RenderNode renderNode = mRenderNode;</span><br><span class="line">       .......</span><br><span class="line">        <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == <span class="number">0</span></span><br><span class="line">                || !renderNode.isValid()</span><br><span class="line">                || (mRecreateDisplayList)) &#123;</span><br><span class="line">            <span class="comment">// Don't need to recreate the display list, just need to tell our</span></span><br><span class="line">            <span class="comment">// children to restore/recreate theirs</span></span><br><span class="line">            <span class="keyword">if</span> (renderNode.isValid()</span><br><span class="line">                    &amp;&amp; !mRecreateDisplayList) &#123;</span><br><span class="line">                mPrivateFlags |= PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;</span><br><span class="line">                mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;</span><br><span class="line">                dispatchGetDisplayList();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> renderNode; <span class="comment">// no work needed</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If we got here, we're recreating it. Mark it as such to ensure that</span></span><br><span class="line">            <span class="comment">// we copy in child display lists into ours in drawChild()</span></span><br><span class="line">            mRecreateDisplayList = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> width = mRight - mLeft;</span><br><span class="line">            <span class="keyword">int</span> height = mBottom - mTop;</span><br><span class="line">            <span class="keyword">int</span> layerType = getLayerType();</span><br><span class="line"></span><br><span class="line">            final DisplayListCanvas canvas = renderNode.start(width, height);</span><br><span class="line">            canvas.setHighContrastText(mAttachInfo.mHighContrastText);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (layerType == LAYER_TYPE_SOFTWARE) &#123;</span><br><span class="line">                    buildDrawingCache(<span class="literal">true</span>);</span><br><span class="line">                    Bitmap cache = getDrawingCache(<span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">if</span> (cache != null) &#123;</span><br><span class="line">                        canvas.drawBitmap(cache, <span class="number">0</span>, <span class="number">0</span>, mLayerPaint);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    computeScroll();</span><br><span class="line"></span><br><span class="line">                    canvas.translate(-mScrollX, -mScrollY);</span><br><span class="line">                    mPrivateFlags |= PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;</span><br><span class="line">                    mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Fast path for layouts with no backgrounds</span></span><br><span class="line">                    <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) &#123;</span><br><span class="line">                        dispatchDraw(canvas);</span><br><span class="line">                        <span class="keyword">if</span> (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) &#123;</span><br><span class="line">                            mOverlay.getOverlayView().draw(canvas);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        draw(canvas);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                renderNode.end(canvas);</span><br><span class="line">                setDisplayListProperties(renderNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mPrivateFlags |= PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;</span><br><span class="line">            mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> renderNode;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果当前View是软件渲染层（类型为LAYER_TYPE_SOFTWARE）的话，则调用buildDrawingCache()获得Bitmap后调用drawBitmap()将该Bitmap记录到DisplayListCanvas中。现在Android中都默认硬件渲染了，为什么还要考虑软件渲染层呢?一方面有些平台不支持硬件渲染，或app不启用硬件加速，另一方面有些UI控件不支持硬件渲染 。在复杂的View（及子View）在动画过程中，可以被绘制成纹理，这样只需要画一次。显然，在View经常更新的情况下并不适用。因为这样每次都需要重新用软件渲染，如果硬件渲染打开时还要上传成硬件纹理（上传纹理是个比较慢的操作）。类似的，硬件渲染层（LAYER_TYPE_HARDWARE）也是适用于类似的复杂View结构进行属性动画的场景，但它与LAYER_TYPE_SOFTWARE的层的区别为它对应FBO，可以直接硬件渲染生成纹理。因此渲染的过程中不需要先生成Bitmap，从而省去了上传成硬件纹理的这一步操作。</p><p>如果当前View对应LAYER_TYPE_NONE或者LAYER_TYPE_HARDWARE，下面会考查是否为没有背景的Layout。这种情况下当前View没什么好画的，会走快速路径。即通过dispatchDraw()直接让子View重绘。否则就调draw()来绘制当前View及其子View。注意View中的draw()有两个重载同名函数。一个参数的版本用于直接调用。三个参数的版本用于ViewGroup中drawChild()时调用。这里调的是一个参数的版本。这个draw()函数中会按下面的顺序进行绘制（DisplayList的更新）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CallSuper</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> privateFlags = mPrivateFlags;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp;</span><br><span class="line">            (mAttachInfo == <span class="keyword">null</span> || !mAttachInfo.mIgnoreDirtyState);</span><br><span class="line">    mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Draw traversal performs several drawing steps which must be executed</span></span><br><span class="line"><span class="comment">     * in the appropriate order:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *      1. Draw the background</span></span><br><span class="line"><span class="comment">     *      2. If necessary, save the canvas' layers to prepare for fading</span></span><br><span class="line"><span class="comment">     *      3. Draw view's content</span></span><br><span class="line"><span class="comment">     *      4. Draw children</span></span><br><span class="line"><span class="comment">     *      5. If necessary, draw the fading edges and restore layers</span></span><br><span class="line"><span class="comment">     *      6. Draw decorations (scrollbars for instance)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 1, draw the background, if needed</span></span><br><span class="line">    ......</span><br><span class="line">    drawBackground(canvas);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// skip step 2 &amp; 5 if possible (common case)</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> viewFlags = mViewFlags;</span><br><span class="line">    <span class="keyword">boolean</span> horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Step 3, draw the content</span></span><br><span class="line">    <span class="keyword">if</span> (!dirtyOpaque) onDraw(canvas);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 4, draw the children</span></span><br><span class="line">    dispatchDraw(canvas);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 5, draw the fade effect and restore layers</span></span><br><span class="line">    <span class="keyword">final</span> Paint p = scrollabilityCache.paint;</span><br><span class="line">    <span class="keyword">final</span> Matrix matrix = scrollabilityCache.matrix;</span><br><span class="line">    <span class="keyword">final</span> Shader fade = scrollabilityCache.shader;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (drawTop) &#123;</span><br><span class="line">        matrix.setScale(<span class="number">1</span>, fadeHeight * topFadeStrength);</span><br><span class="line">        matrix.postTranslate(left, top);</span><br><span class="line">        fade.setLocalMatrix(matrix);</span><br><span class="line">        p.setShader(fade);</span><br><span class="line">        canvas.drawRect(left, top, right, top + length, p);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    canvas.restoreToCount(saveCount);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Overlay is part of the content and draws beneath Foreground</span></span><br><span class="line">    <span class="keyword">if</span> (mOverlay != <span class="keyword">null</span> &amp;&amp; !mOverlay.isEmpty()) &#123;</span><br><span class="line">        mOverlay.getOverlayView().dispatchDraw(canvas);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 6, draw decorations (foreground, scrollbars)</span></span><br><span class="line">    onDrawForeground(canvas);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些是通过drawBackground(), onDraw(), dispatchDraw()和onDrawForeground()等函数实现。这些函数本质上就是将相应内容绘制到提供的DisplayListCanvas上。由于View是以树形层次结构组织的，draw()中会通过dispatchDraw()来更新子View的DisplayList。dispatchDraw()为对每个子View调用drawChild()。然后调用子View的draw()函数（这次就是上面说的draw()的三个参数的版本了）。这个版本的draw()函数里会更新其View的DisplayList，然后调用DisplayListCanvas的drawRenderNode()将该子view对应的RenderNode记录到其父view的DisplayList中去。这样便根据View的树型结构生成了DisplayList的树型结构。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-03-04-DisplayList-RootRenderNode.png" alt="Alt text | center"></p><p>其中onDraw()用于绘制当前View的自定义UI，它是每个View需要自定义的成员函数。比较典型地，在View的绘制函数中会调用canvas的drawXXX函数。比如canvas.drawLine()-&gt;drawLines(android_graphics_Canvas.cpp)，它会通过JNI最后调到RecordingCanvas.cpp中的RecordingCanvas::drawLines()：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\libs\hwui\RecordingCanvas.cpp]</span><br><span class="line"><span class="keyword">void</span> RecordingCanvas::drawLines(<span class="keyword">const</span> <span class="keyword">float</span>* points, <span class="keyword">int</span> floatCount, <span class="keyword">const</span> SkPaint&amp; paint) &#123;</span><br><span class="line">    <span class="keyword">if</span> (CC_UNLIKELY(floatCount &lt; <span class="number">4</span> || PaintUtils::paintWillNotDraw(paint))) <span class="keyword">return</span>;</span><br><span class="line">    floatCount &amp;= ~<span class="number">0x3</span>; <span class="comment">// round down to nearest four</span></span><br><span class="line"></span><br><span class="line">    addOp(alloc().create_trivial&lt;LinesOp&gt;(</span><br><span class="line">            calcBoundsOfPoints(points, floatCount),</span><br><span class="line">            *mState.currentSnapshot()-&gt;transform,</span><br><span class="line">            getRecordedClip(),</span><br><span class="line">            refPaint(&amp;paint), refBuffer&lt;<span class="keyword">float</span>&gt;(points, floatCount), floatCount));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RecordingCanvas中绝大多数的drawXXX系函数都是类似于这样，通过addOp()将一个RecordedOp的继承类存到其成员mDisplayList中。RecordedOp家庭成员很多，有不少继承类，每个对应一种操作。操作的种类可以参照下这个表：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\libs\hwui\RecordedOp.h]</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAP_OPS_BASED_ON_TYPE(PRE_RENDER_OP_FN, RENDER_ONLY_OP_FN, UNMERGEABLE_OP_FN, MERGEABLE_OP_FN) \</span></span><br><span class="line">        PRE_RENDER_OP_FN(RenderNodeOp) \</span><br><span class="line">        PRE_RENDER_OP_FN(CirclePropsOp) \</span><br><span class="line">        PRE_RENDER_OP_FN(RoundRectPropsOp) \</span><br><span class="line">        PRE_RENDER_OP_FN(BeginLayerOp) \</span><br><span class="line">        PRE_RENDER_OP_FN(EndLayerOp) \</span><br><span class="line">        PRE_RENDER_OP_FN(BeginUnclippedLayerOp) \</span><br><span class="line">        PRE_RENDER_OP_FN(EndUnclippedLayerOp) \</span><br><span class="line">        PRE_RENDER_OP_FN(VectorDrawableOp) \</span><br><span class="line">        \</span><br><span class="line">        RENDER_ONLY_OP_FN(ShadowOp) \</span><br><span class="line">        RENDER_ONLY_OP_FN(LayerOp) \</span><br><span class="line">        RENDER_ONLY_OP_FN(CopyToLayerOp) \</span><br><span class="line">        RENDER_ONLY_OP_FN(CopyFromLayerOp) \</span><br><span class="line">        \</span><br><span class="line">        UNMERGEABLE_OP_FN(ArcOp) \</span><br><span class="line">        UNMERGEABLE_OP_FN(BitmapMeshOp) \</span><br><span class="line">        UNMERGEABLE_OP_FN(BitmapRectOp) \</span><br><span class="line">        UNMERGEABLE_OP_FN(ColorOp) \</span><br><span class="line">        UNMERGEABLE_OP_FN(FunctorOp) \</span><br><span class="line">        UNMERGEABLE_OP_FN(LinesOp) \</span><br><span class="line">        UNMERGEABLE_OP_FN(OvalOp) \</span><br><span class="line">        UNMERGEABLE_OP_FN(PathOp) \</span><br><span class="line">        UNMERGEABLE_OP_FN(PointsOp) \</span><br><span class="line">        UNMERGEABLE_OP_FN(RectOp) \</span><br><span class="line">        UNMERGEABLE_OP_FN(RoundRectOp) \</span><br><span class="line">        UNMERGEABLE_OP_FN(SimpleRectsOp) \</span><br><span class="line">        UNMERGEABLE_OP_FN(TextOnPathOp) \</span><br><span class="line">        UNMERGEABLE_OP_FN(TextureLayerOp) \</span><br><span class="line">        \</span><br><span class="line">        MERGEABLE_OP_FN(BitmapOp) \</span><br><span class="line">        MERGEABLE_OP_FN(PatchOp) \</span><br><span class="line">        MERGEABLE_OP_FN(TextOp)</span><br></pre></td></tr></table></figure><p>各个View的DisplayList更新好后，回到udpateRootDisplayList()。如果发现RootRenderNode也需要更新，则先通过Java层的RenderNode::start()获得DisplayListCanvas，在这个Canvas上的动作都会被记录到DisplayList中，直到调用RenderNode.end()。然后为了防止对上下文状态的影响，用Canvas::save()和Canvas::restoreToCount()来生成临时的画布状态。再接下来就是通过drawRenderNode()将DecorView的RenderNode以RenderNodeOp的形式记录到RootRenderNode。</p><p><strong>DisplayList构建实例：</strong><br><a href="https://www.jianshu.com/p/7bf306c09c7e" target="_blank" rel="noopener">Android DisplayList 构建过程</a><br><strong>activity_main.xml</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">链接：https://www.jianshu.com/p/7bf306c09c7e</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    android:orientation=&quot;vertical&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:id=&quot;@+id/sample_text&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;60dp&quot;</span><br><span class="line">        android:gravity=&quot;center&quot;</span><br><span class="line">        android:textSize=&quot;20sp&quot;</span><br><span class="line">        android:text=&quot;Hello World!&quot; /&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;cc.bobby.debugapp.MyView</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;100dp&quot; /&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-03-05-activity_main.xml.png" alt="Alt text | center"></p><p><strong>udpateRootDisplayList()</strong></p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-03-06-updateRootDisplayList.jpg" alt="Alt text | center"></p><p><strong>父View与子View的DisplayList</strong></p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-03-07-rootview-childview-displaylist.png" alt="Alt text | center"></p><h4 id="（四）、RenderNode绘制"><a href="#（四）、RenderNode绘制" class="headerlink" title="（四）、RenderNode绘制"></a>（四）、RenderNode绘制</h4><p>在ThreadedRenderer的draw()函数中构建完DisplayList后，接下来需要准备渲染了。首先通过JNI调用nSyncAndDrawFrame()调用到native层的android_view_ThreadedRenderer_syncAndDrawFrame()。其中将参数中的FrameInfo数组传到RenderProxy的mFrameInfo成员中。它是Android M开始加入用来细化hwui性能统计的。同时调用RenderProxy的syncAndDrawFrame()函数，并将创建的TreeObserver作为参数。函数syncAndDrawFrame()中即调用DrawFrameTask（这是RenderThread的TaskQueue中的特殊Task实例）的drawFrame()函数。继而通过postAndWait()往RenderThread的TaskQueue里插入自身（即DrawFrameTask）来申请新一帧的渲染。在RenderThread的queue()函数中会按Task的运行时间将之插入到适当的位置。接着postAndWait()函数中会block UI线程等待渲染线程将之unblock。渲染线程在N中的改动不大，这里就不花太多文字介绍了，需要的时候把它当作跨线程调用即可。</p><p>另一边，渲染线程处理这个DrawFrameTask时会调用到其run()函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\libs\hwui\renderthread\DrawFrameTask.cpp]</span><br><span class="line"><span class="keyword">void</span> DrawFrameTask::run() &#123;</span><br><span class="line">    ATRACE_NAME(<span class="string">"DrawFrame"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> canUnblockUiThread;</span><br><span class="line">    <span class="keyword">bool</span> canDrawThisFrame;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">TreeInfo <span class="title">info</span><span class="params">(TreeInfo::MODE_FULL, *mContext)</span></span>;</span><br><span class="line">        info.observer = mObserver;</span><br><span class="line">        canUnblockUiThread = syncFrameState(info);</span><br><span class="line">        canDrawThisFrame = info.out.canDrawThisFrame;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Grab a copy of everything we need</span></span><br><span class="line">    CanvasContext* context = mContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// From this point on anything in "this" is *UNSAFE TO ACCESS*</span></span><br><span class="line">    <span class="keyword">if</span> (canUnblockUiThread) &#123;</span><br><span class="line">        unblockUiThread();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CC_LIKELY(canDrawThisFrame)) &#123;</span><br><span class="line">        context-&gt;draw();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// wait on fences so tasks don't overlap next frame</span></span><br><span class="line">        context-&gt;waitOnFences();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!canUnblockUiThread) &#123;</span><br><span class="line">        unblockUiThread();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中首先通过DrawFrameTask::syncFrameState()函数将主线程的渲染信息（如DisplayList，Property和Bitmap等）同步到渲染线程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">syncFrameState()</span><br><span class="line">  -&gt; eglMakeCurrent </span><br><span class="line">    -&gt; eglMakeCurrent(OEM EGL) </span><br><span class="line">      -&gt; <span class="keyword">egl_window_surface_v2_t</span>::connect()</span><br><span class="line">      -&gt; Surface::hook_dequeueBuffer() </span><br><span class="line">        -&gt; Surface::dequeueBuffer() </span><br><span class="line">            -&gt; BpGraphicBufferProducer::dequeueBuffer()</span><br><span class="line">            -&gt; BpGraphicBufferProducer::requestBuffer()</span><br></pre></td></tr></table></figure><p>这个函数中首先会处理DrawFrameTask中的mLayers。它是DeferredLayerUpdater的vector，顾名思义，就是延迟处理的layer更新任务。这主要用于TextureView。TextureView是比较特殊的类。它通常用于显示内容流，生产者端可以是另一个进程。中间通过BufferQueue进行buffer的传输和交换。当有新的buffer来到（或者有属性变化，如visibility等）是，会通过回调设置标志位(mUpdateLayer)并通过invalidate()调度下一次重绘。当下一次draw()被调用时，先通过applyUpdate()-&gt;updateSurfaceTexture()-&gt;ThreadedRenderer::pushLayerUpdate()，再调到渲染线程中的 DrawFrameTask::pushLayerUpdate()，将本次更新记录在DrawFrameTask的mLayers中。这样，在后面调用DrawFrameTask::syncFrameState()是会依次调用mLayers中的apply()进行真正的更新。这里调用它的apply()函数就会取新可用buffer（通过doUpdateTexImage()函数），并将相关纹理信息更新到mLayer。在syncFrameState()函数中，接下来，通过CanvasContext的prepareTree()继而调用RenderNode的prepareTree()同步渲染信息。最后会输出TreeInfo结构，其中的prepareTextures代表纹理上传是否成功。如果为false，说明texture cache用完了。这样为了防止渲染线程在渲染过程中使用的资源和主线程竞争，在渲染线程绘制当前帧时就不能让主线程继续往下跑了，也就不能做到真正并行。在sync完数据后，DrawFrameTask::run()最后会调用CanvasContext::draw()来进行接下来的渲染。这部分的大体流程如下：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-03-08-ThreadRender-draw.png" alt="Alt text | center"></p><p>接下来瞄下CanvasContext::draw()里做了什么。先要小小准备下EGL环境，比如通过EglManager的beginFrame()函数，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">beginFrame()</span><br><span class="line">  -&gt; eglMakeCurrent </span><br><span class="line">    -&gt; eglMakeCurrent(OEM EGL) </span><br><span class="line">      -&gt; Surface::hook_dequeueBuffer() </span><br><span class="line">        -&gt; Surface::dequeueBuffer() </span><br><span class="line">            -&gt; BpGraphicBufferProducer::dequeueBuffer()</span><br><span class="line">            -&gt; BpGraphicBufferProducer::requestBuffer()</span><br><span class="line"></span><br><span class="line">[-&gt;\frameworks\native\opengl\libagl\egl.cpp]</span><br><span class="line">Frame EglManager::beginFrame(EGLSurface surface) &#123;</span><br><span class="line">    .....</span><br><span class="line">    makeCurrent(surface);</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> EglManager::makeCurrent(EGLSurface surface, EGLint* errOut) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!eglMakeCurrent(mEglDisplay, surface, surface, mEglContext)) &#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">EGLBoolean <span class="title">eglMakeCurrent</span><span class="params">(  EGLDisplay dpy, EGLSurface draw,</span></span></span><br><span class="line"><span class="function"><span class="params">                            EGLSurface read, EGLContext ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ctx == EGL_NO_CONTEXT) &#123;</span><br><span class="line">        <span class="comment">// if we're detaching, we need the current context</span></span><br><span class="line">        current_ctx = (EGLContext)getGlThreadSpecific();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">egl_surface_t</span>* d = (<span class="keyword">egl_surface_t</span>*)draw;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (d) &#123;</span><br><span class="line">        <span class="keyword">if</span> (d-&gt;connect() == EGL_FALSE) &#123;</span><br><span class="line">            <span class="keyword">return</span> EGL_FALSE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setError(EGL_BAD_ACCESS, EGL_FALSE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EGLBoolean <span class="keyword">egl_window_surface_v2_t</span>::connect()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dequeue a buffer</span></span><br><span class="line">    <span class="keyword">int</span> fenceFd = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (nativeWindow-&gt;dequeueBuffer(nativeWindow, &amp;buffer,</span><br><span class="line">            &amp;fenceFd) != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_ALLOC, EGL_FALSE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait for the buffer</span></span><br><span class="line">    sp&lt;Fence&gt; fence(<span class="keyword">new</span> Fence(fenceFd));</span><br><span class="line">    <span class="keyword">if</span> (fence-&gt;wait(Fence::TIMEOUT_NEVER) != NO_ERROR) &#123;</span><br><span class="line">        nativeWindow-&gt;cancelBuffer(nativeWindow, buffer, fenceFd);</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_ALLOC, EGL_FALSE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EGL_TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继而用eglMakeCurrent()将渲染context切换到相应的surface。然后EglManager的damageFrame()设定当前帧的脏区域（如果gfx平台支持局部更新的话）。接下来就是绘制的主体部分了。这也是N中改动比较大的部分。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\libs\hwui\renderthread\CanvasContext.cpp]</span><br><span class="line"><span class="keyword">void</span> CanvasContext::draw() &#123;</span><br><span class="line">    SkRect dirty;</span><br><span class="line">    mDamageAccumulator.finish(&amp;dirty);</span><br><span class="line"></span><br><span class="line">    mCurrentFrameInfo-&gt;markIssueDrawCommandsStart();</span><br><span class="line"></span><br><span class="line">    Frame frame = mEglManager.beginFrame(mEglSurface);</span><br><span class="line">    ......</span><br><span class="line">    <span class="function">SkRect <span class="title">screenDirty</span><span class="params">(dirty)</span></span>;</span><br><span class="line">    ......</span><br><span class="line">    mEglManager.damageFrame(frame, dirty);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> HWUI_NEW_OPS</span></span><br><span class="line">    <span class="keyword">auto</span>&amp; caches = Caches::getInstance();</span><br><span class="line">    FrameBuilder frameBuilder(dirty, frame.width(), frame.height(), mLightGeometry, caches);</span><br><span class="line"></span><br><span class="line">    frameBuilder.deferLayers(mLayerUpdateQueue);</span><br><span class="line">    mLayerUpdateQueue.clear();</span><br><span class="line"></span><br><span class="line">    frameBuilder.deferRenderNodeScene(mRenderNodes, mContentDrawBounds);</span><br><span class="line"></span><br><span class="line">    BakedOpRenderer renderer(caches, mRenderThread.renderState(),</span><br><span class="line">            mOpaque, mLightInfo);</span><br><span class="line">    frameBuilder.replayBakedOps&lt;BakedOpDispatcher&gt;(renderer);</span><br><span class="line">    profiler().draw(&amp;renderer);</span><br><span class="line">    <span class="keyword">bool</span> drew = renderer.didDraw();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// post frame cleanup</span></span><br><span class="line">    caches.clearGarbage();</span><br><span class="line">    caches.pathCache.trim();</span><br><span class="line">    caches.tessellationCache.trim();</span><br><span class="line">    ......</span><br><span class="line">    mCanvas-&gt;prepareDirty(frame.width(), frame.height(),</span><br><span class="line">            dirty.fLeft, dirty.fTop, dirty.fRight, dirty.fBottom, mOpaque);</span><br><span class="line"></span><br><span class="line">    Rect outBounds;</span><br><span class="line">    <span class="comment">// It there are multiple render nodes, they are laid out as follows:</span></span><br><span class="line">    <span class="comment">// #0 - backdrop (content + caption)</span></span><br><span class="line">    <span class="comment">// #1 - content (positioned at (0,0) and clipped to - its bounds mContentDrawBounds)</span></span><br><span class="line">    <span class="comment">// #2 - additional overlay nodes</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// Draw all render nodes. Note that</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> sp&lt;RenderNode&gt;&amp; node : mRenderNodes) &#123;</span><br><span class="line">        <span class="keyword">if</span> (layer == <span class="number">0</span>) &#123; <span class="comment">// Backdrop.</span></span><br><span class="line">            .......</span><br><span class="line">            <span class="comment">// Check if we have to draw something on the left side ...</span></span><br><span class="line">            <span class="keyword">if</span> (targetBounds.left &lt; contentBounds.left) &#123;</span><br><span class="line">                mCanvas-&gt;save(SaveFlags::Clip);</span><br><span class="line">                <span class="keyword">if</span> (mCanvas-&gt;clipRect(targetBounds.left, targetBounds.top,</span><br><span class="line">                                      contentBounds.left, targetBounds.bottom,</span><br><span class="line">                                      SkRegion::kIntersect_Op)) &#123;</span><br><span class="line">                    mCanvas-&gt;drawRenderNode(node.get(), outBounds);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Reduce the target area by the area we have just painted.</span></span><br><span class="line">                targetBounds.left = <span class="built_in">std</span>::min(contentBounds.left, targetBounds.right);</span><br><span class="line">                mCanvas-&gt;restore();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// ... or on the right side ...</span></span><br><span class="line">            <span class="comment">// ... or at the top ...</span></span><br><span class="line">            <span class="comment">// ... or at the bottom.</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (layer == <span class="number">1</span>) &#123; <span class="comment">// Content</span></span><br><span class="line">            <span class="comment">// It gets cropped against the bounds of the backdrop to stay inside.</span></span><br><span class="line">            mCanvas-&gt;save(SaveFlags::MatrixClip);</span><br><span class="line">            ......</span><br><span class="line">            mCanvas-&gt;translate(dx, dy);</span><br><span class="line">            <span class="keyword">if</span> (mCanvas-&gt;clipRect(left, top, left + width, top + height, SkRegion::kIntersect_Op)) &#123;</span><br><span class="line">                mCanvas-&gt;drawRenderNode(node.get(), outBounds);</span><br><span class="line">            &#125;</span><br><span class="line">            mCanvas-&gt;restore();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// draw the rest on top at will!</span></span><br><span class="line">            mCanvas-&gt;drawRenderNode(node.get(), outBounds);</span><br><span class="line">        &#125;</span><br><span class="line">        layer++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    profiler().draw(mCanvas);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> drew = mCanvas-&gt;finish();</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><p>先得到Caches的实例。它是一个单例类，包含了各种绘制资源的cache。然后创建FrameBuilder。该类用于当前帧的构建。FrameBuilder的构造函数中又会创建对应fbo0的LayerBuilder。fbo0即对应通过SurfaceFlinger申请来的on-screen surface，然后将之放入layer stack（通过mLayerBuilders和mLayerStack两个成员维护）。同时还会在initializeSaveStack()函数中创建和初始化Snapshot。就像名字一样，它保存了渲染surface的当前状态的一个“快照”。每个Snapshot有一个指向前继的Snapshot，从而形成一个”栈”。每次调用save()和restore()就相当于压栈和弹栈。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-03-09-frameBuilder.deferLayers.png" alt="Alt text | center"></p><p>接下来deferLayers()函数处理LayerUpdateQueue中的元素。之前在渲染线程每画一帧前同步信息时调用RenderNode::prepareTree()会遍历DisplayList的树形结构，对于子节点递归调用prepareTreeImpl()，如果是render layer，在RenderNode::pushLayerUpdate()中会将该layer的更新操作记录到LayerUpdateQueue中。至于哪些节点是render layer。主要是根据之前提到的view类型（LAYER_TYPE_NONE/SOFTWARE/HARDWARE）。但会有一个优化，如果一个普通view满足promotedToLayer()定义的条件，它会被当做render layer处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\libs\hwui\FrameBuilder.cpp]</span><br><span class="line"><span class="keyword">void</span> FrameBuilder::deferLayers(<span class="keyword">const</span> LayerUpdateQueue&amp; layers) &#123;</span><br><span class="line">    <span class="comment">// Render all layers to be updated, in order. Defer in reverse order, so that they'll be</span></span><br><span class="line">    <span class="comment">// updated in the order they're passed in (mLayerBuilders are issued to Renderer in reverse)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = layers.entries().size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        RenderNode* layerNode = layers.entries()[i].renderNode;</span><br><span class="line">        <span class="comment">// only schedule repaint if node still on layer - possible it may have been</span></span><br><span class="line">        <span class="comment">// removed during a dropped frame, but layers may still remain scheduled so</span></span><br><span class="line">        <span class="comment">// as not to lose info on what portion is damaged</span></span><br><span class="line">        OffscreenBuffer* layer = layerNode-&gt;getLayer();</span><br><span class="line">        <span class="keyword">if</span> (CC_LIKELY(layer)) &#123;</span><br><span class="line">            ATRACE_FORMAT(<span class="string">"Optimize HW Layer DisplayList %s %ux%u"</span>,</span><br><span class="line">                    layerNode-&gt;getName(), layerNode-&gt;getWidth(), layerNode-&gt;getHeight());</span><br><span class="line"></span><br><span class="line">            Rect layerDamage = layers.entries()[i].damage;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> ensure layer damage can't be larger than layer</span></span><br><span class="line">            layerDamage.doIntersect(<span class="number">0</span>, <span class="number">0</span>, layer-&gt;viewportWidth, layer-&gt;viewportHeight);</span><br><span class="line">            layerNode-&gt;computeOrdering();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// map current light center into RenderNode's coordinate space</span></span><br><span class="line">            Vector3 lightCenter = mCanvasState.currentSnapshot()-&gt;getRelativeLightCenter();</span><br><span class="line">            layer-&gt;inverseTransformInWindow.mapPoint3d(lightCenter);</span><br><span class="line"></span><br><span class="line">            saveForLayer(layerNode-&gt;getWidth(), layerNode-&gt;getHeight(), <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                    layerDamage, lightCenter, <span class="literal">nullptr</span>, layerNode);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (layerNode-&gt;getDisplayList()) &#123;</span><br><span class="line">                deferNodeOps(*layerNode);</span><br><span class="line">            &#125;</span><br><span class="line">            restoreForLayer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到deferLayers()函数。这里就是把LayerUpdateQueue里的元素按逆序拿出来，依次调用saveForLayer()，deferNodeOps()和restoreForLayer()。saveForLayer()为该render laye创建Snapshot和LayerBuilder并放进mLayerStack和mLayerBuilders。而restoreForLayer()则是它的逆操作。Layer stack和canvas state是栈的结构。saveForLayer() 和restoreForLayer()就相当于一个push stack，一个pop stack。这里核心的deferNodeOps()函数处理该layer对应的DisplayList，将它们按以下类型以batch的形式组织存放在LayerBuilder的mBatches成员中。其中同一类型中能合并的操作还会进行合并（目前只支持Bitmap, Text和Patch三种类型的操作合并）。Batch的类型有以下几种：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\libs\hwui\LayerBuilder.h]</span><br><span class="line"><span class="keyword">namespace</span> OpBatchType &#123;</span><br><span class="line">    <span class="keyword">enum</span> &#123;</span><br><span class="line">        Bitmap,</span><br><span class="line">        MergedPatch,</span><br><span class="line">        AlphaVertices,</span><br><span class="line">        Vertices,</span><br><span class="line">        AlphaMaskTexture,</span><br><span class="line">        Text,</span><br><span class="line">        ColorText,</span><br><span class="line">        Shadow,</span><br><span class="line">        TextureLayer,</span><br><span class="line">        Functor,</span><br><span class="line">        CopyToLayer,</span><br><span class="line">        CopyFromLayer,</span><br><span class="line"></span><br><span class="line">        Count <span class="comment">// must be last</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面看下deferNodeOps()函数里是怎么处理RenderNode的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\libs\hwui\FrameBuilder.cpp]</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Used to define a list of lambdas referencing private FrameBuilder::onXX::defer() methods.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This allows opIds embedded in the RecordedOps to be used for dispatching to these lambdas.</span></span><br><span class="line"><span class="comment"> * E.g. a BitmapOp op then would be dispatched to FrameBuilder::onBitmapOp(const BitmapOp&amp;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OP_RECEIVER(Type) \</span></span><br><span class="line">        [](FrameBuilder&amp; frameBuilder, <span class="keyword">const</span> RecordedOp&amp; op) &#123; frameBuilder.defer##Type(<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> Type&amp;&gt;(op)); &#125;,</span><br><span class="line"><span class="keyword">void</span> FrameBuilder::deferNodeOps(<span class="keyword">const</span> RenderNode&amp; renderNode) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*OpDispatcher)</span> <span class="params">(FrameBuilder&amp; frameBuilder, <span class="keyword">const</span> RecordedOp&amp; op)</span></span>;</span><br><span class="line">    <span class="keyword">static</span> OpDispatcher receivers[] = BUILD_DEFERRABLE_OP_LUT(OP_RECEIVER);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// can't be null, since DL=null node rejection happens before deferNodePropsAndOps</span></span><br><span class="line">    <span class="keyword">const</span> DisplayList&amp; displayList = *(renderNode.getDisplayList());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; chunk : displayList.getChunks()) &#123;</span><br><span class="line">        FatVector&lt;ZRenderNodeOpPair, <span class="number">16</span>&gt; zTranslatedNodes;</span><br><span class="line">        buildZSortedChildList(&amp;zTranslatedNodes, displayList, chunk);</span><br><span class="line"></span><br><span class="line">        defer3dChildren(chunk.reorderClip, ChildrenSelectMode::Negative, zTranslatedNodes);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> opIndex = chunk.beginOpIndex; opIndex &lt; chunk.endOpIndex; opIndex++) &#123;</span><br><span class="line">            <span class="keyword">const</span> RecordedOp* op = displayList.getOps()[opIndex];</span><br><span class="line">            receivers[op-&gt;opId](*<span class="keyword">this</span>, *op);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (CC_UNLIKELY(!renderNode.mProjectedNodes.empty()</span><br><span class="line">                    &amp;&amp; displayList.projectionReceiveIndex &gt;= <span class="number">0</span></span><br><span class="line">                    &amp;&amp; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(opIndex) == displayList.projectionReceiveIndex)) &#123;</span><br><span class="line">                deferProjectedChildren(renderNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        defer3dChildren(chunk.reorderClip, ChildrenSelectMode::Positive, zTranslatedNodes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DisplayList以chunk为单位组合RecordedOp。这些RecordedOp的opId代表它们的类型。根据这个类型调用receivers这个查找表（通过BUILD_DEFERABLE_OP_LUT构造）中的函数。它会调用FrameBuilder中相应的deferXXX函数（比如deferArcOp, deferBitmapOp, deferRenderNodeOp等）。这些deferXXX系函数一般会将RecordedOp用BakedOpState封装一下，然后会调用LayerBuilder的deferUnmergeableOp()和deferMergeableOp()函数将BakedOpState组织进mBatches成员。同时还有两个查找表mBatchLookup和mMergingBatchLookup分别用于不能合并的batch（OpBatch）和能合并的batch（MergingOpBatch）。它们分别用于查找特定类型的最近一个OpBatch或者MergingOpBatch。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-03-10-DisplayList-chunk.png" alt="Alt text | center"></p><p>先看下deferUnmergeableOp()函数。它会将BakedOpState按batch类型放进mBatches中。mBatches是指向BatchBase对象的vector，每个处理好的BakedOpState都会按类型放进来。如果还未有该类型的batch则创建OpBatch，并把它插入到mBatches的末尾。同时插入mBatchLookup这个查找表（batchId到最近一个该类型的OpBatch对象的映射）。这样之后处理同类型的BakedOpState时候，就会先搜索这个查找表。假如找到了，则进一步在mBatches数组中找到相应的OpBatch并通过它的batchOp()将该BakedOpState加入。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\libs\hwui\LayerBuilder.cpp]</span><br><span class="line"><span class="keyword">void</span> LayerBuilder::deferUnmergeableOp(LinearAllocator&amp; allocator,</span><br><span class="line">        BakedOpState* op, <span class="keyword">batchid_t</span> batchId) &#123;</span><br><span class="line">    onDeferOp(allocator, op);</span><br><span class="line">    OpBatch* targetBatch = mBatchLookup[batchId];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> insertBatchIndex = mBatches.size();</span><br><span class="line">    <span class="keyword">if</span> (targetBatch) &#123;</span><br><span class="line">        locateInsertIndex(batchId, op-&gt;computedState.clippedBounds,</span><br><span class="line">                (BatchBase**)(&amp;targetBatch), &amp;insertBatchIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (targetBatch) &#123;</span><br><span class="line">        targetBatch-&gt;batchOp(op);</span><br><span class="line">    &#125; <span class="keyword">else</span>  &#123;</span><br><span class="line">        <span class="comment">// new non-merging batch</span></span><br><span class="line">        targetBatch = allocator.create&lt;OpBatch&gt;(batchId, op);</span><br><span class="line">        mBatchLookup[batchId] = targetBatch;</span><br><span class="line">        mBatches.insert(mBatches.begin() + insertBatchIndex, targetBatch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来看用于合并操作的deferMergeableOp()函数。它也是类似的，当没有可以合并的MergingOpBatch时会创建新的，并且插入到mBatches。因为可能存在情况这个batchId在mBatches中有但是mMergingBatchLookup中没找到（说明还没有可合并的MergingOpBatch对象）或者通过MergingOpBatch::canMergeWidth()判断不满足合并条件。这时候就要插入到mBatches中该类型所在位置。如果很顺利的情况下，前面已经有MergingOpBatch在mMergingBatchLookup中而且又满足合并条件，就通过MergingOpBatch::mergeOp()将该BakedOpState和已有的进行合并。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\libs\hwui\LayerBuilder.cpp]</span><br><span class="line"><span class="keyword">void</span> LayerBuilder::deferMergeableOp(LinearAllocator&amp; allocator,</span><br><span class="line">        BakedOpState* op, <span class="keyword">batchid_t</span> batchId, <span class="keyword">mergeid_t</span> mergeId) &#123;</span><br><span class="line">    onDeferOp(allocator, op);</span><br><span class="line">    MergingOpBatch* targetBatch = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Try to merge with any existing batch with same mergeId</span></span><br><span class="line">    <span class="keyword">auto</span> getResult = mMergingBatchLookup[batchId].find(mergeId);</span><br><span class="line">    <span class="keyword">if</span> (getResult != mMergingBatchLookup[batchId].end()) &#123;</span><br><span class="line">        targetBatch = getResult-&gt;second;</span><br><span class="line">        <span class="keyword">if</span> (!targetBatch-&gt;canMergeWith(op)) &#123;</span><br><span class="line">            targetBatch = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> insertBatchIndex = mBatches.size();</span><br><span class="line">    locateInsertIndex(batchId, op-&gt;computedState.clippedBounds,</span><br><span class="line">            (BatchBase**)(&amp;targetBatch), &amp;insertBatchIndex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (targetBatch) &#123;</span><br><span class="line">        targetBatch-&gt;mergeOp(op);</span><br><span class="line">    &#125; <span class="keyword">else</span>  &#123;</span><br><span class="line">        <span class="comment">// new merging batch</span></span><br><span class="line">        targetBatch = allocator.create&lt;MergingOpBatch&gt;(batchId, op);</span><br><span class="line">        mMergingBatchLookup[batchId].insert(<span class="built_in">std</span>::make_pair(mergeId, targetBatch));</span><br><span class="line"></span><br><span class="line">        mBatches.insert(mBatches.begin() + insertBatchIndex, targetBatch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>回到CanvasContext::draw()函数，处理好layer后，下面得就是通过FrameBuilder::deferRenderNodeScene()函数处理FrameBuilder成员mRenderNodes中的RenderNode，其中包含了RootRenderNode（也可能有其它的RenderNode，比如backdrop和overlay nodes）。对于每个RenderNode，如果需要绘制则调用FrameBuilder的deferRenderNode()函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\libs\hwui\FrameBuilder.cpp]</span><br><span class="line"><span class="keyword">void</span> FrameBuilder::deferRenderNode(RenderNode&amp; renderNode) &#123;</span><br><span class="line">    renderNode.computeOrdering();</span><br><span class="line"></span><br><span class="line">    mCanvasState.save(SaveFlags::MatrixClip);</span><br><span class="line">    deferNodePropsAndOps(renderNode);</span><br><span class="line">    mCanvasState.restore();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里和前面类似，会为之创建独立的Snapshot（Canvas渲染状态），deferNodePropsAndOps()根据RenderNode中的RenderProperties通过CanvasState设置一堆状态。如果该RenderNode对应是一个render layer，则将它封装为LayerOp（绘制offscreen buffer）并通过deferUnmergeableOp()加入batch。如果该RenderNode对应RenderProperties有半透明效果且不是render layer，则可以将该RenderNode绘制到一个临时的layer（称为save layer）。这是通过BeginLayerOp和EndLayerOp来记录的。正常情况下，还是通过deferNodeOps()来将RenderNode进行batch/merge。这个函数前面已有说明。</p><p>再次回到CanvasContext::draw()函数，下面终于要真得进行渲染了。首先创建BakedOpRenderer，然后调用FrameBuilder::replayBakedOps()函数并将BakedOpRenderer作为参数传进去。注意这是个模板函数，这里模板参数为BakedOpDispatcher。在replayBakedOps()函数中会构造两个用于处理BakedOpState的函数查找表。它们将BakedOpState按操作类型分发到BakedOpDispatcher的相应静态处理函数（onXXX或者onMergedXXX，分别用于非合并和合并的操作） 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\libs\hwui\FrameBuilder.h]</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> StaticDispatcher, <span class="keyword">typename</span> Renderer&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">replayBakedOps</span><span class="params">(Renderer&amp; renderer)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;OffscreenBuffer*&gt; temporaryLayers;</span><br><span class="line">        finishDefer();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Defines a LUT of lambdas which allow a recorded BakedOpState to use state-&gt;op-&gt;opId to</span></span><br><span class="line"><span class="comment">         * dispatch the op via a method on a static dispatcher when the op is replayed.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * For example a BitmapOp would resolve, via the lambda lookup, to calling:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * StaticDispatcher::onBitmapOp(Renderer&amp; renderer, const BitmapOp&amp; op, const BakedOpState&amp; state);</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> X(Type) \</span></span><br><span class="line">                [](<span class="keyword">void</span>* renderer, <span class="keyword">const</span> BakedOpState&amp; state) &#123; \</span><br><span class="line">                    StaticDispatcher::on##Type(*(<span class="keyword">static_cast</span>&lt;Renderer*&gt;(renderer)), \</span><br><span class="line">                            <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> Type&amp;&gt;(*(state.op)), state); \</span><br><span class="line">                &#125;,</span><br><span class="line">        <span class="keyword">static</span> BakedOpReceiver unmergedReceivers[] = BUILD_RENDERABLE_OP_LUT(X);</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">undef</span> X</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Defines a LUT of lambdas which allow merged arrays of BakedOpState* to be passed to a</span></span><br><span class="line"><span class="comment">         * static dispatcher when the group of merged ops is replayed.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> X(Type) \</span></span><br><span class="line">                [](<span class="keyword">void</span>* renderer, <span class="keyword">const</span> MergedBakedOpList&amp; opList) &#123; \</span><br><span class="line">                    StaticDispatcher::onMerged##Type#<span class="meta">#s(*(static_cast<span class="meta-string">&lt;Renderer*&gt;(renderer)), opList); \</span></span></span><br><span class="line">                &#125;,</span><br><span class="line">        <span class="keyword">static</span> MergedOpReceiver mergedReceivers[] = BUILD_MERGEABLE_OP_LUT(X);</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">undef</span> X</span></span><br></pre></td></tr></table></figure><p> 如前面如述，之前已经在FrameBuilder中构造了LayerBuilder的stack。接下来，这儿就是按push时的逆序（z-order高到底）对其中的BakedOpState进行replay，因为下面的layer可能会依赖的上面layer的渲染结果。比如要把上面layer画在FBO上的东西当成纹理画到下一层layer上。对于layer（persistent或者temporary的），先在BakedOpRenderer::startRepaintLayer()中初始化相关GL环境，比如创建FBO，绑定layer对应OffscreenBuffer中的纹理，设置viewport，清color buffer等等。对应地，BakedOpRenderer::endLayer()中最相应的销毁和清理工作。中间调用LayerBuilder::replayBakedOpsImpl()函数做真正的replay动作。对于fbo0（即on-screen surface），也是类似的，只是把startRepaintLayer()和endLayer()换成BakedOpRenderer::startFrame()和BakedOpRenderer::endFrame()。它们的功能也是初始化和销毁GL环境。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\libs\hwui\FrameBuilder.h]</span><br><span class="line">template &lt;typename StaticDispatcher, typename Renderer&gt;</span><br><span class="line">    void replayBakedOps(Renderer&amp; renderer) &#123;</span><br><span class="line">        .....</span><br><span class="line">       // Relay through layers in reverse order, since layers</span><br><span class="line">        // later in the list will be drawn by earlier ones</span><br><span class="line">        for (int i = mLayerBuilders.size() - 1; i &gt;= 1; i--) &#123;</span><br><span class="line">            GL_CHECKPOINT(MODERATE);</span><br><span class="line">            LayerBuilder&amp; layer = *(mLayerBuilders[i]);</span><br><span class="line">            if (layer.renderNode) &#123;</span><br><span class="line">                // cached HW layer - can&apos;t skip layer if empty</span><br><span class="line">                renderer.startRepaintLayer(layer.offscreenBuffer, layer.repaintRect);</span><br><span class="line">                GL_CHECKPOINT(MODERATE);</span><br><span class="line">                layer.replayBakedOpsImpl((void*)&amp;renderer, unmergedReceivers, mergedReceivers);</span><br><span class="line">                GL_CHECKPOINT(MODERATE);</span><br><span class="line">                renderer.endLayer();</span><br><span class="line">            &#125; else if (!layer.empty()) &#123;</span><br><span class="line">                // save layer - skip entire layer if empty (in which case, LayerOp has null layer).</span><br><span class="line">                layer.offscreenBuffer = renderer.startTemporaryLayer(layer.width, layer.height);</span><br><span class="line">                temporaryLayers.push_back(layer.offscreenBuffer);</span><br><span class="line">                GL_CHECKPOINT(MODERATE);</span><br><span class="line">                layer.replayBakedOpsImpl((void*)&amp;renderer, unmergedReceivers, mergedReceivers);</span><br><span class="line">                GL_CHECKPOINT(MODERATE);</span><br><span class="line">                renderer.endLayer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        GL_CHECKPOINT(MODERATE);</span><br><span class="line">        if (CC_LIKELY(mDrawFbo0)) &#123;</span><br><span class="line">            const LayerBuilder&amp; fbo0 = *(mLayerBuilders[0]);</span><br><span class="line">            renderer.startFrame(fbo0.width, fbo0.height, fbo0.repaintRect);</span><br><span class="line">            GL_CHECKPOINT(MODERATE);</span><br><span class="line">            fbo0.replayBakedOpsImpl((void*)&amp;renderer, unmergedReceivers, mergedReceivers);</span><br><span class="line">            GL_CHECKPOINT(MODERATE);</span><br><span class="line">            renderer.endFrame(fbo0.repaintRect);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (auto&amp; temporaryLayer : temporaryLayers) &#123;</span><br><span class="line">            renderer.recycleTemporaryLayer(temporaryLayer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在replayBakedOpsImpl()函数中，会根据操作的类型调用前面生成的unmergedReceivers和mergedReceivers两个函数分发表中的对应处理函数。它们实质指向BakedOpDispatcher中的静态函数。这些函数onXXXOp()和onMergedXXXOps()函数大同小异，基本都是通过GlopBuilder将BakedOpState和相关的信息封装成Glop对象，然后调用BakedOpRenderer::renderGlop()，接着通过DefaultGlopReceiver()调用BakedOpRenderer::renderGlopImpl()函数，最后在RenderState::render()中通过GL命令将Glop渲染出来。大功告成。</p><p><strong>结语</strong><br>合并之后，DeferredDisplayList Vector<batch *=""> mBatches 包含全部整合后的绘制命令，之后渲染即可，需要注意的是这里的合并并不是多个变一个，只是做了一个集合，主要是方便使用各资源纹理等，比如绘制文字的时候，需要根据文字的纹理进行渲染，而这个时候就需要查询文字的纹理坐标系，合并到一起方便统一处理，一次渲染，减少资源加载的浪费，当然对于理解硬件加速的整体流程，这个合并操作可以完全无视，甚至可以直观认为，构建完之后，就可以直接渲染，它的主要特点是在另一个Render线程使用OpenGL进行绘制，这个是它最重要的特点。而mBatches中所有的DrawOp都会通过OpenGL被绘制到GraphicBuffer中，最后通过swapBuffers函数调用queueBuffer()通知SurfaceFlinger合成。</batch></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\native\opengl\libagl\egl.cpp]</span><br><span class="line">EGLBoolean egl_window_surface_v2_t::swapBuffers()</span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">nativeWindow-&gt;queueBuffer(nativeWindow, buffer); </span><br><span class="line">nativeWindow-&gt;dequeueBuffer(nativeWindow, &amp;buffer);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来说，可以看到一个View上的东西要绘制出来，要经过多步的转化。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-03-11-View-draw-Surface.png" alt="Alt text | center"></p><p>这样做有几个好处：第一、对绘制操作进行batch/merge可以减少GL的draw call，从而减少渲染状态切换，提高了性能。第二、因为将View层次结构要绘制的东西转化为DisplayList这种“中间语言”的形式，当需要绘制时才转化为GL命令。因此在View中内容没有更改或只有部分属性更改时只要修改中间表示（即RenderNode和RenderProperties）即可，从而避免很多重复劳动。第三、由于DisplayList中包含了要绘制的所有信息，一些属性动画可以由渲染线程全权处理，无需主线程介入，主线程卡住也不会让界面卡住。另一方面，也可以看到一些潜力可挖。比如当前可以合并的操作类型有限。另外主线程和渲染线程间的很多调用还是同步的，并行度或许可以进一步提高。另外Vulkan的引入也可以帮助进一步榨干GPU的能力。<br><strong>例如：</strong></p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-03-12-one_button_draw.png" alt="Alt text | center"></p><p>绘制的批次按文本、图片资源、几何图形等进行分类，分批绘制的效果如下图所示:</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-03-13-BakedOpDispatcher-onMergedBitmapOps.gif" alt="Alt text | center"></p><h4 id="（五）、参考资料-特别感谢各位前辈的分析和图示-："><a href="#（五）、参考资料-特别感谢各位前辈的分析和图示-：" class="headerlink" title="（五）、参考资料(特别感谢各位前辈的分析和图示)："></a>（五）、参考资料(特别感谢各位前辈的分析和图示)：</h4><p><a href="https://blog.csdn.net/jinzhuojun/article/details/54234354" target="_blank" rel="noopener">Android N中UI硬件渲染（hwui）的HWUI_NEW_OPS(基于Android 7.1) </a><br><a href="https://blog.csdn.net/luoshengyang/article/details/45601143" target="_blank" rel="noopener">Android应用程序UI硬件加速渲染技术简要介绍和学习计划</a><br><a href="https://blog.csdn.net/jinzhuojun/article/details/54234354" target="_blank" rel="noopener">【特别感谢 - Android N中UI硬件渲染（hwui）的HWUI_NEW_OPS(基于Android 7.1)】</a><br><a href="https://www.jianshu.com/p/7bf306c09c7e" target="_blank" rel="noopener">Android DisplayList 构建过程</a><br><a href="http://www.androidperformance.com/2015/08/12/AndroidL-hwui-RenderThread-workflow/" target="_blank" rel="noopener">Android5.0中 hwui 中 RenderThread 工作流程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;amp;&amp;amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内
      
    
    </summary>
    
      <category term="Android" scheme="http://zhoujinjian.cc/categories/Android/"/>
    
    
      <category term="Android" scheme="http://zhoujinjian.cc/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android Display System（2）：Android Display System 系统分析之Android EGL &amp;&amp; OpenGL</title>
    <link href="http://zhoujinjian.cc/2018/07/20/Android%20Display%20System%EF%BC%882%EF%BC%89%EF%BC%9AAndroid%20Display%20System%20%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B9%8BAndroid%20EGL%20&amp;&amp;%20OpenGL/"/>
    <id>http://zhoujinjian.cc/2018/07/20/Android Display System（2）：Android Display System 系统分析之Android EGL &amp;&amp; OpenGL/</id>
    <published>2018-07-19T16:00:00.000Z</published>
    <updated>2018-06-20T15:11:14.394Z</updated>
    
    <content type="html"><![CDATA[<hr><p>注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;&amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除，禁止转载（©Qualcomm Technologies, Inc. 版权所有），谢谢。</p><p><a href="https://github.com/izhoujinjian/zhoujinjian.cc/tree/master/display.system" target="_blank" rel="noopener">【博客原图链接】</a></p><p><a href="http://www.kandroid.org/board/data/board/conference/file_in_body/1/3AndroidGraphicsAndAndroidEGL.pdf" target="_blank" rel="noopener">【特别感谢 - Android Graphics and Android EGL】</a><br><a href="https://blog.csdn.net/jinzhuojun/article/details/17427491" target="_blank" rel="noopener">【特别感谢 - Android 4.4 (KitKat) Design Pattern-Graphics Subsystem】</a><br><a href="https://blog.csdn.net/jinzhuojun/article/details/17293325" target="_blank" rel="noopener">【特别感谢 - Android 4.4 (KitKat) in virtualization VSync signal】</a><br><a href="https://blog.csdn.net/yangwen123/article/details/22647255" target="_blank" rel="noopener">【特别感谢 - Android显示系统设计框架介绍】</a><br><a href="http://www.cnblogs.com/samchen2009/p/3367496.html" target="_blank" rel="noopener">【特别感谢 - 图解Android - Android GUI 系统 (2) - 窗口管理 (View, Canvas, Window Manager)】</a></p><p>Google Pixel、Pixel XL 内核代码（文章基于 Kernel-3.18）：<br> <a href="https://github.com/matthewdalex/marlin" target="_blank" rel="noopener">Kernel source for Pixel and Pixel XL - GitHub</a></p><p>AOSP 源码（文章基于 Android 7.1.2）：<br> <a href="https://testerhome.com/topics/2229" target="_blank" rel="noopener"> Android 系统全套源代码分享 (更新到 8.1.0_r1)</a></p><p> 🌀🌀：专注于Linux &amp;&amp; Android Multimedia（Camera、Video、Audio、Display）系统分析与研究</p><p>【Android Display System 系统分析系列】：<br>【Android Display System（1）：Android 7.1.2 (Android N) Android Graphics 系统 分析】<br>【Android Display System（2）：Android Display System 系统分析之Android EGL &amp;&amp; OpenGL】<br>【Android Display System（3）：Android Display System 系统分析之HardwareRenderer.draw()绘制流程分析】<br>【Android Display System（4）：Android Display System 系统分析之Gralloc &amp;&amp; HWComposer模块分析】<br>【Android Display System（5）：Android Display System 系统分析之Display Driver Architecture】</p><hr><blockquote><p><strong>Android EGL、GLES_CM、GLES2：</strong></p></blockquote><p>\frameworks\native\opengl\libs\EGL</p><ul><li>egl.cpp</li><li>egl_display.cpp</li><li>eglApi.cpp</li><li>Loader.cpp</li></ul><p>\frameworks\native\opengl\libs\GLES_CM</p><ul><li>gl.cpp</li><li>gl_api.in</li><li>glext_api.in</li></ul><p>\frameworks\native\opengl\libs\GLES2</p><ul><li>gl2.cpp</li><li>gl2_api.in</li><li>gl2ext_api.in</li></ul><blockquote><p><strong>OpenGL Native &amp;&amp; JNI ：</strong></p></blockquote><p>\frameworks\base\core\jni\</p><ul><li>android_opengl_GLES10.cpp</li><li>android_opengl_GLES10Ext.cpp</li><li>android_opengl_GLES11.cpp</li><li>android_opengl_GLES11Ext.cpp</li><li>android_opengl_GLES20.cpp</li><li>android_opengl_GLES30.cpp</li><li>android_opengl_GLES31.cpp</li><li>android_opengl_GLES31Ext.cpp</li><li>android_opengl_GLES32.cpp</li><li>com_google_android_gles_jni_EGLImpl.cpp</li><li>com_google_android_gles_jni_GLImpl.cpp</li></ul><blockquote><p><strong>Opengl Java：</strong></p></blockquote><p>\frameworks\base\opengl\java\android\opengl</p><ul><li>GLES10.java</li><li>GLES10Ext.java</li><li>GLLogWrapper.java</li><li>GLSurfaceView.java</li><li>EGLDisplay.java</li><li>EGLConfig.java</li><li>EGLContext.java</li><li>EGLSurface.java</li></ul><p>\frameworks\base\opengl\java\javax\microedition\khronos\opengles</p><ul><li>GL10.java</li><li>GL11.java</li></ul><p>\frameworks\base\opengl\java\com\google\android\gles_jni</p><ul><li>GLImpl.java</li><li>EGLImpl.java</li><li>EGLConfigImpl.java</li><li>EGLContextImpl.java</li><li>EGLDisplayImpl.java</li></ul><hr><p>总体架构：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-02-01-Android-Graphics-Architecture-EGL.png" alt="Alt text | center"></p><p><a href="http://zhoujinjian.cc/2018/02/01/Android-7-1-2-Android-N-Android-Graphics-%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/">【Android Display System（1）- Android Graphics 系统 分析】</a></p><p>####（一）、 Android EGL 应用实例</p><h5 id="1-1、Android-Graphics-测试程序"><a href="#1-1、Android-Graphics-测试程序" class="headerlink" title="1.1、Android Graphics 测试程序"></a>1.1、Android Graphics 测试程序</h5><p>首先看一下Android测试程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line">参考\frameworks\native\services\surfaceflinger\tests\Transaction_test.cpp</span><br><span class="line">拷贝同目录下.mk文件push到手机运行即可看到效果。</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gtest/gtest.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;android/native_window.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;binder/IMemory.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gui/ISurfaceComposer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gui/Surface.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gui/SurfaceComposerClient.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;private/gui/ComposerService.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;private/gui/LayerState.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utils/String8.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ui/DisplayInfo.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> android &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fill an RGBA_8888 formatted surface with a single color.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fillSurfaceRGBA8</span><span class="params">(<span class="keyword">const</span> sp&lt;SurfaceControl&gt;&amp; sc,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">uint8_t</span> r, <span class="keyword">uint8_t</span> g, <span class="keyword">uint8_t</span> b)</span> </span>&#123;</span><br><span class="line">    ANativeWindow_Buffer outBuffer;</span><br><span class="line">    sp&lt;Surface&gt; s = sc-&gt;getSurface();</span><br><span class="line">    ASSERT_TRUE(s != <span class="literal">NULL</span>);</span><br><span class="line">    ASSERT_EQ(NO_ERROR, s-&gt;lock(&amp;outBuffer, <span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">uint8_t</span>* img = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint8_t</span>*&gt;(outBuffer.bits);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; outBuffer.height; y++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; outBuffer.width; x++) &#123;</span><br><span class="line">            <span class="keyword">uint8_t</span>* pixel = img + (<span class="number">4</span> * (y*outBuffer.stride + x));</span><br><span class="line">            pixel[<span class="number">0</span>] = r;</span><br><span class="line">            pixel[<span class="number">1</span>] = g;</span><br><span class="line">            pixel[<span class="number">2</span>] = b;</span><br><span class="line">            pixel[<span class="number">3</span>] = <span class="number">255</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ASSERT_EQ(NO_ERROR, s-&gt;unlockAndPost());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LayerTest</span> :</span> <span class="keyword">public</span> ::testing::Test &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mComposerClient = <span class="keyword">new</span> SurfaceComposerClient;</span><br><span class="line">        ASSERT_EQ(NO_ERROR, mComposerClient-&gt;initCheck());</span><br><span class="line"></span><br><span class="line">        sp&lt;IBinder&gt; display(SurfaceComposerClient::getBuiltInDisplay(</span><br><span class="line">                ISurfaceComposer::eDisplayIdMain));</span><br><span class="line">        DisplayInfo info;</span><br><span class="line">        SurfaceComposerClient::getDisplayInfo(display, &amp;info);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">ssize_t</span> displayWidth = info.w;</span><br><span class="line">        <span class="keyword">ssize_t</span> displayHeight = info.h;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Background surface black</span></span><br><span class="line">        mBGSurfaceControl = mComposerClient-&gt;createSurface(</span><br><span class="line">                String8(<span class="string">"BG Test Surface"</span>), displayWidth, displayHeight<span class="number">-720</span>,</span><br><span class="line">                PIXEL_FORMAT_RGBA_8888, <span class="number">0</span>);</span><br><span class="line">        ASSERT_TRUE(mBGSurfaceControl != <span class="literal">NULL</span>);</span><br><span class="line">        ASSERT_TRUE(mBGSurfaceControl-&gt;isValid());</span><br><span class="line">        fillSurfaceRGBA8(mBGSurfaceControl, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Foreground surface red</span></span><br><span class="line">        mFGSurfaceControl = mComposerClient-&gt;createSurface(</span><br><span class="line">                String8(<span class="string">"FG Test Surface"</span>), <span class="number">360</span>, <span class="number">360</span>, PIXEL_FORMAT_RGBA_8888, <span class="number">0</span>);</span><br><span class="line">        ASSERT_TRUE(mFGSurfaceControl != <span class="literal">NULL</span>);</span><br><span class="line">        ASSERT_TRUE(mFGSurfaceControl-&gt;isValid());</span><br><span class="line"></span><br><span class="line">        fillSurfaceRGBA8(mFGSurfaceControl, <span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Foreground surface blue</span></span><br><span class="line">        mFGSurfaceControlBlue = mComposerClient-&gt;createSurface(</span><br><span class="line">                String8(<span class="string">"FG Test Surface"</span>), <span class="number">360</span>, <span class="number">360</span>, PIXEL_FORMAT_RGBA_8888, <span class="number">0</span>);</span><br><span class="line">        ASSERT_TRUE(mFGSurfaceControlBlue != <span class="literal">NULL</span>);</span><br><span class="line">        ASSERT_TRUE(mFGSurfaceControlBlue-&gt;isValid());</span><br><span class="line"></span><br><span class="line">        fillSurfaceRGBA8(mFGSurfaceControl, <span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Foreground surface green</span></span><br><span class="line">        mFGSurfaceControlGreen = mComposerClient-&gt;createSurface(</span><br><span class="line">                String8(<span class="string">"FG Test Surface"</span>), <span class="number">360</span>, <span class="number">360</span>, PIXEL_FORMAT_RGBA_8888, <span class="number">0</span>);</span><br><span class="line">        ASSERT_TRUE(mFGSurfaceControlGreen != <span class="literal">NULL</span>);</span><br><span class="line">        ASSERT_TRUE(mFGSurfaceControlGreen-&gt;isValid());</span><br><span class="line"></span><br><span class="line">        fillSurfaceRGBA8(mFGSurfaceControl, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Synchronization surface</span></span><br><span class="line">        mSyncSurfaceControl = mComposerClient-&gt;createSurface(</span><br><span class="line">                String8(<span class="string">"Sync Test Surface"</span>), <span class="number">1</span>, <span class="number">1</span>, PIXEL_FORMAT_RGBA_8888, <span class="number">0</span>);</span><br><span class="line">        ASSERT_TRUE(mSyncSurfaceControl != <span class="literal">NULL</span>);</span><br><span class="line">        ASSERT_TRUE(mSyncSurfaceControl-&gt;isValid());</span><br><span class="line"></span><br><span class="line">        fillSurfaceRGBA8(mSyncSurfaceControl, <span class="number">31</span>, <span class="number">31</span>, <span class="number">31</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//SurfaceComposerClient::openGlobalTransaction()</span></span><br><span class="line"></span><br><span class="line">        SurfaceComposerClient::openGlobalTransaction();</span><br><span class="line"></span><br><span class="line">        mComposerClient-&gt;setDisplayLayerStack(display, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//black</span></span><br><span class="line">        ASSERT_EQ(NO_ERROR, mBGSurfaceControl-&gt;setLayer(INT_MAX<span class="number">-4</span>));</span><br><span class="line">        ASSERT_EQ(NO_ERROR, mBGSurfaceControl-&gt;show());</span><br><span class="line">        <span class="comment">//red</span></span><br><span class="line">        ASSERT_EQ(NO_ERROR, mFGSurfaceControl-&gt;setLayer(INT_MAX<span class="number">-3</span>));</span><br><span class="line">        ASSERT_EQ(NO_ERROR, mFGSurfaceControl-&gt;setPosition(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        ASSERT_EQ(NO_ERROR, mFGSurfaceControl-&gt;show());</span><br><span class="line"><span class="comment">//blue</span></span><br><span class="line">ASSERT_EQ(NO_ERROR, mFGSurfaceControlBlue-&gt;setLayer(INT_MAX<span class="number">-2</span>));</span><br><span class="line">        ASSERT_EQ(NO_ERROR, mFGSurfaceControlBlue-&gt;setPosition(<span class="number">360</span>, <span class="number">360</span>));</span><br><span class="line">        ASSERT_EQ(NO_ERROR, mFGSurfaceControlBlue-&gt;show());</span><br><span class="line"><span class="comment">//green</span></span><br><span class="line">ASSERT_EQ(NO_ERROR, mFGSurfaceControlGreen-&gt;setLayer(INT_MAX<span class="number">-1</span>));</span><br><span class="line">        ASSERT_EQ(NO_ERROR, mFGSurfaceControlGreen-&gt;setPosition(<span class="number">720</span>, <span class="number">720</span>));</span><br><span class="line">        ASSERT_EQ(NO_ERROR, mFGSurfaceControlGreen-&gt;show());</span><br><span class="line"></span><br><span class="line">        ASSERT_EQ(NO_ERROR, mSyncSurfaceControl-&gt;setLayer(INT_MAX<span class="number">-1</span>));</span><br><span class="line">        ASSERT_EQ(NO_ERROR, mSyncSurfaceControl-&gt;setPosition(displayWidth<span class="number">-2</span>,</span><br><span class="line">                displayHeight<span class="number">-2</span>));</span><br><span class="line">        ASSERT_EQ(NO_ERROR, mSyncSurfaceControl-&gt;show());</span><br><span class="line"></span><br><span class="line">        SurfaceComposerClient::closeGlobalTransaction(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">waitForPostedBuffers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">TearDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mComposerClient-&gt;dispose();</span><br><span class="line">        mBGSurfaceControl = <span class="number">0</span>;</span><br><span class="line">        mFGSurfaceControl = <span class="number">0</span>;</span><br><span class="line">        mSyncSurfaceControl = <span class="number">0</span>;</span><br><span class="line">        mComposerClient = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">waitForPostedBuffers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Since the sync surface is in synchronous mode (i.e. double buffered)</span></span><br><span class="line">        <span class="comment">// posting three buffers to it should ensure that at least two</span></span><br><span class="line">        <span class="comment">// SurfaceFlinger::handlePageFlip calls have been made, which should</span></span><br><span class="line">        <span class="comment">// guaranteed that a buffer posted to another Surface has been retired.</span></span><br><span class="line">        fillSurfaceRGBA8(mFGSurfaceControl, <span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        fillSurfaceRGBA8(mFGSurfaceControlBlue, <span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>);</span><br><span class="line">        fillSurfaceRGBA8(mFGSurfaceControlGreen, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">    fillSurfaceRGBA8(mSyncSurfaceControl, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;SurfaceComposerClient&gt; mComposerClient;</span><br><span class="line">    sp&lt;SurfaceControl&gt; mBGSurfaceControl;</span><br><span class="line">    sp&lt;SurfaceControl&gt; mFGSurfaceControl;<span class="comment">//red</span></span><br><span class="line">    sp&lt;SurfaceControl&gt; mFGSurfaceControlBlue;</span><br><span class="line">    sp&lt;SurfaceControl&gt; mFGSurfaceControlGreen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This surface is used to ensure that the buffers posted to</span></span><br><span class="line">    <span class="comment">// mFGSurfaceControl have been picked up by SurfaceFlinger.</span></span><br><span class="line">    sp&lt;SurfaceControl&gt; mSyncSurfaceControl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TEST_F(LayerTest, LayerWorks) &#123;</span><br><span class="line"></span><br><span class="line">    SurfaceComposerClient::openGlobalTransaction();</span><br><span class="line">    ASSERT_EQ(NO_ERROR, mFGSurfaceControl-&gt;setPosition(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    SurfaceComposerClient::closeGlobalTransaction(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">sp&lt;IBinder&gt; display(SurfaceComposerClient::getBuiltInDisplay(</span><br><span class="line">ISurfaceComposer::eDisplayIdMain));</span><br><span class="line">DisplayInfo info;</span><br><span class="line">SurfaceComposerClient::getDisplayInfo(display, &amp;info);</span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> displayWidth = info.w;</span><br><span class="line"><span class="keyword">ssize_t</span> displayHeight = info.h;</span><br><span class="line"></span><br><span class="line">SurfaceComposerClient::openGlobalTransaction();</span><br><span class="line"></span><br><span class="line">mComposerClient-&gt;setDisplayLayerStack(display, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">ASSERT_EQ(NO_ERROR, mBGSurfaceControl-&gt;setLayer(INT_MAX<span class="number">-4</span>));</span><br><span class="line">ASSERT_EQ(NO_ERROR, mBGSurfaceControl-&gt;show());</span><br><span class="line"><span class="comment">//red</span></span><br><span class="line">ASSERT_EQ(NO_ERROR, mFGSurfaceControl-&gt;setLayer(INT_MAX<span class="number">-3</span>));</span><br><span class="line">ASSERT_EQ(NO_ERROR, mFGSurfaceControl-&gt;setPosition(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">ASSERT_EQ(NO_ERROR, mFGSurfaceControl-&gt;show());</span><br><span class="line"><span class="comment">//blue</span></span><br><span class="line">ASSERT_EQ(NO_ERROR, mFGSurfaceControlBlue-&gt;setLayer(INT_MAX<span class="number">-2</span>));</span><br><span class="line">ASSERT_EQ(NO_ERROR, mFGSurfaceControlBlue-&gt;setPosition(<span class="number">360</span>, <span class="number">360</span>));</span><br><span class="line">ASSERT_EQ(NO_ERROR, mFGSurfaceControlBlue-&gt;show());</span><br><span class="line"><span class="comment">//green</span></span><br><span class="line">ASSERT_EQ(NO_ERROR, mFGSurfaceControlGreen-&gt;setLayer(INT_MAX<span class="number">-1</span>));</span><br><span class="line">ASSERT_EQ(NO_ERROR, mFGSurfaceControlGreen-&gt;setPosition(<span class="number">720</span>, <span class="number">720</span>));</span><br><span class="line">ASSERT_EQ(NO_ERROR, mFGSurfaceControlGreen-&gt;show());</span><br><span class="line"><span class="comment">//Sync</span></span><br><span class="line">ASSERT_EQ(NO_ERROR, mSyncSurfaceControl-&gt;setLayer(INT_MAX<span class="number">-1</span>));</span><br><span class="line">ASSERT_EQ(NO_ERROR, mSyncSurfaceControl-&gt;setPosition(displayWidth<span class="number">-2</span>,</span><br><span class="line">displayHeight<span class="number">-2</span>));</span><br><span class="line">ASSERT_EQ(NO_ERROR, mSyncSurfaceControl-&gt;show());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SurfaceComposerClient::closeGlobalTransaction(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现效果（保持运行，可以看到界面最顶层会绘制黑色背景和红绿蓝三个色块）：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-02-02-Android-graphics-surface-test.gif" alt="Alt text | center"></p><p>可以看到比较关键的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建SurfaceComposerClient</span></span><br><span class="line">mComposerClient = <span class="keyword">new</span> SurfaceComposerClient;</span><br><span class="line">ASSERT_EQ(NO_ERROR, mComposerClient-&gt;initCheck());</span><br><span class="line"><span class="comment">//获取display信息</span></span><br><span class="line">sp&lt;IBinder&gt; display(SurfaceComposerClient::getBuiltInDisplay(</span><br><span class="line">        ISurfaceComposer::eDisplayIdMain));</span><br><span class="line">DisplayInfo info;</span><br><span class="line">SurfaceComposerClient::getDisplayInfo(display, &amp;info);</span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> displayWidth = info.w;</span><br><span class="line"><span class="keyword">ssize_t</span> displayHeight = info.h;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Background surface black</span></span><br><span class="line"><span class="comment">//请求SurfaceFlinger创建Surface</span></span><br><span class="line">mBGSurfaceControl = mComposerClient-&gt;createSurface(</span><br><span class="line">        String8(<span class="string">"BG Test Surface"</span>), displayWidth, displayHeight<span class="number">-720</span>,</span><br><span class="line">        PIXEL_FORMAT_RGBA_8888, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//填充Surface</span></span><br><span class="line">fillSurfaceRGBA8(mBGSurfaceControl, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//设置Layer层级</span></span><br><span class="line">ASSERT_EQ(NO_ERROR, mBGSurfaceControl-&gt;setLayer(INT_MAX<span class="number">-4</span>));</span><br><span class="line"><span class="comment">//SurfaceControl-&gt;show()显示surface</span></span><br><span class="line">ASSERT_EQ(NO_ERROR, mBGSurfaceControl-&gt;show());</span><br></pre></td></tr></table></figure><p>这部分的分析请参考<a href="http://zhoujinjian.cc/2018/02/01/Android-7-1-2-Android-N-Android-Graphics-%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/">【Android Display System（1）- Android Graphics 系统 分析】</a><br>我们这里主要为了引出Android底层如何利用EGL绘图。</p><h5 id="1-2、Android-BootAnimation-开机动画-EGL在Android中应用"><a href="#1-2、Android-BootAnimation-开机动画-EGL在Android中应用" class="headerlink" title="1.2、Android BootAnimation 开机动画(EGL在Android中应用)"></a>1.2、Android BootAnimation 开机动画(EGL在Android中应用)</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-02-03-Android-boot-egl.png" alt="Alt text | center"></p><p>关键代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\cmds\bootanimation\BootAnimation.cpp]</span><br><span class="line"><span class="keyword">status_t</span> BootAnimation::readyToRun() &#123;</span><br><span class="line">    mAssets.addDefaultAssets();</span><br><span class="line">    sp&lt;IBinder&gt; dtoken(SurfaceComposerClient::getBuiltInDisplay(</span><br><span class="line">            ISurfaceComposer::eDisplayIdMain));</span><br><span class="line">    DisplayInfo dinfo;</span><br><span class="line">    <span class="keyword">status_t</span> status = SurfaceComposerClient::getDisplayInfo(dtoken, &amp;dinfo);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// create the native surface</span></span><br><span class="line">    sp&lt;SurfaceControl&gt; control = session()-&gt;createSurface(String8(<span class="string">"BootAnimation"</span>),</span><br><span class="line">            dinfo.w, dinfo.h, PIXEL_FORMAT_RGB_565);</span><br><span class="line"></span><br><span class="line">    SurfaceComposerClient::openGlobalTransaction();</span><br><span class="line">    control-&gt;setLayer(<span class="number">0x40000000</span>);</span><br><span class="line">    SurfaceComposerClient::closeGlobalTransaction();</span><br><span class="line"></span><br><span class="line">    sp&lt;Surface&gt; s = control-&gt;getSurface();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialize opengl and egl</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// (1)、获得 EGLDisplay 对象。</span></span><br><span class="line">    EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);</span><br><span class="line">    <span class="comment">// (2)、初始化 EGLDisplay 对象</span></span><br><span class="line">    eglInitialize(display, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// (3)、选择 EGLConfig</span></span><br><span class="line">    eglChooseConfig(display, attribs, &amp;config, <span class="number">1</span>, &amp;numConfigs);</span><br><span class="line">    <span class="comment">// (4)、创建 Windows Surface</span></span><br><span class="line">    surface = eglCreateWindowSurface(display, config, s.get(), <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// (5)、创建 EGL context</span></span><br><span class="line">    context = eglCreateContext(display, config, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    eglQuerySurface(display, surface, EGL_WIDTH, &amp;w);</span><br><span class="line">    eglQuerySurface(display, surface, EGL_HEIGHT, &amp;h);</span><br><span class="line">    <span class="comment">// (6)、启用前面创建的 EGL context</span></span><br><span class="line">    <span class="keyword">if</span> (eglMakeCurrent(display, surface, surface, context) == EGL_FALSE)</span><br><span class="line">        <span class="keyword">return</span> NO_INIT;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">bool</span> BootAnimation::playAnimation(<span class="keyword">const</span> Animation&amp; animation)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">                <span class="comment">// (7)、OpenGL ES API 绘制图形：gl_*()</span></span><br><span class="line">                glDrawTexiOES(xc, mHeight - (yc + frame.trimHeight),</span><br><span class="line">                              <span class="number">0</span>, frame.trimWidth, frame.trimHeight);</span><br><span class="line">                ......</span><br><span class="line">                <span class="comment">// (8)、SwapBuffers显示</span></span><br><span class="line">                eglSwapBuffers(mDisplay, mSurface);</span><br><span class="line">                ......</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>使用EGL一般会经历以上几个步骤。</p><h5 id="1-2、Understanding-Android-Graphics-Internals"><a href="#1-2、Understanding-Android-Graphics-Internals" class="headerlink" title="1.2、Understanding Android Graphics Internals"></a>1.2、Understanding Android Graphics Internals</h5><p>要深入了解Android Graphics机制，需要了解熟悉以下知识（包括但不限于）。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-02-04-understand-android-graphics-internals.png" alt="Alt text | center"></p><p>####（二）、OpenGL ES 2.0 知识串讲<br>在了解EGL之前，先来看看前人总结的知识<a href="http://geekfaner.com/shineengine/index.html" target="_blank" rel="noopener">OPENGL ES 2.0 知识串讲</a>：</p><h5 id="2-1、写在前面的话"><a href="#2-1、写在前面的话" class="headerlink" title="2.1、写在前面的话"></a>2.1、写在前面的话</h5><h5 id="2-1-1、电脑是做什么用的"><a href="#2-1-1、电脑是做什么用的" class="headerlink" title="2.1.1、电脑是做什么用的?"></a>2.1.1、电脑是做什么用的?</h5><p>电脑又被称为计算机,那么最重要的工作就是计算。看过三体的同学都知道, 电脑中有无数纳米级别的计算单元,通过 0 和 1 的转换,完成加减乘除的操作。</p><h5 id="2-1-2、是什么使得电脑工作"><a href="#2-1-2、是什么使得电脑工作" class="headerlink" title="2.1.2、是什么使得电脑工作?"></a>2.1.2、是什么使得电脑工作?</h5><p>驱动,驱使着硬件完成工作。</p><h5 id="2-1-3、谁来写驱动"><a href="#2-1-3、谁来写驱动" class="headerlink" title="2.1.3、谁来写驱动?"></a>2.1.3、谁来写驱动?</h5><p>制造电脑的公司自己来写驱动,因为他们对自己的底层硬件架构最熟悉。</p><h5 id="2-1-4、谁会使用驱动"><a href="#2-1-4、谁会使用驱动" class="headerlink" title="2.1.4、谁会使用驱动?"></a>2.1.4、谁会使用驱动?</h5><p>所有的软件工程师都会直接或者间接的使用到驱动。</p><p>那么问题来了,如果说不同的电脑公司,制造出来不同的硬件,使用不同的 驱动,提供出来不同的接口供软件工程师进行使用,那么软件工程师就要崩溃了。</p><p>所以,一定是需要一个标准,来统一一下。</p><h5 id="2-1-5、那么在哪里进行统一"><a href="#2-1-5、那么在哪里进行统一" class="headerlink" title="2.1.5、那么在哪里进行统一?"></a>2.1.5、那么在哪里进行统一?</h5><p>硬件没有办法统一,每个电脑公司为了优化自己电脑性能和功耗,制造出来 不同的硬件架构,这是需要无数的心血完成的,如果统一了,那么就不需要那么 多电脑公司了。</p><p>所以只能统一驱动的接口。</p><p>电脑组件大致分为:CPU、GPU、内存、总线等。而 OpenGL 就是 GPU 驱动 的一套标准接口(OpenGL ES 为嵌入式设备 GPU 驱动的标准接口,比如手机, OpenGL ES 全称:OpenGL for Embedded Systems)。</p><p>所以综上所述,我使用了 5 个问题,引出了 OpenGL 的用处:就是将复杂的、 各种各样的 GPU 硬件包装起来,各个电脑公司编写自家的驱动,然后提供出来 一套统一的接口,供上层软件工程师调用。这样,世界就和平了。</p><h5 id="2-1-6、谁这么牛-定义了-OpenGL-这套标准"><a href="#2-1-6、谁这么牛-定义了-OpenGL-这套标准" class="headerlink" title="2.1.6、谁这么牛,定义了 OpenGL 这套标准?"></a>2.1.6、谁这么牛,定义了 OpenGL 这套标准?</h5><p>Khronos。每当我打这几个字母的时候,都会抱有一种敬畏的心理,因为它 不是一家公司,它是一个组织,它是由众多大公司联合组建而来,比如 Apple、 Intel、AMD、Google、ARM、Qualcomm、Nvidia 等等等等。各个大公司投入了大 量的人力、资金等创建了这个组织。对电脑 GPU 定义了统一的接口 OpenGL,对 手机 GPU 定义了统一的接口 OpenGL ES(我也非常有幸,在 Intel 工作期间,跟 Intel 驻 Khronos 的 3D 负责人共事了一段时间,每周一次的跨洋电话,都会让我受益匪浅)</p><p>这个组织除了定义了 OpenGL 接口之外,还定义了很多其他接口。目前针对 GPU 又提出了另外一套更底层的接口 Vulkan,这是一套比 OpenGL 更底层的接口, 使用其可以更容易优化,不过目前硬件厂商的驱动还有待开发,可能普及 Vulkan 还需要很多年。就好比 OpenGL ES 已经发展到了 3.1,而市面上的手机很多还是 只能支持 OpenGL ES 2.0 一样。所以新的科技从提出,到实现,到量产,到使用, 到普及,是一段很长的路。</p><p>所以,我们现在学习 OpenGL ES 2.0 是适时的,且是非常必要的(不懂 2.0, 想直接学习更难的 3.0、3.1、Vulkan,很难)。</p><p>事先预告一下,OpenGL ES 2.0 会分十三个课程,结束之后,我会立即奉上 OpenGL ES 3.0 在 OpenGL ES 2.0 基础上的改变。</p><h5 id="2-1-7、OpenGL-和我们游戏（Android-）开发者有什么关系"><a href="#2-1-7、OpenGL-和我们游戏（Android-）开发者有什么关系" class="headerlink" title="2.1.7、OpenGL 和我们游戏（Android ）开发者有什么关系?"></a>2.1.7、OpenGL 和我们游戏（Android ）开发者有什么关系?</h5><p>电脑/手机屏幕上显示的东西,要么是 2D 的,要么是 3D 的,那么如果是 3D 的,不管是 App 也好,游戏也好,简单的图片界面也好,底层都是通过 GPU、 通过 OpenGL(ES)绘制出来的。</p><p>开发 App 的时候,是通过创建控件的方式,而控件已经对底层进行了一层封装,所以 App 开发者很少会接触到 OpenGL(ES)。</p><p>游戏的开发是通过游戏引擎,而游戏引擎的最底层,是直接调用了 OpenGL(ES),直接对 GPU 进行控制。</p><p>所以说游戏引擎工程师必须懂 OpenGL(ES),而游戏开发者,想要更好的对游戏进行更好的理解和优化,也建议学一些 OpenGL(ES)。</p><h5 id="2-1-8、DirectX-是什么"><a href="#2-1-8、DirectX-是什么" class="headerlink" title="2.1.8、DirectX 是什么?"></a>2.1.8、DirectX 是什么?</h5><p>最后一个问题。我们发现 Khronos 组织的成员中,我没有提到大名鼎鼎的微 软,因为微软不在组织中,而它提出了自己的 GPU 驱动标准,DirectX。</p><p>所以目前手机,不管是 iOS 还是 Android,都是支持 OpenGL ES。电脑,Windows 系统支持 DirectX 和 OpenGL,Linux/Mac(Unix)系统支持 OpenGL。</p><h4 id="2-2、OpenGL-ES-的两个小伙伴"><a href="#2-2、OpenGL-ES-的两个小伙伴" class="headerlink" title="2.2、OpenGL ES 的两个小伙伴"></a>2.2、OpenGL ES 的两个小伙伴</h4><p>虽然,我们教程的标题是 OpenGL ES,但是我们的内容将不仅限于 OpenGL ES。 OpenGL ES 是负责 GPU 工作的,目的是通过 GPU 计算,得到一张图片,这张图 片在内存中其实就是一块 buffer,存储有每个点的颜色信息等。而这张图片最终是要显示到屏幕上,所以还需要具体的窗口系统来操作,OpenGL ES 并没有相关的函数。所以,OpenGL ES 有一个好搭档 EGL。</p><p>EGL,全称:embedded Graphic Interface,是 OpenGL ES 和底层 Native 平台 视窗系统之间的接口。所以大概流程是这样的:首先,通过 EGL 获取到手机屏幕 的 handle,获取到手机支持的配置(RGBA8888/RGB565 之类,表示每个像素中包 含的颜色等信息的存储空间是多少位),然后根据这个配置创建一块包含默认 buffer 的 surface(buffer 的大小是根据屏幕分辨率乘以每个像素信息所占大小计 算而得)和用于存放 OpenGL ES 状态集的 context,并将它们 enable 起来。然后, 通过 OpenGL ES 操作 GPU 进行计算,将计算的结果保存在 surface 的 buffer 中。 最后,使用 EGL,将绘制的图片显示到手机屏幕上。</p><p>而在 OpenGL ES 操作 GPU 计算的时候,还需要介绍 OpenGL ES 的另外一个好搭档 GLSL。</p><p>GLSL,全称:OpenGL Shading Language,是 OpenGL ES 中使用到的着色器的 语言,用这个语言可以编写小程序运行在 GPU 上。</p><p>在这里需要先提到 CPU 和 GPU 的区别,它们的功能都是用于计算,也都是由很多核组成,区别在于 CPU 的核比较少,但是单个核的计算能力比较强,而 GPU 的核很多,但是每个核的计算能力都不算特别强。目前 GPU 的主要工作是用于生成图片(现在也有通过 GPU 进行高性能运算_并行运算,但是在这里不属于讨论的范围),原因就是图片是由很多像素组成,每个像素都包含有颜色、深度等信息,而为了得到这些信息数据,针对每个像素点的计算,是可以通过统一的算法来完成。GPU 就擅长处理针对这种大规模数据,使用同一个算法进行计算。而这个算法,就是使用 GLSL 写成 Shader,供 GPU 运算使用。</p><p>在图形学的视角中,所有的图片都是由三角形构成的。所以通过 OpenGL ES 绘制图片的时候,我们需要通过 OpenGL ES API 创建用于在 GPU 上运行的 shader, 然后将通过 CPU 获取到的图片顶点信息,传入 GPU 中的 Shader 中。在 Vertex Shader 中通过矩阵变换,将顶点坐标从模型坐标系转换到世界坐标系,再到观察坐标系,到裁剪坐标系,最后投影到屏幕坐标系中,计算出在屏幕上各个顶点的坐标。然后,通过光栅化,以插值的方法得到所有像素点的信息,并在 Fragment shader 中计算出所有像素点的颜色。最后,通过 OpenGL ES 的 API 设定的状态,将得到的像素信息进行 depth/stencil test、blend,得到最终的图片。</p><h4 id="2-3、屏幕图片的本质和产生过程"><a href="#2-3、屏幕图片的本质和产生过程" class="headerlink" title="2.3、屏幕图片的本质和产生过程"></a>2.3、屏幕图片的本质和产生过程</h4><p>当我们买一个手机的时候,我们会非常关注这个手机的分辨率。分辨率代表着像素的多少,比如我们熟知的 iphone6 的分辨率为 1334×750,而 iphone6 plus 的分辨率是1920×1080。</p><p>手机屏幕上的图片,是由一个一个的像素组成,那么可以计算出来,一个屏幕上的图片,是由上百万个像素点组成。而每个像素点都有自己的颜色,每种颜色都是由 RGB 三原色组成。三原色按照不同的比例混合,组成了手机所能显示出来的颜色。</p><p>每个像素的颜色信息都保存在 buffer 中,这块 buffer 可以分给 RGB 每个通 道各 8bit 进行信息保存,也可以分给 RGB 每个通道不同的空间进行信息保存, 比如由于人眼对绿色最敏感,那么可以分配给 G 通道 6 位,R 和 B 通道各 5 位。这些都是常见的手机配置。假如使用 RGB888 的手机配置,也就是每种颜色的取值从 0 到 255,0 最小,255 最大。那么红绿蓝都为 0 的时候,这个像素点的颜色就是黑色,红绿蓝都为 255 的时候,这个像素点的颜色就是白色。当红为 255, 绿蓝都为 0 的时候,这个像素点的颜色就是红色。当红绿为 255,蓝为 0 的时候, 这个像素点的颜色就是黄色。当然不是只取 0 或者 255,可以取 0-255 中间的值, 100,200,任意在 0 和 255 中间的值都没有问题。那么我们可以算一下,按照红绿蓝不同比例进行搭配,每个像素点,可以显示的颜色有 255<em>255</em>255=16581375 种,这个数字是非常恐怖,所以我们的手机可以显示出来各种各样的颜色。 这里在延伸的科普一下,我们看到手机可以显示那么多种颜色了,但是是不是说我们的手机在颜色上就已经发展到极致了呢?其实是远远没有的,在这个手机配置下,三原色中每一种的取值可以从 0 到 255,而在现实生活中,它们的取 值可以从 0 到 1 亿,而我们人类的眼睛所能看到的范围是,从 0 到 10 万。所以手机硬件还存在很大的提升空间。而在手机硬件提升之前,我们也可以通过 HDR 等技术尽量的在手机中多显示一些颜色。所以,讲到这里,我们知道了,手机屏幕上显示的图片,是由这上百万个像素点,以及这上百万个像素点对应的颜色组成的。</p><p>用程序员的角度来看,就是手机屏幕对应着一块 buffer,这块 buffer 对应上百万个像素点,每个像素点需要一定的空间来存储其颜色。如果使用更加形象的例子来比喻,手机屏幕对应的 buffer 就好像一块巨大的棋盘,棋盘上有上百万个格子,每个格子都有自己的颜色,那么从远处整体的看这个棋盘,就是我们看手机的时候显示的样子。这就是手机屏幕上图片的本质。</p><p>通过我们对 EGL、GLSL、OpenGL ES 的理解,借助一张图片,从专业的角度来解释一下手机屏幕上的图片是如何生成的。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-02-05-OpenGL-Picture-Generate.png" alt="Alt text | center"></p><p>首先,通过 EGL 获取手机屏幕,进而获取到手机屏幕对应的这个棋盘,同时, 在手机的 GPU 中根据手机的配置信息,生成另外一个的棋盘和一个本子,本子是用于记录这个棋盘初始颜色等信息。</p><p>然后,OpenGL ES 就好像程序员的画笔,程序员需要知道自己想画什么东西,比如想画一个苹果,那么就需要通过为数不多的基本几何图元(如点、直线、三 角形)来创建所需要的模型。比如用几个三角形和点和线来近似的组成这个苹果 (图形学的根本就是点、线和三角形,所有的图形,都可以由这些基本图形组成, 比如正方形或者长方形,就可以由两个三角形组成,圆形可以由无数个三角形组成,只是三角形的数量越多,圆形看上去越圆润)。</p><p>根据这些几何图元,建立数学描述,比如每个三角形或者线的顶点坐标位置、每个顶点的颜色。得到这些信息之后,可以先通过 OpenGL ES 将 EGL 生成的棋盘 (buffer)进行颜色初始化,一般会被初始化为黑色。然后将刚才我们获取到的顶点坐标位置,通过矩阵变化的方式,进行模型变换、观察变换、投影变换,最后映射到屏幕上,得到屏幕上的坐标。这个步骤可以在 CPU 中完成,也就是在 OpenGL ES 把坐标信息传给 Shader 之前,在 CPU 中通过矩阵相乘等方式进行更新,或者是直接把坐标信息通过 OpenGL ES 传给 Shader,同时也把矩阵信息传给 Shader,通过 Shader 在 GPU 端进行坐标更新,更新的算法通过 GLSL 写在 Shader 中。这个进行坐标更新的 Shader 被称为 vertex shader,简称 VS,是 OpenGL ES2.0, 也是 GLSL130 版本对应的最重要两个 shader 之一,作用是完成顶点操作阶段中的所有操作。经过矩阵变换后的像素坐标信息,为屏幕坐标系中的坐标信息。在 VS 中,最重要的输入为顶点坐标、矩阵(还可以传入顶点的颜色、法线、纹理 坐标等信息),而最重要的运算结果,就是这个将要显示在屏幕上的坐标信息。 VS 会针对传入的所有顶点进行运算,比如在 OpenGL ES 中只想绘制一个三角形 和一条线,这两个图元不共享顶点,那么在 VS 中,也就传入了 5 个顶点信息, 根据矩阵变换,这 5 个顶点的坐标转换成了屏幕上的顶点坐标信息,从图上显示, 也就是从左上角的图一,更新成了中上图的图二。</p><p>再然后,当图二生成之后,我们知道了图元在屏幕上的顶点位置,而顶点的颜色在 VS 中没有发生变化,所以图元的顶点颜色我们也是知道的。下面就是根据 OpenGL ES 中设置的状态,表明哪些点连成线,哪些点组成三角形,进行图元装配,也就是我们在右上角的图三中看到的样子。这个样子在 GPU 中不会显示, 那几条线也是虚拟的线,是不会显示在棋盘 buffer 中的,而 GPU 做的是光珊化,这一步是发生在从 VS 出来,进入另外一个Shader (Pixel shader,也称 fragment shader)之前,在 GPU 中进行的。作用是把线上,或者三角形内部所有的像素点找到,并根据插值或者其他方式计算出其颜色等信息(如果不通过插值,可以使用其他的方法,这些在 OpenGL ES 和 GLSL 中都可以进行设置)。也就生成了下面一行的图四和图五。</p><p>我们大概可以看到在图 4 和图 5 种出现了大量的顶点,大概数一下估计有 40 个点左右,这些点全部都会进入 PS 进行操作,在 PS 中可以对这些点的颜色进行操作,比如可以只显示这些点的红色通道,其他的绿蓝通道的值设置为 0, 比如之前某个点的 RGB 为 200,100,100。在 PS 中可以将其通过计算,更新为 200,0,0。这样做的结果就是所显示的图片均为红色,只是深浅不同。这也就好像戴上了一层红色的滤镜,其他颜色均为滤掉了。所以用 PS 来做滤镜是非常方便的。再比如,假如一盏红色的灯照到了苹果上,那么显示出来的颜色就是在苹果原本的颜色基础上,红色值进行一定的增值。</p><p>所以,总结一下,经过 VS 和 PS 之后,程序员想要画的东西,就已经被画出来了。想要绘制的东西,也就是左下角图五的样子。然后再根据 OpenGL ES 的设置,对新绘制出来的东西进行 Depth/Stencil Test,剔除掉被遮挡的部分,将剩余部分与原图片进行 Blend,生成新的图片。 最后,通过 EGL,把这个生成的棋盘 buffer 和手机屏幕上对应的棋盘 buffer 进行调换,让手机屏幕显示这个新生成的棋盘,旧的那个棋盘再去绘制新的图片信息。周而复始,不停的把棋盘进行切换,也就像过去看连环画一样,动画就是由一幅幅的图片组成,当每秒切换的图片数量超过 30 张的时候,我们的手机也就看到了动态的效果。这就是屏幕上图片的产生过程。</p><p>在这里再进行一下延伸,这个例子中,VS 计算了 5 个顶点的数据,PS 计算 了大概 40 个顶点的数据,而我们刚才说过,手机中存在上百万个像素点,这上百万个像素点都可以是顶点,那么这个计算量是非常大的。而这也是为什么要将 shader 运算放在 GPU 中的原因,因为 GPU 擅长进行这种运算。</p><p>我们知道 CPU 现在一般都是双核或者 4 核,多的也就是 8 核或者 16 核,但是 GPU 动辄就是 72 核,多的还有上千核,这么多核的目的就是进行并行运算, 虽然单个的 GPU 核不如 CPU 核,但是单个的 GPU 核足够进行加减乘除运算,所以大量的 GPU 核用在图形学像素点运算上,是非常有效的。而 CPU 虽然单个很强大,而且也可以通过多级流水来提高吞吐率,但是终究还是不如 GPU 的多核来得快。但是在通过 GPU 进行多核运算的时候,需要注意的是:如果 shader 中存放判断语句,就会对 GPU 造成比较大的负荷,不同 GPU 的实现方式不同,多数 GPU 会对判断语句的两种情况都进行运算,然后根据判断结果取其中一个。</p><p>我们通过这个例子再次清楚了 OpenGL ES 绘制的整个流程,而这个例子也是最简单的一个例子,其中有很多 OpenGL ES 的其他操作没有被涉及到。比如,我们绘制物体的颜色大多是从纹理中采样出来,那么设计到通过 OpenGL ES 对纹理 进行操作。而 OpenGL ES 的这些功能,我们会在下面一点一点进行学习。</p><h4 id="2-4-2、OpenGL-流水线（pipeline）"><a href="#2-4-2、OpenGL-流水线（pipeline）" class="headerlink" title="2.4.2、OpenGL 流水线（pipeline）"></a>2.4.2、OpenGL 流水线（pipeline）</h4><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-02-06-OpenGL-ES-pipeline.png" alt="Alt text | center"></p><p>EGL 是用于与手机设备打交道,比如获取绘制 buffer,将绘制 buffer 展现到手机屏幕中。那么抛开 EGL 不说,OpenGL ES 与 GLSL 的主要功能,就是往这块 buffer 上绘制图片。</p><p>所以,我们可以把OpenGL ES和GLSL的流程单独拿出来进行归纳总结,而这幅流程图就是著名的 OpenGL ES2.0 pipeline。</p><p>首先,最左边的 API 指的就是 OpenGL ES 的 API,OpenGL ES 其实是一个图形学库,由 109 个 API 组成,只要明白了这 109 个 API 的意义和用途,就掌握了OpenGL ES 2.0。</p><p>然后,我们通过 API 先设定了顶点的信息,顶点的坐标、索引、颜色等信息,将这些信息传入 VS。</p><p>在 VS 中进行运算,得到最终的顶点坐标。再把算出来的顶点坐标进行图元装配,构建成虚拟的线和三角形。再进行光珊化(在光珊化的时候,把顶点连接起来形成直线,或者填充多边形的时候,需要考虑直线和多边形的直线宽度、点的大小、渐变算法以及是否使用支持抗锯齿处理的覆盖算法。最终的每个像素点,都具有各自的颜色和深度值)。</p><p>将光珊化的结果传入 PS,进行最终的颜色计算。</p><p>然后,这所谓最终的结果在被实际存储到绘制 buffer 之前,还需要进行一系列的操作。这些操作可能会修改甚至丢弃这些像素点。</p><p>这些操作主要为 alpha test、Depth/Stencil test、Blend、Dither。</p><p>Alpha Test 采用一种很霸道极端的机制,只要一个像素的 alpha 不满足条件, 那么它就会被 fragment shader 舍弃,被舍弃的 fragments 不会对后面的各种 Tests 产生影响;否则,就会按正常方式继续下面的检验。Alpha Test 产生的效果也很极端,要么完全透明,即看不到,要么完全不透明。</p><p>Depth/stencil test 比较容易理解。由于我们绘制的是 3D 图形,那么坐标为 XYZ,而 Z 一般就是深度值,OpenGL ES 可以对深度测试进行设定,比如设定深度值大的被抛弃,那么假如绘制 buffer 上某个像素点的深度值为 0,而 PS 输出的 像素点的深度值为 1,那么 PS 输出的像素点就被抛弃了。而 stencil 测试更加简单,其又被称为蒙版测试,比如可以通过 OpenGL ES 设定不同 stencil 值的配抛弃, 那么假如绘制 buffer 上某个像素点的 stencil 值为 0,而 PS 输出的像素点的 stencil 值为 1,那么 PS 输出的像素点就被抛弃了。</p><p>既然说到了 Depth/stencil,那么就在这里说一下绘制 buffer 到底有多大,存 储了多少信息。按照我们刚才的说法,手机可以支持一百万个像素,那么生成的 绘制 buffer 就需要存储这一百万个像素所包含的信息,而每个像素包含的信息, 与手机配置有关,假如手机支持 Depth/stencil。那么通过 EGL 获取的绘制 buffer 中,每个像素点就包含了 RGBA 的颜色值,depth 值和 stencil 值,其中 RGBA 每个分量一般占据 8 位,也就是 8bit,也就是 1byte,而 depth 大多数占 24 位,stencil 占 8 位。所以每个像素占 64bit,也就是 8byte。那么 iphone6 plus 的绘制 buffer 的尺寸为 1920×1080×8=16588800byte=16200KB=15.8MB。</p><p>下面还有 blend,通过 OpenGL ES 可以设置 blend 混合模式。由于绘制 buffer 中原本每个像素点已经有颜色了,那么 PS 输出的颜色与绘制 buffer 中的颜色如何混合,生成新的颜色存储在绘制 buffer 中,就是通过 blend 来进行设定。</p><p>最后的 dither,dither 是一种图像处理技术,是故意造成的噪音,用以随机化量化误差,阻止大幅度拉升图像时,导致的像 banding(色带)这样的问题。也 是通过OpenGL ES 可以开启或者关闭。</p><p>经过了这一系列的运算和测试,也就得到了最终的像素点信息,将其存储到绘制 buffer 上之后,OpenGL ES 的 pipeline 也就结束了。</p><p>整个pipeline中，纵向按照流水线作业，横线按照独立作业，多级并行、提高渲染性能</p><p>####（三）、 Android EGL Overview： OpenGL ES 和 EGL 介绍</p><h4 id="3-1-0、OpenGL-ES"><a href="#3-1-0、OpenGL-ES" class="headerlink" title="3.1.0、OpenGL ES"></a>3.1.0、OpenGL ES</h4><p>OpenGL ES（OpenGL for Embedded Systems）是 OpenGL 三维图形API的子集，针对手机、PDA和游戏主机等嵌入式设备而设计，各显卡制造商和系统制造商来实现这组 API。</p><h4 id="3-1-1、OpenGL-基本概念"><a href="#3-1-1、OpenGL-基本概念" class="headerlink" title="3.1.1、OpenGL 基本概念"></a>3.1.1、OpenGL 基本概念</h4><p>OpenGL 的结构可以从逻辑上划分为下面 3 个部分：</p><p>☯ 图元（Primitives）<br>☯ 缓冲区（Buffers）<br>☯ 光栅化（Rasterize）<br> <strong>图元（Primitives）</strong><br>在 OpenGL 的世界里，我们只能画点、线、三角形这三种基本图形，而其它复杂的图形都可以通过三角形来组成。所以这里的图元指的就是这三种基础图形：</p><p>☯ 点：点存在于三维空间，坐标用（x,y,z）表示。<br>☯ 线：由两个三维空间中的点组成。<br>☯ 三角形：由三个三维空间的点组成。<br><strong>缓冲区（Buffers）</strong><br>OpenGL 中主要有 3 种 Buffer：</p><p><strong>帧缓冲区（Frame Buffers）</strong> 帧缓冲区：<strong>这个是存储OpenGL 最终渲染输出结果的地方</strong>，它是一个包含多个图像的集合，例如颜色图像、深度图像、模板图像等。</p><p><strong>渲染缓冲区（Render Buffers）</strong> 渲染缓冲区：渲染缓冲区就是一个图像，它是 Frame Buffer 的一个子集。</p><p><strong>缓冲区对象（Buffer Objects）</strong> 缓冲区对象就是程序员输入到 OpenGL 的数据，分为结构类和索引类的。前者被称为“数组缓冲区对象”或“顶点缓冲区对象”（“Array Buffer Object”或“Vertex Buff er Object”），即用来描述模型的数组，如顶点数组、纹理数组等； 后者被称为“索引缓冲区对象”（“Index Buffer Object”），是对上述数组的索引。</p><p><strong>光栅化（Rasterize）</strong><br>在介绍光栅化之前，首先来补充 OpenGL 中的两个非常重要的概念：</p><p>Vertex Vertex 就是图形中顶点，一系列的顶点就围成了一个图形。<br>Fragment Fragment 是三维空间的点、线、三角形这些基本图元映射到二维平面上的映射区域，通常一个 Fragment 对应于屏幕上的一个像素，但高分辨率的屏幕可能会用多个像素点映射到一个 Fragment，以减少 GPU 的工作。<br>而光栅化是把点、线、三角形映射到屏幕上的像素点的过程。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-02-07-OpenGL-guangshanhua.png" alt="Alt text | center"></p><p>着色器程序（Shader）<br>Shader 用来描述如何绘制（渲染），GLSL 是 OpenGL 的编程语言，全称 OpenGL Shader Language，它的语法类似于 C 语言。OpenGL 渲染需要两种 Shader：Vertex Shader 和 Fragment Shader。</p><p>Vertex Shader Vertex Shader 对于3D模型网格的每个顶点执行一次，主要是确定该顶点的最终位置。<br>Fragment Shader Fragment Shader对光栅化之后2D图像中的每个像素处理一次。3D物体的表面最终显示成什么样将由它决定，例如为模型的可见表面添加纹理，处理光照、阴影的影响等等。</p><h4 id="3-2、EGL-Overview"><a href="#3-2、EGL-Overview" class="headerlink" title="3.2、EGL Overview"></a>3.2、EGL Overview</h4><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-02-08-OpenGL-EGL-Overview.png.png" alt="Alt text | center"></p><p>What is the Direction?<br>SW : Standard API (Java, NDK Stable API)<br>HW : OpenGLES, OpenSLES, OpenMAX<br>EGL™ is an interface between Khronos rendering APIs such as OpenGL ES or OpenVG and the underlying native platform window system</p><h4 id="3-2-1、什么是-EGL？"><a href="#3-2-1、什么是-EGL？" class="headerlink" title="3.2.1、什么是 EGL？"></a>3.2.1、什么是 EGL？</h4><p>EGL 是 OpenGL ES 渲染 API 和本地窗口系统(native platform window system)之间的一个中间接口层，它主要由系统制造商实现。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-02-09-eglCreateWindowSurface.png" alt="Alt text | center"></p><p>EGL提供如下机制：<br>与设备的原生窗口系统通信<br>查询绘图表面的可用类型和配置<br>创建绘图表面<br>在OpenGL ES 和其他图形渲染API之间同步渲染<br>管理纹理贴图等渲染资源<br>为了让OpenGL ES能够绘制在当前设备上，我们需要EGL作为OpenGL ES与设备的桥梁。</p><h4 id="3-2-2、使用-EGL-绘图的基本步骤"><a href="#3-2-2、使用-EGL-绘图的基本步骤" class="headerlink" title="3.2.2、使用 EGL 绘图的基本步骤"></a>3.2.2、使用 EGL 绘图的基本步骤</h4><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-02-10-egl-draw-surface.png.png" alt="Alt text | center"></p><p>☯  Display(EGLDisplay) 是对实际显示设备的抽象。<br>☯  Surface（EGLSurface）是对用来存储图像的内存区域<br>☯  FrameBuffer 的抽象，包括 Color Buffer， Stencil Buffer ，Depth Buffer。Context (EGLContext) 存储 OpenGL ES绘图的一些状态信息。<br>使用EGL的绘图的一般步骤：</p><p>1、获取 EGL Display 对象：eglGetDisplay()<br>2、初始化与 EGLDisplay 之间的连接：eglInitialize()<br>3、获取 EGLConfig 对象：eglChooseConfig()<br>4、创建 EGLContext 实例：eglCreateContext()<br>5、创建 EGLSurface 实例：eglCreateWindowSurface()<br>6、连接 EGLContext 和 EGLSurface：eglMakeCurrent()<br>7、使用 OpenGL ES API 绘制图形：gl_*()<br>8、切换 front buffer 和 back buffer 送显：eglSwapBuffer()<br>9、断开并释放与 EGLSurface 关联的 EGLContext 对象：eglRelease()<br>10、删除 EGLSurface 对象<br>11、删除 EGLContext 对象<br>12、终止与 EGLDisplay 之间的连接</p><h4 id="3-3、EGLSurface-and-ANativeWindow-关系"><a href="#3-3、EGLSurface-and-ANativeWindow-关系" class="headerlink" title="3.3、EGLSurface and ANativeWindow 关系"></a>3.3、EGLSurface and ANativeWindow 关系</h4><p>OpenGL ES 定义了一个渲染图形的 API，但没有定义窗口系统。为了让 GLES 能够适合各种平台，GLES 将与知道如何通过操作系统创建和访问窗口的库结合使用。用于 Android 的库称为 EGL。如果要绘制纹理多边形，应使用 GLES 调用；如果要在屏幕上进行渲染，应使用 EGL 调用。</p><p>在使用 GLES 进行任何操作之前，需要创建一个 GL 上下文。在 EGL 中，这意味着要创建一个 EGLContext 和一个 EGLSurface。GLES 操作适用于当前上下文，该上下文通过线程局部存储访问，而不是作为参数进行传递。这意味着您必须注意渲染代码在哪个线程上执行，以及该线程上的当前上下文。</p><h4 id="3-3-1、EGLSurface"><a href="#3-3-1、EGLSurface" class="headerlink" title="3.3.1、EGLSurface"></a>3.3.1、EGLSurface</h4><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-02-11-eglsurface-anativewindwo.png" alt="Alt text | center"></p><p>EGLSurface 可以是由 EGL 分配的离屏缓冲区（称为“pbuffer”），或由操作系统分配的窗口。EGL 窗口 Surface 通过 eglCreateWindowSurface() 调用被创建。该调用将“窗口对象”作为参数，在 Android 上，该对象可以是 SurfaceView、SurfaceTexture、SurfaceHolder 或 Surface，所有这些对象下面都有一个 BufferQueue。当您进行此调用时，EGL 将创建一个新的 EGLSurface 对象，并将其连接到窗口对象的 BufferQueue 的生产方接口。此后，渲染到该 EGLSurface 会导致一个缓冲区离开队列、进行渲染，然后排队等待消耗方使用。（术语“窗口”表示预期用途，但请注意，输出内容不一定会显示在显示屏上。）</p><p>EGL 不提供锁定/解锁调用，而是由您发出绘制命令，然后调用 eglSwapBuffers() 来提交当前帧。方法名称来自传统的前后缓冲区交换，但实际实现可能会有很大的不同。</p><p>一个 Surface 一次只能与一个 EGLSurface 关联（您只能将一个生产方连接到一个 BufferQueue），但是如果您销毁该 EGLSurface，它将与该 BufferQueue 断开连接，并允许其他内容连接到该 BufferQueue。</p><p>通过更改“当前”EGLSurface，指定线程可在多个 EGLSurface 之间进行切换。一个 EGLSurface 一次只能在一个线程上处于当前状态。</p><p>关于 EGLSurface 最常见的一个错误理解就是假设它只是 Surface 的另一方面（如 SurfaceHolder）。它是一个相关但独立的概念。您可以在没有 Surface 作为支持的 EGLSurface 上绘制，也可以在没有 EGL 的情况下使用 Surface。EGLSurface 仅为 GLES 提供一个绘制的地方。</p><h4 id="3-3-2、ANativeWindow"><a href="#3-3-2、ANativeWindow" class="headerlink" title="3.3.2、ANativeWindow"></a>3.3.2、ANativeWindow</h4><p>公开的 Surface 类以 Java 编程语言实现。C/C++ 中的同等项是 ANATIONWindow 类，由 Android NDK 半公开。您可以使用 ANativeWindow_fromSurface() 调用从 Surface 获取 ANativeWindow。就像它的 Java 语言同等项一样，您可以对 ANativeWindow 进行锁定、在软件中进行渲染，以及解锁并发布。</p><p>要从原生代码创建 EGL 窗口 Surface，可将 EGLNativeWindowType 的实例传递到 eglCreateWindowSurface()。EGLNativeWindowType 是 ANativeWindow 的同义词，您可以自由地在它们之间转换。</p><p>基本的“原生窗口”类型只是封装 BufferQueue 的生产方，这一点并不足为奇。</p><h4 id="3-3-3、egl-surface-t-关系图"><a href="#3-3-3、egl-surface-t-关系图" class="headerlink" title="3.3.3、egl_surface_t 关系图"></a>3.3.3、egl_surface_t 关系图</h4><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-02-12-egl_surface_t.png" alt="Alt text | center"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\native\opengl\libagl\egl.cpp]</span><br><span class="line"><span class="function"><span class="keyword">static</span> EGLSurface <span class="title">createWindowSurface</span><span class="params">(EGLDisplay dpy, EGLConfig config,</span></span></span><br><span class="line"><span class="function"><span class="params">        NativeWindowType window, <span class="keyword">const</span> EGLint* <span class="comment">/*attrib_list*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    EGLint surfaceType;</span><br><span class="line">    <span class="keyword">if</span> (!(surfaceType &amp; EGL_WINDOW_BIT))</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_MATCH, EGL_NO_SURFACE);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">static_cast</span>&lt;ANativeWindow*&gt;(window)-&gt;common.magic !=</span><br><span class="line">            ANDROID_NATIVE_WINDOW_MAGIC) &#123;</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_NATIVE_WINDOW, EGL_NO_SURFACE);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    EGLint configID;</span><br><span class="line">    <span class="keyword">if</span> (getConfigAttrib(dpy, config, EGL_CONFIG_ID, &amp;configID) == EGL_FALSE)</span><br><span class="line">        <span class="keyword">return</span> EGL_FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int32_t</span> depthFormat;</span><br><span class="line">    <span class="keyword">int32_t</span> pixelFormat;</span><br><span class="line">    <span class="keyword">if</span> (getConfigFormatInfo(configID, pixelFormat, depthFormat) != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_MATCH, EGL_NO_SURFACE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   ......</span><br><span class="line">    <span class="keyword">egl_surface_t</span>* surface;</span><br><span class="line">    surface = <span class="keyword">new</span> <span class="keyword">egl_window_surface_v2_t</span>(dpy, config, depthFormat,</span><br><span class="line">            <span class="keyword">static_cast</span>&lt;ANativeWindow*&gt;(window));</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> surface;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-02-13-framebufferwindow-surface.png" alt="Alt text | center"></p><h4 id="3-3-4、EGLContext-and-Thread-Local-Storage"><a href="#3-3-4、EGLContext-and-Thread-Local-Storage" class="headerlink" title="3.3.4、EGLContext and Thread Local Storage"></a>3.3.4、EGLContext and Thread Local Storage</h4><h4 id="3-3-4-1、EGLContext"><a href="#3-3-4-1、EGLContext" class="headerlink" title="3.3.4.1、EGLContext"></a>3.3.4.1、EGLContext</h4><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-02-14-eglcontect-TLS.png" alt="Alt text | center"></p><h4 id="3-3-4-2、Thread-Local-Storage"><a href="#3-3-4-2、Thread-Local-Storage" class="headerlink" title="3.3.4.2、Thread Local Storage"></a>3.3.4.2、Thread Local Storage</h4><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-02-15-eglcontect-Thread-Loacal.png.png" alt="Alt text | center"></p><h4 id="3-3-5、EGLImplementation-HWCompser-and-SurfaceFlinger"><a href="#3-3-5、EGLImplementation-HWCompser-and-SurfaceFlinger" class="headerlink" title="3.3.5、EGLImplementation : HWCompser and SurfaceFlinger"></a>3.3.5、EGLImplementation : HWCompser and SurfaceFlinger</h4><h4 id="3-3-5-1、HWCompser"><a href="#3-3-5-1、HWCompser" class="headerlink" title="3.3.5.1、HWCompser"></a>3.3.5.1、HWCompser</h4><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-02-16-Android-graphics-components.png" alt="Alt text | center"></p><h4 id="3-3-5-2、SurfaceFlinger"><a href="#3-3-5-2、SurfaceFlinger" class="headerlink" title="3.3.5.2、SurfaceFlinger"></a>3.3.5.2、SurfaceFlinger</h4><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-02-17-eglimp-hwrenderer-surfaceflinger.png" alt="Alt text | center"></p><p>####（四）、Android EGL：OpenGL ES 库和 EGL 库加载过程<br>在详细分析 EGL 绘图基本步骤 前，先来看看OpenGL ES 库和 EGL 库加载过程。</p><h5 id="4-1、OpenGL-ES-和-OpenGL-ES-库的区别"><a href="#4-1、OpenGL-ES-和-OpenGL-ES-库的区别" class="headerlink" title="4.1、OpenGL ES 和 OpenGL ES 库的区别"></a>4.1、OpenGL ES 和 OpenGL ES 库的区别</h5><p><strong>OpenGL ES ：</strong> 它本身只是一个协议规范，定义了一套可以供上层应用程序进行调用的 API，它抽象了 GPU 的功能，使应用开发者不必关心底层的 GPU 类型和具体实现。<br><strong>OpenGL ES 库：</strong>OpenGL ES 库就是上面 OpenGL ES 中定义的 API 的具体实现。由于每个显卡制造厂商的 GPU 硬件结构不同，从而导致各个厂商的OpenGL ES 库也各不相同，所以 Android 系统中的 OpenGL ES 库通常是由硬件厂商提供的，通常存放在 Android 系统中的 /system/lib64/（/system/lib/） 。<br><strong>OpenGL ES Wrapper 库：</strong>OpenGL ES Wrapper 库是一个对 OpenGL ES API 进行封装的一个包裹库，它向上为应用程序提供了标准的 OpenGL ES API，向下可以和不同厂商实现的 OpenGL ES 库进行绑定，将 OpenGL ES API 和对应的实现函数一一绑定在一起。<br>并且，OpenGL ES 库的实现分为：<br><strong>软件模拟实现</strong><br><strong>硬件加速实现</strong><br>现在，因为我们 Android 手机中的 Soc 片上芯片中都集成了 GPU 模块，所以这里使用的就是硬件加速实现的 OpenGL ES 库。但是，像 Android Emulator 中的 Android 系统，如果不支持将 OpenGL ES API 指令重定向到主机系统的 GPU 加速执行的话，它所采用的 OpenGL ES 库就是软件模拟实现的。</p><p>补充：如前面小节【OpenGL ES 和 EGL 介绍】中介绍的，EGL 也是一套 API，它的实现也需要系统厂商来提供。系统厂商通常会将这两套 API 的实现封装在一个共享链接库中，但是根据最新的标准，OpenGL ES API 实现的共享链接库和 EGL API 实现的共享链接库是独立分开的，例如  Nexus 9 平板设备中 OpenGL ES 和 EGL API 实现库就是独立分开的。</p><h5 id="4-2、Android-中-OpenGL-ES-软件层次栈"><a href="#4-2、Android-中-OpenGL-ES-软件层次栈" class="headerlink" title="4.2、Android 中 OpenGL ES 软件层次栈"></a>4.2、Android 中 OpenGL ES 软件层次栈</h5><p>按照分层理念的设计，Android 中的 OpenGL ES 实现也是层次设计的，形成一个软件层次栈。最上面的是 Java 层，接着下面是 JNI 层，再调用下面的 wrapper 层，wrapper 层下面则是 OpenGL ES API 的具体软件实或者硬件实现了。整个 OpenGL 软件层次栈的调用关系如下所示：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-02-18-OpenGL_ES_call_graph_so.png" alt="Alt text | center"></p><h5 id="4-3、OpenGL-ES-EGL-Wrapper-库"><a href="#4-3、OpenGL-ES-EGL-Wrapper-库" class="headerlink" title="4.3、OpenGL ES/EGL Wrapper 库"></a>4.3、OpenGL ES/EGL Wrapper 库</h5><p>前面我们已经介绍过 OpenGL ES/EGL Wrapper 库是一个将 OpenGL ES API 和 OpenGL ES API 具体实现绑定在一起的库，它对应的源码路径是：/frameworks/native/opengl/libs/，其中:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">libGLESv1_CM.so：OpenGL ES <span class="number">1.</span>x API 的 Wrapper 库</span><br><span class="line">libGLESv2.so：OpenGL ES <span class="number">2.0</span> 的 Wrapper 库</span><br><span class="line">libGLESv3.so：OpenGL ES <span class="number">3.0</span> 的 Wrapper 库</span><br></pre></td></tr></table></figure><p>其中因为 OpenGL ES 3.0 API 是兼容 OpenGL ES 2.0 API 的，所以 libGLESv2.so 库本质上和 libGLESv3.so 库是一样的。</p><h5 id="4-3-1、OpenGL-ES-EGL-实现库"><a href="#4-3-1、OpenGL-ES-EGL-实现库" class="headerlink" title="4.3.1、OpenGL ES/EGL 实现库"></a>4.3.1、OpenGL ES/EGL 实现库</h5><p>如果Android系统平台支持 OpenGL ES 硬件加速渲染，那么 OpenGL ES/EGL 实现库由系统厂商以.so的共享链接库的形式提供，例如，高通的实现：system\vendor\lib\egl</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">libEGL_adreno.so </span><br><span class="line">libGLESv1_CM_adreno.so</span><br><span class="line">libGLESv2_adreno.so</span><br></pre></td></tr></table></figure><p>如果Android系统平台不支持 OpenGL ES 硬件加速渲染，那么它就会默认启用软件模拟渲染，这时 OpenGL ES/EGL 实现库就是由 AOSP 提供，链接库的存在的路径为： /system/lib64/egl/libGLES_android.so。而 libGLES_android.so 库在 Android 7.1 系统对应的实现源码路径为：/frameworks/native/opengl/libagl/ 。</p><h5 id="4-3-2、Android-7-1-中加载-OpenGL-ES-库的过程"><a href="#4-3-2、Android-7-1-中加载-OpenGL-ES-库的过程" class="headerlink" title="4.3.2、Android 7.1 中加载 OpenGL ES 库的过程"></a>4.3.2、Android 7.1 中加载 OpenGL ES 库的过程</h5><p>Android 中图形渲染所采用的方式（硬件 or 软件）是在系统启动之后动态确定的，而确定渲染方式的这个源码文件就是 /frameworks/native/opengl/libs/EGL/Loader.cpp 。</p><h5 id="4-3-2-1、-Android-7-1-OpenGL-ES-库和-EGL-库加载说明"><a href="#4-3-2-1、-Android-7-1-OpenGL-ES-库和-EGL-库加载说明" class="headerlink" title="4.3.2.1、 Android 7.1 OpenGL ES 库和 EGL 库加载说明"></a>4.3.2.1、 Android 7.1 OpenGL ES 库和 EGL 库加载说明</h5><p><a href="http://www.2net.co.uk/tutorial/android-egl-cgf-is-dead" target="_blank" rel="noopener">How Android finds OpenGL libraries, and the death of egl.cfg</a> 这篇文章中提到了非常关键的一点，就是从 Android Kitkat 4.4 之后，Android 中加载 OpenGL ES/EGL 库的方法发生了变化了（但是整个加载过程都是由 /frameworks/native/opengl/libs/EGL/Loader.cpp 程序所决定的，也就是说 Loader.cpp 文件发生了变化）。</p><p>在 Android 4.4 之前，加载 OpenGL ES 库是由 /system/lib/egl/egl.cfg 文件所决定的，通过读取这个配置文件来确定是加载 OpenGL ES 软件模拟实现的库，还是OpenGL ES 硬件加速实现的库。</p><p>但是，在Android 4.4 之后，Android 不再通过读取 egl.cfg 配置文件的方式来加载 OpenGL ES 库，新的加载 OpenGL ES 库的规则，如下所示：</p><p>从 /system/lib/egl 或者 /system/vendor/lib/egl/ 目录下加载 libGLES.so 库文件或者 libEGL_vendor.so，libGLESv1_CM_vendor.so，libGLESv2<em>vendor.so 库文件。<br>为了向下兼容旧的库的命名方式，同样也会加载 /system/lib/egl 或者 /vendor/lib/egl/ 目录下的 libGLES</em><em>.so 或者 libEGL_</em>.so，libGLESv1CM<em>.so，libGLESv2_</em>.so 库文件。</p><h5 id="4-3-2-2、硬件加速渲染-or-软件模拟渲染？"><a href="#4-3-2-2、硬件加速渲染-or-软件模拟渲染？" class="headerlink" title="4.3.2.2、硬件加速渲染 or 软件模拟渲染？"></a>4.3.2.2、硬件加速渲染 or 软件模拟渲染？</h5><p>前面我们提到 OpenGL ES 库的实现方式有两种，一种是硬件加速实现，一种是软件模拟实现，那么系统是怎么确定加载那一种 OpenGL ES 库的呢？</p><p>Android 7.1 源码中负责加载 OpenGL ES/EGL 库部分的代码位于：/frameworks/native/opengl/libs/EGL/Loader.cpp 文件中，这个文件中代码的主要入口函数是 Loader::open() 函数，而决定加载硬件加速渲染库还是软件模拟渲染库主要涉及到下面两个函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setEmulatorGlesValue()</span><br><span class="line">checkGlesEmulationStatus()</span><br></pre></td></tr></table></figure><p>下面就来简要的分析一下 Android 系统是如何选择加载硬件加速渲染库还是软件模拟渲染库：</p><p>首先，Loader::open() 入口函数会调用 setEmulatorGlesValue() 从 property 属性系统中获取一些属性值来判断当前 Android 系统是否在 Emulator 环境中运行，并根据读取出来的信息来重新设置新的属性键值对，setEmulatorGlesValue() 函数的代码如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/native/opengl/libs/EGL/Loader.cpp]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setEmulatorGlesValue</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">char</span> prop[PROPERTY_VALUE_MAX];</span><br><span class="line">     property_get(<span class="string">"ro.kernel.qemu"</span>, prop, <span class="string">"0"</span>); <span class="comment">//读取 ro.kernel.qemu 属性值，判断Android系统是否运行在 qemu 中</span></span><br><span class="line">     <span class="keyword">if</span> (atoi(prop) != <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">     property_get(<span class="string">"ro.kernel.qemu.gles"</span>, prop, <span class="string">"0"</span>); <span class="comment">//读取 ro.kernel.qemu.gles 属性值，判断 qemu 中 OpenGL ES 库的实现方式</span></span><br><span class="line">     <span class="keyword">if</span> (atoi(prop) == <span class="number">1</span>) &#123;</span><br><span class="line">         ALOGD(<span class="string">"Emulator has host GPU support, qemu.gles is set to 1."</span>);</span><br><span class="line">         property_set(<span class="string">"qemu.gles"</span>, <span class="string">"1"</span>);</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">// for now, checking the following</span></span><br><span class="line">     <span class="comment">// directory is good enough for emulator system images</span></span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">char</span>* vendor_lib_path =</span><br><span class="line"> #<span class="keyword">if</span> defined(__LP64__)</span><br><span class="line">         <span class="string">"/vendor/lib64/egl"</span>;</span><br><span class="line"> <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">         <span class="string">"/vendor/lib/egl"</span>;</span><br><span class="line"> <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">bool</span> has_vendor_lib = (access(vendor_lib_path, R_OK) == <span class="number">0</span>);</span><br><span class="line">     <span class="comment">//如果存在 vendor_lib_path 这个路径，那么就说明厂商提供了 OpenGL ES库自己的软件模拟渲染库，而不是 Android 系统自己编译得到的软件模拟渲染库</span></span><br><span class="line">     <span class="keyword">if</span> (has_vendor_lib) &#123;</span><br><span class="line">         ALOGD(<span class="string">"Emulator has vendor provided software renderer, qemu.gles is set to 2."</span>);</span><br><span class="line">         property_set(<span class="string">"qemu.gles"</span>, <span class="string">"2"</span>);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         ALOGD(<span class="string">"Emulator without GPU support detected. "</span></span><br><span class="line">               <span class="string">"Fallback to legacy software renderer, qemu.gles is set to 0."</span>);</span><br><span class="line">         property_set(<span class="string">"qemu.gles"</span>, <span class="string">"0"</span>); <span class="comment">//最后，默认采取的是方案就是调用传统的Android系统自己编译得到软件模拟渲染库</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在 load_system_driver() 函数中，内部类 MatchFile 类中会调用 checkGlesEmulationStatus() 函数来检查 Android 系统是否运行在模拟器中，以及在模拟器中是否启用了主机硬件加速的功能，然后根据 checkGlesEmulationStatus() 函数的返回状态值来确定要加载共享链接库的文件绝对路径。load_system_driver() 和 checkGlesEmulationStatus() 函数代码如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/native/opengl/libs/EGL/Loader.cpp]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">load_system_driver</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* kind)</span> </span>&#123;</span><br><span class="line">     ATRACE_CALL();</span><br><span class="line">     <span class="class"><span class="keyword">class</span> <span class="title">MatchFile</span> &#123;</span></span><br><span class="line">     <span class="keyword">public</span>:</span><br><span class="line">         <span class="comment">//这个函数作用是返回需要加载打开的 OpenGL ES 和 EGL API 实现库文件的绝对路径</span></span><br><span class="line">         <span class="function"><span class="keyword">static</span> String8 <span class="title">find</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* kind)</span> </span>&#123;</span><br><span class="line">             String8 result;</span><br><span class="line">             <span class="keyword">int</span> emulationStatus = checkGlesEmulationStatus(); <span class="comment">//检查 Android 系统是否运行在模拟器中，以及在模拟器中是否启用了主机硬件加速的功能</span></span><br><span class="line">             <span class="keyword">switch</span> (emulationStatus) &#123;</span><br><span class="line">             <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">//Android 运行在模拟器中，使用系统软件模拟实现的 OpenGL ES API 库 libGLES_android.so</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">if</span> defined(__LP64__)</span></span><br><span class="line">                 result.setTo(<span class="string">"/system/lib64/egl/libGLES_android.so"</span>);</span><br><span class="line"> <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">                 result.setTo(<span class="string">"/system/lib/egl/libGLES_android.so"</span>);</span><br><span class="line"> <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                 <span class="keyword">return</span> result;</span><br><span class="line">             <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// Android 运行在模拟器中，通过主机系统中实现 OpenGL ES 加速渲染，通过 libGLES_emulation.so 库将  OpenGL ES API 指令重定向到 host 中执行</span></span><br><span class="line">                 <span class="comment">// Use host-side OpenGL through the "emulation" library</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">if</span> defined(__LP64__)</span></span><br><span class="line">                 result.appendFormat(<span class="string">"/system/lib64/egl/lib%s_emulation.so"</span>, kind);</span><br><span class="line"> <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">                 result.appendFormat(<span class="string">"/system/lib/egl/lib%s_emulation.so"</span>, kind);</span><br><span class="line"> <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                 <span class="keyword">return</span> result;</span><br><span class="line">             <span class="keyword">default</span>:</span><br><span class="line">                 <span class="comment">// Not in emulator, or use other guest-side implementation</span></span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">    </span><br><span class="line">             <span class="comment">// 如果不是上面两种情况，就根据库的命名规则去找到厂商实现库文件的绝对路径</span></span><br><span class="line">             String8 pattern;</span><br><span class="line">             pattern.appendFormat(<span class="string">"lib%s"</span>, kind);</span><br><span class="line">             <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> searchPaths[] = &#123;</span><br><span class="line"> #<span class="keyword">if</span> defined(__LP64__)</span><br><span class="line">                 <span class="string">"/vendor/lib64/egl"</span>,</span><br><span class="line">                 <span class="string">"/system/lib64/egl"</span></span><br><span class="line"> #<span class="keyword">else</span></span><br><span class="line">                 <span class="string">"/vendor/lib/egl"</span>,</span><br><span class="line">                 <span class="string">"/system/lib/egl"</span></span><br><span class="line"> #endif</span><br><span class="line">             &#125;;</span><br><span class="line">                </span><br><span class="line">             ......</span><br><span class="line">     &#125;</span><br><span class="line">        </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>总结一下上面代码的功能就是，首先判断 Android 是否在 qemu 虚拟机中运行，如果不是，那么就直接去加载厂商存放库的路径中去加载 OpenGL ES 实现库（不管是硬件加速实现的，还是软件模拟实现的）；如果是在 qemu 中运行，那么就要根据返回的 emulationStatus 值 来确定是加软件模拟实现的 OpenGL ES API 库 libGLES_android.so，还是加载 libGLES_emulation.so库将 OpenGL ES 指令重定向到 Host 系统中去执行。</p><h5 id="4-3-3、OpenGL-ES-EGL-库加载和解析过程"><a href="#4-3-3、OpenGL-ES-EGL-库加载和解析过程" class="headerlink" title="4.3.3、OpenGL ES/EGL 库加载和解析过程"></a>4.3.3、OpenGL ES/EGL 库加载和解析过程</h5><p>正如前面分析，在进行 OpenGL 编程时，最先开始需要获取 Display，这将调用 eglgGetDisplay() 函数被调用。在 eglGetDisplay() 里则会调用 egl_init_drivers() 初始化驱动：装载各个库进行解析，将 OpenGL ES/EGL API 函数接口和具体的实现绑定在一起，并将结果保存在 egl_connection_t 类型的全局变量 gEGLImpl 的结构体的成员变量中。</p><p>下面以 SurfaceFlinger 进程init()为例进行分析，整个 OpenGL ES/EGL 库的加载和解析流程如下所示：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-02-19-SF_init.png" alt="Alt text | center"></p><p>这里通过调用 EGL 库的 eglGetDisplay() 获得 Display。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\native\opengl\libs\EGL\eglApi.cpp]</span><br><span class="line"><span class="function">EGLDisplay <span class="title">eglGetDisplay</span><span class="params">(EGLNativeDisplayType display)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (egl_init_drivers() == EGL_FALSE) &#123;</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_PARAMETER, EGL_NO_DISPLAY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EGLDisplay dpy = <span class="keyword">egl_display_t</span>::getFromNativeDisplay(display);</span><br><span class="line">    <span class="keyword">return</span> dpy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数EGLBoolean egl_init_drivers()就是负责OpenGL库的加载。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\native\opengl\libs\EGL\egl.cpp]</span><br><span class="line"><span class="function">EGLBoolean <span class="title">egl_init_drivers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EGLBoolean res;</span><br><span class="line">    pthread_mutex_lock(&amp;sInitDriverMutex);</span><br><span class="line">    res = egl_init_drivers_locked();</span><br><span class="line">    pthread_mutex_unlock(&amp;sInitDriverMutex);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为保证多线程访问的安全性，使用线程锁来放完另一个接口函数egl_init_drivers_locked()<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\native\opengl\libs\EGL\egl.cpp]</span><br><span class="line"><span class="comment">//在该文件起始位置定义的全局变量</span></span><br><span class="line"><span class="keyword">egl_connection_t</span> gEGLImpl; <span class="comment">// 描述EGL实现内容的结构体对象</span></span><br><span class="line"><span class="keyword">gl_hooks_t</span> gHooks[<span class="number">2</span>]; <span class="comment">// gl_hooks_t 是包含 OpenGL ES API 函数声明对应的函数指针结构体</span></span><br><span class="line"><span class="keyword">gl_hooks_t</span> gHooksNoContext;</span><br><span class="line"><span class="keyword">pthread_key_t</span> gGLWrapperKey = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> EGLBoolean <span class="title">egl_init_drivers_locked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sEarlyInitState) &#123;</span><br><span class="line">        <span class="comment">// initialized by static ctor. should be set here.</span></span><br><span class="line">        <span class="keyword">return</span> EGL_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到 Loader 对象单例</span></span><br><span class="line">    <span class="comment">// get our driver loader</span></span><br><span class="line">    Loader&amp; loader(Loader::getInstance());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  gEGLImple 是一个全局变量，数据类型为 egl_connection_t 结构体类型</span></span><br><span class="line">    <span class="comment">// dynamically load our EGL implementation</span></span><br><span class="line">    <span class="keyword">egl_connection_t</span>* cnx = &amp;gEGLImpl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cnx-&gt;dso 本质上是一个 (void *)类型的指针，它指向的对象是 EGL 共享库打开之后的句柄</span></span><br><span class="line">    <span class="keyword">if</span> (cnx-&gt;dso == <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="comment">// &gt;= 将cnx中的 hooks 数组中指向OpenGL ES API 函数指针结构体指的数组成员，用 gHooks 中的成员的地址去初始化</span></span><br><span class="line">        <span class="comment">//也就是说 gEGLImpl 中 hook 数组指向 gHooks 数组，最终指向同一个 OpenGL ES API 函数指针的实现</span></span><br><span class="line">        cnx-&gt;hooks[<span class="keyword">egl_connection_t</span>::GLESv1_INDEX] =</span><br><span class="line">            &amp;gHooks[<span class="keyword">egl_connection_t</span>::GLESv1_INDEX];</span><br><span class="line">        cnx-&gt;hooks[<span class="keyword">egl_connection_t</span>::GLESv2_INDEX] =</span><br><span class="line">            &amp;gHooks[<span class="keyword">egl_connection_t</span>::GLESv2_INDEX];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// &gt;= 最后通过loader对象的open函数开始加载 OpenGL ES 和 EGL wrapper 库</span></span><br><span class="line">        cnx-&gt;dso = loader.open(cnx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cnx-&gt;dso ? EGL_TRUE : EGL_FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这个函数中，有一个非常关键的 egl_connection_t 指针指向一个全局变量 gEGLImpl，当第一次初始化加载 OpenGL ES 实现库和 EGL 实现库时，还需要将 gEGLImpl 中的 hooks 数组中的两个指针指向一个全局的 gl_hooks_t 数组 gHooks（这就是两个指针钩子，最终初始化完成后将分别勾住 OpenGL ES 1.0 和 OpenGL ES 2.0 的实现库），接着调用 Loader 类的实例的 open() 函数完成从 OpenGL ES 实现库中完成符号解析工作。</p><p>Loader::open() 函数的代码如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[/frameworks/native/opengl/libs/EGL/Loader.cpp]</span><br><span class="line"><span class="comment">// &gt;= Loader 类对象构造完成后，就在 /EGL/egl.cpp 文件中的 egl_init_drivers_locked() 中被调用</span></span><br><span class="line"><span class="keyword">void</span>* Loader::open(<span class="keyword">egl_connection_t</span>* cnx)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span>* dso;</span><br><span class="line">    <span class="keyword">driver_t</span>* hnd = <span class="number">0</span>;</span><br><span class="line">    setEmulatorGlesValue();</span><br><span class="line">    dso = load_driver(<span class="string">"GLES"</span>, cnx, EGL | GLESv1_CM | GLESv2);</span><br><span class="line">    <span class="keyword">if</span> (dso) &#123;</span><br><span class="line">        hnd = <span class="keyword">new</span> <span class="keyword">driver_t</span>(dso);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Always load EGL first</span></span><br><span class="line">        dso = load_driver(<span class="string">"EGL"</span>, cnx, EGL);</span><br><span class="line">        <span class="keyword">if</span> (dso) &#123;</span><br><span class="line">            hnd = <span class="keyword">new</span> <span class="keyword">driver_t</span>(dso);</span><br><span class="line">            hnd-&gt;<span class="built_in">set</span>( load_driver(<span class="string">"GLESv1_CM"</span>, cnx, GLESv1_CM), GLESv1_CM );</span><br><span class="line">            hnd-&gt;<span class="built_in">set</span>( load_driver(<span class="string">"GLESv2"</span>,    cnx, GLESv2),    GLESv2 );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    cnx-&gt;libEgl   = load_wrapper(EGL_WRAPPER_DIR <span class="string">"/libEGL.so"</span>);</span><br><span class="line">    cnx-&gt;libGles2 = load_wrapper(EGL_WRAPPER_DIR <span class="string">"/libGLESv2.so"</span>);</span><br><span class="line">    cnx-&gt;libGles1 = load_wrapper(EGL_WRAPPER_DIR <span class="string">"/libGLESv1_CM.so"</span>);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*)hnd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>open() 函数主要负责 OpenGL ES 库加载前的准备工作，具体的加载细节，则是通过调用 load_driver() 去完成的。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">[/frameworks/native/opengl/libs/EGL/Loader.cpp]</span><br><span class="line">oid *Loader::load_driver(<span class="keyword">const</span> <span class="keyword">char</span>* kind,</span><br><span class="line">                          <span class="keyword">egl_connection_t</span>* cnx, <span class="keyword">uint32_t</span> mask)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span>* dso = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (mGetDriverNamespace) &#123;</span><br><span class="line">        <span class="keyword">android_namespace_t</span>* ns = mGetDriverNamespace();</span><br><span class="line">        <span class="keyword">if</span> (ns) &#123;</span><br><span class="line">            dso = load_updated_driver(kind, ns); <span class="comment">//加载 OpenGL ES 实现库，放回打开的共享链接库的句柄</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!dso) &#123;</span><br><span class="line">        dso = load_system_driver(kind);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析 EGL 库，并将wrapper 库 libEGL.so 中的函数 API 指针和具体的实现绑定在一起</span></span><br><span class="line">    <span class="keyword">if</span> (mask &amp; EGL) &#123;</span><br><span class="line">        getProcAddress = (getProcAddressType)dlsym(dso, <span class="string">"eglGetProcAddress"</span>);</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">egl_t</span>* egl = &amp;cnx-&gt;egl; <span class="comment">//将 egl 指针指向描述当前系统支持 OpenGL ES和 EGL 全局变量的 gEGLImpl</span></span><br><span class="line">        __eglMustCastToProperFunctionPointerType* curr =</span><br><span class="line">            (__eglMustCastToProperFunctionPointerType*)egl;</span><br><span class="line">        <span class="keyword">char</span> <span class="keyword">const</span> * <span class="keyword">const</span> * api = egl_names; <span class="comment">//egl_names 是定义在 egl.cpp 文件中的一个数组，数组中的元素是 EGL API 函数指针</span></span><br><span class="line">        <span class="keyword">while</span> (*api) &#123;</span><br><span class="line">            <span class="keyword">char</span> <span class="keyword">const</span> * name = *api;</span><br><span class="line">            __eglMustCastToProperFunctionPointerType f =</span><br><span class="line">                (__eglMustCastToProperFunctionPointerType)dlsym(dso, name);</span><br><span class="line">            <span class="keyword">if</span> (f == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">// couldn't find the entry-point, use eglGetProcAddress()</span></span><br><span class="line">                f = getProcAddress(name);</span><br><span class="line">                <span class="keyword">if</span> (f == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    f = (__eglMustCastToProperFunctionPointerType)<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            *curr++ = f; <span class="comment">//这一步就是最关键的将共享链接库中的 EGL API 的实现和上层调用的 API 函数指针绑定在一起</span></span><br><span class="line">            api++; <span class="comment">//指向下一个需要绑定的 api 函数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析 OpenGL ES 库中的 OpenGL ES 1.x API 符号</span></span><br><span class="line">    <span class="keyword">if</span> (mask &amp; GLESv1_CM) &#123;</span><br><span class="line">        <span class="comment">// 调用 init_api 实现 OpenGL API 和对应实现函数的绑定</span></span><br><span class="line">        init_api(dso, gl_names, <span class="comment">// gl_names 是定义在 egl.cpp 文件中的一个数组，数组中的元素是 OpenGL ES API 函数指针</span></span><br><span class="line">                 (__eglMustCastToProperFunctionPointerType*)</span><br><span class="line">                 &amp;cnx-&gt;hooks[<span class="keyword">egl_connection_t</span>::GLESv1_INDEX]-&gt;gl, <span class="comment">//gl成员变量是一个结构体变量，结构体中的是 OpenGL ES API 函数指针</span></span><br><span class="line">                 getProcAddress);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析 OpenGL ES 库中的 OpenGL ES 2.0 API 符号</span></span><br><span class="line">    <span class="keyword">if</span> (mask &amp; GLESv2) &#123;</span><br><span class="line">        init_api(dso, gl_names,</span><br><span class="line">                 (__eglMustCastToProperFunctionPointerType*)</span><br><span class="line">                 &amp;cnx-&gt;hooks[<span class="keyword">egl_connection_t</span>::GLESv2_INDEX]-&gt;gl,</span><br><span class="line">                 getProcAddress);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dso;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Loader::load_driver() 它主要实现了两个功能：</p><p>通过 load_system_driver()  函数查找 OpenGL ES/EGL 实现库，并在指定的存放路径中找到共享链接库文件并打开它。<br>调用 init_api()解析打开的 OpenGL ES/EGL 共享链接库，将 OpenGL ES/EGL API 函数指针和共享链接库中实现的对应的函数符号绑定在一起，这样调用 OpenGL ES/EGL API 就会调用到具体实现的OpenGL ES/EGL 共享链接库中对应函数。</p><h5 id="4-4、小结"><a href="#4-4、小结" class="headerlink" title="4.4、小结"></a>4.4、小结</h5><p>Android OpenGL ES 图形库结构<br>Android 的 OpenGL ES 图形系统涉及多个库，根据设备类型的不同，这些库有着不同的结构。</p><p>对于模拟器，没有开启 OpenGL ES 的 GPU 硬件模拟的情况，Android OpenGL ES 图形库结构如下：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-02-20-opencl-egl-imp.png" alt="Alt text | center"></p><p>当为模拟器开启了 OpenGL ES 的 GPU 硬件模拟，实际的 EGL 和 OpenGL ES 实现库会采用由 android-7.1.1_r22/device/generic/goldfish-opengl 下的源码编译出来的几个库文件，即 libGLESv2_emulation.so、libGLESv1_CM_emulation.so 和 libEGL_emulation.so。此时，OpenGL ES 图形库结构如下：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-02-21-opencl-egl-imp-emulate.png" alt="Alt text | center"></p><p>对于真实的物理 Android 设备，OpenGL ES 图形库结构如下，例如高通实现（libEGL_adreno.so<br>libGLESv1_CM_adreno.so libGLESv2_adreno.so [\system\vendor\lib64\egl]）：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-02-22-opencl-egl-imp-qcom-adreno.png" alt="Alt text | center"></p><p>####（五）、OpenGL ES：EGL接口解析与理解</p><p>由前面的分析知道EGL的绘图的一般步骤如下，接下来分析主要的1-8个小步骤：</p><blockquote><p>使用EGL的绘图的一般步骤：<br>1、获取 EGL Display 对象：eglGetDisplay()<br>2、初始化与 EGLDisplay 之间的连接：eglInitialize()<br>3、获取 EGLConfig 对象：eglChooseConfig()<br>4、创建 EGLContext 实例：eglCreateContext()<br>5、创建 EGLSurface 实例：eglCreateWindowSurface()<br>6、连接 EGLContext 和 EGLSurface：eglMakeCurrent()<br>7、使用 OpenGL ES API 绘制图形：gl_*()<br>8、切换 front buffer 和 back buffer 送显：eglSwapBuffer()<br>9、断开并释放与 EGLSurface 关联的 EGLContext 对象：eglRelease()<br>10、删除 EGLSurface 对象<br>11、删除 EGLContext 对象<br>12、终止与 EGLDisplay 之间的连接</p></blockquote><p>标准 EGL 数据类型如下所示：</p><p>EGLBoolean ——EGL_TRUE =1, EGL_FALSE=0<br>EGLint ——int 数据类型<br>EGLDisplay ——系统显示 ID 或句柄，可以理解为一个前端的显示窗口<br>EGLConfig ——Surface的EGL配置，可以理解为绘制目标framebuffer的配置属性<br>EGLSurface ——系统窗口或 frame buffer 句柄 ，可以理解为一个后端的渲染目标窗口。<br>EGLContext ——OpenGL ES 图形上下文，它代表了OpenGL状态机；如果没有它，OpenGL指令就没有执行的环境。</p><p>下面几个类型比较复杂，通过例子可以更深入的理解。这里要说明的是这几个类型在不同平台其实现是不同的，EGL只提供抽象标准。</p><p>NativeDisplayType——Native 系统显示类型，标识你所开发设备的物理屏幕<br>NativeWindowType ——Native 系统窗口缓存类型，标识系统窗口<br>NativePixmapType ——Native 系统 frame buffer，可以作为 Framebuffer 的系统图像（内存）数据类型，该类型只用于离屏渲染.</p><h5 id="5-1、eglGetDisplay"><a href="#5-1、eglGetDisplay" class="headerlink" title="5.1、eglGetDisplay()"></a>5.1、eglGetDisplay()</h5><p>EGLDisplay 是一个关联系统物理屏幕的通用数据类型，表示显示设备句柄，也可以认为是一个前端显示窗。为了使用系统的显示设备， EGL 提供了 EGLDisplay 数据类型，以及一组操作设备显示的 API 。<br>下面的函数原型用于获取 Native Display ：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\native\opengl\libagl\egl.cpp]</span><br><span class="line"><span class="function">EGLDisplay <span class="title">eglGetDisplay</span><span class="params">(NativeDisplayType display)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">if</span> (display == EGL_DEFAULT_DISPLAY) &#123;</span><br><span class="line">        EGLDisplay dpy = (EGLDisplay)<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">egl_display_t</span>&amp; d = <span class="keyword">egl_display_t</span>::get_display(dpy);</span><br><span class="line">        d.type = display;</span><br><span class="line">        <span class="keyword">return</span> dpy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> EGL_NO_DISPLAY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">egl_display_t</span>&amp; <span class="keyword">egl_display_t</span>::get_display(EGLDisplay dpy) &#123;</span><br><span class="line">    <span class="keyword">return</span> gDisplays[<span class="keyword">uintptr_t</span>(dpy)<span class="number">-1U</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其 中 display 参数是 native 系统的窗口显示 ID 值。如果你只是想得到一个系统默认的 Display ，你可以使用 EGL_DEFAULT_DISPLAY 参数。如果系统中没有一个可用的 native display ID 与给定的 display 参数匹配，函数将返回 EGL_NO_DISPLAY ，而没有任何 Error 状态被设置。</p><h5 id="5-2、eglInitialize"><a href="#5-2、eglInitialize" class="headerlink" title="5.2、eglInitialize()"></a>5.2、eglInitialize()</h5><p>每个 EGLDisplay 在使用前都需要初始化。初始化 EGLDisplay 的同时，你可以得到系统中 EGL 的实现版本号。了解当前的版本号在向后兼容性方面是非常有价值的。在移动设备上，通过动态查询 EGL 版本号，你可以为新旧版本的 EGL 附加额外的特性或运行环境。基于平台配置，软件开发可用清楚知道哪些 API 可用访问，这将会为你的代码提供最大限度的可移植性。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\native\opengl\libagl\egl.cpp]</span><br><span class="line"><span class="function">EGLBoolean <span class="title">eglInitialize</span><span class="params">(EGLDisplay dpy, EGLint *major, EGLint *minor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">egl_display_t</span>::is_valid(dpy) == EGL_FALSE)</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_DISPLAY, EGL_FALSE);</span><br><span class="line"></span><br><span class="line">    EGLBoolean res = EGL_TRUE;</span><br><span class="line">    <span class="keyword">egl_display_t</span>&amp; d = <span class="keyword">egl_display_t</span>::get_display(dpy);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (d.initialized.fetch_add(<span class="number">1</span>, <span class="built_in">std</span>::memory_order_acquire) == <span class="number">0</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res == EGL_TRUE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (major != <span class="literal">NULL</span>) *major = VERSION_MAJOR;</span><br><span class="line">        <span class="keyword">if</span> (minor != <span class="literal">NULL</span>) *minor = VERSION_MINOR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中 dpy 应该是一个有效的 EGLDisplay 。函数返回时， major 和 minor 将被赋予当前 EGL 版本号。比如 EGL1.0 ， major 返回 1 ， minor 则返回 0 。给 major 和 minor 传 NULL 是有效的，如果你不关心版本号。<br>eglQueryString() 函数是另外一个获取版本信息和其他信息的途径。通过 eglQueryString() 获取版本信息需要解析版本字符串，所以通过传递一个指针给 eglInitializ() 函数比较容易获得这个信息。注意在调用 eglQueryString() 必须先使用 eglInitialize() 初始化 EGLDisplay ，否则将得到 EGL_NOT_INITIALIZED 错误信息。</p><h5 id="5-3、eglChooseConfig"><a href="#5-3、eglChooseConfig" class="headerlink" title="5.3、eglChooseConfig()"></a>5.3、eglChooseConfig()</h5><p>基 于 EGL 的属性，可以得到一个和需求接近的Config，但也可以选择自己需要的Config，只要平台支持。不是所有的Config都是有效的，也就是不是所有Config都会支持。 eglChooseConfig() 函数将适配一个所期望的配置，并且尽可能接近一个有效的系统配置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\native\opengl\libagl\egl.cpp]</span><br><span class="line"><span class="function">EGLBoolean <span class="title">eglChooseConfig</span><span class="params">( EGLDisplay dpy, <span class="keyword">const</span> EGLint *attrib_list,</span></span></span><br><span class="line"><span class="function"><span class="params">                            EGLConfig *configs, EGLint config_size,</span></span></span><br><span class="line"><span class="function"><span class="params">                            EGLint *num_config)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">egl_display_t</span>::is_valid(dpy) == EGL_FALSE)</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_DISPLAY, EGL_FALSE);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (ggl_unlikely(num_config==<span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_PARAMETER, EGL_FALSE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ggl_unlikely(attrib_list==<span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * A NULL attrib_list should be treated as though it was an empty</span></span><br><span class="line"><span class="comment">         * one (terminated with EGL_NONE) as defined in</span></span><br><span class="line"><span class="comment">         * section 3.4.1 "Querying Configurations" in the EGL specification.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> EGLint dummy = EGL_NONE;</span><br><span class="line">        attrib_list = &amp;dummy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numAttributes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> numConfigs =  NELEM(gConfigs);</span><br><span class="line">    <span class="keyword">uint32_t</span> possibleMatch = (<span class="number">1</span>&lt;&lt;numConfigs)<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(possibleMatch &amp;&amp; *attrib_list != EGL_NONE) &#123;</span><br><span class="line">        numAttributes++;</span><br><span class="line">        EGLint attr = *attrib_list++;</span><br><span class="line">        EGLint val  = *attrib_list++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span> ; possibleMatch &amp;&amp; i&lt;numConfigs ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(possibleMatch &amp; (<span class="number">1</span>&lt;&lt;i)))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (isAttributeMatching(i, attr, val) == <span class="number">0</span>) &#123;</span><br><span class="line">                possibleMatch &amp;= ~(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// now, handle the attributes which have a useful default value</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> j=<span class="number">0</span> ; possibleMatch &amp;&amp; j&lt;NELEM(config_defaults) ; j++) &#123;</span><br><span class="line">        <span class="comment">// see if this attribute was specified, if not, apply its</span></span><br><span class="line">        <span class="comment">// default value</span></span><br><span class="line">        <span class="keyword">if</span> (binarySearch&lt;<span class="keyword">config_pair_t</span>&gt;(</span><br><span class="line">                (<span class="keyword">config_pair_t</span> <span class="keyword">const</span>*)attrib_list,</span><br><span class="line">                <span class="number">0</span>, numAttributes<span class="number">-1</span>,</span><br><span class="line">                config_defaults[j].key) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span> ; possibleMatch &amp;&amp; i&lt;numConfigs ; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!(possibleMatch &amp; (<span class="number">1</span>&lt;&lt;i)))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (isAttributeMatching(i,</span><br><span class="line">                        config_defaults[j].key,</span><br><span class="line">                        config_defaults[j].value) == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    possibleMatch &amp;= ~(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return the configurations found</span></span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (possibleMatch) &#123;</span><br><span class="line">        <span class="keyword">if</span> (configs) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span> ; config_size &amp;&amp; i&lt;numConfigs ; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (possibleMatch &amp; (<span class="number">1</span>&lt;&lt;i)) &#123;</span><br><span class="line">                    *configs++ = (EGLConfig)(<span class="keyword">uintptr_t</span>)i;</span><br><span class="line">                    config_size--;</span><br><span class="line">                    n++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;numConfigs ; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (possibleMatch &amp; (<span class="number">1</span>&lt;&lt;i)) &#123;</span><br><span class="line">                    n++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *num_config = n;</span><br><span class="line">     <span class="keyword">return</span> EGL_TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数 attrib_list 指定了选择配置时需要参照的属性。参数 configs 将返回一个按照 attrib_list 排序的平台有效的所有 EGL framebuffer 配置列表。参数 config_size 指定了可以返回到 configs 的总配置个数。参数 num_config 返回了实际匹配的配置总数。</p><h5 id="5-4、eglCreateContext"><a href="#5-4、eglCreateContext" class="headerlink" title="5.4、eglCreateContext()"></a>5.4、eglCreateContext()</h5><p>OpenGL ES的pipeline从程序的角度看就是一个状态机，有当前的颜色、纹理坐标、变换矩阵、绚染模式等一大堆状态，这些状态作用于OpenGL API程序提交的顶点坐标等图元从而形成帧缓冲内的像素。在OpenGL的编程接口中，Context就代表这个状态机，OpenGL API程序的主要工作就是向Context提供图元、设置状态，偶尔也从Context里获取一些信息。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\native\opengl\libagl\egl.cpp]</span><br><span class="line"><span class="function">EGLContext <span class="title">eglCreateContext</span><span class="params">(EGLDisplay dpy, EGLConfig config,</span></span></span><br><span class="line"><span class="function"><span class="params">                            EGLContext <span class="comment">/*share_list*/</span>, <span class="keyword">const</span> EGLint* <span class="comment">/*attrib_list*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">egl_display_t</span>::is_valid(dpy) == EGL_FALSE)</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_DISPLAY, EGL_NO_SURFACE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ogles_context_t</span>* gl = ogles_init(<span class="keyword">sizeof</span>(<span class="keyword">egl_context_t</span>));</span><br><span class="line">    <span class="keyword">if</span> (!gl) <span class="keyword">return</span> setError(EGL_BAD_ALLOC, EGL_NO_CONTEXT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">egl_context_t</span>* c = <span class="keyword">static_cast</span>&lt;<span class="keyword">egl_context_t</span>*&gt;(gl-&gt;rasterizer.base);</span><br><span class="line">    c-&gt;flags = <span class="keyword">egl_context_t</span>::NEVER_CURRENT;</span><br><span class="line">    c-&gt;dpy = dpy;</span><br><span class="line">    c-&gt;config = config;</span><br><span class="line">    c-&gt;read = <span class="number">0</span>;</span><br><span class="line">    c-&gt;draw = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (EGLContext)gl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="5-5、eglCreateWindowSurface"><a href="#5-5、eglCreateWindowSurface" class="headerlink" title="5.5、eglCreateWindowSurface()"></a>5.5、eglCreateWindowSurface()</h5><p>Surface实际上就是一个FrameBuffer，也就是渲染目的地，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\native\opengl\libagl\egl.cpp]</span><br><span class="line"><span class="function">EGLSurface <span class="title">eglCreateWindowSurface</span><span class="params">(  EGLDisplay dpy, EGLConfig config,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    NativeWindowType window,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">const</span> EGLint *attrib_list)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createWindowSurface(dpy, config, window, attrib_list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> EGLSurface <span class="title">createWindowSurface</span><span class="params">(EGLDisplay dpy, EGLConfig config,</span></span></span><br><span class="line"><span class="function"><span class="params">        NativeWindowType window, <span class="keyword">const</span> EGLint* <span class="comment">/*attrib_list*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">egl_display_t</span>::is_valid(dpy) == EGL_FALSE)</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_DISPLAY, EGL_NO_SURFACE);</span><br><span class="line">    <span class="keyword">if</span> (window == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_MATCH, EGL_NO_SURFACE);</span><br><span class="line"></span><br><span class="line">    EGLint surfaceType;</span><br><span class="line">    <span class="keyword">if</span> (getConfigAttrib(dpy, config, EGL_SURFACE_TYPE, &amp;surfaceType) == EGL_FALSE)</span><br><span class="line">        <span class="keyword">return</span> EGL_FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(surfaceType &amp; EGL_WINDOW_BIT))</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_MATCH, EGL_NO_SURFACE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">static_cast</span>&lt;ANativeWindow*&gt;(window)-&gt;common.magic !=</span><br><span class="line">            ANDROID_NATIVE_WINDOW_MAGIC) &#123;</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_NATIVE_WINDOW, EGL_NO_SURFACE);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    EGLint configID;</span><br><span class="line">    <span class="keyword">if</span> (getConfigAttrib(dpy, config, EGL_CONFIG_ID, &amp;configID) == EGL_FALSE)</span><br><span class="line">        <span class="keyword">return</span> EGL_FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int32_t</span> depthFormat;</span><br><span class="line">    <span class="keyword">int32_t</span> pixelFormat;</span><br><span class="line">    <span class="keyword">if</span> (getConfigFormatInfo(configID, pixelFormat, depthFormat) != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_MATCH, EGL_NO_SURFACE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">egl_surface_t</span>* surface;</span><br><span class="line">    surface = <span class="keyword">new</span> <span class="keyword">egl_window_surface_v2_t</span>(dpy, config, depthFormat,</span><br><span class="line">            <span class="keyword">static_cast</span>&lt;ANativeWindow*&gt;(window));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!surface-&gt;initCheck()) &#123;</span><br><span class="line">        <span class="keyword">delete</span> surface;</span><br><span class="line">        surface = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> surface;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来创建一个可实际显示的Surface。</p><p>系统通常还支持另外两种Surface：PixmapSurface和PBufferSurface，这两种都不是可显示的Surface，PixmapSurface是保存在系统内存中的位图，PBuffer则是保存在显存中的帧。</p><p>对于这两种surface，Android系统中，支持PBufferSurface。</p><h5 id="5-6、eglMakeCurrent"><a href="#5-6、eglMakeCurrent" class="headerlink" title="5.6、eglMakeCurrent()"></a>5.6、eglMakeCurrent()</h5><p>该接口将申请到的display，draw（surface）和 context进行了绑定。也就是说，在context下的OpenGLAPI指令将draw（surface）作为其渲染最终目的地。而display作为draw（surface）的前端显示。调用后，当前线程使用的EGLContex为context。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\native\opengl\libagl\egl.cpp]</span><br><span class="line"><span class="function">EGLBoolean <span class="title">eglMakeCurrent</span><span class="params">(  EGLDisplay dpy, EGLSurface draw,</span></span></span><br><span class="line"><span class="function"><span class="params">                            EGLSurface read, EGLContext ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">egl_display_t</span>::is_valid(dpy) == EGL_FALSE)</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_DISPLAY, EGL_FALSE);</span><br><span class="line">    <span class="keyword">if</span> (draw) &#123;</span><br><span class="line">        <span class="keyword">egl_surface_t</span>* s = (<span class="keyword">egl_surface_t</span>*)draw;</span><br><span class="line">        <span class="keyword">if</span> (!s-&gt;isValid())</span><br><span class="line">            <span class="keyword">return</span> setError(EGL_BAD_SURFACE, EGL_FALSE);</span><br><span class="line">        <span class="keyword">if</span> (s-&gt;dpy != dpy)</span><br><span class="line">            <span class="keyword">return</span> setError(EGL_BAD_DISPLAY, EGL_FALSE);</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> check that draw is compatible with the context</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (read &amp;&amp; read!=draw) &#123;</span><br><span class="line">        <span class="keyword">egl_surface_t</span>* s = (<span class="keyword">egl_surface_t</span>*)read;</span><br><span class="line">        <span class="keyword">if</span> (!s-&gt;isValid())</span><br><span class="line">            <span class="keyword">return</span> setError(EGL_BAD_SURFACE, EGL_FALSE);</span><br><span class="line">        <span class="keyword">if</span> (s-&gt;dpy != dpy)</span><br><span class="line">            <span class="keyword">return</span> setError(EGL_BAD_DISPLAY, EGL_FALSE);</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> check that read is compatible with the context</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EGLContext current_ctx = EGL_NO_CONTEXT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((read == EGL_NO_SURFACE &amp;&amp; draw == EGL_NO_SURFACE) &amp;&amp; (ctx != EGL_NO_CONTEXT))</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_MATCH, EGL_FALSE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((read != EGL_NO_SURFACE || draw != EGL_NO_SURFACE) &amp;&amp; (ctx == EGL_NO_CONTEXT))</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_MATCH, EGL_FALSE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ctx == EGL_NO_CONTEXT) &#123;</span><br><span class="line">        <span class="comment">// if we're detaching, we need the current context</span></span><br><span class="line">        current_ctx = (EGLContext)getGlThreadSpecific();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">egl_context_t</span>* c = <span class="keyword">egl_context_t</span>::context(ctx);</span><br><span class="line">        <span class="keyword">egl_surface_t</span>* d = (<span class="keyword">egl_surface_t</span>*)draw;</span><br><span class="line">        <span class="keyword">egl_surface_t</span>* r = (<span class="keyword">egl_surface_t</span>*)read;</span><br><span class="line">        <span class="keyword">if</span> ((d &amp;&amp; d-&gt;ctx &amp;&amp; d-&gt;ctx != ctx) ||</span><br><span class="line">            (r &amp;&amp; r-&gt;ctx &amp;&amp; r-&gt;ctx != ctx)) &#123;</span><br><span class="line">            <span class="comment">// one of the surface is bound to a context in another thread</span></span><br><span class="line">            <span class="keyword">return</span> setError(EGL_BAD_ACCESS, EGL_FALSE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ogles_context_t</span>* gl = (<span class="keyword">ogles_context_t</span>*)ctx;</span><br><span class="line">    <span class="keyword">if</span> (makeCurrent(gl) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ctx) &#123;</span><br><span class="line">            <span class="keyword">egl_context_t</span>* c = <span class="keyword">egl_context_t</span>::context(ctx);</span><br><span class="line">            <span class="keyword">egl_surface_t</span>* d = (<span class="keyword">egl_surface_t</span>*)draw;</span><br><span class="line">            <span class="keyword">egl_surface_t</span>* r = (<span class="keyword">egl_surface_t</span>*)read;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (c-&gt;draw) &#123;</span><br><span class="line">                <span class="keyword">egl_surface_t</span>* s = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">egl_surface_t</span>*&gt;(c-&gt;draw);</span><br><span class="line">                s-&gt;disconnect();</span><br><span class="line">                s-&gt;ctx = EGL_NO_CONTEXT;</span><br><span class="line">                <span class="keyword">if</span> (s-&gt;zombie)</span><br><span class="line">                    <span class="keyword">delete</span> s;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c-&gt;read) &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">FIXME:</span> unlock/disconnect the read surface too </span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            c-&gt;draw = draw;</span><br><span class="line">            c-&gt;read = read;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c-&gt;flags &amp; <span class="keyword">egl_context_t</span>::NEVER_CURRENT) &#123;</span><br><span class="line">                c-&gt;flags &amp;= ~<span class="keyword">egl_context_t</span>::NEVER_CURRENT;</span><br><span class="line">                GLint w = <span class="number">0</span>;</span><br><span class="line">                GLint h = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (draw) &#123;</span><br><span class="line">                    w = d-&gt;getWidth();</span><br><span class="line">                    h = d-&gt;getHeight();</span><br><span class="line">                &#125;</span><br><span class="line">                ogles_surfaceport(gl, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                ogles_viewport(gl, <span class="number">0</span>, <span class="number">0</span>, w, h);</span><br><span class="line">                ogles_scissor(gl, <span class="number">0</span>, <span class="number">0</span>, w, h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (d) &#123;</span><br><span class="line">                <span class="keyword">if</span> (d-&gt;connect() == EGL_FALSE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> EGL_FALSE;</span><br><span class="line">                &#125;</span><br><span class="line">                d-&gt;ctx = ctx;</span><br><span class="line">                d-&gt;bindDrawSurface(gl);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (r) &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">FIXME:</span> lock/connect the read surface too </span></span><br><span class="line">                r-&gt;ctx = ctx;</span><br><span class="line">                r-&gt;bindReadSurface(gl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// if surfaces were bound to the context bound to this thread</span></span><br><span class="line">            <span class="comment">// mark then as unbound.</span></span><br><span class="line">            <span class="keyword">if</span> (current_ctx) &#123;</span><br><span class="line">                <span class="keyword">egl_context_t</span>* c = <span class="keyword">egl_context_t</span>::context(current_ctx);</span><br><span class="line">                <span class="keyword">egl_surface_t</span>* d = (<span class="keyword">egl_surface_t</span>*)c-&gt;draw;</span><br><span class="line">                <span class="keyword">egl_surface_t</span>* r = (<span class="keyword">egl_surface_t</span>*)c-&gt;read;</span><br><span class="line">                <span class="keyword">if</span> (d) &#123;</span><br><span class="line">                    c-&gt;draw = <span class="number">0</span>;</span><br><span class="line">                    d-&gt;disconnect();</span><br><span class="line">                    d-&gt;ctx = EGL_NO_CONTEXT;</span><br><span class="line">                    <span class="keyword">if</span> (d-&gt;zombie)</span><br><span class="line">                        <span class="keyword">delete</span> d;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (r) &#123;</span><br><span class="line">                    c-&gt;read = <span class="number">0</span>;</span><br><span class="line">                    r-&gt;ctx = EGL_NO_CONTEXT;</span><br><span class="line">                    <span class="comment">// <span class="doctag">FIXME:</span> unlock/disconnect the read surface too </span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> EGL_TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setError(EGL_BAD_ACCESS, EGL_FALSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="5-7、绘制gl"><a href="#5-7、绘制gl" class="headerlink" title="5.7、绘制gl_*()"></a>5.7、绘制gl_*()</h5><p>应用程序通过OpenGL API进行绘制，一帧完成之后，调用eglSwapBuffers(EGLDisplay dpy, EGLContext ctx)来显示。</p><h5 id="5-8、eglSwapBuffers接口实现说明"><a href="#5-8、eglSwapBuffers接口实现说明" class="headerlink" title="5.8、eglSwapBuffers接口实现说明"></a>5.8、eglSwapBuffers接口实现说明</h5><p>Android平台：</p><p>为了实现eglSwapBuffers， eglSurface其实代表了一个从NativeWindow 申请到的一个Buffer（Dequeue操作）。当调用eglSwapBuffers时，对于一般应用窗口而言，NativeWindow将该Surface的Buffer 提交回去给SurfaceFlinger（Queue操作)，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\native\opengl\libagl\egl.cpp]</span><br><span class="line">EGLBoolean egl_window_surface_v2_t::swapBuffers()</span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">nativeWindow-&gt;queueBuffer(nativeWindow, buffer); </span><br><span class="line">nativeWindow-&gt;dequeueBuffer(nativeWindow, &amp;buffer);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后又重新从NativeWindow中重新Dequeue出来一个新的Buffer给eglSurface。而eglDisplay并不代表实际的意义。我们只是从接口上感觉是，surface和display进行了交换。（注：现在是Triple Buffer）</p><blockquote><p><strong>总结：从前面关于Android EGL、OpenGL ES的分析知道，现在我们可以通过SurfaceFlinger申请一块Surface（Buffer），然后可以利用OpenGL ES接口在Native 层绘制相关的图片、文字；那么疑问来了，Android上层绚丽多彩的App界面是如何绘制而成的呢、App层如何通过底层的OpenGL ES接口来完成绘制呢？？？</strong></p></blockquote><h4 id="（六）、参考资料-特别感谢各位前辈的分析和图示-："><a href="#（六）、参考资料-特别感谢各位前辈的分析和图示-：" class="headerlink" title="（六）、参考资料(特别感谢各位前辈的分析和图示)："></a>（六）、参考资料(特别感谢各位前辈的分析和图示)：</h4><p><a href="https://www.khronos.org/" target="_blank" rel="noopener">Khronos Group</a><br><a href="https://source.android.com/devices/graphics/architecture" target="_blank" rel="noopener">Android图形架构 官方文档</a><br><a href="http://geekfaner.com/shineengine/index.html" target="_blank" rel="noopener">OPENGL ES 2.0 知识串讲</a><br><a href="https://www.slideshare.net/namjungsoo/egl-31239467" target="_blank" rel="noopener">OpenGL ES EGL Spec&amp;APIs</a><br><a href="https://www.slideshare.net/SuhanLee2/understaing-android-egl" target="_blank" rel="noopener">Understaing-Android-Egl</a><br><a href="https://woshijpf.github.io/category/android/" target="_blank" rel="noopener">Android 系统图形栈(1) &amp;&amp;(2)： OpenGL ES 和 EGL</a><br><a href="https://blog.csdn.net/hovan/article/details/43198399" target="_blank" rel="noopener">Android L 的开机动画流程 - CSDN博客</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;amp;&amp;amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内
      
    
    </summary>
    
      <category term="Android" scheme="http://zhoujinjian.cc/categories/Android/"/>
    
    
      <category term="Android" scheme="http://zhoujinjian.cc/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android Camera System（2）：Camera System(Camera 系统)startPreview、takePicture、Recorder流程分析</title>
    <link href="http://zhoujinjian.cc/2018/07/10/Android%20Camera%20System%EF%BC%882%EF%BC%89%EF%BC%9ACamera%20System%5BCamera%20%E7%B3%BB%E7%BB%9F%5DstartPreview%E3%80%81takePicture%E3%80%81Recorder%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <id>http://zhoujinjian.cc/2018/07/10/Android Camera System（2）：Camera System[Camera 系统]startPreview、takePicture、Recorder流程分析/</id>
    <published>2018-07-09T16:00:00.000Z</published>
    <updated>2018-05-25T12:12:49.620Z</updated>
    
    <content type="html"><![CDATA[<hr><p>注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;&amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除，禁止转载（©Qualcomm Technologies, Inc. 版权所有），谢谢。</p><p><a href="https://github.com/izhoujinjian/zhoujinjian.cc/tree/master/camera.system" target="_blank" rel="noopener">【博客原图链接】</a><br><a href="https://blog.csdn.net/armwind/article/category/6282972" target="_blank" rel="noopener">【特别感谢 - Android Camera fw学习-Armwind】</a><br><a href="https://blog.csdn.net/gzzaigcnforever/article/category/3066721" target="_blank" rel="noopener">【特别感谢 - Android Camera API2分析-Gzzaigcnforever】</a><br><a href="https://blog.csdn.net/qq_16775897/article/category/7112759" target="_blank" rel="noopener">【特别感谢 - Android Camera 流程学习记录 Android 7.12-QQ_16775897】</a><br><a href="https://blog.csdn.net/column/details/guming-camera.html" target="_blank" rel="noopener">【特别感谢 - 专栏：古冥的android6.0下的Camera API2.0的源码分析之旅】</a><br>Google Pixel、Pixel XL 内核代码（文章基于 Kernel-3.18）：<br> <a href="https://github.com/matthewdalex/marlin" target="_blank" rel="noopener">Kernel source for Pixel and Pixel XL - GitHub</a></p><p>AOSP 源码（文章基于 Android 7.1.2）：<br> <a href="https://testerhome.com/topics/2229" target="_blank" rel="noopener"> Android 系统全套源代码分享 (更新到 8.1.0_r1)</a></p><p> 🌀🌀：专注于Linux &amp;&amp; Android Multimedia（Camera、Video、Audio、Display）系统分析与研究</p><hr><p>☯ Application：<br>☯ /packages/apps/Camera2/src/com/android/camera/</p><p>☯ Framework：<br>☯ /frameworks/base/core/java/android/hardware/Camera.java</p><p>☯ JNI:<br>☯ /frameworks/base/core/jni/android_hardware_Camera.cpp</p><p>☯ Native:<br>☯ Client：<br>frameworks/av/camera/CameraBase.cpp<br>frameworks/av/camera/Camera.cpp<br>frameworks/av/camera/ICamera.cpp<br>frameworks/av/camera/aidl/android/hardware/ICamera.aidl<br>frameworks/av/camera/aidl/android/hardware/ICameraClient.aidl<br>☯ Server：<br>frameworks/av/camera/cameraserver/main_cameraserver.cpp<br>frameworks/av/services/camera/libcameraservice/CameraService.cpp<br>frameworks/av/services/camera/libcameraservice/api1/CameraClient.cpp<br>frameworks/av/camera/aidl/android/hardware/ICameraService.aidl</p><p>☯ HAL：<br>☯ /frameworks/av/services/camera/libcameraservice/device3/<br>☯ /hardware/qcom/camera/QCamera2(高通HAL)<br>☯ /vendor/qcom/proprietary/mm-camera(高通mm-camera)<br>☯ /vendor/qcom/proprietary/mm-still(高通JPEG)</p><p>☯ Kernel：<br>☯ /kernel/drivers/media/platform/msm/camera_v2(高通V4L2)<br>☯ /kernel/arch/arm/boot/dts/(高通dts)</p><hr><h4 id="（一）、Camera-System-startPreview流程分析"><a href="#（一）、Camera-System-startPreview流程分析" class="headerlink" title="（一）、Camera System startPreview流程分析"></a>（一）、Camera System startPreview流程分析</h4><h5 id="1-1、Camera2-startPreview的应用层-Java-流程分析"><a href="#1-1、Camera2-startPreview的应用层-Java-流程分析" class="headerlink" title="1.1、Camera2 startPreview的应用层(Java)流程分析"></a>1.1、Camera2 startPreview的应用层(Java)流程分析</h5><p>preview流程都是从startPreview开始的，所以来看startPreview方法的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/one/v2/OneCameraImpl.java]</span><br><span class="line">Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startPreview</span><span class="params">(Surface previewSurface, CaptureReadyCallback listener)</span> </span>&#123;</span><br><span class="line">    mPreviewSurface = previewSurface;</span><br><span class="line">    <span class="comment">//根据Surface以及CaptureReadyCallback回调来建立preview环境</span></span><br><span class="line">    setupAsync(mPreviewSurface, listener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这其中有一个比较重要的回调CaptureReadyCallback，先分析setupAsync方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/one/v2/OneCameraImpl.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setupAsync</span><span class="params">(<span class="keyword">final</span> Surface previewSurface, <span class="keyword">final</span> CaptureReadyCallback listener)</span> </span>&#123;</span><br><span class="line">    mCameraHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//建立preview环境</span></span><br><span class="line">            setup(previewSurface, listener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里通过CameraHandler来post一个Runnable对象，它只会调用Runnable的run方法，它仍然属于UI线程，并没有创建新的线程。所以，继续分析setup方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/one/v2/OneCameraImpl.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">(Surface previewSurface, <span class="keyword">final</span> CaptureReadyCallback listener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCaptureSession != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mCaptureSession.abortCaptures();</span><br><span class="line">            mCaptureSession = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Surface&gt; outputSurfaces = <span class="keyword">new</span> ArrayList&lt;Surface&gt;(<span class="number">2</span>);</span><br><span class="line">        outputSurfaces.add(previewSurface);</span><br><span class="line">        outputSurfaces.add(mCaptureImageReader.getSurface());</span><br><span class="line">        <span class="comment">//创建CaptureSession会话来与Camera Device发送Preview请求</span></span><br><span class="line">        mDevice.createCaptureSession(outputSurfaces, <span class="keyword">new</span> CameraCaptureSession.StateCallback() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConfigureFailed</span><span class="params">(CameraCaptureSession session)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//如果配置失败，则回调CaptureReadyCallback的onSetupFailed方法</span></span><br><span class="line">                listener.onSetupFailed();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConfigured</span><span class="params">(CameraCaptureSession session)</span> </span>&#123;</span><br><span class="line">                mCaptureSession = session;</span><br><span class="line">                mAFRegions = ZERO_WEIGHT_3A_REGION;</span><br><span class="line">                mAERegions = ZERO_WEIGHT_3A_REGION;</span><br><span class="line">                mZoomValue = <span class="number">1f</span>;</span><br><span class="line">                mCropRegion = cropRegionForZoom(mZoomValue);</span><br><span class="line">                <span class="comment">//调用repeatingPreview来启动preview</span></span><br><span class="line">                <span class="keyword">boolean</span> success = repeatingPreview(<span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                    <span class="comment">//若启动成功，则回调CaptureReadyCallback的onReadyForCapture，表示准备拍照成功</span></span><br><span class="line">                    listener.onReadyForCapture();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//若启动失败，则回调CaptureReadyCallback的onSetupFailed，表示preview建立失败</span></span><br><span class="line">                    listener.onSetupFailed();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClosed</span><span class="params">(CameraCaptureSession session)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.onClosed(session);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, mCameraHandler);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CameraAccessException ex) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"Could not set up capture session"</span>, ex);</span><br><span class="line">        listener.onSetupFailed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，调用Device的createCaptureSession方法来创建一个会话，并定义了会话的状态回调CameraCaptureSession.StateCallback()，其中，当会话创建成功，则会回调onConfigured()方法,在其中，首先调用repeatingPreview来启动preview，然后处理preview的结果并调用先前定义的CaptureReadyCallback来通知用户进行Capture操作。先分析repeatingPreview方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/one/v2/OneCameraImpl.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">repeatingPreview</span><span class="params">(Object tag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//通过CameraDevice对象创建一个CaptureRequest的preview请求</span></span><br><span class="line">        CaptureRequest.Builder builder = mDevice.createCaptureRequest(</span><br><span class="line">                CameraDevice.TEMPLATE_PREVIEW);</span><br><span class="line">        <span class="comment">//添加预览的目标Surface</span></span><br><span class="line">        builder.addTarget(mPreviewSurface);</span><br><span class="line">        <span class="comment">//设置预览模式</span></span><br><span class="line">        builder.set(CaptureRequest.CONTROL_MODE, CameraMetadata.CONTROL_MODE_AUTO);</span><br><span class="line">        addBaselineCaptureKeysToRequest(builder);</span><br><span class="line">        <span class="comment">//利用会话发送请求，mCaptureCallback为</span></span><br><span class="line">        mCaptureSession.setRepeatingRequest(builder.build(), mCaptureCallback,mCameraHandler);</span><br><span class="line">        Log.v(TAG, String.format(<span class="string">"Sent repeating Preview request, zoom = %.2f"</span>, mZoomValue));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CameraAccessException ex) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"Could not access camera setting up preview."</span>, ex);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先调用CameraDeviceImpl的createCaptureRequest方法创建类型为TEMPLATE_PREVIEW 的CaptureRequest，然后调用CameraCaptureSessionImpl的setRepeatingRequest方法将此请求发送出去：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/base/core/java/android/hardware/camera2/impl/CameraCaptureSessionImpl.java]</span><br><span class="line">Override</span><br><span class="line">public synchronized int setRepeatingRequest(CaptureRequest request, CaptureCallback callback,</span><br><span class="line">        Handler handler) throws CameraAccessException &#123;</span><br><span class="line">    if (request == null) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;request must not be null&quot;);</span><br><span class="line">    &#125; else if (request.isReprocess()) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;repeating reprocess requests are not supported&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    checkNotClosed();</span><br><span class="line">    handler = checkHandler(handler, callback);</span><br><span class="line">    ...</span><br><span class="line">    //将此请求添加到待处理的序列里</span><br><span class="line">    return addPendingSequence(mDeviceImpl.setRepeatingRequest(request,createCaptureCallbackProxy(</span><br><span class="line">        handler, callback), mDeviceHandler));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此应用层的preview的请求流程分析结束，继续分析其结果处理，如果preview开启成功，则会回调CaptureReadyCallback的onReadyForCapture方法，现在分析CaptureReadyCallback回调：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/CaptureModule.java]</span><br><span class="line"><span class="keyword">new</span> CaptureReadyCallback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSetupFailed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mCameraOpenCloseLock.release();</span><br><span class="line">        Log.e(TAG, <span class="string">"Could not set up preview."</span>);</span><br><span class="line">        mMainThread.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (mCamera == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Log.d(TAG, <span class="string">"Camera closed, aborting."</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                mCamera.close();</span><br><span class="line">                mCamera = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReadyForCapture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mCameraOpenCloseLock.release();</span><br><span class="line">        mMainThread.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"Ready for capture."</span>);</span><br><span class="line">                <span class="keyword">if</span> (mCamera == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Log.d(TAG, <span class="string">"Camera closed, aborting."</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                onPreviewStarted();</span><br><span class="line">                onReadyStateChanged(<span class="keyword">true</span>);</span><br><span class="line">                mCamera.setReadyStateChangedListener(CaptureModule.<span class="keyword">this</span>);</span><br><span class="line">                mUI.initializeZoom(mCamera.getMaxZoom());</span><br><span class="line">                mCamera.setFocusStateListener(CaptureModule.<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据前面的分析，预览成功后会回调onReadyForCapture方法，它主要是通知主线程的状态改变，并设置Camera的ReadyStateChangedListener的监听，其回调方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/CaptureModule.java]</span><br><span class="line">Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReadyStateChanged</span><span class="params">(<span class="keyword">boolean</span> readyForCapture)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (readyForCapture) &#123;</span><br><span class="line">        mAppController.getCameraAppUI().enableModeOptions();</span><br><span class="line">    &#125;</span><br><span class="line">    mAppController.setShutterEnabled(readyForCapture);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如代码所示，当其状态变成准备好拍照，则将会调用CameraActivity的setShutterEnabled方法，即使能快门按键，此时也就是说预览成功结束，可以按快门进行拍照了，所以，到这里，应用层的preview的流程基本分析完毕，下图是应用层的关键调用的流程时序图： </p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/camera.system/02-01-preview_java_flow.png" alt="Alt text"></p><h5 id="1-2、Camera2-startPreview的Native层流程分析"><a href="#1-2、Camera2-startPreview的Native层流程分析" class="headerlink" title="1.2、Camera2 startPreview的Native层流程分析"></a>1.2、Camera2 startPreview的Native层流程分析</h5><p>分析Preview的Native的代码真是费了九牛二虎之力，若有分析不正确之处，请各位大神指正，在第一小节的后段最后会调用CameraDeviceImpl的setRepeatingRequest方法来提交请求，而在android6.0源码分析之Camera API2.0简介中，分析了Camera2框架Java IPC通信使用了CameraDeviceUser来进行通信，所以看Native层的ICameraDeviceUser的onTransact方法来处理请求的提交：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/camera/aidl/android/hardware/camera2/ICameraDeviceUser.aidl]</span><br><span class="line">status_t BnCameraDeviceUser::onTransact(uint32_t code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, </span><br><span class="line">        uint32_t flags)&#123;</span><br><span class="line">    <span class="keyword">switch</span>(code) &#123;</span><br><span class="line">        …</span><br><span class="line">        <span class="comment">//请求提交</span></span><br><span class="line">        <span class="keyword">case</span> SUBMIT_REQUEST: &#123;</span><br><span class="line">            CHECK_INTERFACE(ICameraDeviceUser, data, reply);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// arg0 = request</span></span><br><span class="line">            sp&lt;CaptureRequest&gt; request;</span><br><span class="line">            <span class="keyword">if</span> (data.readInt32() != <span class="number">0</span>) &#123;</span><br><span class="line">                request = <span class="keyword">new</span> CaptureRequest();</span><br><span class="line">                request-&gt;readFromParcel(const_cast&lt;Parcel*&gt;(&amp;data));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// arg1 = streaming (bool)</span></span><br><span class="line">            bool repeating = data.readInt32();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// return code: requestId (int32)</span></span><br><span class="line">            reply-&gt;writeNoException();</span><br><span class="line">            int64_t lastFrameNumber = -<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//将实现BnCameraDeviceUser的对下岗的submitRequest方法代码写入Binder</span></span><br><span class="line">            reply-&gt;writeInt32(submitRequest(request, repeating, &amp;lastFrameNumber));</span><br><span class="line">            reply-&gt;writeInt32(<span class="number">1</span>);</span><br><span class="line">            reply-&gt;writeInt64(lastFrameNumber);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CameraDeviceClientBase继承了BnCameraDeviceUser类，所以CameraDeviceClientBase相当于IPC Binder中的client，所以会调用其submitRequest方法，此处，至于IPC Binder通信原理不做分析，其参照其它资料：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\camera\libcameraservice\api2\CameraDeviceClient.cpp]</span><br><span class="line"><span class="keyword">status_t</span> CameraDeviceClient::submitRequest(sp&lt;CaptureRequest&gt; request,<span class="keyword">bool</span> streaming,</span><br><span class="line">        <span class="comment">/*out*/</span><span class="keyword">int64_t</span>* lastFrameNumber) &#123;</span><br><span class="line">    List&lt;sp&lt;CaptureRequest&gt; &gt; requestList;</span><br><span class="line">    requestList.push_back(request);</span><br><span class="line">    <span class="keyword">return</span> submitRequestList(requestList, streaming, lastFrameNumber);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的调用，继续分析submitRequestList：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\camera\libcameraservice\api2\CameraDeviceClient.cpp]</span><br><span class="line"><span class="keyword">status_t</span> CameraDeviceClient::submitRequestList(List&lt;sp&lt;CaptureRequest&gt; &gt; requests,<span class="keyword">bool</span> streaming, </span><br><span class="line">        <span class="keyword">int64_t</span>* lastFrameNumber) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//Metadata链表</span></span><br><span class="line">    List&lt;<span class="keyword">const</span> CameraMetadata&gt; metadataRequestList;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (List&lt;sp&lt;CaptureRequest&gt; &gt;::iterator it = requests.begin(); it != requests.end(); ++it) &#123;</span><br><span class="line">        sp&lt;CaptureRequest&gt; request = *it;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//初始化Metadata数据</span></span><br><span class="line">        <span class="function">CameraMetadata <span class="title">metadata</span><span class="params">(request-&gt;mMetadata)</span></span>;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//设置Stream的容量</span></span><br><span class="line">        Vector&lt;<span class="keyword">int32_t</span>&gt; outputStreamIds;</span><br><span class="line">        outputStreamIds.setCapacity(request-&gt;mSurfaceList.size());</span><br><span class="line">        <span class="comment">//循环初始化Surface</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; request-&gt;mSurfaceList.size(); ++i) &#123;</span><br><span class="line">            sp&lt;Surface&gt; surface = request-&gt;mSurfaceList[i];</span><br><span class="line">            <span class="keyword">if</span> (surface == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            sp&lt;IGraphicBufferProducer&gt; gbp = surface-&gt;getIGraphicBufferProducer();</span><br><span class="line">            <span class="keyword">int</span> idx = mStreamMap.indexOfKey(IInterface::asBinder(gbp));</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">int</span> streamId = mStreamMap.valueAt(idx);</span><br><span class="line">            outputStreamIds.push_back(streamId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新数据</span></span><br><span class="line">        metadata.update(ANDROID_REQUEST_OUTPUT_STREAMS, &amp;outputStreamIds[<span class="number">0</span>],</span><br><span class="line">                        outputStreamIds.size());</span><br><span class="line">        <span class="keyword">if</span> (request-&gt;mIsReprocess) &#123;</span><br><span class="line">            metadata.update(ANDROID_REQUEST_INPUT_STREAMS, &amp;mInputStream.id, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        metadata.update(ANDROID_REQUEST_ID, &amp;requestId, <span class="comment">/*size*/</span><span class="number">1</span>);</span><br><span class="line">        loopCounter++; <span class="comment">// loopCounter starts from 1</span></span><br><span class="line">        <span class="comment">//压栈</span></span><br><span class="line">        metadataRequestList.push_back(metadata);</span><br><span class="line">    &#125;</span><br><span class="line">    mRequestIdCounter++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (streaming) &#123;</span><br><span class="line">        <span class="comment">//预览会走此条通道</span></span><br><span class="line">        res = mDevice-&gt;setStreamingRequestList(metadataRequestList, lastFrameNumber);</span><br><span class="line">        <span class="keyword">if</span> (res != OK) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mStreamingRequestList.push_back(requestId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//Capture等走此条通道</span></span><br><span class="line">        res = mDevice-&gt;captureList(metadataRequestList, lastFrameNumber);</span><br><span class="line">        <span class="keyword">if</span> (res != OK) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res == OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> requestId;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>setStreamingRequestList和captureList方法都调用了submitRequestsHelper方法，只是他们的repeating参数一个ture,一个为false，而本节分析的preview调用的是setStreamingRequestList方法，并且API2.0下Device的实现为Camera3Device，所以看它的submitRequestsHelper实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\camera\libcameraservice\device3\Camera3Device.cpp]</span><br><span class="line"><span class="keyword">status_t</span> Camera3Device::submitRequestsHelper(<span class="keyword">const</span> List&lt;<span class="keyword">const</span> CameraMetadata&gt; &amp;requests, </span><br><span class="line">        <span class="keyword">bool</span> repeating,<span class="comment">/*out*/</span><span class="keyword">int64_t</span> *lastFrameNumber) &#123;</span><br><span class="line">    ...</span><br><span class="line">    RequestList requestList;</span><br><span class="line">    <span class="comment">//在这里面会进行CaptureRequest的创建，并调用configureStreamLocked进行stream的配置，主要是设置了一个回调captureResultCb，即后面要分析的重要的回调</span></span><br><span class="line">    res = convertMetadataListToRequestListLocked(requests, <span class="comment">/*out*/</span>&amp;requestList);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (repeating) &#123;</span><br><span class="line">        <span class="comment">//眼熟不，这个方法名和应用层中CameraDevice的setRepeatingRequests一样</span></span><br><span class="line">        res = mRequestThread-&gt;setRepeatingRequests(requestList, lastFrameNumber);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//不需重复，即repeating为false时，调用此方法来讲请求提交</span></span><br><span class="line">        res = mRequestThread-&gt;queueRequestList(requestList, lastFrameNumber);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/camera.system/02-02-preview_native_architecture.png" alt="Alt text"></p><p>从代码可知，在Camera3Device里创建了要给RequestThread线程，调用它的setRepeatingRequests或者queueRequestList方法来将应用层发送过来的Request提交，继续看setRepeatingRequests方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\camera\libcameraservice\device3\Camera3Device.cpp]</span><br><span class="line"><span class="keyword">status_t</span> Camera3Device::RequestThread::setRepeatingRequests(<span class="keyword">const</span> RequestList &amp;requests,</span><br><span class="line">        <span class="comment">/*out*/</span><span class="keyword">int64_t</span> *lastFrameNumber) &#123;</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">l</span><span class="params">(mRequestLock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (lastFrameNumber != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *lastFrameNumber = mRepeatingLastFrameNumber;</span><br><span class="line">    &#125;</span><br><span class="line">    mRepeatingRequests.clear();</span><br><span class="line">    <span class="comment">//将其插入mRepeatingRequest链表</span></span><br><span class="line">    mRepeatingRequests.insert(mRepeatingRequests.begin(),</span><br><span class="line">            requests.begin(), requests.end());</span><br><span class="line"></span><br><span class="line">    unpauseForNewRequests();</span><br><span class="line"></span><br><span class="line">    mRepeatingLastFrameNumber = NO_IN_FLIGHT_REPEATING_FRAMES;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，Native层的preview过程基本分析结束，下面的工作将会交给Camera HAL层来处理，先给出Native层的调用时序图： </p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/camera.system/02-03-preview_native_flow.png" alt="Alt text"></p><h5 id="1-3、Camera2-startPreview的HAL层流程分析"><a href="#1-3、Camera2-startPreview的HAL层流程分析" class="headerlink" title="1.3、Camera2 startPreview的HAL层流程分析"></a>1.3、Camera2 startPreview的HAL层流程分析</h5><p>本节将不再对Camera的HAL层的初始化以及相关配置进行分析，只对preview等相关流程中的frame metadata的处理流程进行分析，具体的CameraHAL分析请参考前一篇分析，在第二小节的submitRequestsHelper方法中调用convertMetadataListToRequestListLocked的时候会进行CaptureRequest的创建，并调用configureStreamLocked进行stream的配置，主要是设置了一个回调captureResultCb，所以Native层在request提交后，会回调此captureResultCb方法，首先分析captureResultCb：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/hardware/qcom/camera/QCamera2/HAL3/QCamera3HWI.cpp]</span><br><span class="line"><span class="keyword">void</span> QCamera3HardwareInterface::captureResultCb(<span class="keyword">mm_camera_super_buf_t</span> *metadata_buf,</span><br><span class="line">        <span class="keyword">camera3_stream_buffer_t</span> *buffer, <span class="keyword">uint32_t</span> frame_number)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (metadata_buf) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mBatchSize) &#123;</span><br><span class="line">            <span class="comment">//批处理模式，但代码也是循环调用handleMetadataWithLock方法</span></span><br><span class="line">            handleBatchMetadata(metadata_buf, <span class="literal">true</span> <span class="comment">/* free_and_bufdone_meta_buf */</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">/* mBatchSize = 0 */</span></span><br><span class="line">            pthread_mutex_lock(&amp;mMutex);    </span><br><span class="line">            <span class="comment">//处理元数据</span></span><br><span class="line">            handleMetadataWithLock(metadata_buf, <span class="literal">true</span> <span class="comment">/* free_and_bufdone_meta_buf */</span>);</span><br><span class="line">            pthread_mutex_unlock(&amp;mMutex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mMutex);</span><br><span class="line">        handleBufferWithLock(buffer, frame_number);</span><br><span class="line">        pthread_mutex_unlock(&amp;mMutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一种是通过循环来进行元数据的批处理，另一种是直接进行元数据的处理，但是批处理最终也是循环调用handleMetadataWithLock来处理：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/hardware/qcom/camera/QCamera2/HAL3/QCamera3HWI.cpp]</span><br><span class="line"><span class="keyword">void</span> QCamera3HardwareInterface::handleMetadataWithLock(<span class="keyword">mm_camera_super_buf_t</span> *metadata_buf, </span><br><span class="line">        <span class="keyword">bool</span> free_and_bufdone_meta_buf)&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//Partial result on process_capture_result for timestamp</span></span><br><span class="line">    <span class="keyword">if</span> (urgent_frame_number_valid) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">for</span> (List&lt;PendingRequestInfo&gt;::iterator i =mPendingRequestsList.begin(); </span><br><span class="line">                i != mPendingRequestsList.end(); i++) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> (i-&gt;frame_number == urgent_frame_number &amp;&amp;i-&gt;bUrgentReceived == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">camera3_capture_result_t</span> result;</span><br><span class="line">                <span class="built_in">memset</span>(&amp;result, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">camera3_capture_result_t</span>));</span><br><span class="line">                i-&gt;partial_result_cnt++;</span><br><span class="line">                i-&gt;bUrgentReceived = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//提取3A数据</span></span><br><span class="line">                result.result =translateCbUrgentMetadataToResultMetadata(metadata);</span><br><span class="line">                ...</span><br><span class="line">                <span class="comment">//对Capture Result进行处理</span></span><br><span class="line">                mCallbackOps-&gt;process_capture_result(mCallbackOps, &amp;result);</span><br><span class="line">                <span class="comment">//释放camera_metadata_t</span></span><br><span class="line">                free_camera_metadata((<span class="keyword">camera_metadata_t</span> *)result.result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (List&lt;PendingRequestInfo&gt;::iterator i = mPendingRequestsList.begin();</span><br><span class="line">            i != mPendingRequestsList.end() &amp;&amp; i-&gt;frame_number &lt;= frame_number;) &#123;</span><br><span class="line">        <span class="keyword">camera3_capture_result_t</span> result;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;result, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">camera3_capture_result_t</span>));</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (i-&gt;frame_number &lt; frame_number) &#123;</span><br><span class="line">            <span class="comment">//清空数据结构</span></span><br><span class="line">            <span class="keyword">camera3_notify_msg_t</span> notify_msg;</span><br><span class="line">            <span class="built_in">memset</span>(&amp;notify_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">camera3_notify_msg_t</span>));</span><br><span class="line">            <span class="comment">//定义消息类型</span></span><br><span class="line">            notify_msg.type = CAMERA3_MSG_SHUTTER;</span><br><span class="line">            notify_msg.message.shutter.frame_number = i-&gt;frame_number;</span><br><span class="line">            notify_msg.message.shutter.timestamp = (<span class="keyword">uint64_t</span>)capture_time (urgent_frame_number - </span><br><span class="line">                i-&gt;frame_number) * NSEC_PER_33MSEC;</span><br><span class="line">            <span class="comment">//调用回调通知应用层发生CAMERA3_MSG_SHUTTER消息</span></span><br><span class="line">            mCallbackOps-&gt;notify(mCallbackOps, &amp;notify_msg);</span><br><span class="line">            ...</span><br><span class="line">            CameraMetadata dummyMetadata;</span><br><span class="line">            <span class="comment">//更新元数据</span></span><br><span class="line">            dummyMetadata.update(ANDROID_SENSOR_TIMESTAMP,</span><br><span class="line">                    &amp;i-&gt;timestamp, <span class="number">1</span>);</span><br><span class="line">            dummyMetadata.update(ANDROID_REQUEST_ID,</span><br><span class="line">                    &amp;(i-&gt;request_id), <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//得到元数据释放结果</span></span><br><span class="line">            result.result = dummyMetadata.release();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">camera3_notify_msg_t</span> notify_msg;</span><br><span class="line">            <span class="built_in">memset</span>(&amp;notify_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">camera3_notify_msg_t</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Send shutter notify to frameworks</span></span><br><span class="line">            notify_msg.type = CAMERA3_MSG_SHUTTER;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//从HAL中获得Metadata</span></span><br><span class="line">            result.result = translateFromHalMetadata(metadata,</span><br><span class="line">                    i-&gt;timestamp, i-&gt;request_id, i-&gt;jpegMetadata, i-&gt;pipeline_depth,</span><br><span class="line">                    i-&gt;capture_intent);</span><br><span class="line">            saveExifParams(metadata);</span><br><span class="line">            <span class="keyword">if</span> (i-&gt;blob_request) &#123;</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">if</span> (enabled &amp;&amp; metadata-&gt;is_tuning_params_valid) &#123;</span><br><span class="line">                    <span class="comment">//将Metadata复制到文件</span></span><br><span class="line">                    dumpMetadataToFile(metadata-&gt;tuning_params, mMetaFrameCount, enabled,</span><br><span class="line">                        <span class="string">"Snapshot"</span>,frame_number);</span><br><span class="line">                &#125;</span><br><span class="line">                mPictureChannel-&gt;queueReprocMetadata(metadata_buf);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Return metadata buffer</span></span><br><span class="line">                <span class="keyword">if</span> (free_and_bufdone_meta_buf) &#123;</span><br><span class="line">                    mMetadataChannel-&gt;bufDone(metadata_buf);</span><br><span class="line">                    <span class="built_in">free</span>(metadata_buf);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，首先会调用回调的process_capture_result方法来对Capture Result进行处理，然后会调用回调的notify方法来发送一个CAMERA3_MSG_SHUTTER消息，而process_capture_result所对应的实现其实就是Camera3Device的processCaptureResult方法，先分析processCaptureResult：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\camera\libcameraservice\device3\Camera3Device.cpp]</span><br><span class="line">void Camera3Device::processCaptureResult(const camera3_capture_result *result) &#123;</span><br><span class="line">    ...</span><br><span class="line">    //对于HAL3.2+,如果HAL不支持partial，当metadata被包含在result中时，它必须将partial_result设置为1</span><br><span class="line">    ...</span><br><span class="line">    &#123;</span><br><span class="line">        Mutex::Autolock l(mInFlightLock);</span><br><span class="line">        ssize_t idx = mInFlightMap.indexOfKey(frameNumber);</span><br><span class="line">        ...</span><br><span class="line">        InFlightRequest &amp;request = mInFlightMap.editValueAt(idx);</span><br><span class="line">        if (result-&gt;partial_result != 0)</span><br><span class="line">            request.resultExtras.partialResultCount = result-&gt;partial_result;</span><br><span class="line">        // 检查结果是否只有partial metadata</span><br><span class="line">        if (mUsePartialResult &amp;&amp; result-&gt;result != NULL) &#123;</span><br><span class="line">            if (mDeviceVersion &gt;= CAMERA_DEVICE_API_VERSION_3_2) &#123;//HAL版本高于3.2</span><br><span class="line">                if (result-&gt;partial_result &gt; mNumPartialResults || result-&gt;partial_result &lt; 1) &#123;</span><br><span class="line">                    //Log显示错误</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                isPartialResult = (result-&gt;partial_result &lt; mNumPartialResults);</span><br><span class="line">                if (isPartialResult) &#123;</span><br><span class="line">                    //将结果加入到请求的结果集中</span><br><span class="line">                    request.partialResult.collectedResult.append(result-&gt;result);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;//低于3.2</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            if (isPartialResult) &#123;</span><br><span class="line">                // Fire off a 3A-only result if possible</span><br><span class="line">                if (!request.partialResult.haveSent3A) &#123;</span><br><span class="line">                    request.partialResult.haveSent3A =processPartial3AResult(frameNumber,</span><br><span class="line">                        request.partialResult.collectedResult,request.resultExtras);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        if (result-&gt;result != NULL &amp;&amp; !isPartialResult) &#123;</span><br><span class="line">            if (shutterTimestamp == 0) &#123;</span><br><span class="line">                request.pendingMetadata = result-&gt;result;</span><br><span class="line">                request.partialResult.collectedResult = collectedPartialResult;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                CameraMetadata metadata;</span><br><span class="line">                metadata = result-&gt;result;</span><br><span class="line">                //发送Capture Result</span><br><span class="line">                sendCaptureResult(metadata, request.resultExtras, collectedPartialResult, </span><br><span class="line">                    frameNumber, hasInputBufferInRequest,request.aeTriggerCancelOverride);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //结果处理好了，将请求移除</span><br><span class="line">        removeInFlightRequestIfReadyLocked(idx);</span><br><span class="line">    &#125; // scope for mInFlightLock</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由代码可知，它会处理局部的或者全部的metadata数据，最后如果result不为空，且得到的是请求处理的全部数据，则会调用sendCaptureResult方法来将请求结果发送出去：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\camera\libcameraservice\device3\Camera3Device.cpp]</span><br><span class="line"><span class="keyword">void</span> Camera3Device::sendCaptureResult(CameraMetadata &amp;pendingMetadata,CaptureResultExtras </span><br><span class="line">        &amp;resultExtras,CameraMetadata &amp;collectedPartialResult,<span class="keyword">uint32_t</span> frameNumber,<span class="keyword">bool</span> reprocess,</span><br><span class="line">        <span class="keyword">const</span> AeTriggerCancelOverride_t &amp;aeTriggerCancelOverride) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pendingMetadata.isEmpty())<span class="comment">//如果数据为空，直接返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    ...</span><br><span class="line">    CaptureResult captureResult;</span><br><span class="line">    captureResult.mResultExtras = resultExtras;</span><br><span class="line">    captureResult.mMetadata = pendingMetadata;</span><br><span class="line">    <span class="comment">//更新metadata</span></span><br><span class="line">    <span class="keyword">if</span> (captureResult.mMetadata.update(ANDROID_REQUEST_FRAME_COUNT(<span class="keyword">int32_t</span>*)&amp;frameNumber, <span class="number">1</span>) </span><br><span class="line">            != OK) &#123;</span><br><span class="line">        SET_ERR(<span class="string">"Failed to set frame# in metadata (%d)"</span>,frameNumber);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Append any previous partials to form a complete result</span></span><br><span class="line">    <span class="keyword">if</span> (mUsePartialResult &amp;&amp; !collectedPartialResult.isEmpty()) &#123;</span><br><span class="line">        captureResult.mMetadata.append(collectedPartialResult);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//排序</span></span><br><span class="line">    captureResult.mMetadata.sort();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check that there's a timestamp in the result metadata</span></span><br><span class="line">    camera_metadata_entry entry = captureResult.mMetadata.find(ANDROID_SENSOR_TIMESTAMP);</span><br><span class="line">    ...</span><br><span class="line">    overrideResultForPrecaptureCancel(&amp;captureResult.mMetadata, aeTriggerCancelOverride);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有效的结果，将其插入Buffer</span></span><br><span class="line">    List&lt;CaptureResult&gt;::iterator queuedResult =mResultQueue.insert(mResultQueue.end(), </span><br><span class="line">        CaptureResult(captureResult));</span><br><span class="line">    ...</span><br><span class="line">    mResultSignal.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，它将Capture Result插入了结果队列，并释放了结果的信号量，所以到这里，Capture Result处理成功，下面分析前面的notify发送CAMERA3_MSG_SHUTTER消息：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\camera\libcameraservice\device3\Camera3Device.cpp]</span><br><span class="line"><span class="keyword">void</span> Camera3Device::notify(<span class="keyword">const</span> camera3_notify_msg *msg) &#123;</span><br><span class="line"></span><br><span class="line">    NotificationListener *listener;</span><br><span class="line">    &#123;</span><br><span class="line">        Mutex::<span class="function">Autolock <span class="title">l</span><span class="params">(mOutputLock)</span></span>;</span><br><span class="line">        listener = mListener;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span> (msg-&gt;type) &#123;</span><br><span class="line">        <span class="keyword">case</span> CAMERA3_MSG_ERROR: &#123;</span><br><span class="line">            notifyError(msg-&gt;message.error, listener);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> CAMERA3_MSG_SHUTTER: &#123;</span><br><span class="line">            notifyShutter(msg-&gt;message.shutter, listener);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            SET_ERR(<span class="string">"Unknown notify message from HAL: %d"</span>,</span><br><span class="line">                    msg-&gt;type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它调用了notifyShutter方法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\camera\libcameraservice\device3\Camera3Device.cpp]</span><br><span class="line"><span class="keyword">void</span> Camera3Device::notifyShutter(<span class="keyword">const</span> <span class="keyword">camera3_shutter_msg_t</span> &amp;msg,</span><br><span class="line">        NotificationListener *listener) &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Set timestamp for the request in the in-flight tracking</span></span><br><span class="line">    <span class="comment">// and get the request ID to send upstream</span></span><br><span class="line">    &#123;</span><br><span class="line">        Mutex::<span class="function">Autolock <span class="title">l</span><span class="params">(mInFlightLock)</span></span>;</span><br><span class="line">        idx = mInFlightMap.indexOfKey(msg.frame_number);</span><br><span class="line">        <span class="keyword">if</span> (idx &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            InFlightRequest &amp;r = mInFlightMap.editValueAt(idx);</span><br><span class="line">            <span class="comment">// Call listener, if any</span></span><br><span class="line">            <span class="keyword">if</span> (listener != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">//调用监听的notifyShutter法国法</span></span><br><span class="line">                listener-&gt;notifyShutter(r.resultExtras, msg.timestamp);</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//将待处理的result发送到Buffer</span></span><br><span class="line">            sendCaptureResult(r.pendingMetadata, r.resultExtras,</span><br><span class="line">                r.partialResult.collectedResult, msg.frame_number,</span><br><span class="line">                r.hasInputBuffer, r.aeTriggerCancelOverride);</span><br><span class="line">            returnOutputBuffers(r.pendingOutputBuffers.<span class="built_in">array</span>(),</span><br><span class="line">                r.pendingOutputBuffers.size(), r.shutterTimestamp);</span><br><span class="line">            r.pendingOutputBuffers.clear();</span><br><span class="line">            removeInFlightRequestIfReadyLocked(idx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先它会通知listener preview成功，最后会调用sendCaptureResult将结果加入到结果队列。它会调用listener的notifyShutter方法，此处的listener其实是CameraDeviceClient类，所以会调用CameraDeviceClient类的notifyShutter方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\camera\libcameraservice\api2\CameraDeviceClient.cpp]</span><br><span class="line"><span class="keyword">void</span> CameraDeviceClient::notifyShutter(<span class="keyword">const</span> CaptureResultExtras&amp; resultExtras,<span class="keyword">nsecs_t</span> timestamp) &#123;</span><br><span class="line">    <span class="comment">// Thread safe. Don't bother locking.</span></span><br><span class="line">    sp&lt;ICameraDeviceCallbacks&gt; remoteCb = getRemoteCallback();</span><br><span class="line">    <span class="keyword">if</span> (remoteCb != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//调用应用层的回调(CaptureCallback的onCaptureStarted方法)</span></span><br><span class="line">        remoteCb-&gt;onCaptureStarted(resultExtras, timestamp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处的ICameraDeviceCallbacks对应的是Java层的CameraDeviceImpl.java中的内部类CameraDeviceCallbacks，所以会调用它的onCaptureStarted方法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\core\java\android\hardware\camera2\impl\CameraDeviceImpl.java]</span><br><span class="line">@Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCaptureStarted</span><span class="params">(final CaptureResultExtras resultExtras, final <span class="keyword">long</span> timestamp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> requestId = resultExtras.getRequestId();</span><br><span class="line">    final <span class="keyword">long</span> frameNumber = resultExtras.getFrameNumber();</span><br><span class="line">    final CaptureCallbackHolder holder;</span><br><span class="line"></span><br><span class="line">    synchronized(mInterfaceLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mRemoteDevice == null) <span class="keyword">return</span>; <span class="comment">// Camera already closed</span></span><br><span class="line">        <span class="comment">// Get the callback for this frame ID, if there is one</span></span><br><span class="line">        holder = CameraDeviceImpl.<span class="keyword">this</span>.mCaptureCallbackMap.get(requestId);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// Dispatch capture start notice</span></span><br><span class="line">        holder.getHandler().post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</span><br><span class="line">                <span class="keyword">if</span> (!CameraDeviceImpl.<span class="keyword">this</span>.isClosed()) &#123;</span><br><span class="line">                    holder.getCallback().onCaptureStarted(CameraDeviceImpl.<span class="keyword">this</span>,holder.getRequest(</span><br><span class="line">                        resultExtras.getSubsequenceId()),timestamp, frameNumber);</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>它会调用OneCameraImpl.java中的mCaptureCallback的onCaptureStarted方法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\core\java\android\hardware\camera2\impl\CameraDeviceImpl.java]</span><br><span class="line"><span class="comment">//Common listener for preview frame metadata.  </span></span><br><span class="line"><span class="keyword">private</span> final CameraCaptureSession.CaptureCallback mCaptureCallback =</span><br><span class="line">    <span class="keyword">new</span> CameraCaptureSession.CaptureCallback() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> onCaptureStarted(CameraCaptureSession session,CaptureRequest request, </span><br><span class="line">            <span class="keyword">long</span> timestamp,<span class="keyword">long</span> frameNumber) &#123;</span><br><span class="line">            <span class="keyword">if</span> (request.getTag() == RequestTag.CAPTURE&amp;&amp; mLastPictureCallback != null) &#123;</span><br><span class="line">                mLastPictureCallback.onQuickExpose();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>camera工作时，存在了５中流处理线程和一个专门向hal发送请求的request线程。线程之间通过信号来同步，稍不注意就搞不明白代码是如何运行的了。其中很容易让我们忽视的就是在流发送之前的parent-&gt;registerInFlight()该操作将当前的请求保存到一个数组(可以理解成)中。这个数组对象在后续回帧操作中，会将相应帧的shutter,时间戳信息填充到对应的request中，紧接着就把对应帧的信息返回给app。好了先到这吧，下一篇分析Camera recording流程。</p></blockquote><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/camera.system/02-04-preview_hal_architecture.png" alt="Alt text"></p><p>注意：Capture,preview以及autoFocus都是使用的这个回调，而Capture调用的时候，其RequestTag为CAPTURE，而autoFocus的时候为TAP_TO_FOCUS,而preview请求时没有对RequestTag进行设置，所以回调到onCaptureStarted方法时，不需要进行处理，但是到此时，preview已经启动成功，可以进行预览了，其数据都在buffer里。所以到此时，preview的流程全部分析结束，下面给出HAL层上的流程时序图 </p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/camera.system/02-05-preview_hal_flow.png" alt="Alt text"></p><h4 id="（二）、Camera-System-takePicture流程分析"><a href="#（二）、Camera-System-takePicture流程分析" class="headerlink" title="（二）、Camera System takePicture流程分析"></a>（二）、Camera System takePicture流程分析</h4><p>与TakePicture息息相关的主要有4个线程CaptureSequencer,JpegProcessor,Camera3Device::RequestThread,FrameProcessorBase如下面的代码可以发现，在Camera2client对象初始化后，已经有３个线程已经run起来了，还有有一个RequestThread线程会在Camera3Device初始化时创建的。他们工作非常密切，如下大概画了一个他们的工作机制，４个线程都是通过Conditon条件变量来同步的。 </p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/camera.system/02-06-Camera3Device-RequestThread.png" alt="Alt text"></p><p>前面分析preview的时候，当预览成功后，会使能ShutterButton，即可以进行拍照，定位到ShutterButton的监听事件为onShutterButtonClick方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/CaptureModule.java]</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onShutterButtonClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Camera未打开</span></span><br><span class="line">    <span class="keyword">if</span> (mCamera == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> countDownDuration = mSettingsManager.getInteger(SettingsManager</span><br><span class="line">        .SCOPE_GLOBAL,Keys.KEY_COUNTDOWN_DURATION);</span><br><span class="line">    <span class="keyword">if</span> (countDownDuration &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 开始倒计时</span></span><br><span class="line">        mAppController.getCameraAppUI().transitionToCancel();</span><br><span class="line">        mAppController.getCameraAppUI().hideModeOptions();</span><br><span class="line">        mUI.setCountdownFinishedListener(<span class="keyword">this</span>);</span><br><span class="line">        mUI.startCountdown(countDownDuration);</span><br><span class="line">        <span class="comment">// Will take picture later via listener callback.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//即刻拍照</span></span><br><span class="line">        takePictureNow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，读取Camera的配置，判断配置是否需要延时拍照，此处分析不需延时的情况，即调用takePictureNow方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/CaptureModule.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">takePictureNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mCamera == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">"Not taking picture since Camera is closed."</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建Capture会话并开启会话</span></span><br><span class="line">    CaptureSession session = createAndStartCaptureSession();</span><br><span class="line">    <span class="comment">//获取Camera的方向</span></span><br><span class="line">    <span class="keyword">int</span> orientation = mAppController.getOrientationManager()</span><br><span class="line">        .getDeviceOrientation().getDegrees();</span><br><span class="line">    <span class="comment">//初始化图片参数</span></span><br><span class="line">    PhotoCaptureParameters params = <span class="keyword">new</span> PhotoCaptureParameters(</span><br><span class="line">            session.getTitle(), orientation, session.getLocation(),</span><br><span class="line">            mContext.getExternalCacheDir(), <span class="keyword">this</span>, mPictureSaverCallback,</span><br><span class="line">            mHeadingSensor.getCurrentHeading(), mZoomValue, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//装配Session</span></span><br><span class="line">    decorateSessionAtCaptureTime(session);</span><br><span class="line">    <span class="comment">//拍照</span></span><br><span class="line">    mCamera.takePicture(params, session);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它首先调用createAndStartCaptureSession来创建一个CaptureSession并且启动会话,这里并且会进行初始参数的设置，譬如设置CaptureModule(此处实参为this)为图片处理的回调(后面再分析)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/CaptureModule.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> CaptureSession <span class="title">createAndStartCaptureSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取会话时间</span></span><br><span class="line">    <span class="keyword">long</span> sessionTime = getSessionTime();</span><br><span class="line">    <span class="comment">//当前位置</span></span><br><span class="line">    Location location = mLocationManager.getCurrentLocation();</span><br><span class="line">    <span class="comment">//设置picture name</span></span><br><span class="line">    String title = CameraUtil.instance().createJpegName(sessionTime);</span><br><span class="line">    <span class="comment">//创建会话</span></span><br><span class="line">    CaptureSession session = getServices().getCaptureSessionManager()</span><br><span class="line">           .createNewSession(title, sessionTime, location);</span><br><span class="line">    <span class="comment">//开启会话</span></span><br><span class="line">    session.startEmpty(<span class="keyword">new</span> CaptureStats(mHdrPlusEnabled),<span class="keyword">new</span> Size(</span><br><span class="line">        (<span class="keyword">int</span>) mPreviewArea.width(), (<span class="keyword">int</span>) mPreviewArea.height()));</span><br><span class="line">    <span class="keyword">return</span> session;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line">首先，获取会话的相关参数，包括会话时间，拍照的照片名字以及位置信息等，然后调用Session管理来创建CaptureSession，最后将此CaptureSession启动。到这里，会话就创建并启动了，所以接着分析上面的拍照流程，它会调用OneCameraImpl的takePicture方法来进行拍照：</span><br><span class="line"></span><br><span class="line">``` java</span><br><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/one/v2/OneCameraImpl.java]</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takePicture</span><span class="params">(<span class="keyword">final</span> PhotoCaptureParameters params, <span class="keyword">final</span> CaptureSession session)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 除非拍照已经返回，否则就广播一个未准备好状态的广播，即等待本次拍照结束</span></span><br><span class="line">    broadcastReadyState(<span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">//创建一个线程</span></span><br><span class="line">    mTakePictureRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//拍照</span></span><br><span class="line">            takePictureNow(params, session);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//设置回调，此回调后面将分析，它其实就是CaptureModule,它实现了PictureCallback</span></span><br><span class="line">    mLastPictureCallback = params.callback;</span><br><span class="line">    mTakePictureStartMillis = SystemClock.uptimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果需要自动聚焦</span></span><br><span class="line">    <span class="keyword">if</span> (mLastResultAFState == AutoFocusState.ACTIVE_SCAN) &#123;</span><br><span class="line">        mTakePictureWhenLensIsStopped = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//拍照</span></span><br><span class="line">        takePictureNow(params, session);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在拍照里，首先广播一个未准备好的状态广播，然后进行拍照的回调设置，并且判断是否有自动聚焦，如果是则将mTakePictureWhenLensIsStopped 设为ture，即即刻拍照被停止了，否则则调用OneCameraImpl的takePictureNow方法来发起拍照请求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/one/v2/OneCameraImpl.java]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takePictureNow</span><span class="params">(PhotoCaptureParameters params, CaptureSession </span></span></span><br><span class="line"><span class="function"><span class="params">        session)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> dt = SystemClock.uptimeMillis() - mTakePictureStartMillis;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 构造JPEG图片拍照的请求</span></span><br><span class="line">        CaptureRequest.Builder builder = mDevice.createCaptureRequest(</span><br><span class="line">            CameraDevice.TEMPLATE_STILL_CAPTURE);</span><br><span class="line">        builder.setTag(RequestTag.CAPTURE);</span><br><span class="line">        addBaselineCaptureKeysToRequest(builder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Enable lens-shading correction for even better DNGs.</span></span><br><span class="line">        <span class="keyword">if</span> (sCaptureImageFormat == ImageFormat.RAW_SENSOR) &#123;</span><br><span class="line">            builder.set(CaptureRequest.STATISTICS_LENS_SHADING_MAP_MODE,</span><br><span class="line">                CaptureRequest.STATISTICS_LENS_SHADING_MAP_MODE_ON);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sCaptureImageFormat == ImageFormat.JPEG) &#123;</span><br><span class="line">            builder.set(CaptureRequest.JPEG_QUALITY, JPEG_QUALITY);</span><br><span class="line">                .getJpegRotation(params.orientation, mCharacteristics));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//用于preview的控件</span></span><br><span class="line">        builder.addTarget(mPreviewSurface);</span><br><span class="line">        <span class="comment">//用于图片显示的控件</span></span><br><span class="line">        builder.addTarget(mCaptureImageReader.getSurface());</span><br><span class="line">        CaptureRequest request = builder.build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_WRITE_CAPTURE_DATA) &#123;</span><br><span class="line">            <span class="keyword">final</span> String debugDataDir = makeDebugDir(params.debugDataFolder,</span><br><span class="line">                        <span class="string">"normal_capture_debug"</span>);</span><br><span class="line">            Log.i(TAG, <span class="string">"Writing capture data to: "</span> + debugDataDir);</span><br><span class="line">            CaptureDataSerializer.toFile(<span class="string">"Normal Capture"</span>, request, </span><br><span class="line">                <span class="keyword">new</span> File(debugDataDir,<span class="string">"capture.txt"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//拍照，mCaptureCallback为回调</span></span><br><span class="line">        mCaptureSession.capture(request, mCaptureCallback, mCameraHandler);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CameraAccessException e) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"Could not access camera for still image capture."</span>);</span><br><span class="line">        broadcastReadyState(<span class="keyword">true</span>);</span><br><span class="line">        params.callback.onPictureTakingFailed();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (mCaptureQueue) &#123;</span><br><span class="line">        mCaptureQueue.add(<span class="keyword">new</span> InFlightCapture(params, session));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与preview类似，都是通过CaptureRequest来与Camera进行通信的，通过session的capture来进行拍照，并设置拍照的回调函数为mCaptureCallback：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/base/core/java/android/hardware/camera2/impl/CameraCaptureSessionImpl.java]</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">capture</span><span class="params">(CaptureRequest request,CaptureCallback callback,Handler handler)</span><span class="keyword">throws</span> CameraAccessException</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    handler = checkHandler(handler,callback);</span><br><span class="line">    <span class="keyword">return</span> addPendingSequence(mDeviceImpl.capture(request,createCaptureCallbackProxy(</span><br><span class="line">        handler,callback),mDeviceHandler));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码与preview中的类似，都是将请求加入到待处理的请求集，现在看CaptureCallback回调：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/one/v2/OneCameraImpl.java]</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CameraCaptureSession.CaptureCallback mCaptureCallback = <span class="keyword">new</span> CameraCaptureSession.CaptureCallback()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCaptureStarted</span><span class="params">(CameraCaptureSession session,CaptureRequest request,<span class="keyword">long</span> </span></span></span><br><span class="line"><span class="function"><span class="params">            timestamp,<span class="keyword">long</span> frameNumber)</span></span>&#123;</span><br><span class="line">　　　　　<span class="comment">//与preview类似</span></span><br><span class="line">        <span class="keyword">if</span>(request.getTag() == RequestTag.CAPTURE&amp;&amp;mLastPictureCallback!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            mLastPictureCallback.onQuickExpose();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCaptureCompleted</span><span class="params">(CameraCaptureSession session,CaptureRequest request</span></span></span><br><span class="line"><span class="function"><span class="params">            ,TotalCaptureResult result)</span></span>&#123;</span><br><span class="line">        autofocusStateChangeDispatcher(result);</span><br><span class="line">        <span class="keyword">if</span>(result.get(CaptureResult.CONTROL_AF_STATE) == <span class="keyword">null</span>)&#123;</span><br><span class="line">　　　　　　　<span class="comment">//检查自动聚焦的状态</span></span><br><span class="line">            AutoFocusHelper.checkControlAfState(result);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span>(request.getTag() == RequestTag.CAPTURE)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(mCaptureQueue)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mCaptureQueue.getFirst().setCaptureResult(result).isCaptureComplete())&#123;</span><br><span class="line">                    capture = mCaptureQueue.removeFirst();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(capture != <span class="keyword">null</span>)&#123;</span><br><span class="line">　　　　　　　　　<span class="comment">//拍照结束</span></span><br><span class="line">                OneCameraImpl.<span class="keyword">this</span>.onCaptureCompleted(capture);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.onCaptureCompleted(session,request,result);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是Native层在处理请求时，会调用相应的回调，如capture开始时，会回调onCaptureStarted,具体的在preview中有过分析，当拍照结束时，会回调onCaptureCompleted方法，其中会根据CaptureResult来检查自动聚焦的状态，并通过TAG判断其是Capture动作时，再来看它是否是队列中的第一个请求，如果是，则将请求移除，因为请求已经处理成功，最后再调用OneCameraImpl的onCaptureCompleted方法来进行处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/one/v2/OneCameraImpl.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onCaptureCompleted</span><span class="params">(InFlightCapture capture)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isCaptureImageFormat == ImageFormat.RAW_SENSOR)&#123;</span><br><span class="line">        ...</span><br><span class="line">        File dngFile = <span class="keyword">new</span> File(RAW_DIRECTORY,capture.session.getTitle()+<span class="string">".dng"</span>);</span><br><span class="line">        writeDngBytesAndClose(capture.image,capture.totalCaptureResult,mCharacteristics,dngFile);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//解析result中的图片数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] imageBytes = acquireJpegBytesAndClose(capture.image);</span><br><span class="line">        <span class="comment">//保存Jpeg图片</span></span><br><span class="line">        saveJpegPicture(imageBytes,capture.parameters,capture.session,capture.totalCaptureResult);</span><br><span class="line">    &#125;</span><br><span class="line">    broadcastReadyState(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//调用回调</span></span><br><span class="line">    capture.parameters.callback.onPictureTaken(capture.session);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如代码所示，首先，对result中的图片数据进行了解析，然后调用saveJpegPicture方法将解析得到的图片数据进行保存，最后再调用里面的回调(即CaptureModule，前面在初始化Parameters时说明了，它实现了PictureCallbak接口)的onPictureTaken方法，所以，接下来先分析saveJpegPicture方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/one/v2/OneCameraImpl.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">saveJpegPicture</span><span class="params">(<span class="keyword">byte</span>[] jpegData,<span class="keyword">final</span> PhotoCaptureParameters captureParams,CaptureSession session,CaptureResult result)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ListenableFuture&lt;Optional&lt;Uri&gt;&gt; futureUri = session.saveAndFinish(jpegData,width,</span><br><span class="line">            height,rotation,exif);</span><br><span class="line">    Futures.addCallback(futureUri,<span class="keyword">new</span> FutureCallback&lt;Optional&lt;Uri&gt;&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(Optional&lt;Uri&gt; uriOptional)</span></span>&#123;</span><br><span class="line">            captureParams.callback.onPictureSaved(mOptional.orNull());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Throwable throwable)</span></span>&#123;</span><br><span class="line">            captureParams.callback.onPictureSaved(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它最后会回调onPictureSaved方法来对图片进行保存，所以需要分析CaptureModule的onPictureSaved方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/CaptureModule.java]</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPictureSaved</span><span class="params">(Uri uri)</span></span>&#123;</span><br><span class="line">    mAppController.notifyNewMedia(uri);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mAppController的实现为CameraActivity，所以分析notifyNewMedia方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/CameraActivity.java]</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyNewMedia</span><span class="params">(Uri uri)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span>(FilmstripItemUtils.isMimeTypeVideo(mimeType))&#123;</span><br><span class="line">　　　　<span class="comment">//如果拍摄的是video</span></span><br><span class="line">        sendBroadcast(<span class="keyword">new</span> Intent(CameraUtil.ACTION_NEW_VIDEO,uri));</span><br><span class="line">        newData = mVideoItemFactory.queryContentUri(uri);</span><br><span class="line">        ...</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(FilmstripItemUtils.isMimeTypeImage(mimeType))&#123;</span><br><span class="line">　　　　<span class="comment">//如果是拍摄图片</span></span><br><span class="line">        CameraUtil.broadcastNewPicture(mAppContext,uri);</span><br><span class="line">        newData = mPhotoItemFactory.queryCotentUri(uri);</span><br><span class="line">        ...</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">new</span> AsyncTask&lt;FilmstripItem,Void,FilmstripItem&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> FilmstripItem <span class="title">doInBackground</span><span class="params">(FilmstripItem... Params)</span></span>&#123;</span><br><span class="line">            FilmstripItem data = params[<span class="number">0</span>];</span><br><span class="line">            MetadataLoader.loadMetadata(getAndroidContet(),data);</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由代码可知，这里有两种数据的处理，一种是video，另一种是image。而我们这里分析的是capture图片数据，所以首先会根据在回调函数传入的参数Uri和PhotoItemFactory来查询到相应的拍照数据，然后再开启一个异步的Task来对此数据进行处理，即通过MetadataLoader的loadMetadata来加载数据，并返回。至此，capture的流程就基本分析结束了，下面将给出capture流程的整个过程中的时序图： </p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/camera.system/02-07-capture_over_flow.png" alt="Alt text"></p><h4 id="（三）、Camera-System-takepicture-ZSL-流程分析（本小节基于-Android-5-1-API11源码）"><a href="#（三）、Camera-System-takepicture-ZSL-流程分析（本小节基于-Android-5-1-API11源码）" class="headerlink" title="（三）、Camera System takepicture(ZSL)流程分析（本小节基于 Android 5.1 API11源码）"></a>（三）、Camera System takepicture(ZSL)流程分析（本小节基于 Android 5.1 API11源码）</h4><p>ZSL(zear shutter lag)即零延时，就是在拍照时不停预览就可以拍照.由于有较好的用户体验度，该feature是现在大部分手机都拥有的功能。<br>面不再贴出大量代码来描述过程，直接上图。下图是画了2个小时整理出来的Android5.1 Zsl的基本流程，可以看到与ZSL密切相关的有5个线程frameprocessor、captureSequencer、ZslProcessor3、JpegProcessor、Camera3Device:requestThread。其实还有一个主线程用于更新参数。针对Android5.1看代码所得，ZSL过程中大概分成下面7个流程.</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/camera.system/02-08-ZSL_takepicture.png" alt="Alt text"></p><p>更正：图中左上角的FrameProcessor线程起来后会在waitForNextFrame中执行mResultSignal.waitRelative()，图中没有更改过来。</p><h5 id="3-0、注册帧监听对象"><a href="#3-0、注册帧监听对象" class="headerlink" title="3.0、注册帧监听对象"></a>3.0、注册帧监听对象</h5><h5 id="3-0-1、captureSequence线程注册帧监听对象"><a href="#3-0-1、captureSequence线程注册帧监听对象" class="headerlink" title="3.0.1、captureSequence线程注册帧监听对象"></a>3.0.1、captureSequence线程注册帧监听对象</h5><h5 id="3-0-1-1、注册时机"><a href="#3-0-1-1、注册时机" class="headerlink" title="3.0.1.1、注册时机"></a>3.0.1.1、注册时机</h5><p>当上层发出ZSL拍照请求时，底层就会触发拍照捕获状态机，改状态机的基本流程图在上篇笔记中已经整理出来过，这里就不多说了。由于camera2Client与其它处理线程对象基本符合金字塔形的架构，可以看到这里是通过camera2Client的对象将帧可用监听对象注册到FrameProcess对象中的List<rangelistener> mRangeListeners;对象中。</rangelistener></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/services/camera/libcameraservice/api1/client2/CaptureSequencer.cpp]</span><br><span class="line">CaptureSequencer::CaptureState CaptureSequencer::manageZslStart(</span><br><span class="line">        sp&lt;Camera2Client&gt; &amp;client) &#123;</span><br><span class="line">    ALOGV(<span class="string">"%s"</span>, __FUNCTION__);</span><br><span class="line">    <span class="keyword">status_t</span> res;</span><br><span class="line">    sp&lt;ZslProcessorInterface&gt; processor = mZslProcessor.promote();</span><br><span class="line">    <span class="comment">// We don't want to get partial results for ZSL capture.</span></span><br><span class="line">    client-&gt;registerFrameListener(mCaptureId, mCaptureId + <span class="number">1</span>,</span><br><span class="line">            <span class="keyword">this</span>,</span><br><span class="line">            <span class="comment">/*sendPartials*/</span><span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Actually select the right thing here.</span></span><br><span class="line">    res = processor-&gt;pushToReprocess(mCaptureId);</span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特别注意：可以看到在注册帧监听对象时，传入的两个参数是mCaptureId, mCaptureId + 1,为什么会是这样呢,因为这个就是标记我们想抓的是哪一帧,当拍照buffer从hal上来之后,Camera3Device就会回调帧可用监听对象，然后得到拍照帧的时间戳，紧接着根据时间戳从ZSL RingBuffer中找到最理想的inputBuffer，然后下发给hal进行Jpeg编解码。对比下面ZSL线程的CaptureId,应该就理解了.</p><h5 id="3-0-1-2、捕获时机"><a href="#3-0-1-2、捕获时机" class="headerlink" title="3.0.1.2、捕获时机"></a>3.0.1.2、捕获时机</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/services/camera/libcameraservice/api1/client2/CaptureSequencer.cpp]</span><br><span class="line"><span class="keyword">void</span> CaptureSequencer::onResultAvailable(<span class="keyword">const</span> CaptureResult &amp;result) &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ALOGV(<span class="string">"%s: New result available."</span>, __FUNCTION__);</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">l</span><span class="params">(mInputMutex)</span></span>;</span><br><span class="line">    mNewFrameId = result.mResultExtras.requestId;</span><br><span class="line">    mNewFrame = result.mMetadata;</span><br><span class="line">    <span class="keyword">if</span> (!mNewFrameReceived) &#123;</span><br><span class="line">        mNewFrameReceived = <span class="literal">true</span>;</span><br><span class="line">        .signal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面即是拍照状态机注册的回调函数，其中当ZSL拍照帧上来之后，机会激活正在等待中的CaptureSequencer线程，以进行后续的操作。</p><h5 id="3-0-2、ZslProcess3线程注册帧监听对象"><a href="#3-0-2、ZslProcess3线程注册帧监听对象" class="headerlink" title="3.0.2、ZslProcess3线程注册帧监听对象"></a>3.0.2、ZslProcess3线程注册帧监听对象</h5><h5 id="3-0-2-1、注册时机"><a href="#3-0-2-1、注册时机" class="headerlink" title="3.0.2.1、注册时机"></a>3.0.2.1、注册时机</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/services/camera/libcameraservice/api1/client2/ZslProcessor.cpp]</span><br><span class="line"><span class="keyword">status_t</span> ZslProcessor::updateStream(<span class="keyword">const</span> Parameters &amp;params) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mZslStreamId == NO_STREAM) &#123;</span><br><span class="line">        <span class="comment">// Create stream for HAL production</span></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Sort out better way to select resolution for ZSL</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Note that format specified internally in Camera3ZslStream</span></span><br><span class="line">        res = device-&gt;createZslStream(</span><br><span class="line">                params.fastInfo.arrayWidth, params.fastInfo.arrayHeight,</span><br><span class="line">                mBufferQueueDepth,</span><br><span class="line">                &amp;mZslStreamId,</span><br><span class="line">                &amp;mZslStream);</span><br><span class="line">        <span class="comment">// Only add the camera3 buffer listener when the stream is created.</span></span><br><span class="line">        mZslStream-&gt;addBufferListener(<span class="keyword">this</span>);<span class="comment">//这里是在BufferQueue注册的callback，暂时不用关心。</span></span><br><span class="line">    &#125;</span><br><span class="line">    client-&gt;registerFrameListener(Camera2Client::kPreviewRequestIdStart,</span><br><span class="line">            Camera2Client::kPreviewRequestIdEnd,</span><br><span class="line">            <span class="keyword">this</span>,</span><br><span class="line">            <span class="comment">/*sendPartials*/</span><span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的即为更新zsl流时调用的函数,可以看到其中使用registerFrameListener注册了RingBuffer可用监听对象，这里我们要特别注意的是下面2个宏。这个是专门为预览预留的requestId，考虑这样也会有录像和拍照的requestId,每次更新参数后，这个requestId会有+1操作，没有参数更新，则不会+1，这个可以在各自的Debug手机上发现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/services/camera/libcameraservice/api1/Camera2Client.h]</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int32_t</span> kPreviewRequestIdStart = <span class="number">10000000</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int32_t</span> kPreviewRequestIdEnd   = <span class="number">20000000</span>;</span><br></pre></td></tr></table></figure><h5 id="3-0-2-2、捕获时机"><a href="#3-0-2-2、捕获时机" class="headerlink" title="3.0.2.2、捕获时机"></a>3.0.2.2、捕获时机</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/services/camera/libcameraservice/api1/client2/ZslProcessor.cpp]</span><br><span class="line"><span class="keyword">void</span> ZslProcessor::onResultAvailable(<span class="keyword">const</span> CaptureResult &amp;result) &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ALOGV(<span class="string">"%s:"</span>, __FUNCTION__);</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">l</span><span class="params">(mInputMutex)</span></span>;</span><br><span class="line">    <span class="keyword">camera_metadata_ro_entry_t</span> entry;</span><br><span class="line">    entry = result.mMetadata.find(ANDROID_SENSOR_TIMESTAMP);</span><br><span class="line">    <span class="keyword">nsecs_t</span> timestamp = entry.data.i64[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    entry = result.mMetadata.find(ANDROID_REQUEST_FRAME_COUNT);</span><br><span class="line">    <span class="keyword">int32_t</span> frameNumber = entry.data.i32[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Corresponding buffer has been cleared. No need to push into mFrameList</span></span><br><span class="line">    <span class="keyword">if</span> (timestamp &lt;= mLatestClearedBufferTimestamp) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    mFrameList.editItemAt(mFrameListHead) = result.mMetadata;</span><br><span class="line">    mFrameListHead = (mFrameListHead + <span class="number">1</span>) % mFrameListDepth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>去掉错误检查代码，上面由于CaptureID是下面2个，也就是ZSL的所有预览Buffer可用之后都会回调这个方法,当队列满之后，新buffer会覆盖旧buffer位置。上面可以看到mFrameList中会保存每一帧的metadata数据，mFrameListHead用来标识下一次存放数据的位置。</p><h5 id="3-1、查找ZSL拍照最合适的buffer"><a href="#3-1、查找ZSL拍照最合适的buffer" class="headerlink" title="3.1、查找ZSL拍照最合适的buffer"></a>3.1、查找ZSL拍照最合适的buffer</h5><p>一开始我以为是是根据想要抓取那帧的captureId来找到zsl拍照buffer的，但是现在看来就是找时间戳最近的那个buffer来进行jpeg编解码(而且google工程师在源码中注释也是这样说的).</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/services/camera/libcameraservice/api1/client2/ZslProcessor.cpp]</span><br><span class="line"><span class="keyword">status_t</span> ZslProcessor::pushToReprocess(<span class="keyword">int32_t</span> requestId) &#123;</span><br><span class="line">    ALOGV(<span class="string">"%s: Send in reprocess request with id %d"</span>,</span><br><span class="line">            __FUNCTION__, requestId);</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">l</span><span class="params">(mInputMutex)</span></span>;</span><br><span class="line">    <span class="keyword">status_t</span> res;</span><br><span class="line">    sp&lt;Camera2Client&gt; client = mClient.promote();</span><br><span class="line">    <span class="comment">//下面是就是在mFrameList查找时间戳最近的帧。</span></span><br><span class="line">    <span class="keyword">size_t</span> metadataIdx;</span><br><span class="line">    <span class="keyword">nsecs_t</span> candidateTimestamp = getCandidateTimestampLocked(&amp;metadataIdx);</span><br><span class="line">   <span class="comment">//根据上一次查找的时间戳，从ZSL BufferQueue中查找时间最接近的Buffer，并将</span></span><br><span class="line">   <span class="comment">//buffer保存到mInputBufferQueue队列中。</span></span><br><span class="line">    res = mZslStream-&gt;enqueueInputBufferByTimestamp(candidateTimestamp,</span><br><span class="line">                                                    <span class="comment">/*actualTimestamp*/</span><span class="literal">NULL</span>);</span><br><span class="line">   <span class="comment">//-----------------</span></span><br><span class="line">    &#123;<span class="comment">//获取zsl 编解码的metadataId，稍后会传入给hal编解码。</span></span><br><span class="line">        CameraMetadata request = mFrameList[metadataIdx];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Verify that the frame is reasonable for reprocessing</span></span><br><span class="line">        <span class="keyword">camera_metadata_entry_t</span> entry;</span><br><span class="line">        entry = request.find(ANDROID_CONTROL_AE_STATE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (entry.data.u8[<span class="number">0</span>] != ANDROID_CONTROL_AE_STATE_CONVERGED &amp;&amp;</span><br><span class="line">                entry.data.u8[<span class="number">0</span>] != ANDROID_CONTROL_AE_STATE_LOCKED) &#123;</span><br><span class="line">            ALOGV(<span class="string">"%s: ZSL queue frame AE state is %d, need full capture"</span>,</span><br><span class="line">                    __FUNCTION__, entry.data.u8[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> NOT_ENOUGH_DATA;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//这中间会更新输入stream的流ID、更新捕获意图为静态拍照、判断这一帧是否AE稳定、</span></span><br><span class="line">       <span class="comment">//获取jpegStreamID并更新到metadata中、更新请求ID，最后根据更新后的request metadata</span></span><br><span class="line">       <span class="comment">//更新jpeg metadata。最后一步启动Camera3Device抓取图片。</span></span><br><span class="line">        <span class="comment">// Update post-processing settings</span></span><br><span class="line">        res = updateRequestWithDefaultStillRequest(request);</span><br><span class="line">        mLatestCapturedRequest = request;</span><br><span class="line">        res = client-&gt;getCameraDevice()-&gt;capture(request);</span><br><span class="line">        mState = LOCKED;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 还记得在启动状态机器时，注册的帧监听对象吧。这里参数requestId就是我们想要抓拍的图片的请求ID,目前发现该请求ID后面会更新到metadata中。这里只要知道该函数功能就可以了。</p><p>☯ 1、从mFrameList中查找时间戳最小的metadata。<br>☯ 2、根据从第一步获取到时间戳，从ZSL BufferQueue选择时间最接近Buffer.<br>☯3、将Buffer放到mInputBufferQueue中，更新jpeg编解码metadata，启动Capture功能。</p><h5 id="3-2、设置zsl-input-buffer和-jpeg-out-buffer"><a href="#3-2、设置zsl-input-buffer和-jpeg-out-buffer" class="headerlink" title="3.2、设置zsl input buffer和 jpeg out buffer"></a>3.2、设置zsl input buffer和 jpeg out buffer</h5><p>  其实这一步之前已经讨论过，inputBuffer是ZslProcess3线程查找到最合适的用于jpeg编解码的buffer。outputBuffer为JpegProcessor线程更新的buffer用于存放hal编解码之后的jpeg图片。其中准备jpeg OutBuffer的操作就是在下面操作的。可以看到将outputStream的ID，保存到metadata中了。这样就会在Camera3Device中根据这项metadata来添加outputBuffer到hal。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> ZslProcessor::pushToReprocess(<span class="keyword">int32_t</span> requestId) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Shouldn't we also update the latest preview frame?</span></span><br><span class="line">        <span class="keyword">int32_t</span> outputStreams[<span class="number">1</span>] =</span><br><span class="line">                &#123; client-&gt;getCaptureStreamId() &#125;;</span><br><span class="line">        res = request.update(ANDROID_REQUEST_OUTPUT_STREAMS,</span><br><span class="line">                outputStreams, <span class="number">1</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="3-3、归还jpeg-Buffer干了什么"><a href="#3-3、归还jpeg-Buffer干了什么" class="headerlink" title="3.3、归还jpeg Buffer干了什么."></a>3.3、归还jpeg Buffer干了什么.</h5><p>  当framework将ZSL inputBuffer和jpeg outputBuffer,传给hal后，hal就会启动STLL_CAPTURE流程，将inputBuffer中的图像数据，进行一系列的后处理流程。当后处理完成后，hal则会将临时Buffer拷贝到outPutBuffer中(注意：这里要记得做flush操作，即刷新Buffer,要不然图片有可能会出现绿条).<br>  因为JpegBuffer也是从BufferQueue Dequeue出来的buffer,而且在创建BufferQueue时，也注册了帧监听对象(即：onFrameAvailable()回调).这样的话当帧可用(即：进行了enqueue操作），就会回调onFrameAvailable()方法，这样当hal归还jpegBuffer时就是要进行enqueue()操作。在onFrameAvailable()方法中，会激活jpegproces线程，进行后续的处理，最后激活captureSequeue拍照状态机线程。</p><h5 id="3-4、保存ZSLBuffer"><a href="#3-4、保存ZSLBuffer" class="headerlink" title="3.4、保存ZSLBuffer."></a>3.4、保存ZSLBuffer.</h5><p>  这里由于ZSL Buffer一直会从hal上来，所以当zslBuffer上来后，就会激活FrameProcesor线程保存这一ZslBuffer，目前FrameWork那边默认是4个buffer，这样的话当队列满之后，就会覆盖之前最老的buffer,如此反复操作。</p><h5 id="3-5、获取拍照jpeg-Buffer"><a href="#3-5、获取拍照jpeg-Buffer" class="headerlink" title="3.5、获取拍照jpeg Buffer"></a>3.5、获取拍照jpeg Buffer</h5><p>  当hal上来jpeg帧后，就会激活jpegProcess线程,并从BufferQueue中拿到jpegbuffer，下面可以发现进行lockNextBuffer,unlockBuffer操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/services/camera/libcameraservice/api1/client2/JpegProcessor.cpp]</span><br><span class="line"><span class="keyword">status_t</span> JpegProcessor::processNewCapture() &#123;</span><br><span class="line">    res = mCaptureConsumer-&gt;lockNextBuffer(&amp;imgBuffer);</span><br><span class="line">    mCaptureConsumer-&gt;unlockBuffer(imgBuffer);</span><br><span class="line">    sp&lt;CaptureSequencer&gt; sequencer = mSequencer.promote();</span><br><span class="line">   <span class="comment">//...... </span></span><br><span class="line">    <span class="keyword">if</span> (sequencer != <span class="number">0</span>) &#123;</span><br><span class="line">        sequencer-&gt;onCaptureAvailable(imgBuffer.timestamp, captureBuffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面可以发现最后回调了captureSequencer线程的onCaptureAvailable()回调方法。该回调方法主要作用就是将时间戳和jpeg buffer的传送到CaptureSequencer线程中,然后激活CaptureSequencer线程。最后将Buffer CallBack到应用层。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/services/camera/libcameraservice/api1/client2/CaptureSequencer.cpp]</span><br><span class="line"><span class="keyword">void</span> CaptureSequencer::onCaptureAvailable(<span class="keyword">nsecs_t</span> timestamp,</span><br><span class="line">        sp&lt;MemoryBase&gt; captureBuffer) &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ALOGV(<span class="string">"%s"</span>, __FUNCTION__);</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">l</span><span class="params">(mInputMutex)</span></span>;</span><br><span class="line">    mCaptureTimestamp = timestamp;</span><br><span class="line">    mCaptureBuffer = captureBuffer;</span><br><span class="line">    <span class="keyword">if</span> (!mNewCaptureReceived) &#123;</span><br><span class="line">        mNewCaptureReceived = <span class="literal">true</span>;</span><br><span class="line">        mNewCaptureSignal.signal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-6、拍照帧可用回调"><a href="#3-6、拍照帧可用回调" class="headerlink" title="3.6、拍照帧可用回调"></a>3.6、拍照帧可用回调</h5><p>当拍照帧回到Framework后，就会回调CaptureSequencer的onResultAvailable()接口，用于设置captureSequencer状态机的标志位和条件激活,如下代码所示。条件变量和标志位的使用可以在状态机方法manageStandardCaptureWait()看到使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/services/camera/libcameraservice/api1/client2/CaptureSequencer.cpp]</span><br><span class="line"><span class="keyword">void</span> CaptureSequencer::onResultAvailable(<span class="keyword">const</span> CaptureResult &amp;result) &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ALOGV(<span class="string">"%s: New result available."</span>, __FUNCTION__);</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">l</span><span class="params">(mInputMutex)</span></span>;</span><br><span class="line">    mNewFrameId = result.mResultExtras.requestId;</span><br><span class="line">    mNewFrame = result.mMetadata;</span><br><span class="line">    <span class="keyword">if</span> (!mNewFrameReceived) &#123;</span><br><span class="line">        mNewFrameReceived = <span class="literal">true</span>;</span><br><span class="line">        mNewFrameSignal.signal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-7、jpeg-buffer回调到app"><a href="#3-7、jpeg-buffer回调到app" class="headerlink" title="3.7、jpeg buffer回调到app"></a>3.7、jpeg buffer回调到app</h5><p>该callback是应用注册过来的一个代理对象，下面就是通过binder进程间调用将jpeg Buffer传送到APP端，注意这里的msgTyep = CAMERA_MSG_COMPRESSED_IMAGE,就是告诉上层这是一个压缩的图像数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/services/camera/libcameraservice/api1/client2/CaptureSequencer.cpp]</span><br><span class="line">CaptureSequencer::CaptureState CaptureSequencer::manageDone(sp&lt;Camera2Client&gt; &amp;client) &#123;</span><br><span class="line">    <span class="keyword">status_t</span> res = OK;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    mCaptureId++;</span><br><span class="line">        ......</span><br><span class="line">            Camera2Client::SharedCameraCallbacks::Lock</span><br><span class="line">            l(client-&gt;mSharedCameraCallbacks);</span><br><span class="line">        ALOGV(<span class="string">"%s: Sending still image to client"</span>, __FUNCTION__);</span><br><span class="line">        <span class="keyword">if</span> (l.mRemoteCallback != <span class="number">0</span>) &#123;</span><br><span class="line">            l.mRemoteCallback-&gt;dataCallback(CAMERA_MSG_COMPRESSED_IMAGE,</span><br><span class="line">                    mCaptureBuffer, <span class="literal">NULL</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ALOGV(<span class="string">"%s: No client!"</span>, __FUNCTION__);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（四）、Camera-System-Recorder流程分析"><a href="#（四）、Camera-System-Recorder流程分析" class="headerlink" title="（四）、Camera System Recorder流程分析"></a>（四）、Camera System Recorder流程分析</h4><p>camera Video.虽然标题是recording流程分析，但这里很多和preview是相似的(包含更新，创建Stream,创建Request)，这里主要分析MediaRecorder对象创建、video帧监听对象注册、帧可用事件以及一系列callback流程分析。</p><h5 id="4-1、认识video-mediaRecorder-状态机"><a href="#4-1、认识video-mediaRecorder-状态机" class="headerlink" title="4.1、认识video(mediaRecorder)状态机"></a>4.1、认识video(mediaRecorder)状态机</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/camera.system/02-09-mediaRecorder-status.png" alt="Alt text"></p><blockquote><p>Used to record audio and video. The recording control is based on a<br>simple state machine (see below).状态机请看上面源码中给的流程图。<br>A common case of using MediaRecorder to record audio works as follows:<br>1.MediaRecorder recorder = new MediaRecorder();<br>2.recorder.setAudioSource(MediaRecorder.AudioSource.MIC);<br>3.recorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP);<br>4.recorder.setAudioEncoder(MediaRecorder.AudioEncoder.AMR_NB);<br>5.recorder.setOutputFile(PATH_NAME);<br>6.recorder.prepare();<br>7.recorder.start(); // Recording is now started<br>8….<br>9.recorder.stop();<br>10.recorder.reset(); // You can reuse the object by going back to setAudioSource() step<br>recorder.release(); // Now the object cannot be reused<br>  Applications may want to register for informational and error<br>events in order to be informed of some internal update and possible<br>runtime errors during recording. Registration for such events is<br>done by setting the appropriate listeners (via calls<br>(to {@link #setOnInfoListener(OnInfoListener)}setOnInfoListener and/or<br>{@link #setOnErrorListener(OnErrorListener)}setOnErrorListener).<br>In order to receive the respective callback associated with these listeners,<br>applications are required to create MediaRecorder objects on threads with a<br>Looper running (the main UI thread by default already has a Looper running).</p></blockquote><p>上面是googole工程师加的注释，最权威的资料。大概意思就是说“使用mediaRecorder记录音视频，需要一个简单的状态机来控制”。上面的1,2,3…就是在操作时需要准守的步骤。算了吧，翻译水平有限，重点还是放到camera这边吧。</p><h5 id="4-2、Camera-app如何启动录像"><a href="#4-2、Camera-app如何启动录像" class="headerlink" title="4.2、Camera app如何启动录像"></a>4.2、Camera app如何启动录像</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码路径:pdk/apps/TestingCamera/src/com/android/testingcamera/TestingCamera.java</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startRecording</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log(<span class="string">"Starting recording"</span>);</span><br><span class="line">        logIndent(<span class="number">1</span>);</span><br><span class="line">        log(<span class="string">"Configuring MediaRecoder"</span>);</span><br><span class="line">        <span class="comment">//这里会检查是否打开了录像功能。这里我们省略了，直接不如正题</span></span><br><span class="line"><span class="comment">//上面首先创建了一个MediaRecorder的java对象(注意这里同camera.java类似，java对象中肯定包含了一个mediaRecorder jni本地对象，继续往下看)</span></span><br><span class="line">        mRecorder = <span class="keyword">new</span> MediaRecorder();</span><br><span class="line">        <span class="comment">//下面就是设置一些callback.</span></span><br><span class="line">        mRecorder.setOnErrorListener(mRecordingErrorListener);</span><br><span class="line">        mRecorder.setOnInfoListener(mRecordingInfoListener);</span><br><span class="line">        <span class="keyword">if</span> (!mRecordHandoffCheckBox.isChecked()) &#123;</span><br><span class="line">    <span class="comment">//将当前camera java对象设置给了mediaRecorder java对象。</span></span><br><span class="line">    <span class="comment">//这里setCamera是jni接口，后面我们贴代码在分析。</span></span><br><span class="line">            mRecorder.setCamera(mCamera);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//将preview surface java对象设置给mediaRecorder java对象，后面贴代码</span></span><br><span class="line">    <span class="comment">//详细说明。</span></span><br><span class="line">        mRecorder.setPreviewDisplay(mPreviewHolder.getSurface());</span><br><span class="line">　　　　<span class="comment">//下面２个是设置音频和视频的资源。</span></span><br><span class="line">        mRecorder.setAudioSource(MediaRecorder.AudioSource.CAMCORDER);</span><br><span class="line">        mRecorder.setVideoSource(MediaRecorder.VideoSource.CAMERA);</span><br><span class="line">        mRecorder.setProfile(mCamcorderProfiles.get(mCamcorderProfile));</span><br><span class="line">        <span class="comment">//从app控件选择录像帧大小，并设置给mediaRecorder</span></span><br><span class="line">        Camera.Size videoRecordSize = mVideoRecordSizes.get(mVideoRecordSize);</span><br><span class="line">        <span class="keyword">if</span> (videoRecordSize.width &gt; <span class="number">0</span> &amp;&amp; videoRecordSize.height &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            mRecorder.setVideoSize(videoRecordSize.width, videoRecordSize.height);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从app控件选择录像帧率，并设置给mediaRecorder.</span></span><br><span class="line">        <span class="keyword">if</span> (mVideoFrameRates.get(mVideoFrameRate) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            mRecorder.setVideoFrameRate(mVideoFrameRates.get(mVideoFrameRate));</span><br><span class="line">        &#125;</span><br><span class="line">        File outputFile = getOutputMediaFile(MEDIA_TYPE_VIDEO);</span><br><span class="line">        log(<span class="string">"File name:"</span> + outputFile.toString());</span><br><span class="line">        mRecorder.setOutputFile(outputFile.toString());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> ready = <span class="keyword">false</span>;</span><br><span class="line">        log(<span class="string">"Preparing MediaRecorder"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//准备一下，请看下面google给的使用mediaRecorder标准流程</span></span><br><span class="line">            mRecorder.prepare();</span><br><span class="line">            ready = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;<span class="comment">//------异常处理省略</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ready) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log(<span class="string">"Starting MediaRecorder"</span>);</span><br><span class="line">                mRecorder.start();<span class="comment">//启动录像</span></span><br><span class="line">                mState = CAMERA_RECORD;</span><br><span class="line">                log(<span class="string">"Recording active"</span>);</span><br><span class="line">                mRecordingFile = outputFile;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;<span class="comment">//-----异常处理省略</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//------------</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到应用启动录像功能是是符合状态机流程的。在应用开发中，也要这样来做。</p><p>☯ 1.创建mediaRecorderjava对象，mRecorder = new MediaRecorder();<br>☯ 2.设置camera java对象到mediaRecorder中，mRecorder.setCamera(mCamera);<br>☯ 3.将preview surface对象设置给mediaRecorder,mRecorder.setPreviewDisplay(mPreviewHolder.getSurface());<br>☯ 4.设置音频源，mRecorder.setAudioSource(MediaRecorder.AudioSource.CAMCORDER);<br>☯ 5.设置视频源，mRecorder.setVideoSource(MediaRecorder.VideoSource.CAMERA);<br>☯ 6.设置录像帧大小和帧率，以及setOutputFile<br>☯ 8.准备工作，mRecorder.prepare();<br>☯ 9.启动mdiaRecorder,mRecorder.start();</p><h5 id="4-3、与MediaPlayerService相关的类接口之间的关系简介"><a href="#4-3、与MediaPlayerService相关的类接口之间的关系简介" class="headerlink" title="4.3、与MediaPlayerService相关的类接口之间的关系简介"></a>4.3、与MediaPlayerService相关的类接口之间的关系简介</h5><h5 id="4-3-1、mediaRecorder何时与MediaPlayerService发送关系"><a href="#4-3-1、mediaRecorder何时与MediaPlayerService发送关系" class="headerlink" title="4.3.1、mediaRecorder何时与MediaPlayerService发送关系"></a>4.3.1、mediaRecorder何时与MediaPlayerService发送关系</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/camera.system/02-10-MediaRecorder.png" alt="Alt text"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/frameworks/base/media/java/android/media/MediaRecorder.java</span><br><span class="line">MediaRecorder::MediaRecorder() : mSurfaceMediaSource(<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ALOGV(<span class="string">"constructor"</span>);</span><br><span class="line">    <span class="keyword">const</span> sp&lt;IMediaPlayerService&gt;&amp; service(getMediaPlayerService());</span><br><span class="line">    <span class="keyword">if</span> (service != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mMediaRecorder = service-&gt;createMediaRecorder();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mMediaRecorder != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mCurrentState = MEDIA_RECORDER_IDLE;</span><br><span class="line">    &#125;</span><br><span class="line">    doCleanUp();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在jni中创建mediaRecorder对象时，其实在构造函数中偷偷的链接了mediaPlayerService，这也是Android习惯用的方法。获取到MediaPlayerService代理对象后，通过匿名binder获取mediaRecorder代理对象。 </p><h5 id="4-3-2、mediaPlayerService类和接口之间关系"><a href="#4-3-2、mediaPlayerService类和接口之间关系" class="headerlink" title="4.3.2、mediaPlayerService类和接口之间关系"></a>4.3.2、mediaPlayerService类和接口之间关系</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/camera.system/02-11-mediaPlayerService.png" alt="Alt text"></p><table><thead><tr><th style="text-align:left">接口类型</th><th>接口说明</th></tr></thead><tbody><tr><td style="text-align:left">virtual sp createMediaRecorder() = 0;</td><td>创建mediaRecorder录视频服务对象的接口</td></tr><tr><td style="text-align:left">virtual sp create(const sp&amp; client, int　audioSessionId = 0) = 0;</td><td>创建mediaPlayer播放音乐服务对象的接口，播放音乐都是通过mediaPlayer对象播放的</td></tr><tr><td style="text-align:left">virtual status_t decode() = 0;</td><td>音频解码器</td></tr></tbody></table><h5 id="4-3-3、MediaRecorder类和接口之间关系"><a href="#4-3-3、MediaRecorder类和接口之间关系" class="headerlink" title="4.3.3、MediaRecorder类和接口之间关系"></a>4.3.3、MediaRecorder类和接口之间关系</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/camera.system/02-12-IMediaRecorder.png" alt="Alt text"></p><p>mediaRecorder功能就是来录像的。其中MediaRecorder类中，包含了BpMediaRecorder代理对象引用。MediaRecorderClient本地对象驻留在mediaPlayService中。它的接口比较多，这里就列出我们今天关注的几个接口。其它接口查看源码吧<br>详细介绍可以参考源码：frameworks/av/include/media/IMediaRecorder.h<br>| 接口类型 |     接口说明|<br>| :——– |: ——–|<br>| virtual status_t setCamera(const sp&amp; camera,const sp&amp; proxy) = 0;        |   这个接口也是非常需要我们关注的，这里获取到了启动录像操作的本地对象(BnCameraRecordingProxy），并通过匿名binder通信方式，第二个参数就是本地对象.然后在startRecording时将帧监听对象注册到camera本地对象中了|<br>| virtual status_t setPreviewSurface(const sp&amp; surface) = 0;            |   将preview预览surface对象设置给medaiRecorder，因为mediaRecorder也有一个camera本地client,所以这个surface对象最终还是会设置到cameraService用于显示。而录像的帧会在CameraService本地创建一个bufferQueue，具体下面会详细说明|<br>| virtual status_t setListener(const sp&amp; listener) = 0;        |   这里一看就是设置监听对象，监听对象是jni中的JNIMediaRecorderListener对象，该对象可以回调MediaRecorder.java类中的postEventFromNative方法，将时间送到java层。其实MediaRecorder实现了BnMediaRecorderClient接口，即实现notify接口，那么这里其实将本地对象传到MediaRecorder本地的客户端对象中（本地对象拿到的就是代理对象了），参考代码片段1|<br>| virtual status_t start() = 0;        |   启动录像功能，函数追究下去和Camera关系不大了，这里就不细说了|  </p><h5 id="4-3-3-1、代码片段1"><a href="#4-3-3-1、代码片段1" class="headerlink" title="4.3.3.1、代码片段1"></a>4.3.3.1、代码片段1</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">源码路径：frameworks/base/media/jni/android_media_MediaRecorder.cpp</span><br><span class="line"><span class="comment">// create new listener and give it to MediaRecorder</span></span><br><span class="line">sp&lt;JNIMediaRecorderListener&gt; listener = <span class="keyword">new</span> JNIMediaRecorderListener(env, thiz, weak_this);</span><br><span class="line">mr-&gt;setListener(listener);</span><br></pre></td></tr></table></figure><p>mediaRecorder jni接口回调java方法，通知上层native事件。</p><h5 id="4-3-3-2、代码片段2"><a href="#4-3-3-2、代码片段2" class="headerlink" title="4.3.3.2、代码片段2"></a>4.3.3.2、代码片段2</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\media\jni\android_media_MediaRecorder.cpp]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_media_MediaRecorder_setCamera</span><span class="params">(JNIEnv* env, jobject thiz, jobject camera)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// we should not pass a null camera to get_native_camera() call.</span></span><br><span class="line"><span class="comment">//这里检查camera是不是空的，显然不是空的。</span></span><br><span class="line">    <span class="comment">//这个地方需要好好研究一下，其中camera是java层的camera对象(即camera.java)</span></span><br><span class="line">    <span class="comment">//这里由java对象获取到camera应用端本地对象。</span></span><br><span class="line">    sp&lt;Camera&gt; c = get_native_camera(env, camera, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// get_native_camera will throw an exception in this case</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取mediaRecorder本地对象</span></span><br><span class="line">    sp&lt;MediaRecorder&gt; mr = getMediaRecorder(env, thiz);</span><br><span class="line">    <span class="comment">//下面要特别注意，这里为什么传入的不是Camera对象而是c-&gt;remote()，当时琢磨</span></span><br><span class="line">    <span class="comment">//着，camera.cpp也没实现什么代理类的接口啊，不过后来在cameraBase类中发现</span></span><br><span class="line">    <span class="comment">//重载了remote()方法，该方法返回ICamera代理对象，呵呵。这样的话就会在</span></span><br><span class="line">    <span class="comment">//mediaRecorder中创建一个新的ICamera代理对象。并在mediaPlayerService中</span></span><br><span class="line">    <span class="comment">//创建了一个本地的Camera对象。</span></span><br><span class="line">    <span class="comment">//c-&gt;getRecordingProxy():获取camera本地对象实现的Recording本地对象。这里</span></span><br><span class="line">    <span class="comment">//调用setCamera设置到mediaRecorder本地对象中了(见代码片段３)</span></span><br><span class="line">   process_media_recorder_call(env, mr-&gt;setCamera(c-&gt;remote(), c-&gt;getRecordingProxy()),</span><br><span class="line">            <span class="string">"java/lang/RuntimeException"</span>, <span class="string">"setCamera failed."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//camera端</span></span><br><span class="line">sp&lt;ICameraRecordingProxy&gt; Camera::getRecordingProxy() &#123;</span><br><span class="line">    ALOGV(<span class="string">"getProxy"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RecordingProxy(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//看看下面RecordingProxy实现了BnCameraRecordingProxy接口，</span></span><br><span class="line"><span class="comment">//是个本地对象，水落石出了。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecordingProxy</span> :</span> <span class="keyword">public</span> BnCameraRecordingProxy</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        RecordingProxy(<span class="keyword">const</span> sp&lt;Camera&gt;&amp; camera);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ICameraRecordingProxy interface</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> status_t <span class="title">startRecording</span><span class="params">(<span class="keyword">const</span> sp&lt;ICameraRecordingProxyListener&gt;&amp; listener)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">stopRecording</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">releaseRecordingFrame</span><span class="params">(<span class="keyword">const</span> sp&lt;IMemory&gt;&amp; mem)</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//这里的是mCamera已经不再是之前preview启动时对应的那个本地Camera对象</span></span><br><span class="line">    <span class="comment">//这是mediaRecorder重新创建的camera本地对象。</span></span><br><span class="line">        sp&lt;Camera&gt;         mCamera;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><h5 id="4-3-3-3、代码片段3-setCamera本地实现"><a href="#4-3-3-3、代码片段3-setCamera本地实现" class="headerlink" title="4.3.3.3、代码片段3-setCamera本地实现"></a>4.3.3.3、代码片段3-setCamera本地实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\MediaRecorderClient.cpp]</span><br><span class="line"><span class="keyword">status_t</span> MediaRecorderClient::setCamera(<span class="keyword">const</span> sp&lt;ICamera&gt;&amp; camera,</span><br><span class="line">                                        <span class="keyword">const</span> sp&lt;ICameraRecordingProxy&gt;&amp; proxy)</span><br><span class="line">&#123;</span><br><span class="line">    ALOGV(<span class="string">"setCamera"</span>);</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">lock</span><span class="params">(mLock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (mRecorder == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"recorder is not initialized"</span>);</span><br><span class="line">        <span class="keyword">return</span> NO_INIT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mRecorder-&gt;setCamera(camera, proxy);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造函数中可以看到创建了一个StagefrightRecorder对象，后续的其它操作</span></span><br><span class="line"><span class="comment">//都是通过mRecorder对象实现的</span></span><br><span class="line">MediaRecorderClient::MediaRecorderClient(<span class="keyword">const</span> sp&lt;MediaPlayerService&gt;&amp; service, <span class="keyword">pid_t</span> pid)</span><br><span class="line">&#123;</span><br><span class="line">    ALOGV(<span class="string">"Client constructor"</span>);</span><br><span class="line">    mPid = pid;</span><br><span class="line">    mRecorder = <span class="keyword">new</span> StagefrightRecorder;</span><br><span class="line">    mMediaPlayerService = service;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//StagefrightRecorder::setCamera实现</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StagefrightRecorder</span> :</span> <span class="keyword">public</span> MediaRecorderBase &#123;&#125;</span><br><span class="line"><span class="keyword">status_t</span> StagefrightRecorder::setCamera(<span class="keyword">const</span> sp&lt;ICamera&gt; &amp;camera,</span><br><span class="line">                                        <span class="keyword">const</span> sp&lt;ICameraRecordingProxy&gt; &amp;proxy) &#123;</span><br><span class="line"><span class="comment">//省去一些错误检查代码</span></span><br><span class="line">    mCamera = camera;</span><br><span class="line">    mCameraProxy = proxy;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终ICamera,ICameraRecordingProxy代理对象都存放到StagefrightRecorder对应的成员变量中，看来猪脚就在这个类中。</p><h5 id="4-3-3-4、代码片段4"><a href="#4-3-3-4、代码片段4" class="headerlink" title="4.3.3.4、代码片段4"></a>4.3.3.4、代码片段4</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/media/libstagefright/CameraSource.cpp]</span><br><span class="line"><span class="keyword">status_t</span> CameraSource::isCameraAvailable(</span><br><span class="line">    <span class="keyword">const</span> sp&lt;ICamera&gt;&amp; camera, <span class="keyword">const</span> sp&lt;ICameraRecordingProxy&gt;&amp; proxy,</span><br><span class="line">    <span class="keyword">int32_t</span> cameraId, <span class="keyword">const</span> String16&amp; clientName, <span class="keyword">uid_t</span> clientUid) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (camera == <span class="number">0</span>) &#123;</span><br><span class="line">        mCamera = Camera::connect(cameraId, clientName, clientUid);</span><br><span class="line">        <span class="keyword">if</span> (mCamera == <span class="number">0</span>) <span class="keyword">return</span> -EBUSY;</span><br><span class="line">        mCameraFlags &amp;= ~FLAGS_HOT_CAMERA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// We get the proxy from Camera, not ICamera. We need to get the proxy</span></span><br><span class="line">        <span class="comment">// to the remote Camera owned by the application. Here mCamera is a</span></span><br><span class="line">        <span class="comment">// local Camera object created by us. We cannot use the proxy from</span></span><br><span class="line">        <span class="comment">// mCamera here.</span></span><br><span class="line">        <span class="comment">//根据ICamera代理对象重新创建Camera本地对象</span></span><br><span class="line">        mCamera = Camera::create(camera);</span><br><span class="line">        <span class="keyword">if</span> (mCamera == <span class="number">0</span>) <span class="keyword">return</span> -EBUSY;</span><br><span class="line">        mCameraRecordingProxy = proxy;</span><br><span class="line">        <span class="comment">//目前还不清楚是什么标记，权且理解成支持热插拔标记</span></span><br><span class="line">        mCameraFlags |= FLAGS_HOT_CAMERA;</span><br><span class="line">        <span class="comment">//代理对象绑定死亡通知对象</span></span><br><span class="line">        mDeathNotifier = <span class="keyword">new</span> DeathNotifier();</span><br><span class="line">        <span class="comment">// isBinderAlive needs linkToDeath to work.</span></span><br><span class="line">        mCameraRecordingProxy-&gt;asBinder()-&gt;linkToDeath(mDeathNotifier);</span><br><span class="line">    &#125;</span><br><span class="line">    mCamera-&gt;lock();</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　由上面的类图之间的关系的，就知道mediaRecorder间接包含了cameaSource对象，这里为了简单直接要害代码。</p><p>☯ 1.在创建CameraSource对象时，会去检查一下Camera对象是否可用，可用的话就会根据传进来的代理对象重新创建Camera本地对象（注意这个时候Camera代理对象在mediaRecorder中）<br>☯ 2.然后保存RecordingProxy代理对象到mCameraRecordingProxy成员中，然后绑定死亡通知对象到RecordingProxy代理对象。</p><h5 id="4-3-3-5、代码片段5"><a href="#4-3-3-5、代码片段5" class="headerlink" title="4.3.3.5、代码片段5"></a>4.3.3.5、代码片段5</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/media/libstagefright/CameraSource.cpp]</span><br><span class="line"><span class="keyword">status_t</span> CameraSource::startCameraRecording() &#123;</span><br><span class="line">    ALOGV(<span class="string">"startCameraRecording"</span>);</span><br><span class="line">    <span class="comment">// Reset the identity to the current thread because media server owns the</span></span><br><span class="line">    <span class="comment">// camera and recording is started by the applications. The applications</span></span><br><span class="line">    <span class="comment">// will connect to the camera in ICameraRecordingProxy::startRecording.</span></span><br><span class="line">    <span class="keyword">int64_t</span> token = IPCThreadState::self()-&gt;clearCallingIdentity();</span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line">    <span class="keyword">if</span> (mNumInputBuffers &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        err = mCamera-&gt;sendCommand(</span><br><span class="line">            CAMERA_CMD_SET_VIDEO_BUFFER_COUNT, mNumInputBuffers, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    err = OK;</span><br><span class="line">    <span class="keyword">if</span> (mCameraFlags &amp; FLAGS_HOT_CAMERA) &#123;<span class="comment">//前面已经置位FLAGS_HOT_CAMERA，成立</span></span><br><span class="line">        mCamera-&gt;unlock();</span><br><span class="line">        mCamera.clear();</span><br><span class="line">        <span class="comment">//通过recording代理对象，直接启动camera本地端的recording</span></span><br><span class="line">        <span class="keyword">if</span> ((err = mCameraRecordingProxy-&gt;startRecording(</span><br><span class="line">                <span class="keyword">new</span> ProxyListener(<span class="keyword">this</span>))) != OK) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    IPCThreadState::self()-&gt;restoreCallingIdentity(token);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码需要我们注意的是在启动startRecording()时，创建的监听对象new ProxyListener(this),该监听对象会传到Camera本地对象中。当帧可用时，用来通知mediaRecorder有帧可以使用了，赶紧编码吧。</p><h5 id="4-3-3-6、代码片段6-mediaRecorder注册帧可用监听对象"><a href="#4-3-3-6、代码片段6-mediaRecorder注册帧可用监听对象" class="headerlink" title="4.3.3.6、代码片段6-mediaRecorder注册帧可用监听对象"></a>4.3.3.6、代码片段6-mediaRecorder注册帧可用监听对象</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/include/media/stagefright/CameraSource.h]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyListener</span>:</span> <span class="keyword">public</span> BnCameraRecordingProxyListener &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ProxyListener(<span class="keyword">const</span> sp&lt;CameraSource&gt;&amp; source);</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">dataCallbackTimestamp</span><span class="params">(<span class="keyword">int64_t</span> timestampUs, <span class="keyword">int32_t</span> msgType,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> sp&lt;IMemory&gt; &amp;data)</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        sp&lt;CameraSource&gt; mSource;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">//frameworks/av/camera/Camera.cpp</span></span><br><span class="line"><span class="keyword">status_t</span> Camera::RecordingProxy::startRecording(<span class="keyword">const</span> sp&lt;ICameraRecordingProxyListener&gt;&amp; listener)</span><br><span class="line">&#123;</span><br><span class="line">    ALOGV(<span class="string">"RecordingProxy::startRecording"</span>);</span><br><span class="line">    mCamera-&gt;setRecordingProxyListener(listener);</span><br><span class="line">    mCamera-&gt;reconnect();</span><br><span class="line">    <span class="keyword">return</span> mCamera-&gt;startRecording();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册帧监听对象就是在启动Recording时注册，主要有下面几步：</p><p>☯ 1.使用setRecordingProxyListener接口，将监听对象设置给mRecordingProxyListener 成员。<br>☯ 2.重新和cameraService握手(preview停止时就会断开链接，在切换瞬间就断开了)<br>☯ 3.使用ICamera代理对象启动录像。</p><h5 id="4-4、阶段小结"><a href="#4-4、阶段小结" class="headerlink" title="4.4、阶段小结"></a>4.4、阶段小结</h5><p>到这里Camera如何使用medaiRecorder录像的基本流程已经清楚了，这里我画了一个流程图，大概包含下面9个流程。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/camera.system/02-13-medaiRecorder-java-native.png" alt="Alt text"></p><p>☯ 过程1：上层点击了录像功能，或者录像preview模式下，会创建一个mediaRecorDer Java层对象。<br>☯ 过程2:java层mediaRecorder对象调用native_jni native_setup方法，创建一个native的mediaRecorder对象。创建的过程中连接mediaPlayerService,并通过匿名binder通信方式获取到一个mediaRecorderClient代理对象，并保存到mediaRecorder对象的成员变量mMediaRecorder中。<br>☯ 过程3:ava层的Camera对象传给mediaRecorder native层时，可以通过本地方法获取到Camera本地对象和ICamera代理对象。这里是获取ICamera代理对象和RecordingProxy本地对象<br>☯ 过程4:将ICamera代理对象和RecordingProxy本地对象传给在MedaiService本地端的MediaRecorderClient对象，这时ICamera是重新创建的ICamer代理对象，以及获取到RecordingProxy代理对象。<br>☯ 过程5：根据过程４获取到的新的ICamera代理对象和RecordingProxy代理对象，创建新的本地Camera对象Camera2，以及注册录像帧监听对象到Camera2中。<br>☯ 过程6：启动StartRecording<br>☯ 过程7:当录像帧可用时，通知驻留在MedaiRecorderClient中的Camera2本地对象收帧，于此同时Camera2又是通过注册的帧监听对象告知MediaClientClient对象。MediaClientClient对象拿到帧后进行录像编码。<br>☯ 过程8,过程９：通过回调函数，将一些消息发送给应用端。</p><h5 id="4-5、Camera-video创建BufferQueue"><a href="#4-5、Camera-video创建BufferQueue" class="headerlink" title="4.5、Camera video创建BufferQueue."></a>4.5、Camera video创建BufferQueue.</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/services/camera/libcameraservice/api1/client2/StreamingProcessor.cpp]</span><br><span class="line"><span class="keyword">status_t</span> StreamingProcessor::updateRecordingStream(<span class="keyword">const</span> Parameters &amp;params) &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    <span class="keyword">status_t</span> res;</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">m</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    sp&lt;CameraDeviceBase&gt; device = mDevice.promote();</span><br><span class="line">    <span class="comment">//----------------</span></span><br><span class="line">    <span class="keyword">bool</span> newConsumer = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (mRecordingConsumer == <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGV(<span class="string">"%s: Camera %d: Creating recording consumer with %zu + 1 "</span></span><br><span class="line">                <span class="string">"consumer-side buffers"</span>, __FUNCTION__, mId, mRecordingHeapCount);</span><br><span class="line">        <span class="comment">// Create CPU buffer queue endpoint. We need one more buffer here so that we can</span></span><br><span class="line">        <span class="comment">// always acquire and free a buffer when the heap is full; otherwise the consumer</span></span><br><span class="line">        <span class="comment">// will have buffers in flight we'll never clear out.</span></span><br><span class="line">        sp&lt;IGraphicBufferProducer&gt; producer;</span><br><span class="line">        sp&lt;IGraphicBufferConsumer&gt; consumer;</span><br><span class="line">        <span class="comment">//创建bufferQueue，同时获取到生产者和消费者对象。</span></span><br><span class="line">        BufferQueue::createBufferQueue(&amp;producer, &amp;consumer);</span><br><span class="line">        <span class="comment">//注意下面设置buffer的用处是GRALLOC_USAGE_HW_VIDEO_ENCODER，这个会在</span></span><br><span class="line">        <span class="comment">//mediaRecorder中使用到。</span></span><br><span class="line">        mRecordingConsumer = <span class="keyword">new</span> BufferItemConsumer(consumer,</span><br><span class="line">                GRALLOC_USAGE_HW_VIDEO_ENCODER,</span><br><span class="line">                mRecordingHeapCount + <span class="number">1</span>);</span><br><span class="line">        mRecordingConsumer-&gt;setFrameAvailableListener(<span class="keyword">this</span>);</span><br><span class="line">        mRecordingConsumer-&gt;setName(String8(<span class="string">"Camera2-RecordingConsumer"</span>));</span><br><span class="line">        mRecordingWindow = <span class="keyword">new</span> Surface(producer);</span><br><span class="line">        newConsumer = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// Allocate memory later, since we don't know buffer size until receipt</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//更新部分代码，就不贴出来了－－－－</span></span><br><span class="line"><span class="comment">//注意下面video 录像buffer的像素格式是CAMERA2_HAL_PIXEL_FORMAT_OPAQUE</span></span><br><span class="line">    <span class="keyword">if</span> (mRecordingStreamId == NO_STREAM) &#123;</span><br><span class="line">        mRecordingFrameCount = <span class="number">0</span>;</span><br><span class="line">        res = device-&gt;createStream(mRecordingWindow,</span><br><span class="line">                params.videoWidth, params.videoHeight,</span><br><span class="line">                CAMERA2_HAL_PIXEL_FORMAT_OPAQUE, &amp;mRecordingStreamId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要处理下面几件事情。</p><p>☯ 1.由于录像不需要显示，这里创建CameraService BufferQueue本地对象，这个时候获取到的生产者和消费者都是本地的，只有BufferQueue保存的有IGraphicBufferAlloc代理对象mAllocator，专门用来分配buffer。<br>☯ 2.由于StremingProcess.cpp中实现了FrameAvailableListener监听接口方法onFrameAvailable()。这里会通过setFrameAvailableListener方法注册到BufferQueue中。<br>☯ 3.根据生产者对象创建surface对象，并传给Camera3Device申请录像buffer.<br>☯ 4.如果参数有偏差或者之前已经创建过video Stream.这里会删除或者更新videoStream.如果压根没有创建VideoStream,直接创建VideoStream并根据参数更新流信息。</p><h5 id="4-6、何时录像帧可用"><a href="#4-6、何时录像帧可用" class="headerlink" title="4.6、何时录像帧可用"></a>4.6、何时录像帧可用</h5><h5 id="4-6-1、onFrameAvailable"><a href="#4-6-1、onFrameAvailable" class="headerlink" title="4.6.1、onFrameAvailable()"></a>4.6.1、onFrameAvailable()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/services/camera/libcameraservice/api1/client2/StreamingProcessor.cpp]</span><br><span class="line"><span class="keyword">void</span> StreamingProcessor::onFrameAvailable(<span class="keyword">const</span> BufferItem&amp; <span class="comment">/*item*/</span>) &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">l</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!mRecordingFrameAvailable) &#123;</span><br><span class="line">        mRecordingFrameAvailable = <span class="literal">true</span>;</span><br><span class="line">        mRecordingFrameAvailableSignal.signal();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当video buffer进行enqueue操作后,该函数会被调用。函数中可用发现，激活了StreamingProcessor主线程。</p><h5 id="4-6-2、StreamingProcessor线程loop"><a href="#4-6-2、StreamingProcessor线程loop" class="headerlink" title="4.6.2、StreamingProcessor线程loop"></a>4.6.2、StreamingProcessor线程loop</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/services/camera/libcameraservice/api1/client2/StreamingProcessor.cpp]</span><br><span class="line"><span class="keyword">bool</span> StreamingProcessor::threadLoop() &#123;</span><br><span class="line">    <span class="keyword">status_t</span> res;</span><br><span class="line">    &#123;</span><br><span class="line">        Mutex::<span class="function">Autolock <span class="title">l</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (!mRecordingFrameAvailable) &#123;</span><br><span class="line">        <span class="comment">//之前是在这里挂起的,现在有帧可用就会从这里唤醒。</span></span><br><span class="line">            res = mRecordingFrameAvailableSignal.waitRelative(</span><br><span class="line">                mMutex, kWaitDuration);</span><br><span class="line">            <span class="keyword">if</span> (res == TIMED_OUT) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mRecordingFrameAvailable = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        res = processRecordingFrame();<span class="comment">//进一步处理。</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (res == OK);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里发现，原来StreamingProcessor主线程只为录像服务，previewStream只是使用了它的几个方法而已。</p><h5 id="4-6-3、帧可用消息发送给Camera本地对象"><a href="#4-6-3、帧可用消息发送给Camera本地对象" class="headerlink" title="4.6.3、帧可用消息发送给Camera本地对象"></a>4.6.3、帧可用消息发送给Camera本地对象</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\camera\libcameraservice\api1\client2\StreamingProcessor.cpp]</span><br><span class="line"><span class="keyword">status_t</span> StreamingProcessor::processRecordingFrame() &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    <span class="keyword">status_t</span> res;</span><br><span class="line">    sp&lt;Camera2Heap&gt; recordingHeap;</span><br><span class="line">    <span class="keyword">size_t</span> heapIdx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">nsecs_t</span> timestamp;</span><br><span class="line">    sp&lt;Camera2Client&gt; client = mClient.promote();</span><br><span class="line"></span><br><span class="line">    BufferItemConsumer::BufferItem imgBuffer;</span><br><span class="line">    <span class="comment">//取出buffer消费，就是拿给mediaRecorder编码</span></span><br><span class="line">    res = mRecordingConsumer-&gt;acquireBuffer(&amp;imgBuffer, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//----------------------------</span></span><br><span class="line">    <span class="comment">// Call outside locked parameters to allow re-entrancy from notification</span></span><br><span class="line">    Camera2Client::SharedCameraCallbacks::<span class="function">Lock <span class="title">l</span><span class="params">(client-&gt;mSharedCameraCallbacks)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (l.mRemoteCallback != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//调用Callback通知Camea本地对象。</span></span><br><span class="line">        l.mRemoteCallback-&gt;dataCallbackTimestamp(timestamp,</span><br><span class="line">                CAMERA_MSG_VIDEO_FRAME,</span><br><span class="line">                recordingHeap-&gt;mBuffers[heapIdx]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ALOGW(<span class="string">"%s: Camera %d: Remote callback gone"</span>, __FUNCTION__, mId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br></pre></td></tr></table></figure><p>之前我们已经知道Camera运行时存在类型为ICameraClient的两个对象,其中一个代理对象保存在CameraService中，本地对象保存的Camera本地对象中。这里代理对象通知本地对象取帧了。注意这里消息发送的是“CAMERA_MSG_VIDEO_FRAME”。</p><h5 id="4-6-4、Camera本地对象转发消息给mediaRecorder"><a href="#4-6-4、Camera本地对象转发消息给mediaRecorder" class="headerlink" title="4.6.4、Camera本地对象转发消息给mediaRecorder."></a>4.6.4、Camera本地对象转发消息给mediaRecorder.</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/camera/Camera.cpp]</span><br><span class="line"><span class="keyword">void</span> Camera::dataCallbackTimestamp(<span class="keyword">nsecs_t</span> timestamp, <span class="keyword">int32_t</span> msgType, <span class="keyword">const</span> sp&lt;IMemory&gt;&amp; dataPtr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// If recording proxy listener is registered, forward the frame and return.</span></span><br><span class="line">    <span class="comment">// The other listener (mListener) is ignored because the receiver needs to</span></span><br><span class="line">    <span class="comment">// call releaseRecordingFrame.</span></span><br><span class="line">    sp&lt;ICameraRecordingProxyListener&gt; proxylistener;</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">//这里mRecordingProxyListener就是mediaRecorder注册过来的监听代理对象</span></span><br><span class="line">        Mutex::Autolock _l(mLock);</span><br><span class="line">        proxylistener = mRecordingProxyListener;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (proxylistener != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">//这里就把buffer送到了mediaRecorder中进行编码</span></span><br><span class="line">        proxylistener-&gt;dataCallbackTimestamp(timestamp, msgType, dataPtr);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//---------省略代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里Camera本地对象就会调用mediaRecorder注册来的帧监听对象。前面我们已经做了那么长的铺垫，我想应该可以理解了。好了,mediaRecorder有饭吃了。</p><h5 id="4-7、总结"><a href="#4-7、总结" class="headerlink" title="4.7、总结"></a>4.7、总结</h5><p>1.一开始我自以为preview和Video使用同一个camera本地对象，看了代码发现，原来是不同的对象。<br>2.预览的BufferQueue是在CameraService中创建的，和surfaceFlinger没有关系，只是保留了IGraphicBufferAlloc代理对象mAllocator，用于分配buffer.<br>3.之匿名binder没有理解透彻，以为只有传递本地对象才能使用writeStrongBinder()接口保存binder对象，同时在使用端使用readStrongBinder()就可以获取到代理对象了。其实也可以传递代理对象，只不过代码会走另外一套逻辑，在kernel中重新创建一个binder_ref索引对象返回给另一端。如下mediaRecorder设置camera时就是传递的ICamera代理对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/media/libmedia/IMediaRecorder.cpp]</span><br><span class="line">    <span class="keyword">status_t</span> setCamera(<span class="keyword">const</span> sp&lt;ICamera&gt;&amp; camera, <span class="keyword">const</span> sp&lt;ICameraRecordingProxy&gt;&amp; proxy)</span><br><span class="line">    &#123;</span><br><span class="line">        ALOGV(<span class="string">"setCamera(%p,%p)"</span>, camera.get(), proxy.get());</span><br><span class="line">        Parcel data, reply;</span><br><span class="line">        data.writeInterfaceToken(IMediaRecorder::getInterfaceDescriptor());</span><br><span class="line">        <span class="comment">//camera-&gt;asBinder()是ICamera代理对象</span></span><br><span class="line">        data.writeStrongBinder(camera-&gt;asBinder());</span><br><span class="line">        data.writeStrongBinder(proxy-&gt;asBinder());</span><br><span class="line">        remote()-&gt;transact(SET_CAMERA, data, &amp;reply);</span><br><span class="line">        <span class="keyword">return</span> reply.readInt32();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="（五）、参考资料-特别感谢各位前辈的分析和图示-："><a href="#（五）、参考资料-特别感谢各位前辈的分析和图示-：" class="headerlink" title="（五）、参考资料(特别感谢各位前辈的分析和图示)："></a>（五）、参考资料(特别感谢各位前辈的分析和图示)：</h4><p><a href="https://source.android.com/devices/camera/" target="_blank" rel="noopener">Android Camera官方文档</a><br><a href="https://blog.csdn.net/eternity9255" target="_blank" rel="noopener">Android 5.0 Camera系统源码分析-CSDN博客</a><br><a href="http://www.cnblogs.com/stonedemo/category/1080451.html" target="_blank" rel="noopener">Android Camera 流程学习记录 - StoneDemo - 博客园</a><br><a href="https://blog.csdn.net/shell812/article/category/5905525" target="_blank" rel="noopener">Android Camera 系统架构源码分析 - CSDN博客</a><br><a href="https://blog.csdn.net/hbw1992322/article/details/75259311" target="_blank" rel="noopener">Camera安卓源码-高通mm_camera架构剖析 - CSDN博客</a><br><a href="https://blog.csdn.net/yanbixing123/article/details/52294305/" target="_blank" rel="noopener">5.2 应用程序和驱动程序中buffer的传输流程 - CSDN博客</a><br><a href="https://www.jianshu.com/p/ecb1be82e6a8" target="_blank" rel="noopener">Camera2 数据流从framework到Hal源码分析 - 简书</a><br><a href="https://www.jianshu.com/p/1baad2a5281d" target="_blank" rel="noopener">mm-camera层frame数据流源码分析 - 简书</a><br><a href="https://blog.csdn.net/yanbixing123/article/month/2016/08/4?" target="_blank" rel="noopener">v4l2_capture.c分析—probe函数分析 - CSDN博客</a><br><a href="https://blog.csdn.net/armwind/article/category/6282972" target="_blank" rel="noopener">@@Android Camera fw学习 - CSDN博客</a><br><a href="https://blog.csdn.net/gzzaigcnforever/article/category/3066721" target="_blank" rel="noopener">@@Android Camera API2分析 - CSDN博客</a><br><a href="https://blog.csdn.net/qq_16775897/article/category/7112759" target="_blank" rel="noopener">@@Android Camera 流程学习记录 7.12- CSDN博客</a><br><a href="https://blog.csdn.net/column/details/guming-camera.html" target="_blank" rel="noopener">@@专栏：古冥的android6.0下的Camera API2.0的源码分析之旅 - CSDN博客</a><br><a href="https://blog.csdn.net/gzzaigcnforever/article/details/17751109" target="_blank" rel="noopener">linux3.3 v4l2视频采集驱动框架(vfe, camera i2c driver，v4l2_subdev等之间的联系) - CSDN博客</a><br><a href="https://blog.csdn.net/gzzaigcnforever/article/details/48974523" target="_blank" rel="noopener">Android Camera从Camera HAL1到Camera HAL3的过渡（已更新到Android6.0 HAL3.3） - CSDN博客</a><br><a href="https://blog.csdn.net/gzzaigcnforever/article/details/48972477" target="_blank" rel="noopener">我心依旧之Android Camera模块FW/HAL3探学序 - CSDN博客</a><br><a href="https://blog.csdn.net/armwind/article/details/73709808" target="_blank" rel="noopener">Android Camera fw学习(四)-recording流程分析 - CSDN博客</a><br><a href="https://blog.csdn.net/armwind/article/details/52076879" target="_blank" rel="noopener">android camera动态库加载过程 - CSDN博客</a><br><a href="https://blog.csdn.net/gzzaigcnforever/article/details/49468475" target="_blank" rel="noopener">Android Camera API2.0下全新的Camera FW/HAL架构简述 - CSDN博客</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;amp;&amp;amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内
      
    
    </summary>
    
      <category term="Android" scheme="http://zhoujinjian.cc/categories/Android/"/>
    
    
      <category term="Android" scheme="http://zhoujinjian.cc/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android Camera System（1）：Camera System(Camera 系统)框架、Open()过程分析</title>
    <link href="http://zhoujinjian.cc/2018/06/30/Android%20Camera%20System%EF%BC%881%EF%BC%89%EF%BC%9ACamera%20System%5BCamera%20%E7%B3%BB%E7%BB%9F%5D%E6%A1%86%E6%9E%B6%E3%80%81Open%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <id>http://zhoujinjian.cc/2018/06/30/Android Camera System（1）：Camera System[Camera 系统]框架、Open过程分析/</id>
    <published>2018-06-29T16:00:00.000Z</published>
    <updated>2018-05-25T12:12:49.774Z</updated>
    
    <content type="html"><![CDATA[<hr><p>注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;&amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除，禁止转载（©Qualcomm Technologies, Inc. 版权所有），谢谢。</p><p><a href="https://github.com/izhoujinjian/zhoujinjian.cc/tree/master/camera.system" target="_blank" rel="noopener">【博客原图链接】</a><br><a href="https://blog.csdn.net/armwind/article/category/6282972" target="_blank" rel="noopener">【特别感谢 - Android Camera fw学习-Armwind】</a><br><a href="https://blog.csdn.net/gzzaigcnforever/article/category/3066721" target="_blank" rel="noopener">【特别感谢 - Android Camera API2分析-Gzzaigcnforever】</a><br><a href="https://blog.csdn.net/qq_16775897/article/category/7112759" target="_blank" rel="noopener">【特别感谢 - Android Camera 流程学习记录 Android 7.12-QQ_16775897】</a><br><a href="https://blog.csdn.net/column/details/guming-camera.html" target="_blank" rel="noopener">【特别感谢 - 专栏：古冥的android6.0下的Camera API2.0的源码分析之旅】</a><br>Google Pixel、Pixel XL 内核代码（文章基于 Kernel-3.18）：<br> <a href="https://github.com/matthewdalex/marlin" target="_blank" rel="noopener">Kernel source for Pixel and Pixel XL - GitHub</a></p><p>AOSP 源码（文章基于 Android 7.1.2）：<br> <a href="https://testerhome.com/topics/2229" target="_blank" rel="noopener"> Android 系统全套源代码分享 (更新到 8.1.0_r1)</a></p><p> 🌀🌀：专注于Linux &amp;&amp; Android Multimedia（Camera、Video、Audio、Display）系统分析与研究</p><hr><p>☯ Application：<br>☯ /packages/apps/Camera2/src/com/android/camera/</p><p>☯ Framework：<br>☯ /frameworks/base/core/java/android/hardware/Camera.java</p><p>☯ JNI:<br>☯ /frameworks/base/core/jni/android_hardware_Camera.cpp</p><p>☯ Native:<br>☯ Client：<br>frameworks/av/camera/CameraBase.cpp<br>frameworks/av/camera/Camera.cpp<br>frameworks/av/camera/ICamera.cpp<br>frameworks/av/camera/aidl/android/hardware/ICamera.aidl<br>frameworks/av/camera/aidl/android/hardware/ICameraClient.aidl<br>☯ Server：<br>frameworks/av/camera/cameraserver/main_cameraserver.cpp<br>frameworks/av/services/camera/libcameraservice/CameraService.cpp<br>frameworks/av/services/camera/libcameraservice/api1/CameraClient.cpp<br>frameworks/av/camera/aidl/android/hardware/ICameraService.aidl</p><p>☯ HAL：<br>☯ /frameworks/av/services/camera/libcameraservice/device3/<br>☯ /hardware/qcom/camera/QCamera2(高通HAL)<br>☯ /vendor/qcom/proprietary/mm-camera(高通mm-camera)<br>☯ /vendor/qcom/proprietary/mm-still(高通JPEG)</p><p>☯ Kernel：<br>☯ /kernel/drivers/media/platform/msm/camera_v2(高通V4L2)<br>☯ /kernel/arch/arm/boot/dts/(高通dts)</p><hr><h4 id="（一）、Android-Camera-System-Architecture（Camera系统框架）"><a href="#（一）、Android-Camera-System-Architecture（Camera系统框架）" class="headerlink" title="（一）、Android Camera System Architecture（Camera系统框架）"></a>（一）、Android Camera System Architecture（Camera系统框架）</h4><h5 id="1-1、Android-Camera-System总体框架（Qualcomm平台）"><a href="#1-1、Android-Camera-System总体框架（Qualcomm平台）" class="headerlink" title="1.1、Android Camera System总体框架（Qualcomm平台）"></a>1.1、Android Camera System总体框架（Qualcomm平台）</h5><h5 id="1-1-1、首先看看Android-官方Camera总体架构："><a href="#1-1-1、首先看看Android-官方Camera总体架构：" class="headerlink" title="1.1.1、首先看看Android 官方Camera总体架构："></a>1.1.1、首先看看Android 官方Camera总体架构：</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/camera.system/01-01-android_ape_fwk_camera.png" alt="Alt text"></p><p><strong>☯应用框架</strong><br>应用代码位于应用框架级别，它利用 android.hardware.Camera API 来与相机硬件进行互动。在内部，此代码会调用相应的 JNI 粘合类，以访问与该相机互动的原生代码。<br><strong>☯JNI</strong><br>与 android.hardware.Camera 关联的 JNI 代码位于 frameworks/base/core/jni/android_hardware_Camera.cpp 中。此代码会调用较低级别的原生代码以获取对物理相机的访问权限，并返回用于在框架级别创建 android.hardware.Camera 对象的数据。<br><strong>☯原生框架</strong><br>在 frameworks/av/camera/Camera.cpp 中定义的原生框架可提供相当于 android.hardware.Camera 类的原生类。此类会调用 IPC binder 代理，以获取对相机服务的访问权限。<br><strong>☯Binder IPC 代理</strong><br>IPC binder 代理用于促进跨越进程边界的通信。调用相机服务的 frameworks/av/camera 目录中有 3 个相机 binder 类。ICameraService 是相机服务的接口，ICamera 是已打开的特定相机设备的接口，ICameraClient 是返回应用框架的设备接口。<br><strong>☯相机服务</strong><br>位于 frameworks/av/services/camera/libcameraservice/CameraService.cpp 下的相机服务是与 HAL 进行互动的实际代码。<br><strong>☯HAL</strong><br>硬件抽象层定义了由相机服务调用且您必须实现以确保相机硬件正常运行的标准接口。<br><strong>☯内核驱动程序</strong><br>相机的驱动程序可与实际相机硬件以及您的 HAL 实现进行互动。相机和驱动程序必须支持 YV12 和 NV21 图片格式，以便在显示和视频录制时支持预览相机图片。</p><h5 id="1-1-2、Qualcomm平台Camera-架构"><a href="#1-1-2、Qualcomm平台Camera-架构" class="headerlink" title="1.1.2、Qualcomm平台Camera 架构"></a>1.1.2、Qualcomm平台Camera 架构</h5><p>Qualcomm平台Camera 架构主要区别在于HAL层和Kernel层的变化，总体架构图如下：</p><h5 id="1-1-2-1、Qualcomm平台Camera总体架构"><a href="#1-1-2-1、Qualcomm平台Camera总体架构" class="headerlink" title="1.1.2.1、Qualcomm平台Camera总体架构"></a>1.1.2.1、Qualcomm平台Camera总体架构</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/camera.system/01-02-Android-Camera-Software-Architecture.png" alt="Alt text"></p><h5 id="1-1-2-2、Qualcomm平台Camera的HAL、mm-camera"><a href="#1-1-2-2、Qualcomm平台Camera的HAL、mm-camera" class="headerlink" title="1.1.2.2、Qualcomm平台Camera的HAL、mm-camera"></a>1.1.2.2、Qualcomm平台Camera的HAL、mm-camera</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/camera.system/01-03-HAL-and-mm-camera-interface.png" alt="Alt text"></p><h5 id="1-1-2-3、Qualcomm平台Camera的Kernel"><a href="#1-1-2-3、Qualcomm平台Camera的Kernel" class="headerlink" title="1.1.2.3、Qualcomm平台Camera的Kernel"></a>1.1.2.3、Qualcomm平台Camera的Kernel</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/camera.system/01-04-Camera-Kernel-Architecture.png" alt="Alt text"></p><h5 id="1-2、Android-Camera-API-2-0-全新的HAL-子系统"><a href="#1-2、Android-Camera-API-2-0-全新的HAL-子系统" class="headerlink" title="1.2、Android Camera API 2.0 全新的HAL 子系统"></a>1.2、Android Camera API 2.0 全新的HAL 子系统</h5><p>Android 7.1.2现在使用的是Camera API 2.0 和 Camera Device 3以及 HAL3。</p><h5 id="1-2-1、请求"><a href="#1-2-1、请求" class="headerlink" title="1.2.1、请求"></a>1.2.1、请求</h5><p>应用框架针对捕获的结果向相机子系统发出请求。一个请求对应一组结果。请求包含有关捕获和处理这些结果的所有配置信息。其中包括分辨率和像素格式；手动传感器、镜头和闪光灯控件；3A 操作模式；RAW 到 YUV 处理控件；以及统计信息的生成。这样一来，便可更好地控制结果的输出和处理。一次可发起多个请求，而且提交的请求不会出现阻塞的情况。请求始终按照接收的顺序进行处理。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/camera.system/01-05-camera2api.png.png" alt="Alt text"></p><h5 id="1-2-2、HAL-和相机子系统"><a href="#1-2-2、HAL-和相机子系统" class="headerlink" title="1.2.2、HAL 和相机子系统"></a>1.2.2、HAL 和相机子系统</h5><p>相机子系统包括相机管道中组件的实现，例如 3A 算法和处理控件。相机 HAL 为您提供了实现您版本的这些组件所需的接口。为了保持多个设备制造商和图像信号处理器（ISP，也称为相机传感器）供应商之间的跨平台兼容性，相机管道模型是虚拟的，且不直接对应任何真正的 ISP。不过，它与真正的处理管道足够相似，因此您可以有效地将其映射到硬件。此外，它足够抽象，可支持多种不同的算法和操作顺序，而不会影响质量、效率或跨设备兼容性。<br>相机管道还支持应用框架开启自动对焦等功能的触发器。它还会将通知发送回应用框架，以通知应用自动对焦锁定或错误等事件。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/camera.system/01-06-camera_hal_request_control.png.png" alt="Alt text"></p><blockquote><p>RAW Bayer 输出在 ISP 内部不经过任何处理。<br>统计信息根据原始传感器数据生成。<br>将原始传感器数据转换为 YUV 的各种处理块按任意顺序排列。<br>当显示多个刻度和剪裁单元时，所有的缩放器单元共享输出区域控件（数字缩放）。不过，每个单元都可能具有不同的输出分辨率和像素格式。</p></blockquote><h5 id="1-2-3、HAL-操作摘要"><a href="#1-2-3、HAL-操作摘要" class="headerlink" title="1.2.3、HAL 操作摘要"></a>1.2.3、HAL 操作摘要</h5><p>☯ 捕获的异步请求来自于框架。<br>☯ HAL 设备必须按顺序处理请求。对于每个请求，均产生输出结果元数据以及一个或多个输出图片缓冲区。<br>☯ 请求和结果以及后续请求引用的流遵守先进先出规则。<br>☯ 指定请求的所有输出的时间戳必须完全相同，以便框架可以根据需要将它们匹配在一起。<br>☯ 所有捕获配置和状态（不包括 3A 例程）都包含在请求和结果中。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/camera.system/01-07-camera-hal-overview-oo.png.png" alt="Alt text"></p><h5 id="1-2-4、启动和预期操作顺序"><a href="#1-2-4、启动和预期操作顺序" class="headerlink" title="1.2.4、启动和预期操作顺序"></a>1.2.4、启动和预期操作顺序</h5><p>1、框架调用 camera_module_t-&gt;common.open()，而这会返回一个 hardware_device_t 结构。<br>2、框架检查 hardware_device_t-&gt;version 字段，并为该版本的相机硬件设备实例化相应的处理程序。如果版本是 CAMERA_DEVICE_API_VERSION_3_0，则该设备会转型为 camera3_device_t。<br>3、框架调用 camera3_device_t-&gt;ops-&gt;initialize() 并显示框架回调函数指针。在调用 ops 结构中的任何其他函数之前，这只会在 open() 之后调用一次。<br>4、框架调用 camera3_device_t-&gt;ops-&gt;configure_streams() 并显示到 HAL 设备的输入/输出流列表。<br>5、框架为 configure_streams 中列出的至少一个输出流分配 gralloc 缓冲区并调用 camera3_device_t-&gt;ops-&gt;register_stream_buffers()。相同的流仅注册一次。<br>6、框架通过调用 camera3_device_t-&gt;ops-&gt;construct_default_request_settings() 来为某些使用情形请求默认设置。这可能会在第 3 步之后的任何时间发生。<br>7、框架通过基于其中一组默认设置的设置以及至少一个框架之前注册的输出流来构建第一个捕获请求并将其发送到 HAL。它通过 camera3_device_t-&gt;ops-&gt;process_capture_request() 发送到 HAL。HAL 必须阻止此调用返回，直到准备好发送下一个请求。<br>8、框架继续提交请求，并且可能会为尚未注册的流调用 register_stream_buffers()，并调用 construct_default_request_settings 来为其他使用情形获取默认设置缓冲区。<br>9、当请求捕获开始（传感器开始曝光以进行捕获）时，HAL 会调用 camera3_callback_ops_t-&gt;notify() 并显示 SHUTTER 事件，包括帧号和开始曝光的时间戳。此通知调用必须在第一次调用该帧号的 process_capture_result() 之前进行。<br>10、在某个管道延迟后，HAL 开始使用 camera3_callback_ops_t-&gt;process_capture_result() 将完成的捕获返回到框架。这些捕获按照与提交请求相同的顺序返回。一次可发起多个请求，具体取决于相机 HAL 设备的管道深度。<br>11、一段时间后，框架可能会停止提交新的请求、等待现有捕获完成（所有缓冲区都已填充，所有结果都已返回），然后再次调用 configure_streams()。这会重置相机硬件和管道，以获得一组新的输入/输出流。可重复使用先前配置中的部分流；如果这些流的缓冲区已经过 HAL 注册，则不会再次注册。如果至少还有一个已注册的输出流，则框架从第 7 步继续（否则，需要先完成第 5 步）。<br>12、或者，框架可能会调用 camera3_device_t-&gt;common-&gt;close() 以结束相机会话。当框架中没有其他处于活动状态的调用时，它可能随时会被调用；尽管在所有发起的捕获完成（所有结果都已返回，所有缓冲区都已填充）之前，调用可能会阻塞。在 close 调用返回后，不允许再从 HAL 对 camera3_callback_ops_t 函数进行更多调用。一旦进行 close() 调用，该框架可能不会调用任何其他 HAL 设备函数。<br>13、在发生错误或其他异步事件时，HAL 必须调用 camera3_callback_ops_t-&gt;notify() 并返回相应的错误/事件消息。从严重的设备范围错误通知返回后，HAL 应表现为在其上调用了 close()。但是，HAL 必须在调用 notify() 之前取消或完成所有待处理的捕获，以便在调用 notify() 并返回严重错误时，框架不会收到来自设备的更多回调。在严重的错误消息返回 notify() 方法后，close() 之外的方法应该返回 -ENODEV 或 NULL。</p><h5 id="1-3、Android-Graphics-学习－生产者、消费者、BufferQueue介绍"><a href="#1-3、Android-Graphics-学习－生产者、消费者、BufferQueue介绍" class="headerlink" title="1.3、Android Graphics 学习－生产者、消费者、BufferQueue介绍"></a>1.3、Android Graphics 学习－生产者、消费者、BufferQueue介绍</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/camera.system/01-08-Android-graphics-SurfaceFlinger-BufferQueue.jpg.png" alt="Alt text"></p><p>Graphics 系统详细分析请参考：【Android 7.1.2 (Android N) Android Graphics 系统分析】(<a href="http://zhoujinjian.cc/2018/02/01/Android-7-1-2-Android-N-Android-Graphics-%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/">http://zhoujinjian.cc/2018/02/01/Android-7-1-2-Android-N-Android-Graphics-%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/</a>)</p><h5 id="1-4、Camera类之间的关系和作用"><a href="#1-4、Camera类之间的关系和作用" class="headerlink" title="1.4、Camera类之间的关系和作用"></a>1.4、Camera类之间的关系和作用</h5><h5 id="1-4-1、Camera类关系总体概览"><a href="#1-4-1、Camera类关系总体概览" class="headerlink" title="1.4.1、Camera类关系总体概览"></a>1.4.1、Camera类关系总体概览</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/camera.system/01-09-Android-Camera-class.png" alt="Alt text"></p><p>☯ 1、ICameraClient: 这主要是一些消息发送的接口，包括帧可用通知，回调一些信息给client等消息。不过这里要注意的是，BnCameraClient对象其实是在client这端，不在CameraService端。<br>☯ 2、ICamera:camera的一些标准操作接口，比如startpreview，takepicuture,autofocus,所有的操作动作都是用的这一套接口。<br>☯ 3、ICameraService: 链接Camera服务，Camera device,获取Camera数量，Camera硬件信息，视厂角，镜头等信息。</p><h5 id="1-4-2、ICameraClient"><a href="#1-4-2、ICameraClient" class="headerlink" title="1.4.2、ICameraClient"></a>1.4.2、ICameraClient</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/camera.system/01-10-ICameraClient.png" alt="Alt text"></p><h5 id="1-4-3、ICamera"><a href="#1-4-3、ICamera" class="headerlink" title="1.4.3、ICamera"></a>1.4.3、ICamera</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/camera.system/01-11-ICamera.png" alt="Alt text"></p><h5 id="1-4-4、ICameraService"><a href="#1-4-4、ICameraService" class="headerlink" title="1.4.4、ICameraService"></a>1.4.4、ICameraService</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/camera.system/01-12-ICameraService.png" alt="Alt text"></p><h4 id="（二）、Android-CameraService开机初始化分析"><a href="#（二）、Android-CameraService开机初始化分析" class="headerlink" title="（二）、Android CameraService开机初始化分析"></a>（二）、Android CameraService开机初始化分析</h4><p>首先看下总体时序图：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/camera.system/01-13-CameraService_onFirstRef.png" alt="Alt text"></p><h5 id="2-1、CameraService-初始化过程"><a href="#2-1、CameraService-初始化过程" class="headerlink" title="2.1、CameraService 初始化过程"></a>2.1、CameraService 初始化过程</h5><p>Android启动的时候会收集系统的.rc文件，启动对应的Native Service：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\camera\cameraserver\cameraserver.rc]</span><br><span class="line">service cameraserver /system/bin/cameraserver</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">main</span></span></span><br><span class="line"><span class="class">    <span class="title">user</span> <span class="title">cameraserver</span></span></span><br><span class="line"><span class="class">    <span class="title">group</span> <span class="title">audio</span> <span class="title">camera</span> <span class="title">input</span> <span class="title">drmrpc</span></span></span><br><span class="line"><span class="class">    <span class="title">ioprio</span> <span class="title">rt</span> 4</span></span><br><span class="line"><span class="class">    <span class="title">writepid</span> /<span class="title">dev</span>/<span class="title">cpuset</span>/<span class="title">camera</span>-<span class="title">daemon</span>/<span class="title">tasks</span> /<span class="title">dev</span>/<span class="title">stune</span>/<span class="title">top</span>-<span class="title">app</span>/<span class="title">tasks</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\camera\cameraserver\main_cameraserver.cpp]</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc __unused, <span class="keyword">char</span>** argv __unused)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    signal(SIGPIPE, SIG_IGN);</span><br><span class="line">    sp&lt;ProcessState&gt; proc(ProcessState::self());</span><br><span class="line">    sp&lt;IServiceManager&gt; sm = defaultServiceManager();</span><br><span class="line">    ALOGI(<span class="string">"ServiceManager: %p"</span>, sm.get());</span><br><span class="line">    CameraService::instantiate();</span><br><span class="line">    ProcessState::self()-&gt;startThreadPool();</span><br><span class="line">    IPCThreadState::self()-&gt;joinThreadPool();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CameraService继承自BinderService，instantiate也是在BinderService中定义的，此方法就是调用publish方法，所以来看publish方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\native\include\binder\BinderService.h]</span><br><span class="line"><span class="function"><span class="keyword">static</span> status_t <span class="title">publish</span><span class="params">(<span class="keyword">bool</span> allowIsolated = <span class="literal">false</span>)</span> </span>&#123;</span><br><span class="line">    sp&lt;IServiceManager&gt; sm(defaultServiceManager());</span><br><span class="line">    <span class="comment">//将服务添加到ServiceManager</span></span><br><span class="line">    <span class="keyword">return</span> sm-&gt;addService(String16(SERVICE::getServiceName()),<span class="keyword">new</span> SERVICE(), allowIsolated);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，将会把CameraService服务加入到ServiceManager进行管理。 CameraService的构造时，会调用CameraService的onFirstRef方法：</p><h5 id="2-1-1、CameraService-onFirstRef"><a href="#2-1-1、CameraService-onFirstRef" class="headerlink" title="2.1.1、CameraService::onFirstRef()"></a>2.1.1、CameraService::onFirstRef()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> CameraService::onFirstRef()</span><br><span class="line">&#123;</span><br><span class="line">    ALOGI(<span class="string">"CameraService process starting"</span>);</span><br><span class="line"></span><br><span class="line">    BnCameraService::onFirstRef();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update battery life tracking if service is restarting</span></span><br><span class="line">    BatteryNotifier&amp; notifier(BatteryNotifier::getInstance());</span><br><span class="line">    notifier.noteResetCamera();</span><br><span class="line">    notifier.noteResetFlashlight();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">camera_module_t</span> *rawModule;</span><br><span class="line">    <span class="keyword">int</span> err = hw_get_module(CAMERA_HARDWARE_MODULE_ID,</span><br><span class="line">            (<span class="keyword">const</span> <span class="keyword">hw_module_t</span> **)&amp;rawModule);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    mModule = <span class="keyword">new</span> CameraModule(rawModule);</span><br><span class="line">    err = mModule-&gt;init();</span><br><span class="line">    ......</span><br><span class="line">    mFlashlight = <span class="keyword">new</span> CameraFlashlight(*mModule, *<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">status_t</span> res = mFlashlight-&gt;findFlashUnits();</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (mModule-&gt;getModuleApiVersion() &gt;= CAMERA_MODULE_API_VERSION_2_1) &#123;</span><br><span class="line">        mModule-&gt;setCallbacks(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CameraService::pingCameraServiceProxy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先会通过HAL框架的hw_get_module来创建CameraModule对象，然后会对其进行相应的初始化，并会进行一些参数的设置，如camera的数量，闪光灯的初始化，以及回调函数的设置等，到这里，Camera2 HAL的模块就初始化结束了。</p><h5 id="2-1-2、Camera-动态库加载过程"><a href="#2-1-2、Camera-动态库加载过程" class="headerlink" title="2.1.2、Camera 动态库加载过程"></a>2.1.2、Camera 动态库加载过程</h5><p>在源码中不知大家有没有注意到第二个参数是hw_module_t <strong>module,这里是指针的指针，而我们刚才传的是camera_module_t</strong>指针。大家可以看到camera_module_t 结构第一个域就是hw_module_t 所以这里就不难理解了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">源码路径：hardware/libhardware/hardware.c</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Base path of the hal modules */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAL_LIBRARY_PATH1 <span class="meta-string">"/system/lib/hw"</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAL_LIBRARY_PATH2 <span class="meta-string">"/vendor/lib/hw"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hw_get_module</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *id, <span class="keyword">const</span> struct <span class="keyword">hw_module_t</span> **<span class="keyword">module</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hw_get_module_by_class(id, <span class="literal">NULL</span>, <span class="keyword">module</span>); </span><br><span class="line">    <span class="comment">//这里的id就是camera模块的id，每一个hal module都有对应的id，</span></span><br><span class="line">    <span class="comment">//区分他们就通过这个id来区分了。</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hw_get_module_by_class</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *class_id, <span class="keyword">const</span> <span class="keyword">char</span> *inst,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">const</span> struct <span class="keyword">hw_module_t</span> **<span class="keyword">module</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">hw_module_t</span> *<span class="title">hmi</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="keyword">char</span> prop[PATH_MAX];</span><br><span class="line">    <span class="keyword">char</span> path[PATH_MAX];</span><br><span class="line">    <span class="keyword">char</span> name[PATH_MAX];</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/* Loop through the configuration variants looking for a module */</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;HAL_VARIANT_KEYS_COUNT+<span class="number">1</span> ; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; HAL_VARIANT_KEYS_COUNT) &#123;</span><br><span class="line">            <span class="keyword">if</span> (property_get(variant_keys[i], prop, <span class="literal">NULL</span>) == <span class="number">0</span>) &#123; <span class="comment">//关键字数组，上面有宏代码。</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">snprintf</span>(path, <span class="keyword">sizeof</span>(path), <span class="string">"%s/%s.%s.so"</span>,</span><br><span class="line">                     HAL_LIBRARY_PATH2, name, prop);</span><br><span class="line">            <span class="keyword">if</span> (access(path, R_OK) == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">snprintf</span>(path, <span class="keyword">sizeof</span>(path), <span class="string">"%s/%s.%s.so"</span>, <span class="comment">//拼接完整的camera库。</span></span><br><span class="line">                     HAL_LIBRARY_PATH1, name, prop);</span><br><span class="line">            <span class="keyword">if</span> (access(path, R_OK) == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(path, <span class="keyword">sizeof</span>(path), <span class="string">"%s/%s.default.so"</span>,</span><br><span class="line">                     HAL_LIBRARY_PATH2, name);</span><br><span class="line">            <span class="keyword">if</span> (access(path, R_OK) == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">snprintf</span>(path, <span class="keyword">sizeof</span>(path), <span class="string">"%s/%s.default.so"</span>,</span><br><span class="line">                     HAL_LIBRARY_PATH1, name);</span><br><span class="line">            <span class="keyword">if</span> (access(path, R_OK) == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    status = -ENOENT;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; HAL_VARIANT_KEYS_COUNT+<span class="number">1</span>) &#123;</span><br><span class="line">        status = load(class_id, path, <span class="keyword">module</span>); <span class="comment">//如果上面都进行完毕，走到这里，说明已经找到库了，这里就去加载。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据id来加载hal的module</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">load</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *id,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">char</span> *path,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> struct <span class="keyword">hw_module_t</span> **pHmi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">void</span> *handle;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hw_module_t</span> *<span class="title">hmi</span>;</span></span><br><span class="line">    ......</span><br><span class="line">    handle = dlopen(path, RTLD_NOW); <span class="comment">//动态加载内存的api，这里的path=/system/lib/hw/camera.msm8996.so</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/* Get the address of the struct hal_module_info. */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *sym = HAL_MODULE_INFO_SYM_AS_STR;   <span class="comment">//别的地方定义#define HAL_MODULE_INFO_SYM_AS_STR  "HMI"</span></span><br><span class="line">    hmi = (struct <span class="keyword">hw_module_t</span> *)dlsym(handle, sym); <span class="comment">//我们动态链接的是"HMI"这个符号。</span></span><br><span class="line">    ......</span><br><span class="line">    *pHmi = hmi; <span class="comment">//最后将这个指针，赋给我们之前定义的 struct camera_module变量。这里模块就加载进来了。</span></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//hal代码</span></span><br><span class="line">[-&gt;\hardware\qcom\camera\QCamera2\QCamera2Hal.cpp]</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">hw_module_t</span> camera_common = &#123;</span><br><span class="line">    .tag                    = HARDWARE_MODULE_TAG,</span><br><span class="line">    .module_api_version     = CAMERA_MODULE_API_VERSION_2_4,</span><br><span class="line">    .hal_api_version        = HARDWARE_HAL_API_VERSION,</span><br><span class="line">    .id                     = CAMERA_HARDWARE_MODULE_ID,</span><br><span class="line">    .name                   = <span class="string">"QCamera Module"</span>,</span><br><span class="line">    .author                 = <span class="string">"Qualcomm Innovation Center Inc"</span>,</span><br><span class="line">    .methods                = &amp;qcamera::QCamera2Factory::mModuleMethods, <span class="comment">//它的方法数组里绑定了open接口</span></span><br><span class="line">    .dso                    = <span class="literal">NULL</span>,</span><br><span class="line">    .reserved               = &#123;<span class="number">0</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">camera_module_t</span> HAL_MODULE_INFO_SYM = &#123;</span><br><span class="line">    .common                 = camera_common,</span><br><span class="line">    .get_number_of_cameras  = qcamera::QCamera2Factory::get_number_of_cameras,</span><br><span class="line">    .get_camera_info        = qcamera::QCamera2Factory::get_camera_info,</span><br><span class="line">    .set_callbacks          = qcamera::QCamera2Factory::set_callbacks,</span><br><span class="line">    .get_vendor_tag_ops     = qcamera::QCamera3VendorTags::get_vendor_tag_ops,</span><br><span class="line">    .open_legacy            = qcamera::QCamera2Factory::open_legacy,</span><br><span class="line">    .set_torch_mode         = qcamera::QCamera2Factory::set_torch_mode,</span><br><span class="line">    .init                   = <span class="literal">NULL</span>,</span><br><span class="line">    .reserved               = &#123;<span class="number">0</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hw_module_methods_t</span> <span class="title">QCamera2Factory</span>:</span>:mModuleMethods = &#123;</span><br><span class="line">    <span class="comment">//open方法的绑定</span></span><br><span class="line">    open: QCamera2Factory::camera_device_open,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Camera HAL层的open入口其实就是camera_device_open方法：</p><h5 id="2-1-3、图解camera-module和camera-device-t关系"><a href="#2-1-3、图解camera-module和camera-device-t关系" class="headerlink" title="2.1.3、图解camera_module和camera_device_t关系"></a>2.1.3、图解camera_module和camera_device_t关系</h5><p>camer module在系统中转指camera模块，camera_device_t 转指某一个camera 设备。在流程上，native framwork 先加载在hal层定义的camer_module对象，然后通过camera_module的methods open方法填充camera_device_t 结构体，并最终获取到camera ops这一整个camera最重要的操作集合。下图中我们可以看到struct hw_module_t在camera_module最上面 而camera_device_t最开始保存的是struct hw_device_t. 由此我们平时在看代码时，要注意一些指针转换。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/camera.system/01-14-camera_module camera_device_t.png" alt="Alt text"></p><h4 id="（三）、Android-Camera-Open过程"><a href="#（三）、Android-Camera-Open过程" class="headerlink" title="（三）、Android Camera Open过程"></a>（三）、Android Camera Open过程</h4><h5 id="3-1、Camera2-HAL层Open-过程分析"><a href="#3-1、Camera2-HAL层Open-过程分析" class="headerlink" title="3.1、Camera2 HAL层Open()过程分析"></a>3.1、Camera2 HAL层Open()过程分析</h5><p>高通的Camera，它在后台会有一个守护进程daemon，daemon是介于应用和驱动之间翻译ioctl的中间层(委托处理)。本节将以Camera中的open流程为例，来分析Camera HAL的工作过程，在应用对硬件发出open请求后，会通过Camera HAL来发起open请求，而Camera HAL的open入口在QCamera2Hal.cpp进行了定义，即前面分析的Camera HAL层的open入口其实就是camera_device_open方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\qcom\camera\QCamera2\QCamera2Factory.cpp]</span><br><span class="line"><span class="keyword">int</span> QCamera2Factory::camera_device_open(<span class="keyword">const</span> struct <span class="keyword">hw_module_t</span> *<span class="keyword">module</span>, <span class="keyword">const</span> <span class="keyword">char</span> *id,</span><br><span class="line">        struct <span class="keyword">hw_device_t</span> **hw_device)&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> gQCamera2Factory-&gt;cameraDeviceOpen(atoi(id), hw_device);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它调用了cameraDeviceOpen方法，而其中的hw_device就是最后要返回给应用层的CameraDeviceImpl在Camera HAL层的对象，继续分析cameraDeviceOpen方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\qcom\camera\QCamera2\QCamera2Factory.cpp]</span><br><span class="line"><span class="keyword">int</span> QCamera2Factory::cameraDeviceOpen(<span class="keyword">int</span> camera_id, struct <span class="keyword">hw_device_t</span> **hw_device)&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//Camera2采用的Camera HAL版本为HAL3.0</span></span><br><span class="line">    <span class="keyword">if</span> ( mHalDescriptors[camera_id].device_version == CAMERA_DEVICE_API_VERSION_3_0 ) &#123;</span><br><span class="line">        <span class="comment">//初始化QCamera3HardwareInterface对象，这里构造函数里将会进行configure_streams以及</span></span><br><span class="line">        <span class="comment">//process_capture_result等的绑定</span></span><br><span class="line">        QCamera3HardwareInterface *hw = <span class="keyword">new</span> QCamera3HardwareInterface(</span><br><span class="line">            mHalDescriptors[camera_id].cameraId, mCallbacks);</span><br><span class="line">        <span class="comment">//通过QCamera3HardwareInterface来打开Camera</span></span><br><span class="line">        rc = hw-&gt;openCamera(hw_device);</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mHalDescriptors[camera_id].device_version == CAMERA_DEVICE_API_VERSION_1_0) &#123;</span><br><span class="line">        <span class="comment">//HAL API为2.0</span></span><br><span class="line">        QCamera2HardwareInterface *hw = <span class="keyword">new</span> QCamera2HardwareInterface((<span class="keyword">uint32_t</span>)camera_id);</span><br><span class="line">        rc = hw-&gt;openCamera(hw_device);</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法有两个关键点：一个是QCamera3HardwareInterface对象的创建，它是用户空间与内核空间进行交互的接口；另一个是调用它的openCamera方法来打开Camera，下面将分别进行分析。</p><h5 id="3-1-1、QCamera3HardwareInterface构造函数分析"><a href="#3-1-1、QCamera3HardwareInterface构造函数分析" class="headerlink" title="3.1.1、QCamera3HardwareInterface构造函数分析"></a>3.1.1、QCamera3HardwareInterface构造函数分析</h5><p>在它的构造函数里面有一个关键的初始化，即mCameraDevice.ops = &amp;mCameraOps，它会定义Device操作的接口：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\core\java\android\hardware\camera2\impl\CameraDeviceImpl.java]</span><br><span class="line"><span class="keyword">camera3_device_ops_t</span> QCamera3HardwareInterface::mCameraOps = &#123;</span><br><span class="line">    initialize:                         QCamera3HardwareInterface::initialize,</span><br><span class="line">    <span class="comment">//配置流数据的相关处理</span></span><br><span class="line">    configure_streams:                  QCamera3HardwareInterface::configure_streams,</span><br><span class="line">    register_stream_buffers:            <span class="literal">NULL</span>,</span><br><span class="line">    construct_default_request_settings: </span><br><span class="line">        QCamera3HardwareInterface::construct_default_request_settings,</span><br><span class="line">    <span class="comment">//处理结果的接口</span></span><br><span class="line">    process_capture_request:            </span><br><span class="line">        QCamera3HardwareInterface::process_capture_request,</span><br><span class="line">    get_metadata_vendor_tag_ops:        <span class="literal">NULL</span>,</span><br><span class="line">    dump:                               QCamera3HardwareInterface::dump,</span><br><span class="line">    flush:                              QCamera3HardwareInterface::flush,</span><br><span class="line">    reserved:                           &#123;<span class="number">0</span>&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中，会在configure_streams中配置好流的处理handle：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\core\java\android\hardware\camera2\impl\CameraDeviceImpl.java]</span><br><span class="line"><span class="keyword">int</span> QCamera3HardwareInterface::configure_streams(<span class="keyword">const</span> struct camera3_device *device,</span><br><span class="line">        <span class="keyword">camera3_stream_configuration_t</span> *stream_list)&#123;</span><br><span class="line">    <span class="comment">//获得QCamera3HardwareInterface对象</span></span><br><span class="line">    QCamera3HardwareInterface *hw =<span class="keyword">reinterpret_cast</span>&lt;QCamera3HardwareInterface *&gt;(device-&gt;priv);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//调用它的configureStreams进行配置</span></span><br><span class="line">    <span class="keyword">int</span> rc = hw-&gt;configureStreams(stream_list);</span><br><span class="line">    ..</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续追踪configureStream方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\core\java\android\hardware\camera2\impl\CameraDeviceImpl.java]</span><br><span class="line"><span class="keyword">int</span> QCamera3HardwareInterface::configureStreams(<span class="keyword">camera3_stream_configuration_t</span> *streamList)&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//初始化Camera版本</span></span><br><span class="line">    al_version = CAM_HAL_V3;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//开始配置stream</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//初始化相关Channel为NULL</span></span><br><span class="line">    <span class="keyword">if</span> (mMetadataChannel) &#123;</span><br><span class="line">        <span class="keyword">delete</span> mMetadataChannel;</span><br><span class="line">        mMetadataChannel = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mSupportChannel) &#123;</span><br><span class="line">        <span class="keyword">delete</span> mSupportChannel;</span><br><span class="line">        mSupportChannel = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mAnalysisChannel) &#123;</span><br><span class="line">        <span class="keyword">delete</span> mAnalysisChannel;</span><br><span class="line">        mAnalysisChannel = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建Metadata Channel，并对其进行初始化</span></span><br><span class="line">    mMetadataChannel = <span class="keyword">new</span> QCamera3MetadataChannel(mCameraHandle-&gt;camera_handle,</span><br><span class="line">        mCameraHandle-&gt;ops, captureResultCb,&amp;gCamCapability[mCameraId]-&gt;padding_info, </span><br><span class="line">        CAM_QCOM_FEATURE_NONE, <span class="keyword">this</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    rc = mMetadataChannel-&gt;initialize(IS_TYPE_NONE);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//如果h/w support可用，则创建分析stream的Channel</span></span><br><span class="line">    <span class="keyword">if</span> (gCamCapability[mCameraId]-&gt;hw_analysis_supported) &#123;</span><br><span class="line">        mAnalysisChannel = <span class="keyword">new</span> QCamera3SupportChannel(mCameraHandle-&gt;camera_handle,</span><br><span class="line">                mCameraHandle-&gt;ops,&amp;gCamCapability[mCameraId]-&gt;padding_info,</span><br><span class="line">                CAM_QCOM_FEATURE_PP_SUPERSET_HAL3,CAM_STREAM_TYPE_ANALYSIS,</span><br><span class="line">                &amp;gCamCapability[mCameraId]-&gt;analysis_recommended_res,<span class="keyword">this</span>);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> isRawStreamRequested = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//清空stream配置信息</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;mStreamConfigInfo, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">cam_stream_size_info_t</span>));</span><br><span class="line">    <span class="comment">//为requested stream分配相关的channel对象</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; streamList-&gt;num_streams; i++) &#123;</span><br><span class="line">        <span class="keyword">camera3_stream_t</span> *newStream = streamList-&gt;streams[i];</span><br><span class="line">        <span class="keyword">uint32_t</span> stream_usage = newStream-&gt;usage;</span><br><span class="line">        mStreamConfigInfo.stream_sizes[mStreamConfigInfo.num_streams].width = (<span class="keyword">int32_t</span>)newStream-</span><br><span class="line">                &gt;width;</span><br><span class="line">        mStreamConfigInfo.stream_sizes[mStreamConfigInfo.num_streams].height = (<span class="keyword">int32_t</span>)newStream-</span><br><span class="line">                &gt;height;</span><br><span class="line">        <span class="keyword">if</span> ((newStream-&gt;stream_type == CAMERA3_STREAM_BIDIRECTIONAL||newStream-&gt;usage &amp; </span><br><span class="line">                GRALLOC_USAGE_HW_CAMERA_ZSL) &amp;&amp;newStream-&gt;format == </span><br><span class="line">                HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED &amp;&amp; jpegStream)&#123;</span><br><span class="line">            mStreamConfigInfo.type[mStreamConfigInfo.num_streams] = CAM_STREAM_TYPE_SNAPSHOT;</span><br><span class="line">            mStreamConfigInfo.postprocess_mask[mStreamConfigInfo.num_streams] = </span><br><span class="line">                CAM_QCOM_FEATURE_NONE;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(newStream-&gt;stream_type == CAMERA3_STREAM_INPUT) &#123;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (newStream-&gt;format) &#123;</span><br><span class="line">                <span class="comment">//为非zsl streams查找他们的format</span></span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newStream-&gt;priv == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">//为新的stream构造Channel</span></span><br><span class="line">            <span class="keyword">switch</span> (newStream-&gt;stream_type) &#123;<span class="comment">//分类型构造</span></span><br><span class="line">            <span class="keyword">case</span> CAMERA3_STREAM_INPUT:</span><br><span class="line">                newStream-&gt;usage |= GRALLOC_USAGE_HW_CAMERA_READ;</span><br><span class="line">                newStream-&gt;usage |= GRALLOC_USAGE_HW_CAMERA_WRITE;<span class="comment">//WR for inplace algo's</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CAMERA3_STREAM_BIDIRECTIONAL:</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CAMERA3_STREAM_OUTPUT:</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//根据前面的得到的stream的参数类型以及format分别对各类型的channel进行构造</span></span><br><span class="line">            <span class="keyword">if</span> (newStream-&gt;stream_type == CAMERA3_STREAM_OUTPUT ||</span><br><span class="line">                    newStream-&gt;stream_type == CAMERA3_STREAM_BIDIRECTIONAL) &#123;</span><br><span class="line">                QCamera3Channel *channel = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">switch</span> (newStream-&gt;format) &#123;</span><br><span class="line">                <span class="keyword">case</span> HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED:</span><br><span class="line">                    <span class="comment">/* use higher number of buffers for HFR mode */</span></span><br><span class="line">                    ...</span><br><span class="line">                    <span class="comment">//创建Regular Channel</span></span><br><span class="line">                    channel = <span class="keyword">new</span> QCamera3RegularChannel(mCameraHandle-&gt;camera_handle,</span><br><span class="line">                        mCameraHandle-&gt;ops, captureResultCb,&amp;gCamCapability[mCameraId]-</span><br><span class="line">                        &gt;padding_info,<span class="keyword">this</span>,newStream,(<span class="keyword">cam_stream_type_t</span>)mStreamConfigInfo.type[</span><br><span class="line">                        mStreamConfigInfo.num_streams],mStreamConfigInfo.postprocess_mask[</span><br><span class="line">                        mStreamConfigInfo.num_streams],mMetadataChannel,numBuffers);</span><br><span class="line">                    ...</span><br><span class="line">                    newStream-&gt;max_buffers = channel-&gt;getNumBuffers();</span><br><span class="line">                    newStream-&gt;priv = channel;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> HAL_PIXEL_FORMAT_YCbCr_420_888:</span><br><span class="line">                    <span class="comment">//创建YWV Channel</span></span><br><span class="line">                    ...</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> HAL_PIXEL_FORMAT_RAW_OPAQUE:</span><br><span class="line">                <span class="keyword">case</span> HAL_PIXEL_FORMAT_RAW16:</span><br><span class="line">                <span class="keyword">case</span> HAL_PIXEL_FORMAT_RAW10:</span><br><span class="line">                    <span class="comment">//创建Raw Channel</span></span><br><span class="line">                    ...</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> HAL_PIXEL_FORMAT_BLOB:</span><br><span class="line">                    <span class="comment">//创建QCamera3PicChannel</span></span><br><span class="line">                    ...</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newStream-&gt;stream_type == CAMERA3_STREAM_INPUT) &#123;</span><br><span class="line">                newStream-&gt;max_buffers = MAX_INFLIGHT_REPROCESS_REQUESTS;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (List&lt;<span class="keyword">stream_info_t</span>*&gt;::iterator it=mStreamInfo.begin();it != mStreamInfo.end(); </span><br><span class="line">                    it++) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((*it)-&gt;stream == newStream) &#123;</span><br><span class="line">                    (*it)-&gt;channel = (QCamera3Channel*) newStream-&gt;priv;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newStream-&gt;stream_type != CAMERA3_STREAM_INPUT)</span><br><span class="line">            mStreamConfigInfo.num_streams++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isZsl) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mPictureChannel) &#123;</span><br><span class="line">           mPictureChannel-&gt;overrideYuvSize(zslStream-&gt;width, zslStream-&gt;height);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mPictureChannel &amp;&amp; m_bIs4KVideo) &#123;</span><br><span class="line">        mPictureChannel-&gt;overrideYuvSize(videoWidth, videoHeight);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//RAW DUMP channel</span></span><br><span class="line">    <span class="keyword">if</span> (mEnableRawDump &amp;&amp; isRawStreamRequested == <span class="literal">false</span>)&#123;</span><br><span class="line">        <span class="keyword">cam_dimension_t</span> rawDumpSize;</span><br><span class="line">        rawDumpSize = getMaxRawSize(mCameraId);</span><br><span class="line">        mRawDumpChannel = <span class="keyword">new</span> QCamera3RawDumpChannel(mCameraHandle-&gt;camera_handle,</span><br><span class="line">            mCameraHandle-&gt;ops,rawDumpSize,&amp;gCamCapability[mCameraId]-&gt;padding_info,</span><br><span class="line">            <span class="keyword">this</span>, CAM_QCOM_FEATURE_NONE);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进行相关Channel的配置</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* Initialize mPendingRequestInfo and mPendnigBuffersMap */</span></span><br><span class="line">    <span class="keyword">for</span> (List&lt;PendingRequestInfo&gt;::iterator i = mPendingRequestsList.begin();</span><br><span class="line">                i != mPendingRequestsList.end(); i++) &#123;</span><br><span class="line">        clearInputBuffer(i-&gt;input_buffer);</span><br><span class="line">        i = mPendingRequestsList.erase(i);</span><br><span class="line">    &#125;</span><br><span class="line">    mPendingFrameDropList.clear();</span><br><span class="line">    <span class="comment">// Initialize/Reset the pending buffers list</span></span><br><span class="line">    mPendingBuffersMap.num_buffers = <span class="number">0</span>;</span><br><span class="line">    mPendingBuffersMap.mPendingBufferList.clear();</span><br><span class="line">    mPendingReprocessResultList.clear();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法内容比较多，只抽取其中核心的代码进行说明，它首先会根据HAL的版本来对stream进行相应的配置初始化，然后再根据stream类型对stream_list的stream创建相应的Channel，主要有QCamera3MetadataChannel，QCamera3SupportChannel等，然后再进行相应的配置，其中QCamera3MetadataChannel在后面的处理capture request的时候会用到，这里就不做分析，而Camerametadata则是Java层和CameraService之间传递的元数据，见android6.0源码分析之Camera API2.0简介中的Camera2架构图，至此，QCamera3HardwareInterface构造结束，与本文相关的就是配置了mCameraDevice.ops。</p><h5 id="3-1-2、openCamera-分析"><a href="#3-1-2、openCamera-分析" class="headerlink" title="3.1.2、openCamera()分析"></a>3.1.2、openCamera()分析</h5><p>本节主要分析Module是如何打开Camera的，openCamera的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\qcom\camera\QCamera2\HAL3\QCamera3HWI.cpp]</span><br><span class="line"><span class="keyword">int</span> QCamera3HardwareInterface::openCamera(struct <span class="keyword">hw_device_t</span> **hw_device)&#123;</span><br><span class="line">    <span class="keyword">int</span> rc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (mCameraOpened) &#123;<span class="comment">//如果Camera已经被打开，则此次打开的设备为NULL，并且打开结果为PERMISSION_DENIED</span></span><br><span class="line">        *hw_device = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> PERMISSION_DENIED;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用openCamera方法来打开</span></span><br><span class="line">    rc = openCamera();</span><br><span class="line">    <span class="comment">//打开结果处理</span></span><br><span class="line">    <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//获取打开成功的hw_device_t对象</span></span><br><span class="line">        *hw_device = &amp;mCameraDevice.common;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        *hw_device = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它调用了openCamera()方法来打开Camera:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\qcom\camera\QCamera2\HAL3\QCamera3HWI.cpp]</span><br><span class="line"><span class="keyword">int</span> QCamera3HardwareInterface::openCamera()</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//打开camera，获取mCameraHandle</span></span><br><span class="line">    mCameraHandle = camera_open((<span class="keyword">uint8_t</span>)mCameraId);</span><br><span class="line">    ...</span><br><span class="line">    mCameraOpened = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//注册mm-camera-interface里的事件处理,其中camEctHandle为事件处理Handle</span></span><br><span class="line">    rc = mCameraHandle-&gt;ops-&gt;register_event_notify(mCameraHandle-&gt;camera_handle,camEvtHandle</span><br><span class="line">            ,(<span class="keyword">void</span> *)<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它调用camera_open方法来打开Camera，并且向CameraHandle注册了Camera 时间处理的Handle–camEvtHandle，首先分析camera_open方法，这里就将进入高通的Camera的实现了，而Mm_camera_interface.c是高通提供的相关操作的接口，接下来分析高通Camera的camera_open方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\vendor\qcom\proprietary\mm-camera\apps\appslib\mm_camera_interface.c]</span><br><span class="line"><span class="keyword">mm_camera_vtbl_t</span> * camera_open(<span class="keyword">uint8_t</span> camera_idx)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> rc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">mm_camera_obj_t</span>* cam_obj = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/* opened already 如果已经打开*/</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> != g_cam_ctrl.cam_obj[camera_idx]) &#123;</span><br><span class="line">        <span class="comment">/* Add reference */</span></span><br><span class="line">        g_cam_ctrl.cam_obj[camera_idx]-&gt;ref_count++;</span><br><span class="line">        pthread_mutex_unlock(&amp;g_intf_lock);</span><br><span class="line">        <span class="keyword">return</span> &amp;g_cam_ctrl.cam_obj[camera_idx]-&gt;vtbl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cam_obj = (<span class="keyword">mm_camera_obj_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">mm_camera_obj_t</span>));</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* initialize camera obj */</span></span><br><span class="line">    <span class="built_in">memset</span>(cam_obj, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">mm_camera_obj_t</span>));</span><br><span class="line">    cam_obj-&gt;ctrl_fd = <span class="number">-1</span>;</span><br><span class="line">    cam_obj-&gt;ds_fd = <span class="number">-1</span>;</span><br><span class="line">    cam_obj-&gt;ref_count++;</span><br><span class="line">    cam_obj-&gt;my_hdl = mm_camera_util_generate_handler(camera_idx);</span><br><span class="line">    cam_obj-&gt;vtbl.camera_handle = cam_obj-&gt;my_hdl; <span class="comment">/* set handler */</span></span><br><span class="line">    <span class="comment">//mm_camera_ops里绑定了相关的操作接口</span></span><br><span class="line">    cam_obj-&gt;vtbl.ops = &amp;mm_camera_ops;</span><br><span class="line">    pthread_mutex_init(&amp;cam_obj-&gt;cam_lock, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_lock(&amp;cam_obj-&gt;cam_lock);</span><br><span class="line">    pthread_mutex_unlock(&amp;g_intf_lock);</span><br><span class="line">    <span class="comment">//调用mm_camera_open方法来打开camera</span></span><br><span class="line">    rc = mm_camera_open(cam_obj);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;g_intf_lock);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//结果处理，并返回</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由代码可知，这里将会初始化一个mm_camera_obj_t对象，其中，ds_fd为socket fd，而mm_camera_ops则绑定了相关的接口，最后调用mm_camera_open来打开Camera，首先来看看mm_camera_ops绑定了哪些方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\vendor\qcom\proprietary\mm-camera\apps\appslib\mm_camera_interface.c]</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">mm_camera_ops_t</span> mm_camera_ops = &#123;</span><br><span class="line">    .query_capability = mm_camera_intf_query_capability,</span><br><span class="line">    <span class="comment">//注册事件通知的方法</span></span><br><span class="line">    .register_event_notify = mm_camera_intf_register_event_notify,</span><br><span class="line">    .close_camera = mm_camera_intf_close,</span><br><span class="line">    .set_parms = mm_camera_intf_set_parms,</span><br><span class="line">    .get_parms = mm_camera_intf_get_parms,</span><br><span class="line">    .do_auto_focus = mm_camera_intf_do_auto_focus,</span><br><span class="line">    .cancel_auto_focus = mm_camera_intf_cancel_auto_focus,</span><br><span class="line">    .prepare_snapshot = mm_camera_intf_prepare_snapshot,</span><br><span class="line">    .start_zsl_snapshot = mm_camera_intf_start_zsl_snapshot,</span><br><span class="line">    .stop_zsl_snapshot = mm_camera_intf_stop_zsl_snapshot,</span><br><span class="line">    .map_buf = mm_camera_intf_map_buf,</span><br><span class="line">    .unmap_buf = mm_camera_intf_unmap_buf,</span><br><span class="line">    .add_channel = mm_camera_intf_add_channel,</span><br><span class="line">    .delete_channel = mm_camera_intf_del_channel,</span><br><span class="line">    .get_bundle_info = mm_camera_intf_get_bundle_info,</span><br><span class="line">    .add_stream = mm_camera_intf_add_stream,</span><br><span class="line">    .link_stream = mm_camera_intf_link_stream,</span><br><span class="line">    .delete_stream = mm_camera_intf_del_stream,</span><br><span class="line">    <span class="comment">//配置stream的方法</span></span><br><span class="line">    .config_stream = mm_camera_intf_config_stream,</span><br><span class="line">    .qbuf = mm_camera_intf_qbuf,</span><br><span class="line">    .get_queued_buf_count = mm_camera_intf_get_queued_buf_count,</span><br><span class="line">    .map_stream_buf = mm_camera_intf_map_stream_buf,</span><br><span class="line">    .unmap_stream_buf = mm_camera_intf_unmap_stream_buf,</span><br><span class="line">    .set_stream_parms = mm_camera_intf_set_stream_parms,</span><br><span class="line">    .get_stream_parms = mm_camera_intf_get_stream_parms,</span><br><span class="line">    .start_channel = mm_camera_intf_start_channel,</span><br><span class="line">    .stop_channel = mm_camera_intf_stop_channel,</span><br><span class="line">    .request_super_buf = mm_camera_intf_request_super_buf,</span><br><span class="line">    .cancel_super_buf_request = mm_camera_intf_cancel_super_buf_request,</span><br><span class="line">    .flush_super_buf_queue = mm_camera_intf_flush_super_buf_queue,</span><br><span class="line">    .configure_notify_mode = mm_camera_intf_configure_notify_mode,</span><br><span class="line">    <span class="comment">//处理capture的方法</span></span><br><span class="line">    .process_advanced_capture = mm_camera_intf_process_advanced_capture</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接着分析mm_camera_open方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/hardware/qcom/camera/QCamera2/<span class="built_in">stack</span>/mm-camera-interface/src/mm_camera.c]</span><br><span class="line"><span class="keyword">int32_t</span> mm_camera_open(<span class="keyword">mm_camera_obj_t</span> *my_obj)&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        n_try--;</span><br><span class="line">        <span class="comment">//根据设备名字，打开相应的设备驱动fd</span></span><br><span class="line">        my_obj-&gt;ctrl_fd = open(dev_name, O_RDWR | O_NONBLOCK);</span><br><span class="line">        <span class="keyword">if</span>((my_obj-&gt;ctrl_fd &gt;= <span class="number">0</span>) || (errno != EIO) || (n_try &lt;= <span class="number">0</span> )) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        usleep(sleep_msec * <span class="number">1000U</span>);</span><br><span class="line">    &#125;<span class="keyword">while</span> (n_try &gt; <span class="number">0</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//打开domain socket</span></span><br><span class="line">    n_try = MM_CAMERA_DEV_OPEN_TRIES;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        n_try--;</span><br><span class="line">        my_obj-&gt;ds_fd = mm_camera_socket_create(cam_idx, MM_CAMERA_SOCK_TYPE_UDP);</span><br><span class="line">        usleep(sleep_msec * <span class="number">1000U</span>);</span><br><span class="line">    &#125; <span class="keyword">while</span> (n_try &gt; <span class="number">0</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//初始化锁</span></span><br><span class="line">    pthread_mutex_init(&amp;my_obj-&gt;msg_lock, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_init(&amp;my_obj-&gt;cb_lock, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_init(&amp;my_obj-&gt;evt_lock, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_cond_init(&amp;my_obj-&gt;evt_cond, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开启线程，它的线程体在mm_camera_dispatch_app_event方法中</span></span><br><span class="line">    mm_camera_cmd_thread_launch(&amp;my_obj-&gt;evt_thread,</span><br><span class="line">                                mm_camera_dispatch_app_event,</span><br><span class="line">                                (<span class="keyword">void</span> *)my_obj);</span><br><span class="line">    mm_camera_poll_thread_launch(&amp;my_obj-&gt;evt_poll_thread,</span><br><span class="line">                                 MM_CAMERA_POLL_TYPE_EVT);</span><br><span class="line">    mm_camera_evt_sub(my_obj, TRUE);</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由代码可知，它会打开Camera的设备文件，然后开启dispatch_app_event线程，线程方法体mm_camera_dispatch_app_event方法代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/hardware/qcom/camera/QCamera2/<span class="built_in">stack</span>/mm-camera-interface/src/mm_camera.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mm_camera_dispatch_app_event</span><span class="params">(<span class="keyword">mm_camera_cmdcb_t</span> *cmd_cb,<span class="keyword">void</span>* user_data)</span></span>&#123;</span><br><span class="line">    mm_camera_cmd_thread_name(<span class="string">"mm_cam_event"</span>);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">mm_camera_event_t</span> *event = &amp;cmd_cb-&gt;u.evt;</span><br><span class="line">    <span class="keyword">mm_camera_obj_t</span> * my_obj = (<span class="keyword">mm_camera_obj_t</span> *)user_data;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != my_obj) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;my_obj-&gt;cb_lock);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; MM_CAMERA_EVT_ENTRY_MAX; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(my_obj-&gt;evt.evt[i].evt_cb) &#123;</span><br><span class="line">                <span class="comment">//调用camEvtHandle方法</span></span><br><span class="line">                my_obj-&gt;evt.evt[i].evt_cb(</span><br><span class="line">                    my_obj-&gt;my_hdl,</span><br><span class="line">                    event,</span><br><span class="line">                    my_obj-&gt;evt.evt[i].user_data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;my_obj-&gt;cb_lock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后会调用mm-camera-interface中注册好的事件处理evt_cb，它就是在前面注册好的camEvtHandle：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\qcom\camera\QCamera2\HAL3\QCamera3HWI.cpp]</span><br><span class="line"><span class="keyword">void</span> QCamera3HardwareInterface::camEvtHandle(<span class="keyword">uint32_t</span> <span class="comment">/*camera_handle*/</span>,<span class="keyword">mm_camera_event_t</span> *evt,</span><br><span class="line">        <span class="keyword">void</span> *user_data)&#123;</span><br><span class="line">    <span class="comment">//获取QCamera3HardwareInterface接口指针</span></span><br><span class="line">    QCamera3HardwareInterface *obj = (QCamera3HardwareInterface *)user_data;</span><br><span class="line">    <span class="keyword">if</span> (obj &amp;&amp; evt) &#123;</span><br><span class="line">        <span class="keyword">switch</span>(evt-&gt;server_event_type) &#123;</span><br><span class="line">            <span class="keyword">case</span> CAM_EVENT_TYPE_DAEMON_DIED:</span><br><span class="line">                <span class="keyword">camera3_notify_msg_t</span> notify_msg;</span><br><span class="line">                <span class="built_in">memset</span>(&amp;notify_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">camera3_notify_msg_t</span>));</span><br><span class="line">                notify_msg.type = CAMERA3_MSG_ERROR;</span><br><span class="line">                notify_msg.message.error.error_code = CAMERA3_MSG_ERROR_DEVICE;</span><br><span class="line">                notify_msg.message.error.error_stream = <span class="literal">NULL</span>;</span><br><span class="line">                notify_msg.message.error.frame_number = <span class="number">0</span>;</span><br><span class="line">                obj-&gt;mCallbackOps-&gt;notify(obj-&gt;mCallbackOps, &amp;notify_msg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> CAM_EVENT_TYPE_DAEMON_PULL_REQ:</span><br><span class="line">                pthread_mutex_lock(&amp;obj-&gt;mMutex);</span><br><span class="line">                obj-&gt;mWokenUpByDaemon = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//开启process_capture_request</span></span><br><span class="line">                obj-&gt;unblockRequestIfNecessary();</span><br><span class="line">                pthread_mutex_unlock(&amp;obj-&gt;mMutex);</span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由代码可知，它会调用QCamera3HardwareInterface的unblockRequestIfNecessary来发起结果处理请求：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\qcom\camera\QCamera2\HAL3\QCamera3HWI.cpp]</span><br><span class="line"><span class="keyword">void</span> QCamera3HardwareInterface::unblockRequestIfNecessary()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// Unblock process_capture_request</span></span><br><span class="line">   <span class="comment">//开启process_capture_request</span></span><br><span class="line">   pthread_cond_signal(&amp;mRequestCond);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在初始化QCamera3HardwareInterface对象的时候，就绑定了处理Metadata的回调captureResultCb方法：它主要是对数据源进行相应的处理，而具体的capture请求的结果处理还是由process_capture_request来进行处理的，而这里会调用方法unblockRequestIfNecessary来触发process_capture_request方法执行，而在Camera框架中，发起请求时会启动一个RequestThread线程，在它的threadLoop方法中，会不停的调用process_capture_request方法来进行请求的处理，而它最后会回调Camera3Device中的processCaptureResult方法来进行结果处理：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/services/camera/libcameraservice/device3/Camera3Device.cpp]</span><br><span class="line"><span class="keyword">void</span> Camera3Device::processCaptureResult(<span class="keyword">const</span> camera3_capture_result *result) &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (mUsePartialResult &amp;&amp; result-&gt;result != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mDeviceVersion &gt;= CAMERA_DEVICE_API_VERSION_3_2) &#123;</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">if</span> (isPartialResult) &#123;</span><br><span class="line">                    request.partialResult.collectedResult.append(result-&gt;result);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">camera_metadata_ro_entry_t</span> partialResultEntry;</span><br><span class="line">                res = find_camera_metadata_ro_entry(result-&gt;result,</span><br><span class="line">                        ANDROID_QUIRKS_PARTIAL_RESULT, &amp;partialResultEntry);</span><br><span class="line">                <span class="keyword">if</span> (res != NAME_NOT_FOUND &amp;&amp;partialResultEntry.count &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        partialResultEntry.data.u8[<span class="number">0</span>] ==ANDROID_QUIRKS_PARTIAL_RESULT_PARTIAL) &#123;</span><br><span class="line">                    isPartialResult = <span class="literal">true</span>;</span><br><span class="line">                    request.partialResult.collectedResult.append(</span><br><span class="line">                        result-&gt;result);</span><br><span class="line">                    request.partialResult.collectedResult.erase(</span><br><span class="line">                        ANDROID_QUIRKS_PARTIAL_RESULT);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isPartialResult) &#123;</span><br><span class="line">                <span class="comment">// Fire off a 3A-only result if possible</span></span><br><span class="line">                <span class="keyword">if</span> (!request.partialResult.haveSent3A) &#123;</span><br><span class="line">                    <span class="comment">//处理3A结果</span></span><br><span class="line">                    request.partialResult.haveSent3A =processPartial3AResult(frameNumber,</span><br><span class="line">                        request.partialResult.collectedResult,request.resultExtras);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//查找camera元数据入口</span></span><br><span class="line">        <span class="keyword">camera_metadata_ro_entry_t</span> entry;</span><br><span class="line">        res = find_camera_metadata_ro_entry(result-&gt;result,</span><br><span class="line">                ANDROID_SENSOR_TIMESTAMP, &amp;entry);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (shutterTimestamp == <span class="number">0</span>) &#123;</span><br><span class="line">            request.pendingOutputBuffers.appendArray(result-&gt;output_buffers,</span><br><span class="line">                result-&gt;num_output_buffers);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            重要的分析<span class="comment">//返回处理的outputbuffer</span></span><br><span class="line">            returnOutputBuffers(result-&gt;output_buffers,</span><br><span class="line">                result-&gt;num_output_buffers, shutterTimestamp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result-&gt;result != <span class="literal">NULL</span> &amp;&amp; !isPartialResult) &#123;</span><br><span class="line">            <span class="keyword">if</span> (shutterTimestamp == <span class="number">0</span>) &#123;</span><br><span class="line">                request.pendingMetadata = result-&gt;result;</span><br><span class="line">                request.partialResult.collectedResult = collectedPartialResult;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                CameraMetadata metadata;</span><br><span class="line">                metadata = result-&gt;result;</span><br><span class="line">                <span class="comment">//发送Capture结构，即调用通知回调</span></span><br><span class="line">                sendCaptureResult(metadata, request.resultExtras,</span><br><span class="line">                    collectedPartialResult, frameNumber, hasInputBufferInRequest,</span><br><span class="line">                    request.aeTriggerCancelOverride);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        removeInFlightRequestIfReadyLocked(idx);</span><br><span class="line">    &#125; <span class="comment">// scope for mInFlightLock</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result-&gt;input_buffer != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasInputBufferInRequest) &#123;</span><br><span class="line">            Camera3Stream *stream =</span><br><span class="line">                Camera3Stream::cast(result-&gt;input_buffer-&gt;stream);</span><br><span class="line">            重要的分析<span class="comment">//返回处理的inputbuffer</span></span><br><span class="line">            res = stream-&gt;returnInputBuffer(*(result-&gt;input_buffer));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析returnOutputBuffers方法，inputbuffer的runturnInputBuffer方法流程类似：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/services/camera/libcameraservice/device3/Camera3Device.cpp]</span><br><span class="line"><span class="keyword">void</span> Camera3Device::returnOutputBuffers(<span class="keyword">const</span> <span class="keyword">camera3_stream_buffer_t</span> *outputBuffers, <span class="keyword">size_t</span> </span><br><span class="line">        numBuffers, <span class="keyword">nsecs_t</span> timestamp) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; numBuffers; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Camera3Stream *stream = Camera3Stream::cast(outputBuffers[i].stream);</span><br><span class="line">        <span class="keyword">status_t</span> res = stream-&gt;returnBuffer(outputBuffers[i], timestamp);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法里调用了returnBuffer方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/services/camera/libcameraservice/device3/Camera3Stream.cpp]</span><br><span class="line"><span class="keyword">status_t</span> Camera3Stream::returnBuffer(<span class="keyword">const</span> camera3_stream_buffer &amp;buffer,<span class="keyword">nsecs_t</span> timestamp) &#123;</span><br><span class="line">    <span class="comment">//返回buffer</span></span><br><span class="line">    <span class="keyword">status_t</span> res = returnBufferLocked(buffer, timestamp);</span><br><span class="line">    <span class="keyword">if</span> (res == OK) &#123;</span><br><span class="line">        fireBufferListenersLocked(buffer, <span class="comment">/*acquired*/</span><span class="literal">false</span>, <span class="comment">/*output*/</span><span class="literal">true</span>);</span><br><span class="line">        mOutputBufferReturnedSignal.signal();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再继续看returnBufferLocked,它调用了returnAnyBufferLocked方法，而returnAnyBufferLocked方法又调用了returnBufferCheckedLocked方法，现在分析returnBufferCheckedLocked：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/services/camera/libcameraservice/device3/Camera3OutputStream.cpp]</span><br><span class="line"><span class="keyword">status_t</span> Camera3OutputStream::returnBufferCheckedLocked(<span class="keyword">const</span> camera3_stream_buffer &amp;buffer,</span><br><span class="line">            <span class="keyword">nsecs_t</span> timestamp,<span class="keyword">bool</span> output,<span class="comment">/*out*/</span>sp&lt;Fence&gt; *releaseFenceOut) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Fence management - always honor release fence from HAL</span></span><br><span class="line">    sp&lt;Fence&gt; releaseFence = <span class="keyword">new</span> Fence(buffer.release_fence);</span><br><span class="line">    <span class="keyword">int</span> anwReleaseFence = releaseFence-&gt;dup();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (buffer.status == CAMERA3_BUFFER_STATUS_ERROR) &#123;</span><br><span class="line">        <span class="comment">// Cancel buffer</span></span><br><span class="line">        res = currentConsumer-&gt;cancelBuffer(currentConsumer.get(),</span><br><span class="line">                container_of(buffer.buffer, ANativeWindowBuffer, handle),</span><br><span class="line">                anwReleaseFence);</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        res = currentConsumer-&gt;queueBuffer(currentConsumer.get(),</span><br><span class="line">                container_of(buffer.buffer, ANativeWindowBuffer, handle),</span><br><span class="line">                anwReleaseFence);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由代码可知，如果Buffer没有出现状态错误，它会调用currentConsumer的queueBuffer方法，而具体的Consumer则是在应用层初始化Camera时进行绑定的，典型的Consumer有SurfaceTexture，ImageReader等，而在Native层中，它会调用BufferQueueProducer的queueBuffer方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\native\libs\gui\BufferQueueProducer.cpp]</span><br><span class="line"><span class="keyword">status_t</span> BufferQueueProducer::queueBuffer(<span class="keyword">int</span> slot,</span><br><span class="line">        <span class="keyword">const</span> QueueBufferInput &amp;input, QueueBufferOutput *output) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//初始化Frame可用的监听器</span></span><br><span class="line">    sp&lt;IConsumerListener&gt; frameAvailableListener;</span><br><span class="line">    sp&lt;IConsumerListener&gt; frameReplacedListener;</span><br><span class="line">    <span class="keyword">int</span> callbackTicket = <span class="number">0</span>;</span><br><span class="line">    BufferItem item;</span><br><span class="line">    &#123; <span class="comment">// Autolock scope</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">const</span> sp&lt;GraphicBuffer&gt;&amp; graphicBuffer(mSlots[slot].mGraphicBuffer);</span><br><span class="line">        Rect bufferRect(graphicBuffer-&gt;getWidth(), graphicBuffer-&gt;getHeight());</span><br><span class="line">        Rect croppedRect;</span><br><span class="line">        crop.intersect(bufferRect, &amp;croppedRect);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//如果队列为空</span></span><br><span class="line">        <span class="keyword">if</span> (mCore-&gt;mQueue.empty()) &#123;</span><br><span class="line">            mCore-&gt;mQueue.push_back(item);</span><br><span class="line">            frameAvailableListener = mCore-&gt;mConsumerListener;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//否则，不为空，对Buffer进行处理，并获取FrameAvailableListener监听</span></span><br><span class="line">            BufferQueueCore::Fifo::iterator front(mCore-&gt;mQueue.begin());</span><br><span class="line">            <span class="keyword">if</span> (front-&gt;mIsDroppable) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mCore-&gt;stillTracking(front)) &#123;</span><br><span class="line">                    mSlots[front-&gt;mSlot].mBufferState = BufferSlot::FREE;</span><br><span class="line">                    mCore-&gt;mFreeBuffers.push_front(front-&gt;mSlot);</span><br><span class="line">                &#125;</span><br><span class="line">                *front = item;</span><br><span class="line">                frameReplacedListener = mCore-&gt;mConsumerListener;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mCore-&gt;mQueue.push_back(item);</span><br><span class="line">                frameAvailableListener = mCore-&gt;mConsumerListener;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mCore-&gt;mBufferHasBeenQueued = <span class="literal">true</span>;</span><br><span class="line">        mCore-&gt;mDequeueCondition.broadcast();</span><br><span class="line"></span><br><span class="line">        output-&gt;inflate(mCore-&gt;mDefaultWidth, mCore-&gt;mDefaultHeight,mCore-&gt;mTransformHint,</span><br><span class="line">                <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(mCore-&gt;mQueue.size()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Take a ticket for the callback functions</span></span><br><span class="line">        callbackTicket = mNextCallbackTicket++;</span><br><span class="line"></span><br><span class="line">        mCore-&gt;validateConsistencyLocked();</span><br><span class="line">    &#125; <span class="comment">// Autolock scope</span></span><br><span class="line">    ...</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (frameAvailableListener != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">//回调SurfaceTexture中定义好的监听IConsumerListener的onFrameAvailable方法来对数据进行处理</span></span><br><span class="line">            frameAvailableListener-&gt;onFrameAvailable(item);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (frameReplacedListener != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            frameReplacedListener-&gt;onFrameReplaced(item);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ++mCurrentCallbackTicket;</span><br><span class="line">        mCallbackCondition.broadcast();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由代码可知，它最后会调用Consumer的回调FrameAvailableListener的onFrameAvailable方法，到这里，就比较清晰为什么我们在写Camera应用，为其初始化Surface时，我们需要重写FrameAvailableListener了，因为在此方法里面，会进行结果的处理，至此，Camera HAL的Open流程就分析结束了。下面给出流程的时序图： </p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/camera.system/01-15-open_camera.png" alt="Alt text"></p><h4 id="（四）、Camera-API2-0-初始化流程分析"><a href="#（四）、Camera-API2-0-初始化流程分析" class="headerlink" title="（四）、Camera API2.0 初始化流程分析"></a>（四）、Camera API2.0 初始化流程分析</h4><h5 id="4-1、Camera2-应用层（Java层）Open-过程分析"><a href="#4-1、Camera2-应用层（Java层）Open-过程分析" class="headerlink" title="4.1、Camera2 应用层（Java层）Open()过程分析"></a>4.1、Camera2 应用层（Java层）Open()过程分析</h5><p>Camera2的初始化流程与Camera1.0有所区别，本文将就Camera2的内置应用来分析Camera2.0的初始化过程。Camera2.0首先启动的是CameraActivity，而它继承自QuickActivity，在代码中你会发现没有重写OnCreate等生命周期方法，因为此处采用的是模板方法的设计模式，在QuickActivity中的onCreate方法调用的是onCreateTasks等方法，所以要看onCreate方法就只须看onCreateTasks方法即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/CameraActivity.java]</span><br><span class="line">Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreateTasks</span><span class="params">(Bundle state)</span> </span>&#123;</span><br><span class="line">    Profile profile = mProfiler.create(<span class="string">"CameraActivity.onCreateTasks"</span>)</span><br><span class="line">                            .start();</span><br><span class="line">    ...</span><br><span class="line">    mOnCreateTime = System.currentTimeMillis();</span><br><span class="line">    mAppContext = getApplicationContext();</span><br><span class="line">    mMainHandler = <span class="keyword">new</span> MainHandler(<span class="keyword">this</span>, getMainLooper());</span><br><span class="line">    …</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//初始化OneCameraOpener对象</span></span><br><span class="line">        ①mOneCameraOpener = OneCameraModule.provideOneCameraOpener(</span><br><span class="line">                mFeatureConfig, mAppContext,mActiveCameraDeviceTracker,</span><br><span class="line">                ResolutionUtil.getDisplayMetrics(<span class="keyword">this</span>));</span><br><span class="line">        mOneCameraManager = OneCameraModule.provideOneCameraManager();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (OneCameraException e) &#123;...&#125;</span><br><span class="line">    …</span><br><span class="line">    <span class="comment">//建立模块信息</span></span><br><span class="line">    ②ModulesInfo.setupModules(mAppContext, mModuleManager, mFeatureConfig);</span><br><span class="line">    …</span><br><span class="line">    <span class="comment">//进行初始化</span></span><br><span class="line">    ③mCurrentModule.init(<span class="keyword">this</span>, isSecureCamera(), isCaptureIntent());</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如代码所示，重要的有以上三点，先看第一点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/one/OneCameraModule.java]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> OneCameraOpener <span class="title">provideOneCameraOpener</span><span class="params">(OneCameraFeatureConfig     </span></span></span><br><span class="line"><span class="function"><span class="params">            featureConfig, Context context, ActiveCameraDeviceTracker </span></span></span><br><span class="line"><span class="function"><span class="params">            activeCameraDeviceTracker,DisplayMetrics displayMetrics)</span> </span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> OneCameraException </span>&#123;</span><br><span class="line">    <span class="comment">//创建OneCameraOpener对象</span></span><br><span class="line">    Optional&lt;OneCameraOpener&gt; manager = Camera2OneCameraOpenerImpl.create(</span><br><span class="line">              featureConfig, context, activeCameraDeviceTracker, displayMetrics);</span><br><span class="line">    <span class="keyword">if</span> (!manager.isPresent()) &#123;</span><br><span class="line">        manager = LegacyOneCameraOpenerImpl.create();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> manager.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它调用Camera2OneCameraOpenerImpl的create方法来获得一个OneCameraOpener对象，以供CameraActivity之后的操作使用，继续看create方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/one/OneCameraModule.java]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Optional&lt;OneCameraOpener&gt; <span class="title">create</span><span class="params">(OneCameraFeatureConfig </span></span></span><br><span class="line"><span class="function"><span class="params">            featureConfig, Context context, ActiveCameraDeviceTracker </span></span></span><br><span class="line"><span class="function"><span class="params">            activeCameraDeviceTracker, DisplayMetrics displayMetrics)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    CameraManager cameraManager;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cameraManager = AndroidServices.instance().provideCameraManager();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalStateException ex) &#123;...&#125;</span><br><span class="line">    <span class="comment">//新建一个Camera2OneCameraOpenerImpl对象</span></span><br><span class="line">    OneCameraOpener oneCameraOpener = <span class="keyword">new</span> Camera2OneCameraOpenerImpl(</span><br><span class="line">                featureConfig, context, cameraManager,</span><br><span class="line">                activeCameraDeviceTracker, displayMetrics);</span><br><span class="line">    <span class="keyword">return</span> Optional.of(oneCameraOpener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，它首先获取一个cameraManger对象，然后根据这个cameraManager对象来新创建了一个Camera2OneCameraOpenerImpl对象，所以第一步主要是为了获取一个OneCameraOpener对象，它的实现为Camera2OneCameraOpenerImpl类。<br>继续看第二步，ModulesInfo.setupModules:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/<span class="keyword">module</span>/ModulesInfo.java]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setupModules</span><span class="params">(Context context, ModuleManager moduleManager,</span></span></span><br><span class="line"><span class="function"><span class="params">            OneCameraFeatureConfig config)</span> </span>&#123;</span><br><span class="line">        Resources res = context.getResources();</span><br><span class="line">        <span class="keyword">int</span> photoModuleId = context.getResources().getInteger(</span><br><span class="line">            R.integer.camera_mode_photo);</span><br><span class="line">        <span class="comment">//注册Photo模块</span></span><br><span class="line">        registerPhotoModule(moduleManager, photoModuleId, </span><br><span class="line">            SettingsScopeNamespaces.PHOTO,config.isUsingCaptureModule());</span><br><span class="line">        <span class="comment">//计算你还Photo模块设置为默认的模块</span></span><br><span class="line">        moduleManager.setDefaultModuleIndex(photoModuleId);</span><br><span class="line">        <span class="comment">//注册Videa模块</span></span><br><span class="line">        registerVideoModule(moduleManager, res.getInteger(</span><br><span class="line">            R.integer.camera_mode_video),SettingsScopeNamespaces.VIDEO);</span><br><span class="line">        <span class="keyword">if</span> (PhotoSphereHelper.hasLightCycleCapture(context)) &#123;<span class="comment">//开启闪光</span></span><br><span class="line">            <span class="comment">//注册广角镜头</span></span><br><span class="line">            registerWideAngleModule(moduleManager, res.getInteger(</span><br><span class="line">                R.integer.camera_mode_panorama),SettingsScopeNamespaces</span><br><span class="line">                .PANORAMA);</span><br><span class="line">            <span class="comment">//注册光球模块</span></span><br><span class="line">            registerPhotoSphereModule(moduleManager,res.getInteger(</span><br><span class="line">                R.integer.camera_mode_photosphere),</span><br><span class="line">                SettingsScopeNamespaces.PANORAMA);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//若需重新聚焦</span></span><br><span class="line">        <span class="keyword">if</span> (RefocusHelper.hasRefocusCapture(context)) &#123;</span><br><span class="line">            <span class="comment">//注册重聚焦模块</span></span><br><span class="line">            registerRefocusModule(moduleManager, res.getInteger(</span><br><span class="line">                R.integer.camera_mode_refocus),</span><br><span class="line">                SettingsScopeNamespaces.REFOCUS);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果有色分离模块</span></span><br><span class="line">        <span class="keyword">if</span> (GcamHelper.hasGcamAsSeparateModule(config)) &#123;</span><br><span class="line">            <span class="comment">//注册色分离模块</span></span><br><span class="line">            registerGcamModule(moduleManager, res.getInteger(</span><br><span class="line">                R.integer.camera_mode_gcam),SettingsScopeNamespaces.PHOTO,</span><br><span class="line">                config.getHdrPlusSupportLevel(OneCamera.Facing.BACK));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> imageCaptureIntentModuleId = res.getInteger(</span><br><span class="line">            R.integer.camera_mode_capture_intent);</span><br><span class="line">        registerCaptureIntentModule(moduleManager, </span><br><span class="line">            imageCaptureIntentModuleId,SettingsScopeNamespaces.PHOTO,</span><br><span class="line">            config.isUsingCaptureModule());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码根据配置信息，进行一系列模块的注册，其中PhotoModule和VideoModule被注册，而其他的module则是根据配置来进行的，因为打开Camera应用，既可以拍照片也可以拍视频，此处，只分析PhoneModule的注册：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/<span class="keyword">module</span>/ModulesInfo.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerPhotoModule</span><span class="params">(ModuleManager moduleManager, final </span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> moduleId, final String <span class="keyword">namespace</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">            final boolean enableCaptureModule)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//向ModuleManager注册PhotoModule模块</span></span><br><span class="line">        moduleManager.registerModule(<span class="keyword">new</span> ModuleManager.ModuleAgent() &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">int</span> getModuleId() &#123;</span><br><span class="line">                <span class="keyword">return</span> moduleId;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> boolean requestAppForCamera() &#123;</span><br><span class="line">                <span class="keyword">return</span> !enableCaptureModule;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> String getScopeNamespace() &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">namespace</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> ModuleController createModule(AppController app, Intent </span><br><span class="line">                    intent) &#123;</span><br><span class="line">                Log.v(TAG, <span class="string">"EnableCaptureModule = "</span> + enableCaptureModule);</span><br><span class="line">                <span class="comment">//创建ModuleController</span></span><br><span class="line">                <span class="keyword">return</span> enableCaptureModule ? <span class="keyword">new</span> CaptureModule(app) </span><br><span class="line">                        : <span class="keyword">new</span> PhotoModule(app);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由代码可知，它最终是由ModuleManager来新建一个CaptureModule实例，而CaptureModule其实实现了ModuleController ，即创建了一个CaptureModule模式下的ModuleController对象，而真正的CaptureModule的具体实现为ModuleManagerImpl。<br>至此，前两步已经获得了OneCameraOpener以及新建了ModuleController，并进行了注册，接下来分析第三步，mCurrentModule.init(this, isSecureCamera(), isCaptureIntent()):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/CaptureModule.java]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(CameraActivity activity, <span class="keyword">boolean</span> isSecureCamera, <span class="keyword">boolean</span> </span></span></span><br><span class="line"><span class="function"><span class="params">            isCaptureIntent)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        HandlerThread thread = <span class="keyword">new</span> HandlerThread(<span class="string">"CaptureModule.mCameraHandler"</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        mCameraHandler = <span class="keyword">new</span> Handler(thread.getLooper());</span><br><span class="line">        <span class="comment">//获取第一步中创建的OneCameraOpener对象</span></span><br><span class="line">        mOneCameraOpener = mAppController.getCameraOpener();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取前面创建的OneCameraManager对象</span></span><br><span class="line">            mOneCameraManager = OneCameraModule.provideOneCameraManager();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (OneCameraException e) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"Unable to provide a OneCameraManager. "</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">       `...</span><br><span class="line">        <span class="comment">//新建CaptureModule的UI</span></span><br><span class="line">        mUI = <span class="keyword">new</span> CaptureModuleUI(activity, mAppController.</span><br><span class="line">                getModuleLayoutRoot(), mUIListener);</span><br><span class="line">        <span class="comment">//设置预览状态的监听</span></span><br><span class="line">        mAppController.setPreviewStatusListener(mPreviewStatusListener);</span><br><span class="line">        <span class="keyword">synchronized</span> (mSurfaceTextureLock) &#123;</span><br><span class="line">            <span class="comment">//获取SurfaceTexture</span></span><br><span class="line">            mPreviewSurfaceTexture = mAppController.getCameraAppUI()</span><br><span class="line">                .getSurfaceTexture();</span><br><span class="line">        &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先获取前面创建的OneCameraOpener对象以及OneCameraManager对象，然后再设置预览状态监听，这里主要分析预览状态的监听：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/CaptureModule.java]</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PreviewStatusListener mPreviewStatusListener = <span class="keyword">new</span> </span><br><span class="line">    PreviewStatusListener() &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceTextureAvailable</span><span class="params">(SurfaceTexture surface, </span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">            updatePreviewTransform(width, height, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (mSurfaceTextureLock) &#123;</span><br><span class="line">                mPreviewSurfaceTexture = surface;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//打开Camera</span></span><br><span class="line">            reopenCamera();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onSurfaceTextureDestroyed</span><span class="params">(SurfaceTexture surface)</span> </span>&#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"onSurfaceTextureDestroyed"</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (mSurfaceTextureLock) &#123;</span><br><span class="line">                mPreviewSurfaceTexture = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//关闭Camera</span></span><br><span class="line">            closeCamera();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceTextureSizeChanged</span><span class="params">(SurfaceTexture surface, </span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//更新预览尺寸</span></span><br><span class="line">            updatePreviewBufferSize();</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line">``` </span><br><span class="line">由代码可知，当SurfaceTexture的状态变成可用的时候，会调用reopenCamera()方法来打开Camera，所以继续分析reopenCamera()方法：</span><br><span class="line">``` java</span><br><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/CaptureModule.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reopenCamera</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mPaused) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    AsyncTask.THREAD_POOL_EXECUTOR.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            closeCamera();</span><br><span class="line">            <span class="keyword">if</span>(!mAppController.isPaused()) &#123;</span><br><span class="line">                <span class="comment">//开启Camera并开始预览</span></span><br><span class="line">                openCameraAndStartPreview();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line">它采用异步任务的方法，开启一个异步线程来进行启动操作，首先关闭打开的Camera，然后如果AppController不处于暂停状态，则打开Camera并启动Preview操作，所以继续分析openCameraAndStartPreview方法：</span><br><span class="line">``` java</span><br><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/CaptureModule.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">openCameraAndStartPreview</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (mOneCameraOpener == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"no available OneCameraManager, showing error dialog"</span>);</span><br><span class="line">        <span class="comment">//释放CameraOpenCloseLock锁</span></span><br><span class="line">        mCameraOpenCloseLock.release();</span><br><span class="line">        mAppController.getFatalErrorHandler().onGenericCameraAccessFailure();</span><br><span class="line">        guard.stop(<span class="string">"No OneCameraManager"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Derive objects necessary for camera creation.</span></span><br><span class="line">    MainThread mainThread = MainThread.create();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找需要打开的CameraId</span></span><br><span class="line">    CameraId cameraId = mOneCameraManager.findFirstCameraFacing(</span><br><span class="line">        mCameraFacing);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//打开Camera</span></span><br><span class="line">    mOneCameraOpener.open(cameraId, captureSetting, mCameraHandler,</span><br><span class="line">        mainThread, imageRotationCalculator, mBurstController, </span><br><span class="line">        mSoundPlayer,<span class="keyword">new</span> OpenCallback() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//进行失败的处理</span></span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCameraClosed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCameraOpened</span><span class="params">(@Nonnull <span class="keyword">final</span> OneCamera camera)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"onCameraOpened: "</span> + camera);</span><br><span class="line">                mCamera = camera;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (mAppController.isPaused()) &#123;</span><br><span class="line">                    onFailure();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line">                mMainThread.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="comment">//通知UI，Camera状态变化</span></span><br><span class="line">                        mAppController.getCameraAppUI().onChangeCamera();</span><br><span class="line">                        <span class="comment">//使能拍照按钮</span></span><br><span class="line">                        mAppController.getButtonManager().enableCameraButton();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="comment">//至此，Camera打开成功，开始预览                    </span></span><br><span class="line">                camera.startPreview(<span class="keyword">new</span> Surface(getPreviewSurfaceTexture()), </span><br><span class="line">                    <span class="keyword">new</span> CaptureReadyCallback() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSetupFailed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            ...</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReadyForCapture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            <span class="comment">//释放锁</span></span><br><span class="line">                            mCameraOpenCloseLock.release();</span><br><span class="line">                            mMainThread.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                                    ...</span><br><span class="line">                                    onPreviewStarted();</span><br><span class="line">                                    ...</span><br><span class="line">                                    onReadyStateChanged(<span class="keyword">true</span>);</span><br><span class="line">                                    <span class="comment">//设置CaptureModule为Capture准备的状态监听</span></span><br><span class="line">                                    mCamera.setReadyStateChangedListener(</span><br><span class="line">                                        CaptureModule.<span class="keyword">this</span>);</span><br><span class="line">                                        mUI.initializeZoom(mCamera.getMaxZoom());                                 </span><br><span class="line">                                        mCamera.setFocusStateListener(</span><br><span class="line">                                            CaptureModule.<span class="keyword">this</span>);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125; </span><br><span class="line">              &#125;, mAppController.getFatalErrorHandler());</span><br><span class="line">        guard.stop(<span class="string">"mOneCameraOpener.open()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">首先，它主要会调用Camera2OneCameraOpenerImpl的open方法来打开Camera，并定义了开启的回调函数，对开启结束后的结果进行处理，如失败则释放mCameraOpenCloseLock，并暂停mAppController，如果打开成功，通知UI成功，并开启Camera的Preview，并且定义了Preview的各种回调操作，这里主要分析Open过程，所以继续分析：</span><br><span class="line"></span><br><span class="line">``` java</span><br><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/one/v2/Camera2OneCameraOpenerImpl.java]</span><br><span class="line">Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    ...</span></span></span><br><span class="line"><span class="function"><span class="params">    mActiveCameraDeviceTracker.onCameraOpening(cameraKey)</span></span>;</span><br><span class="line">    <span class="comment">//打开Camera，此处调用框架层的CameraManager类的openCamera，进入frameworks层</span></span><br><span class="line">    mCameraManager.openCamera(cameraKey.getValue(), </span><br><span class="line">        <span class="keyword">new</span> CameraDevice.StateCallback() &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> isFirstCallback = <span class="keyword">true</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpened</span><span class="params">(CameraDevice device)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//第一次调用此回调</span></span><br><span class="line">            <span class="keyword">if</span> (isFirstCallback) &#123;</span><br><span class="line">                isFirstCallback = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    CameraCharacteristics characteristics = mCameraManager</span><br><span class="line">                        .getCameraCharacteristics(device.getId());</span><br><span class="line">                    ...</span><br><span class="line">                    <span class="comment">//创建OneCamera对象</span></span><br><span class="line">                    OneCamera oneCamera = OneCameraCreator.create(device,</span><br><span class="line">                        characteristics, mFeatureConfig, captureSetting,</span><br><span class="line">                        mDisplayMetrics, mContext, mainThread,</span><br><span class="line">                        imageRotationCalculator, burstController, soundPlayer,</span><br><span class="line">                        fatalErrorHandler);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (oneCamera != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//如果oneCamera不为空，则回调onCameraOpened，后面将做分析</span></span><br><span class="line">                        openCallback.onCameraOpened(oneCamera);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        ...</span><br><span class="line">                        openCallback.onFailure();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (CameraAccessException e) &#123;</span><br><span class="line">                    openCallback.onFailure();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (OneCameraAccessException e) &#123;</span><br><span class="line">                    Log.d(TAG, <span class="string">"Could not create OneCamera"</span>, e);</span><br><span class="line">                    openCallback.onFailure();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, handler);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>至此，Camera的初始化流程中应用层的分析就差不多了，下一步将会调用CameraManager的openCamera方法来进入框架层，并进行Camera的初始化，下面将应用层的初始化时序图： </p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/camera.system/01-16-camera_open_java.png" alt="Alt text"></p><h5 id="4-2、Camera2-框架层（JNI-amp-Native）Open-过程分析"><a href="#4-2、Camera2-框架层（JNI-amp-Native）Open-过程分析" class="headerlink" title="4.2、Camera2 框架层（JNI &amp; Native）Open()过程分析"></a>4.2、Camera2 框架层（JNI &amp; Native）Open()过程分析</h5><p>由上面的分析可知，将由应用层进入到框架层处理，将会调用CameraManager的openCamera方法，并且定义了CameraDevice的状态回调函数，具体的回调操作此处不做分析，继续跟踪openCamera()方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CameraManager.java(frameworks/base/core/java/android/hardware/camera2)</span></span><br><span class="line">@RequiresPermission(android.Manifest.permission.CAMERA)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openCamera</span><span class="params">(@NonNull String cameraId,@NonNull final </span></span></span><br><span class="line"><span class="function"><span class="params">        CameraDevice.StateCallback callback, @Nullable Handler handler)</span></span></span><br><span class="line"><span class="function">        throws CameraAccessException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    openCameraDeviceUserAsync(cameraId, callback, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由代码可知，此处与Camera1.0有明显不同，Camera1.0是通过一个异步的线程以及JNI来调用android_hardware_camera.java里面的native_setup方法来连接Camera，其使用的是C++的Binder来与CameraService进行通信的，而此处则不一样，它直接使用的是Java层的Binder来进行通信，先看openCameraDeviceUserAsync代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CameraManager.java(frameworks/base/core/java/android/hardware/camera2)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> CameraDevice <span class="title">openCameraDeviceUserAsync</span><span class="params">(String cameraId,</span></span></span><br><span class="line"><span class="function"><span class="params">        CameraDevice.StateCallback callback, Handler handler)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> CameraAccessException </span>&#123;</span><br><span class="line">    CameraCharacteristics characteristics = getCameraCharacteristics(</span><br><span class="line">        cameraId);</span><br><span class="line">    CameraDevice device = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            ICameraDeviceUser cameraUser = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//初始化一个CameraDevice对象</span></span><br><span class="line">            android.hardware.camera2.impl.CameraDeviceImpl deviceImpl =</span><br><span class="line">                <span class="keyword">new</span> android.hardware.camera2.impl.CameraDeviceImpl(cameraId,</span><br><span class="line">                callback, handler, characteristics);</span><br><span class="line">            BinderHolder holder = <span class="keyword">new</span> BinderHolder();</span><br><span class="line">            <span class="comment">//获取回调</span></span><br><span class="line">            ICameraDeviceCallbacks callbacks = deviceImpl.getCallbacks();</span><br><span class="line">            <span class="keyword">int</span> id = Integer.parseInt(cameraId);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (supportsCamera2ApiLocked(cameraId)) &#123;</span><br><span class="line">                    <span class="comment">//通过Java层的Binder获取CameraService                        </span></span><br><span class="line">                    ICameraService cameraService = CameraManagerGlobal.get()</span><br><span class="line">                        .getCameraService();</span><br><span class="line">                    ...</span><br><span class="line">                    <span class="comment">//通过CameraService连接Camera设备</span></span><br><span class="line">                    cameraService.connectDevice(callbacks, id, mContext</span><br><span class="line">                        .getOpPackageName(), USE_CALLING_UID, holder);</span><br><span class="line">                    <span class="comment">//获取连接成功的CameraUser对象，它用来与CameraService通信</span></span><br><span class="line">                    cameraUser = ICameraDeviceUser.Stub.asInterface(</span><br><span class="line">                        holder.getBinder());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//使用遗留的API</span></span><br><span class="line">                    cameraUser = CameraDeviceUserShim.connectBinderShim(</span><br><span class="line">                        callbacks, id);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (CameraRuntimeException e) &#123;</span><br><span class="line">                ...</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//将其包装成DeviceImpl对象，供应用层使用</span></span><br><span class="line">            deviceImpl.setRemoteDevice(cameraUser);</span><br><span class="line">            device = deviceImpl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CameraRuntimeException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.asChecked();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> device;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法的目的是通过CameraService来连接并获取CameraDevice对象，该对象用来与Camera进行通信操作。代码首先通过Java层的Binder机制获取CameraService，然后调用其connectDevice方法来连接CaneraDevice，最后Camera返回的是CameraDeviceUser对象，而接着将其封装成Jav层CameraDevice对象，而之后所有与Camera的通信都通过CameraDevice的接口来进行。接下来分析一下Native层下的CameraDevice的初始化过程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\camera\libcameraservice\CameraService.cpp]</span><br><span class="line"><span class="comment">//CameraService.cpp，其中device为输出对象</span></span><br><span class="line"><span class="keyword">status_t</span> CameraService::connectDevice(<span class="keyword">const</span> sp&lt;ICameraDeviceCallbacks&gt;&amp; cameraCb,<span class="keyword">int</span> cameraId,</span><br><span class="line">        <span class="keyword">const</span> String16&amp; clientPackageName,<span class="keyword">int</span> clientUid,<span class="comment">/*out*/</span>sp&lt;ICameraDeviceUser&gt;&amp; device) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> ret = NO_ERROR;</span><br><span class="line">    String8 id = String8::format(<span class="string">"%d"</span>, cameraId);</span><br><span class="line">    sp&lt;CameraDeviceClient&gt; client = <span class="literal">nullptr</span>;</span><br><span class="line">    ret = connectHelper&lt;ICameraDeviceCallbacks,CameraDeviceClient&gt;(cameraCb, id,</span><br><span class="line">            CAMERA_HAL_API_VERSION_UNSPECIFIED, clientPackageName, clientUid, API_2, <span class="literal">false</span>, <span class="literal">false</span>,</span><br><span class="line">            <span class="comment">/*out*/</span>client);<span class="comment">//client为输出对象</span></span><br><span class="line">    ...</span><br><span class="line">    device = client;</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Native层的connectDevice方法就是调用了connectHelper方法，所以继续分析connectHelper：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\camera\libcameraservice\CameraService.h]</span><br><span class="line"><span class="comment">//CameraService.h</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">CALLBACK</span>, <span class="title">class</span> <span class="title">CLIENT</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">status_t</span> <span class="title">CameraService</span>:</span>:connectHelper(<span class="keyword">const</span> sp&lt;CALLBACK&gt;&amp; cameraCb, <span class="keyword">const</span> String8&amp; cameraId,</span><br><span class="line">        <span class="keyword">int</span> halVersion, <span class="keyword">const</span> String16&amp; clientPackageName, <span class="keyword">int</span> clientUid,</span><br><span class="line">        apiLevel effectiveApiLevel, <span class="keyword">bool</span> legacyMode, <span class="keyword">bool</span> shimUpdateOnly,</span><br><span class="line">        <span class="comment">/*out*/</span>sp&lt;CLIENT&gt;&amp; device) &#123;</span><br><span class="line">    <span class="keyword">status_t</span> ret = NO_ERROR;</span><br><span class="line">    <span class="function">String8 <span class="title">clientName8</span><span class="params">(clientPackageName)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> clientPid = getCallingPid();</span><br><span class="line">    ...</span><br><span class="line">    sp&lt;CLIENT&gt; client = <span class="literal">nullptr</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果有必要，给FlashLight关闭设备的机会</span></span><br><span class="line">        mFlashlight-&gt;prepareDeviceOpen(cameraId);</span><br><span class="line">        <span class="comment">//获取CameraId</span></span><br><span class="line">        <span class="keyword">int</span> id = cameraIdToInt(cameraId);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//获取Device的版本，此处为Device3</span></span><br><span class="line">        <span class="keyword">int</span> deviceVersion = getDeviceVersion(id, <span class="comment">/*out*/</span>&amp;facing);</span><br><span class="line">        sp&lt;BasicClient&gt; tmp = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">//获取client对象</span></span><br><span class="line">        <span class="keyword">if</span>((ret = makeClient(<span class="keyword">this</span>, cameraCb, clientPackageName, cameraId, facing, clientPid,</span><br><span class="line">                clientUid, getpid(), legacyMode, halVersion, deviceVersion, effectiveApiLevel,</span><br><span class="line">                <span class="comment">/*out*/</span>&amp;tmp)) != NO_ERROR) &#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        client = <span class="keyword">static_cast</span>&lt;CLIENT*&gt;(tmp.get());</span><br><span class="line">        <span class="comment">//调用client的初始化函数来初始化模块</span></span><br><span class="line">        <span class="keyword">if</span> ((ret = client-&gt;initialize(mModule)) != OK) &#123;</span><br><span class="line">            ALOGE(<span class="string">"%s: Could not initialize client from HAL module."</span>, __FUNCTION__);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sp&lt;IBinder&gt; remoteCallback = client-&gt;getRemote();</span><br><span class="line">        <span class="keyword">if</span> (remoteCallback != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            remoteCallback-&gt;linkToDeath(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// lock is destroyed, allow further connect calls</span></span><br><span class="line">    <span class="comment">//将client赋值给输出Device</span></span><br><span class="line">    device = client;</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CameraService根据Camera的相关参数来获取一个client，如makeClient方法，然后再调用client的initialize来进行初始化，首先看makeClient：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\camera\libcameraservice\CameraService.cpp]</span><br><span class="line"><span class="comment">//CameraService.cpp，其中device为输出对象</span></span><br><span class="line"><span class="keyword">status_t</span> CameraService::makeClient(<span class="keyword">const</span> sp&lt;CameraService&gt;&amp; cameraService,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;IInterface&gt;&amp; cameraCb, <span class="keyword">const</span> String16&amp; packageName, <span class="keyword">const</span> String8&amp; cameraId,</span><br><span class="line">        <span class="keyword">int</span> facing, <span class="keyword">int</span> clientPid, <span class="keyword">uid_t</span> clientUid, <span class="keyword">int</span> servicePid, <span class="keyword">bool</span> legacyMode,</span><br><span class="line">        <span class="keyword">int</span> halVersion, <span class="keyword">int</span> deviceVersion, apiLevel effectiveApiLevel,</span><br><span class="line">        <span class="comment">/*out*/</span>sp&lt;BasicClient&gt;* client) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将字符串的CameraId转换成整形</span></span><br><span class="line">    <span class="keyword">int</span> id = cameraIdToInt(cameraId);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (halVersion &lt; <span class="number">0</span> || halVersion == deviceVersion) &#123;<span class="comment">//判断Camera HAL版本是否和Device的版本相同</span></span><br><span class="line">        <span class="keyword">switch</span>(deviceVersion) &#123;</span><br><span class="line">          <span class="keyword">case</span> CAMERA_DEVICE_API_VERSION_1_0:</span><br><span class="line">            <span class="keyword">if</span> (effectiveApiLevel == API_1) &#123;  <span class="comment">// Camera1 API route</span></span><br><span class="line">                sp&lt;ICameraClient&gt; tmp = <span class="keyword">static_cast</span>&lt;ICameraClient*&gt;(cameraCb.get());</span><br><span class="line">                *client = <span class="keyword">new</span> CameraClient(cameraService, tmp, packageName, id, facing,</span><br><span class="line">                        clientPid, clientUid, getpid(), legacyMode);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// Camera2 API route</span></span><br><span class="line">                ALOGW(<span class="string">"Camera using old HAL version: %d"</span>, deviceVersion);</span><br><span class="line">                <span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> CAMERA_DEVICE_API_VERSION_2_0:</span><br><span class="line">          <span class="keyword">case</span> CAMERA_DEVICE_API_VERSION_2_1:</span><br><span class="line">          <span class="keyword">case</span> CAMERA_DEVICE_API_VERSION_3_0:</span><br><span class="line">          <span class="keyword">case</span> CAMERA_DEVICE_API_VERSION_3_1:</span><br><span class="line">          <span class="keyword">case</span> CAMERA_DEVICE_API_VERSION_3_2:</span><br><span class="line">          <span class="keyword">case</span> CAMERA_DEVICE_API_VERSION_3_3:</span><br><span class="line">            <span class="keyword">if</span> (effectiveApiLevel == API_1) &#123; <span class="comment">// Camera1 API route</span></span><br><span class="line">                sp&lt;ICameraClient&gt; tmp = <span class="keyword">static_cast</span>&lt;ICameraClient*&gt;(cameraCb.get());</span><br><span class="line">                *client = <span class="keyword">new</span> Camera2Client(cameraService, tmp, packageName, id, facing,</span><br><span class="line">                        clientPid, clientUid, servicePid, legacyMode);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// Camera2 API route</span></span><br><span class="line">                sp&lt;ICameraDeviceCallbacks&gt; tmp =</span><br><span class="line">                        <span class="keyword">static_cast</span>&lt;ICameraDeviceCallbacks*&gt;(cameraCb.get());</span><br><span class="line">                *client = <span class="keyword">new</span> CameraDeviceClient(cameraService, tmp, packageName, id,</span><br><span class="line">                        facing, clientPid, clientUid, servicePid);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// Should not be reachable</span></span><br><span class="line">            ALOGE(<span class="string">"Unknown camera device HAL version: %d"</span>, deviceVersion);</span><br><span class="line">            <span class="keyword">return</span> INVALID_OPERATION;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// A particular HAL version is requested by caller. Create CameraClient</span></span><br><span class="line">        <span class="comment">// based on the requested HAL version.</span></span><br><span class="line">        <span class="keyword">if</span> (deviceVersion &gt; CAMERA_DEVICE_API_VERSION_1_0 &amp;&amp;</span><br><span class="line">            halVersion == CAMERA_DEVICE_API_VERSION_1_0) &#123;</span><br><span class="line">            <span class="comment">// Only support higher HAL version device opened as HAL1.0 device.</span></span><br><span class="line">            sp&lt;ICameraClient&gt; tmp = <span class="keyword">static_cast</span>&lt;ICameraClient*&gt;(cameraCb.get());</span><br><span class="line">            *client = <span class="keyword">new</span> CameraClient(cameraService, tmp, packageName, id, facing,</span><br><span class="line">                    clientPid, clientUid, servicePid, legacyMode);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Other combinations (e.g. HAL3.x open as HAL2.x) are not supported yet.</span></span><br><span class="line">            ALOGE(<span class="string">"Invalid camera HAL version %x: HAL %x device can only be"</span></span><br><span class="line">                    <span class="string">" opened as HAL %x device"</span>, halVersion, deviceVersion,</span><br><span class="line">                    CAMERA_DEVICE_API_VERSION_1_0);</span><br><span class="line">            <span class="keyword">return</span> INVALID_OPERATION;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中就是创建一个Client对象，由于此处分析的是Camera API2.0，其HAL的版本是3.0+，而Device的版本则其Device的版本即为3.0+，所以会创建一个CameraDeviceClient对象，至此，makeClient已经创建了client对象，并返回了，接着看它的初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\camera\libcameraservice\api2\CameraDeviceClient.cpp]</span><br><span class="line"><span class="keyword">status_t</span> CameraDeviceClient::initialize(CameraModule *<span class="keyword">module</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    <span class="keyword">status_t</span> res;</span><br><span class="line">    <span class="comment">//调用Camera2ClientBase的初始化函数来初始化CameraModule模块</span></span><br><span class="line">    res = Camera2ClientBase::initialize(<span class="keyword">module</span>);</span><br><span class="line">    <span class="keyword">if</span> (res != OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String8 threadName;</span><br><span class="line">    <span class="comment">//初始化FrameProcessor</span></span><br><span class="line">    mFrameProcessor = <span class="keyword">new</span> FrameProcessorBase(mDevice);</span><br><span class="line">    threadName = String8::format(<span class="string">"CDU-%d-FrameProc"</span>, mCameraId);</span><br><span class="line">    mFrameProcessor-&gt;run(threadName.<span class="built_in">string</span>());</span><br><span class="line">    <span class="comment">//并注册监听，监听的实现就在CameraDeviceClient类中</span></span><br><span class="line">    mFrameProcessor-&gt;registerListener(FRAME_PROCESSOR_LISTENER_MIN_ID,</span><br><span class="line">            FRAME_PROCESSOR_LISTENER_MAX_ID, <span class="comment">/*listener*/</span><span class="keyword">this</span>,<span class="comment">/*sendPartials*/</span><span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它会调用Camera2ClientBase的initialize方法来初始化，并且会初始化一个FrameProcessor来进行帧处理，主要是回调每一帧的ExtraResult到应用中，也就是3A相关的数据信息。而Camera1.0中各种Processor模块，即将数据打包处理后再返回到应用的模块都已经不存在，而Camera2.0中将由MediaRecorder、SurfaceView、ImageReader等来直接处理，总体来说效率更好。继续看initialize：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\camera\libcameraservice\common\Camera2ClientBase.cpp]</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TClientBase&gt;</span><br><span class="line"><span class="keyword">status_t</span> Camera2ClientBase&lt;TClientBase&gt;::initialize(CameraModule *<span class="keyword">module</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//调用Device的initialie方法</span></span><br><span class="line">    res = mDevice-&gt;initialize(<span class="keyword">module</span>);</span><br><span class="line">    ...</span><br><span class="line">    res = mDevice-&gt;setNotifyCallback(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码就是调用了Device的initialize方法，此处的Device是在Camera2ClientBase的构造函数中创建的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\camera\libcameraservice\common\Camera2ClientBase.cpp]</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TClientBase&gt;</span><br><span class="line">Camera2ClientBase&lt;TClientBase&gt;::Camera2ClientBase(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;CameraService&gt;&amp; cameraService,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;TCamCallbacks&gt;&amp; remoteCallback,</span><br><span class="line">        <span class="keyword">const</span> String16&amp; clientPackageName,</span><br><span class="line">        <span class="keyword">int</span> cameraId,</span><br><span class="line">        <span class="keyword">int</span> cameraFacing,</span><br><span class="line">        <span class="keyword">int</span> clientPid,</span><br><span class="line">        <span class="keyword">uid_t</span> clientUid,</span><br><span class="line">        <span class="keyword">int</span> servicePid):</span><br><span class="line">        TClientBase(cameraService, remoteCallback, clientPackageName,</span><br><span class="line">                cameraId, cameraFacing, clientPid, clientUid, servicePid),</span><br><span class="line">        mSharedCameraCallbacks(remoteCallback),</span><br><span class="line">        mDeviceVersion(cameraService-&gt;getDeviceVersion(cameraId)),</span><br><span class="line">        mDeviceActive(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ALOGI(<span class="string">"Camera %d: Opened. Client: %s (PID %d, UID %d)"</span>, cameraId,</span><br><span class="line">            String8(clientPackageName).<span class="built_in">string</span>(), clientPid, clientUid);</span><br><span class="line"></span><br><span class="line">    mInitialClientPid = clientPid;</span><br><span class="line">    mDevice = <span class="keyword">new</span> Camera3Device(cameraId);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(mDevice == <span class="number">0</span>, <span class="string">"Device should never be NULL here."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前Camera API是2.0，而Device的API已经是3.0+了，继续看Camera3Device的构造方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\camera\libcameraservice\device3\Camera3Device.cpp]</span><br><span class="line">Camera3Device::Camera3Device(<span class="keyword">int</span> id):</span><br><span class="line">        mId(id),</span><br><span class="line">        mIsConstrainedHighSpeedConfiguration(<span class="literal">false</span>),</span><br><span class="line">        mHal3Device(<span class="literal">NULL</span>),</span><br><span class="line">        mStatus(STATUS_UNINITIALIZED),</span><br><span class="line">        mStatusWaiters(<span class="number">0</span>),</span><br><span class="line">        mUsePartialResult(<span class="literal">false</span>),</span><br><span class="line">        mNumPartialResults(<span class="number">1</span>),</span><br><span class="line">        mTimestampOffset(<span class="number">0</span>),</span><br><span class="line">        mNextResultFrameNumber(<span class="number">0</span>),</span><br><span class="line">        mNextReprocessResultFrameNumber(<span class="number">0</span>),</span><br><span class="line">        mNextShutterFrameNumber(<span class="number">0</span>),</span><br><span class="line">        mNextReprocessShutterFrameNumber(<span class="number">0</span>),</span><br><span class="line">        mListener(<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    camera3_callback_ops::notify = &amp;sNotify;</span><br><span class="line">    camera3_callback_ops::process_capture_result = &amp;sProcessCaptureResult;</span><br><span class="line">    ALOGV(<span class="string">"%s: Created device for camera %d"</span>, __FUNCTION__, id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很显然，它将会创建一个Camera3Device对象，所以，Device的initialize就是调用了Camera3Device的initialize方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\camera\libcameraservice\device3\Camera3Device.cpp]</span><br><span class="line"><span class="keyword">status_t</span> Camera3Device::initialize(CameraModule *<span class="keyword">module</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">camera3_device_t</span> *device;</span><br><span class="line">    <span class="comment">//打开Camera HAL层的Deivce</span></span><br><span class="line">    res = <span class="keyword">module</span>-&gt;open(deviceName.<span class="built_in">string</span>(),</span><br><span class="line">            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">hw_device_t</span>**&gt;(&amp;device));</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交叉检查Device的版本</span></span><br><span class="line">    <span class="keyword">if</span> (device-&gt;common.version &lt; CAMERA_DEVICE_API_VERSION_3_0) &#123;</span><br><span class="line">        SET_ERR_L(<span class="string">"Could not open camera: "</span></span><br><span class="line">                <span class="string">"Camera device should be at least %x, reports %x instead"</span>,</span><br><span class="line">                CAMERA_DEVICE_API_VERSION_3_0,</span><br><span class="line">                device-&gt;common.version);</span><br><span class="line">        device-&gt;common.close(&amp;device-&gt;common);</span><br><span class="line">        <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用回调函数来进行初始化，即调用打开Device的initialize方法来进行初始化</span></span><br><span class="line">    res = device-&gt;ops-&gt;initialize(device, <span class="keyword">this</span>);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动请求队列线程</span></span><br><span class="line">    mRequestThread = <span class="keyword">new</span> RequestThread(<span class="keyword">this</span>, mStatusTracker, device, aeLockAvailable);</span><br><span class="line">    res = mRequestThread-&gt;run(String8::format(<span class="string">"C3Dev-%d-ReqQueue"</span>, mId).<span class="built_in">string</span>());</span><br><span class="line">    <span class="keyword">if</span> (res != OK) &#123;</span><br><span class="line">        SET_ERR_L(<span class="string">"Unable to start request queue thread: %s (%d)"</span>,</span><br><span class="line">                strerror(-res), res);</span><br><span class="line">        device-&gt;common.close(&amp;device-&gt;common);</span><br><span class="line">        mRequestThread.clear();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//返回初始成功</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，会依赖HAL框架打开并获得相应的Device对象，具体的流程请参考android6.0源码分析之Camera2 HAL分析，然后再回调此对象的initialize方法进行初始化，最后再启动RequestThread等线程，并返回initialize成功。至此Camera API2.0下的初始化过程就分析结束了。框架层的初始化时序图如下： </p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/camera.system/01-17-camera_open_native.png" alt="Alt text"></p><h5 id="4-2、总结"><a href="#4-2、总结" class="headerlink" title="4.2、总结"></a>4.2、总结</h5><p>Open()过程道路艰辛，主要为了后续Camera正常工作，添砖加瓦，铺路。下面我们列举一下，主要都准备了什么。<br>1、Camera应用将一些Callback函数，注册到Camera.java中，以使在线程处理函数中可以调用到相应的回调函数。<br>2、camera connect成功后，创建了BpCamera代理对象和BnCameraClient本地对象。<br>3、在JNICameraContext实现CameraListener接口，并将接口注册到客户端camera本地对象中，并在BnCameraClient本地对象中回调这些接口。<br>4、CameraService connect过程中，根据hal硬件版本，创建对应的CameraClient对象。在后续的初始化过程中，创建6大线程。<br>最后以一个简单的工作流程图来结束博文 </p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/camera.system/01-18-Camera_open_overview.png" alt="Alt text"></p><h4 id="（五）、参考资料-特别感谢各位前辈的分析和图示-："><a href="#（五）、参考资料-特别感谢各位前辈的分析和图示-：" class="headerlink" title="（五）、参考资料(特别感谢各位前辈的分析和图示)："></a>（五）、参考资料(特别感谢各位前辈的分析和图示)：</h4><p><a href="https://source.android.com/devices/camera/" target="_blank" rel="noopener">Android Camera官方文档</a><br><a href="https://blog.csdn.net/eternity9255" target="_blank" rel="noopener">Android 5.0 Camera系统源码分析-CSDN博客</a><br><a href="http://www.cnblogs.com/stonedemo/category/1080451.html" target="_blank" rel="noopener">Android Camera 流程学习记录 - StoneDemo - 博客园</a><br><a href="https://blog.csdn.net/shell812/article/category/5905525" target="_blank" rel="noopener">Android Camera 系统架构源码分析 - CSDN博客</a><br><a href="https://blog.csdn.net/hbw1992322/article/details/75259311" target="_blank" rel="noopener">Camera安卓源码-高通mm_camera架构剖析 - CSDN博客</a><br><a href="https://blog.csdn.net/yanbixing123/article/details/52294305/" target="_blank" rel="noopener">5.2 应用程序和驱动程序中buffer的传输流程 - CSDN博客</a><br><a href="https://www.jianshu.com/p/ecb1be82e6a8" target="_blank" rel="noopener">Camera2 数据流从framework到Hal源码分析 - 简书</a><br><a href="https://www.jianshu.com/p/1baad2a5281d" target="_blank" rel="noopener">mm-camera层frame数据流源码分析 - 简书</a><br><a href="https://blog.csdn.net/yanbixing123/article/month/2016/08/4?" target="_blank" rel="noopener">v4l2_capture.c分析—probe函数分析 - CSDN博客</a><br><a href="https://blog.csdn.net/armwind/article/category/6282972" target="_blank" rel="noopener">@@Android Camera fw学习 - CSDN博客</a><br><a href="https://blog.csdn.net/gzzaigcnforever/article/category/3066721" target="_blank" rel="noopener">@@Android Camera API2分析 - CSDN博客</a><br><a href="https://blog.csdn.net/qq_16775897/article/category/7112759" target="_blank" rel="noopener">@@Android Camera 流程学习记录 7.12- CSDN博客</a><br><a href="https://blog.csdn.net/column/details/guming-camera.html" target="_blank" rel="noopener">@@专栏：古冥的android6.0下的Camera API2.0的源码分析之旅 - CSDN博客</a><br><a href="https://blog.csdn.net/gzzaigcnforever/article/details/17751109" target="_blank" rel="noopener">linux3.3 v4l2视频采集驱动框架(vfe, camera i2c driver，v4l2_subdev等之间的联系) - CSDN博客</a><br><a href="https://blog.csdn.net/gzzaigcnforever/article/details/48974523" target="_blank" rel="noopener">Android Camera从Camera HAL1到Camera HAL3的过渡（已更新到Android6.0 HAL3.3） - CSDN博客</a><br><a href="https://blog.csdn.net/gzzaigcnforever/article/details/48972477" target="_blank" rel="noopener">我心依旧之Android Camera模块FW/HAL3探学序 - CSDN博客</a><br><a href="https://blog.csdn.net/armwind/article/details/73709808" target="_blank" rel="noopener">Android Camera fw学习(四)-recording流程分析 - CSDN博客</a><br><a href="https://blog.csdn.net/armwind/article/details/52076879" target="_blank" rel="noopener">android camera动态库加载过程 - CSDN博客</a><br><a href="https://blog.csdn.net/gzzaigcnforever/article/details/49468475" target="_blank" rel="noopener">Android Camera API2.0下全新的Camera FW/HAL架构简述 - CSDN博客</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;amp;&amp;amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内
      
    
    </summary>
    
      <category term="Android" scheme="http://zhoujinjian.cc/categories/Android/"/>
    
    
      <category term="Android" scheme="http://zhoujinjian.cc/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android Video System（3）：音视频录制Recorder、编码Encoder、混合MediaMuxer源码分析</title>
    <link href="http://zhoujinjian.cc/2018/06/18/Android%20Video%20System%EF%BC%883%EF%BC%89%EF%BC%9A%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6Recorder%E3%80%81%E7%BC%96%E7%A0%81Encoder%E3%80%81%E6%B7%B7%E5%90%88MediaMuxer%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://zhoujinjian.cc/2018/06/18/Android Video System（3）：音视频录制Recorder、编码Encoder、混合MediaMuxer源码分析/</id>
    <published>2018-06-17T16:00:00.000Z</published>
    <updated>2018-07-03T12:51:51.638Z</updated>
    
    <content type="html"><![CDATA[<hr><p>注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;&amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除，禁止转载（©Qualcomm Technologies, Inc. 版权所有），谢谢。</p><p><a href="https://github.com/izhoujinjian/zhoujinjian.cc/tree/master/video.system" target="_blank" rel="noopener">【博客原图链接】</a><br><a href="http://www.cnblogs.com/tocy/tag/%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6/" target="_blank" rel="noopener">【特别感谢 -  Android NuPlayer播放框架】</a><br><a href="https://blog.csdn.net/dfhuang09/article/details/54926526" target="_blank" rel="noopener">【特别感谢 -  android ACodec MediaCodec NuPlayer flow】</a></p><p>Google Pixel、Pixel XL 内核代码（文章基于 Kernel-3.18）：<br> <a href="https://github.com/matthewdalex/marlin" target="_blank" rel="noopener">Kernel source for Pixel and Pixel XL - GitHub</a></p><p>AOSP 源码（文章基于 Android 7.1.2）：<br> <a href="https://testerhome.com/topics/2229" target="_blank" rel="noopener"> Android 系统全套源代码分享 (更新到 8.1.0_r1)</a></p><hr><p>☯ V4l2 框架代码<br>☯ kernel/drivers/media/v4l2-core/（文件前缀为 videobuf2）</p><p>☯ MSM 视频驱动程序文件<br>☯ kernel/drivers/media/platform/msm/vidc/</p><p>☯ 设备树<br>☯ /kernel/arch/arm/boot/dts/qcom（Venus 的寄存器基址，时钟频率）</p><p>☯ Stagefright、libmedia、libmediaplayerservice、mediaserver<br>☯ /frameworks/av/media/</p><p>☯ OMX<br>☯ /hardware/qcom/media/mam8996/mm-video-v4l2/vidc/</p><p>☯ OMX 核心<br>☯ /hardware/qcom/media/mm-core</p><p>☯ 软件编解码器路径<br>☯ /vendor/qcom/proprietary/mm-video/omx_vpp(?) → 解码器代码<br>☯ /vendor/qcom/proprietary/mm-video/omx_vpp(?) → 编码器代码</p><hr><p>首先看一下使用MediaRecorder 录制音频的Java实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MediaRecorder recorder=newMediaRecorder();</span><br><span class="line">recorder.setAudioSource(MediaRecorder.AudioSource.MIC);</span><br><span class="line">recorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP);</span><br><span class="line">recorder.setAudioEncoder(MediaRecorder.AudioEncoder.AMR_NB);</span><br><span class="line">recorder.setOutputFile(PATH_NAME);</span><br><span class="line">recorder.prepare();</span><br><span class="line">recorder.start();  <span class="comment">// Recording is now started</span></span><br><span class="line">...</span><br><span class="line">recorder.stop();  <span class="comment">//</span></span><br><span class="line">recorder.reset();  <span class="comment">// You can reuse the object by going back to setAudioSource() step</span></span><br><span class="line">recorder.release();<span class="comment">// Now the object cannot be reused</span></span><br></pre></td></tr></table></figure><p>之前在<a href="http://zhoujinjian.cc/2018/05/15/Audio%20System%EF%BC%882%EF%BC%89%EF%BC%9ALinux%20ALSA%E9%9F%B3%E9%A2%91%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/#%EF%BC%88%E5%85%AB%EF%BC%89%E3%80%81tinyplay-playback%E3%80%81capture">Audio System（2）：Linux ALSA音频系统分析</a> 第（八）节画过tinyplay capture录音时序图，但当时没有仔细分析，今天来分析Audio录音如何从Java层一步步最终到达tinyalsa层的pcm_open()、pcm_read()函数的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;E:\android<span class="number">-7.1</span><span class="number">.2</span>_r1\external\tinyalsa\tinycap.c]</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">capture_sample</span><span class="params">(FILE *file, <span class="keyword">unsigned</span> <span class="keyword">int</span> card, <span class="keyword">unsigned</span> <span class="keyword">int</span> device,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">unsigned</span> <span class="keyword">int</span> channels, <span class="keyword">unsigned</span> <span class="keyword">int</span> rate,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">enum</span> pcm_format format, <span class="keyword">unsigned</span> <span class="keyword">int</span> period_size,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">unsigned</span> <span class="keyword">int</span> period_count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pcm_config</span> <span class="title">config</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pcm</span> *<span class="title">pcm</span>;</span></span><br><span class="line">    <span class="keyword">char</span> *buffer;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> bytes_read = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;config, <span class="number">0</span>, <span class="keyword">sizeof</span>(config));</span><br><span class="line">    config.channels = channels;</span><br><span class="line">    config.rate = rate;</span><br><span class="line">    config.period_size = period_size;</span><br><span class="line">    config.period_count = period_count;</span><br><span class="line">    config.format = format;</span><br><span class="line">    config.start_threshold = <span class="number">0</span>;</span><br><span class="line">    config.stop_threshold = <span class="number">0</span>;</span><br><span class="line">    config.silence_threshold = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//打开录制节点</span></span><br><span class="line">    pcm = pcm_open(card, device, PCM_IN, &amp;config);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并读取从Kernel内核传过来的数据最终合成音频文件的过程<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;E:\android<span class="number">-7.1</span><span class="number">.2</span>_r1\external\tinyalsa\tinycap.c]</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">capture_sample</span><span class="params">(FILE *file, <span class="keyword">unsigned</span> <span class="keyword">int</span> card, <span class="keyword">unsigned</span> <span class="keyword">int</span> device,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">unsigned</span> <span class="keyword">int</span> channels, <span class="keyword">unsigned</span> <span class="keyword">int</span> rate,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">enum</span> pcm_format format, <span class="keyword">unsigned</span> <span class="keyword">int</span> period_size,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">unsigned</span> <span class="keyword">int</span> period_count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//循环读取音频数据</span></span><br><span class="line">    size = pcm_frames_to_bytes(pcm, pcm_get_buffer_size(pcm));</span><br><span class="line">    buffer = <span class="built_in">malloc</span>(size);</span><br><span class="line">        <span class="keyword">while</span> (capturing &amp;&amp; !pcm_read(pcm, buffer, size)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fwrite(buffer, <span class="number">1</span>, size, file) != size) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Error capturing sample\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        bytes_read += size;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>开始分析音频录制编码合成之旅，之后分析视频录制编码合成过程。</p><h4 id="（一）、Audio-Recorder-音频录制源码分析"><a href="#（一）、Audio-Recorder-音频录制源码分析" class="headerlink" title="（一）、Audio Recorder 音频录制源码分析"></a>（一）、Audio Recorder 音频录制源码分析</h4><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/VS-03-01-MediaRecorder-flow.png" alt="Alt text"></p><h4 id="（二）、Media-Recorder-视频录制源码分析"><a href="#（二）、Media-Recorder-视频录制源码分析" class="headerlink" title="（二）、Media Recorder 视频录制源码分析"></a>（二）、Media Recorder 视频录制源码分析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">mCamera = getCameraInstance();</span><br><span class="line">mCamera .open()</span><br><span class="line">mCamera.startPreview() </span><br><span class="line"></span><br><span class="line">      mMediaRecorder = new MediaRecorder();</span><br><span class="line">      mMediaRecorder.setCamera(mCamera);</span><br><span class="line"> </span><br><span class="line">      mMediaRecorder.setPreviewDisplay(android.view.SurfaceHolder);</span><br><span class="line">      mMediaRecorder.setAudioSource(MediaRecorder.AudioSource.CAMCORDER);</span><br><span class="line">      mMediaRecorder.setVideoSource(MediaRecorder.VideoSource.CAMERA);</span><br><span class="line"></span><br><span class="line">      mMediaRecorder.setVideoSize(videoRecordSize.width, videoRecordSize.height);</span><br><span class="line">mMediaRecorder.setProfile(CamcorderProfile.get(CamcorderProfile.QUALITY_HIGH));</span><br><span class="line">      mMediaRecorder.setOutputFile(outputFile.toString());</span><br><span class="line">      //MediaRecorder.OutputFormat.MPEG_4.</span><br><span class="line"></span><br><span class="line">      mMediaRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.AMR_NB)</span><br><span class="line">      mMediaRecorder.setVideoEncoder(MediaRecorder.VideoEncoder.MPEG_4_SP)</span><br><span class="line">      </span><br><span class="line">      mMediaRecorder.prepare();</span><br><span class="line">      mMediaRecorder.start();</span><br><span class="line"></span><br><span class="line">mMediaRecorder.stop()</span><br><span class="line">mMediaRecorder.release()</span><br><span class="line">mCamera.stopPreview()</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/VS-03-02-MediaRecorder-video-flow.png" alt="Alt text"></p><h4 id="（三）、音频Recorder编码Encoder"><a href="#（三）、音频Recorder编码Encoder" class="headerlink" title="（三）、音频Recorder编码Encoder"></a>（三）、音频Recorder编码Encoder</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">Line 3036: 07-02 17:00:07.175  8430  8479 V ACodec  : Now uninitialized</span><br><span class="line">Line 3674: 07-02 17:00:35.717   745  1949 V ACodec  : Now uninitialized</span><br><span class="line">Line 3675: 07-02 17:00:35.718   745  8649 V ACodec  : onAllocateComponent</span><br><span class="line">Line 3678: 07-02 17:00:35.721   731   921 I OMXMaster: makeComponentInstance(OMX.google.amrnb.encoder) in mediacodec process</span><br><span class="line">Line 3679: 07-02 17:00:35.742   745  8649 V ACodec  : [OMX.google.amrnb.encoder] Now Loaded</span><br><span class="line">Line 3680: 07-02 17:00:35.742   745  8649 I MediaCodec: MediaCodec will operate in async mode</span><br><span class="line">Line 3680: 07-02 17:00:35.742   745  8649 I MediaCodec: MediaCodec will operate in async mode</span><br><span class="line">Line 3681: 07-02 17:00:35.742   745  8649 V MediaCodec: Found 0 pieces of codec specific data.</span><br><span class="line">Line 3682: 07-02 17:00:35.742   745  8649 V ACodec  : onConfigureComponent</span><br><span class="line">Line 3684: 07-02 17:00:35.744   745  8649 I ACodec  : codec does not support config priority (err -2147483648)</span><br><span class="line">Line 3686: 07-02 17:00:35.751   745  8649 I ACodec  : codec does not support config priority (err -2147483648)</span><br><span class="line">Line 3687: 07-02 17:00:35.755   745  8649 V MediaCodec: [OMX.google.amrnb.encoder] configured as input format: AMessage(what = 0x00000000) = &#123;</span><br><span class="line">Line 3688: 07-02 17:00:35.755   745  8649 V MediaCodec:       string mime = &quot;audio/raw&quot;</span><br><span class="line">Line 3689: 07-02 17:00:35.755   745  8649 V MediaCodec:       int32_t channel-count = 1</span><br><span class="line">Line 3690: 07-02 17:00:35.755   745  8649 V MediaCodec:       int32_t sample-rate = 8000</span><br><span class="line">Line 3691: 07-02 17:00:35.755   745  8649 V MediaCodec:       int32_t pcm-encoding = 2</span><br><span class="line">Line 3692: 07-02 17:00:35.755   745  8649 V MediaCodec:     &#125;, output format: AMessage(what = 0x00000000) = &#123;</span><br><span class="line">Line 3693: 07-02 17:00:35.755   745  8649 V MediaCodec:       int32_t bitrate = 12200</span><br><span class="line">Line 3694: 07-02 17:00:35.755   745  8649 V MediaCodec:       int32_t max-bitrate = 12200</span><br><span class="line">Line 3695: 07-02 17:00:35.755   745  8649 V MediaCodec:       int32_t channel-count = 1</span><br><span class="line">Line 3696: 07-02 17:00:35.755   745  8649 V MediaCodec:       string mime = &quot;audio/3gpp&quot;</span><br><span class="line">Line 3697: 07-02 17:00:35.755   745  8649 V MediaCodec:       int32_t sample-rate = 8000</span><br><span class="line">Line 3698: 07-02 17:00:35.755   745  8649 V MediaCodec:     &#125;</span><br><span class="line">Line 3699: 07-02 17:00:35.757   745  8649 V ACodec  : onStart</span><br><span class="line">Line 3700: 07-02 17:00:35.758   745  8649 V ACodec  : [OMX.google.amrnb.encoder] Now Loaded-&gt;Idle</span><br><span class="line">Line 3701: 07-02 17:00:35.758   745  8649 V ACodec  : [OMX.google.amrnb.encoder] Allocating 4 buffers of size 2048/2048 (from 2048 using Invalid) on input port</span><br><span class="line">Line 3702: 07-02 17:00:35.766   745  8649 V ACodec  : [OMX.google.amrnb.encoder] Allocating 4 buffers of size 8192/8192 (from 8192 using Invalid) on output port</span><br><span class="line">Line 3703: 07-02 17:00:35.771   745  8649 V MediaCodec: input buffers allocated</span><br><span class="line">Line 3704: 07-02 17:00:35.771   745  8649 V MediaCodec: output buffers allocated</span><br><span class="line">Line 3705: 07-02 17:00:35.772   745  8646 I MediaCodecSource: MediaCodecSource (audio) starting</span><br><span class="line">    Line 3706: 07-02 17:00:35.772   745  8649 V ACodec  : [OMX.google.amrnb.encoder] Now Idle-&gt;Executing</span><br><span class="line">Line 3701: 07-02 17:00:35.758   745  8649 V ACodec  : [OMX.google.amrnb.encoder] Allocating 4 buffers of size 2048/2048 (from 2048 using Invalid) on input port</span><br><span class="line">Line 3702: 07-02 17:00:35.766   745  8649 V ACodec  : [OMX.google.amrnb.encoder] Allocating 4 buffers of size 8192/8192 (from 8192 using Invalid) on output port</span><br><span class="line">Line 3706: 07-02 17:00:35.772   745  8649 V ACodec  : [OMX.google.amrnb.encoder] Now Idle-&gt;Executing</span><br><span class="line">Line 3707: 07-02 17:00:35.773   745  8649 V ACodec  : [OMX.google.amrnb.encoder] calling fillBuffer 5</span><br><span class="line">Line 3708: 07-02 17:00:35.773   745  8649 V ACodec  : [OMX.google.amrnb.encoder] calling fillBuffer 6</span><br><span class="line">Line 3711: 07-02 17:00:35.775   745  8649 V ACodec  : [OMX.google.amrnb.encoder] calling fillBuffer 7</span><br><span class="line">Line 3715: 07-02 17:00:35.775   745  8649 V ACodec  : [OMX.google.amrnb.encoder] calling fillBuffer 8</span><br><span class="line">Line 3717: 07-02 17:00:35.776   745  8649 V ACodec  : [OMX.google.amrnb.encoder] Now Executing</span><br><span class="line">Line 3833: 07-02 17:00:35.902   745  8649 V ACodec  : [OMX.google.amrnb.encoder] calling emptyBuffer 1 w/ time 20000 us</span><br><span class="line">Line 3834: 07-02 17:00:35.904   745  8649 V ACodec  : [OMX.google.amrnb.encoder] onOMXEmptyBufferDone 1</span><br><span class="line">Line 3835: 07-02 17:00:35.907   745  8649 V ACodec  : [OMX.google.amrnb.encoder] onOMXFillBufferDone 5 time 20000 us, flags = 0x00000010</span><br><span class="line">Line 3836: 07-02 17:00:35.911   745  8649 V MediaCodec: [OMX.google.amrnb.encoder] output format changed to: AMessage(what = 0x00000000) = &#123;</span><br><span class="line">Line 3843: 07-02 17:00:35.913   745  8649 V ACodec  : [OMX.google.amrnb.encoder] calling fillBuffer 5</span><br><span class="line">Line 3844: 07-02 17:00:35.925   745  8649 V ACodec  : [OMX.google.amrnb.encoder] calling emptyBuffer 2 w/ time 40000 us</span><br><span class="line">Line 3845: 07-02 17:00:35.926   745  8649 V ACodec  : [OMX.google.amrnb.encoder] onOMXEmptyBufferDone 2</span><br><span class="line">Line 3846: 07-02 17:00:35.927   745  8649 V ACodec  : [OMX.google.amrnb.encoder] onOMXFillBufferDone 6 time 40000 us, flags = 0x00000010</span><br><span class="line">Line 3847: 07-02 17:00:35.927   745  8649 V ACodec  : [OMX.google.amrnb.encoder] calling fillBuffer 6</span><br><span class="line">Line 3848: 07-02 17:00:35.942   745  8649 V ACodec  : [OMX.google.amrnb.encoder] calling emptyBuffer 3 w/ time 60000 us</span><br><span class="line">Line 3849: 07-02 17:00:35.945   745  8649 V ACodec  : [OMX.google.amrnb.encoder] onOMXEmptyBufferDone 3</span><br><span class="line">Line 3850: 07-02 17:00:35.945   745  8649 V ACodec  : [OMX.google.amrnb.encoder] onOMXFillBufferDone 7 time 60000 us, flags = 0x00000010</span><br><span class="line">Line 3851: 07-02 17:00:35.946   745  8649 V ACodec  : [OMX.google.amrnb.encoder] calling fillBuffer 7</span><br><span class="line">Line 3852: 07-02 17:00:35.963   745  8649 V ACodec  : [OMX.google.amrnb.encoder] calling emptyBuffer 4 w/ time 80000 us</span><br><span class="line">Line 3853: 07-02 17:00:35.965   745  8649 V ACodec  : [OMX.google.amrnb.encoder] onOMXEmptyBufferDone 4</span><br><span class="line">Line 3854: 07-02 17:00:35.966   745  8649 V ACodec  : [OMX.google.amrnb.encoder] onOMXFillBufferDone 8 time 80000 us, flags = 0x00000010</span><br><span class="line">Line 3855: 07-02 17:00:35.967   745  8649 V ACodec  : [OMX.google.amrnb.encoder] calling fillBuffer 8</span><br><span class="line">Line 3856: 07-02 17:00:35.982   745  8649 V ACodec  : [OMX.google.amrnb.encoder] calling emptyBuffer 1 w/ time 100000 us</span><br><span class="line">Line 3857: 07-02 17:00:35.983   745  8649 V ACodec  : [OMX.google.amrnb.encoder] onOMXEmptyBufferDone 1</span><br><span class="line">Line 3858: 07-02 17:00:35.985   745  8649 V ACodec  : [OMX.google.amrnb.encoder] onOMXFillBufferDone 5 time 100000 us, flags = 0x00000010</span><br><span class="line">......</span><br><span class="line">Line 8217: 07-02 17:00:56.446   745  8649 V ACodec  : [OMX.google.amrnb.encoder] calling fillBuffer 8</span><br><span class="line">Line 8218: 07-02 17:00:56.462   745  8649 V ACodec  : [OMX.google.amrnb.encoder] calling emptyBuffer 1 w/ time 20580000 us</span><br><span class="line">Line 8219: 07-02 17:00:56.464   745  8649 V ACodec  : [OMX.google.amrnb.encoder] onOMXEmptyBufferDone 1</span><br><span class="line">Line 8220: 07-02 17:00:56.466   745  8649 V ACodec  : [OMX.google.amrnb.encoder] onOMXFillBufferDone 5 time 20580000 us, flags = 0x00000010</span><br><span class="line">Line 8221: 07-02 17:00:56.467   745  8649 V ACodec  : [OMX.google.amrnb.encoder] calling fillBuffer 5</span><br><span class="line">Line 8222: 07-02 17:00:56.468   745  8646 I MediaCodecSource: encoder (audio) stopping</span><br><span class="line">Line 8223: 07-02 17:00:56.483   745  8649 V ACodec  : [OMX.google.amrnb.encoder] Now Executing-&gt;Idle</span><br><span class="line">Line 8224: 07-02 17:00:56.484   745  8649 V ACodec  : [OMX.google.amrnb.encoder] onOMXFillBufferDone 5 time 20580000 us, flags = 0x00000000</span><br><span class="line">Line 8225: 07-02 17:00:56.484   745  8649 V ACodec  : [OMX.google.amrnb.encoder] onOMXFillBufferDone 6 time 20520000 us, flags = 0x00000000</span><br><span class="line">Line 8226: 07-02 17:00:56.484   745  8649 V ACodec  : [OMX.google.amrnb.encoder] onOMXFillBufferDone 7 time 20540000 us, flags = 0x00000000</span><br><span class="line">Line 8227: 07-02 17:00:56.484   745  8649 V ACodec  : [OMX.google.amrnb.encoder] onOMXFillBufferDone 8 time 20560000 us, flags = 0x00000000</span><br><span class="line">Line 8228: 07-02 17:00:56.496   745  8649 V ACodec  : [OMX.google.amrnb.encoder] Now Idle-&gt;Loaded</span><br><span class="line">Line 8229: 07-02 17:00:56.496   745  8649 V ACodec  : [OMX.google.amrnb.encoder] Now Loaded</span><br><span class="line">Line 8231: 07-02 17:00:56.499   745  8646 I MediaCodecSource: encoder (audio) stopped</span><br></pre></td></tr></table></figure><h4 id="（四）、视频Recorder编码Encoder"><a href="#（四）、视频Recorder编码Encoder" class="headerlink" title="（四）、视频Recorder编码Encoder"></a>（四）、视频Recorder编码Encoder</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">44.947</span>  <span class="number">6238</span>  <span class="number">6238</span> V CAM_VideoModule: startVideoRecording</span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">44.974</span>  <span class="number">6238</span>  <span class="number">6238</span> D CameraStorage: External storage state=mounted</span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">44.995</span>  <span class="number">6238</span>  <span class="number">6238</span> D CameraStorage: External storage state=mounted</span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">44.998</span>  <span class="number">6238</span>  <span class="number">6238</span> V CAM_VideoModule: initializeRecorder</span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.003</span>   <span class="number">741</span>  <span class="number">1966</span> V MediaPlayerService: Create <span class="keyword">new</span> media recorder client from pid <span class="number">6238</span></span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.009</span>  <span class="number">6238</span>  <span class="number">6238</span> I CAM_VideoModule: NOTE: hfr = off : hsr = off</span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.024</span>   <span class="number">802</span>  <span class="number">6282</span> E mm-camera: &lt;ISP   &gt;&lt;ERROR&gt; <span class="number">378</span>: tintless40_algo_process_be: failed: update_func rc <span class="number">-4</span></span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.024</span>   <span class="number">802</span>  <span class="number">6282</span> E mm-camera: &lt;ISP   &gt;&lt;ERROR&gt; <span class="number">851</span>: tintless40_algo_execute: failed: tintless40_trigger_algo</span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.024</span>   <span class="number">802</span>  <span class="number">6282</span> E mm-camera: &lt;ISP   &gt;&lt;ERROR&gt; <span class="number">98</span>: isp_algo_execute_internal_algo: failed to run algo tintless</span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.024</span>   <span class="number">802</span>  <span class="number">6282</span> E mm-camera: &lt;ISP   &gt;&lt;ERROR&gt; <span class="number">710</span>: isp_parser_thread_func: failed: isp_parser_process</span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.031</span>  <span class="number">6238</span>  <span class="number">6238</span> D LocationManager: No location received yet.</span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.033</span>  <span class="number">6238</span>  <span class="number">6238</span> D LocationManager: No location received yet.</span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.033</span>  <span class="number">6238</span>  <span class="number">6238</span> V CAM_VideoModule: New video filename: /storage/emulated/<span class="number">0</span>/DCIM/Camera/VID_20180703_114345.mp4</span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.059</span>  <span class="number">1391</span>  <span class="number">2526</span> I MediaFocusControl:  AudioFocus  requestAudioFocus() from uid/pid <span class="number">10025</span>/<span class="number">6238</span> clientId=android.media.AudioManager@<span class="number">11f</span>939d req=<span class="number">2</span> flags=<span class="number">0x0</span></span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.062</span>  <span class="number">4966</span>  <span class="number">4966</span> D AudioManager: AudioManager dispatching onAudioFocusChange(<span class="number">-2</span>) <span class="keyword">for</span> android.media.AudioManager@e6fb066com.android.music.MediaPlaybackService$<span class="number">4</span>@<span class="number">2315f</span>a7</span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.063</span>  <span class="number">4966</span>  <span class="number">4966</span> V MediaPlaybackService: AudioFocus: received AUDIOFOCUS_LOSS_TRANSIENT</span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.079</span>   <span class="number">726</span>  <span class="number">6266</span> E QCamera : &lt;HAL&gt;&lt;ERROR&gt; <span class="keyword">status_t</span> qcamera::QCameraParameters::setSkinBeautify(<span class="keyword">const</span> qcamera::QCameraParameters &amp;): <span class="number">15184</span>: gpw <span class="keyword">status_t</span> qcamera::QCameraParameters::setSkinBeautify(<span class="keyword">const</span> qcamera::QCameraParameters &amp;): str=off , prev_str=off</span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.079</span>   <span class="number">726</span>  <span class="number">6266</span> E QCamera : &lt;HAL&gt;&lt;ERROR&gt; <span class="keyword">int32_t</span> qcamera::QCameraParameters::setAjustLevel(<span class="keyword">const</span> qcamera::QCameraParameters &amp;): <span class="number">15302</span>: gpw   <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span></span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.079</span>   <span class="number">726</span>  <span class="number">6266</span> E QCamera : &lt;HAL&gt;&lt;ERROR&gt; <span class="keyword">int32_t</span> qcamera::QCameraParameters::setAjustLevel(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>): <span class="number">15232</span>: ggw3 <span class="number">-1</span> <span class="number">-1</span>  </span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.091</span>   <span class="number">726</span>  <span class="number">2209</span> E CameraClient: setVideoBufferMode: <span class="number">535</span>: videoBufferMode <span class="number">2</span> is <span class="keyword">not</span> supported.</span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.100</span>   <span class="number">802</span>  <span class="number">6282</span> E mm-camera: &lt;ISP   &gt;&lt;ERROR&gt; <span class="number">378</span>: tintless40_algo_process_be: failed: update_func rc <span class="number">-4</span></span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.101</span>   <span class="number">802</span>  <span class="number">6282</span> E mm-camera: &lt;ISP   &gt;&lt;ERROR&gt; <span class="number">851</span>: tintless40_algo_execute: failed: tintless40_trigger_algo</span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.101</span>   <span class="number">802</span>  <span class="number">6282</span> E mm-camera: &lt;ISP   &gt;&lt;ERROR&gt; <span class="number">98</span>: isp_algo_execute_internal_algo: failed to run algo tintless</span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.101</span>   <span class="number">802</span>  <span class="number">6282</span> E mm-camera: &lt;ISP   &gt;&lt;ERROR&gt; <span class="number">710</span>: isp_parser_thread_func: failed: isp_parser_process</span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.105</span>   <span class="number">802</span>  <span class="number">6296</span> E mm-camera: &lt;IMGLIB&gt;&lt;ERROR&gt; <span class="number">318</span>: faceproc_comp_set_param: Error param=<span class="number">523</span></span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.111</span>   <span class="number">726</span>  <span class="number">6266</span> E QCamera : &lt;HAL&gt;&lt;ERROR&gt; <span class="keyword">status_t</span> qcamera::QCameraParameters::setSkinBeautify(<span class="keyword">const</span> qcamera::QCameraParameters &amp;): <span class="number">15184</span>: gpw <span class="keyword">status_t</span> qcamera::QCameraParameters::setSkinBeautify(<span class="keyword">const</span> qcamera::QCameraParameters &amp;): str=off , prev_str=off</span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.111</span>   <span class="number">726</span>  <span class="number">6266</span> E QCamera : &lt;HAL&gt;&lt;ERROR&gt; <span class="keyword">int32_t</span> qcamera::QCameraParameters::setAjustLevel(<span class="keyword">const</span> qcamera::QCameraParameters &amp;): <span class="number">15302</span>: gpw   <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span></span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.111</span>   <span class="number">726</span>  <span class="number">6266</span> E QCamera : &lt;HAL&gt;&lt;ERROR&gt; <span class="keyword">int32_t</span> qcamera::QCameraParameters::setAjustLevel(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>): <span class="number">15232</span>: ggw3 <span class="number">-1</span> <span class="number">-1</span>  </span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.121</span>   <span class="number">741</span>  <span class="number">6349</span> I MediaPlayerService: MediaPlayerService::getOMX</span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.122</span>   <span class="number">741</span>  <span class="number">6349</span> I OMXClient: MuxOMX ctor</span><br><span class="line"></span><br><span class="line">Line <span class="number">5362</span>: <span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">41.712</span>  <span class="number">6238</span>  <span class="number">6238</span> V CAM_VideoModule: Video Encoder selected = <span class="number">2</span></span><br><span class="line">Line <span class="number">5363</span>: <span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">41.712</span>  <span class="number">6238</span>  <span class="number">6238</span> V CAM_VideoModule: Audio Encoder selected = <span class="number">3</span></span><br><span class="line">Line <span class="number">5449</span>: <span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">41.944</span>  <span class="number">6238</span>  <span class="number">6238</span> V CAM_VideoModule: Video Encoder selected = <span class="number">2</span></span><br><span class="line">Line <span class="number">5450</span>: <span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">41.944</span>  <span class="number">6238</span>  <span class="number">6238</span> V CAM_VideoModule: Audio Encoder selected = <span class="number">3</span></span><br><span class="line">Line <span class="number">6011</span>: <span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.123</span>   <span class="number">732</span>  <span class="number">2029</span> I OMXMaster: makeComponentInstance(OMX.qcom.video.encoder.avc) in mediacodec process</span><br><span class="line">Line <span class="number">6014</span>: <span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.170</span>   <span class="number">732</span>  <span class="number">2029</span> I OMX-VENC: Component_init : OMX.qcom.video.encoder.avc : <span class="keyword">return</span> = <span class="number">0x0</span></span><br><span class="line">Line <span class="number">6017</span>: <span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.180</span>   <span class="number">732</span>  <span class="number">2168</span> E OMXNodeInstance: getParameter(<span class="number">2</span>dc0040:qcom.encoder.avc, ParamConsumerUsageBits(<span class="number">0x6f800004</span>)) ERROR: UnsupportedIndex(<span class="number">0x8000101a</span>)</span><br><span class="line">Line <span class="number">6019</span>: <span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.181</span>   <span class="number">732</span>  <span class="number">1863</span> W OMXNodeInstance: [<span class="number">2</span>dc0040:qcom.encoder.avc] component does <span class="keyword">not</span> support metadata mode; <span class="keyword">using</span> fallback</span><br><span class="line">Line <span class="number">6020</span>: <span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.181</span>   <span class="number">741</span>  <span class="number">6349</span> E ACodec  : [OMX.qcom.video.encoder.avc] storeMetaDataInBuffers (output) failed w/ err <span class="number">-1010</span></span><br><span class="line">Line <span class="number">6021</span>: <span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.182</span>   <span class="number">741</span>  <span class="number">6349</span> I ExtendedACodec: setupVideoEncoder()</span><br><span class="line">Line <span class="number">6026</span>: <span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.231</span>   <span class="number">741</span>  <span class="number">6349</span> I ACodec  : setupAVCEncoderParameters with [profile: Baseline] [level: Level1]</span><br><span class="line">Line <span class="number">6028</span>: <span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.241</span>   <span class="number">732</span>  <span class="number">1863</span> E OMXNodeInstance: getConfig(<span class="number">2</span>dc0040:qcom.encoder.avc, ??(<span class="number">0x7f000062</span>)) ERROR: UnsupportedSetting(<span class="number">0x80001019</span>)</span><br><span class="line">Line <span class="number">6029</span>: <span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.245</span>   <span class="number">741</span>  <span class="number">6349</span> I ACodec  : [OMX.qcom.video.encoder.avc] cannot encode HDR <span class="keyword">static</span> metadata. Ignoring.</span><br><span class="line">Line <span class="number">6030</span>: <span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.245</span>   <span class="number">741</span>  <span class="number">6349</span> I ACodec  : setupVideoEncoder succeeded</span><br><span class="line">Line 6031: 07-03 11:43:45.245   741  6349 I ExtendedACodec: [OMX.qcom.video.encoder.avc] configure, AMessage : AMessage(what = 'conf', target = 75) = &#123;</span><br><span class="line">Line <span class="number">6044</span>: <span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.245</span>   <span class="number">741</span>  <span class="number">6349</span> I ExtendedACodec:   <span class="keyword">int32_t</span> encoder = <span class="number">1</span></span><br><span class="line">Line <span class="number">6174</span>: <span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.455</span>   <span class="number">732</span>  <span class="number">2169</span> I OMXMaster: makeComponentInstance(OMX.qcom.audio.encoder.aac) in mediacodec process</span><br><span class="line">Line <span class="number">6180</span>: <span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.460</span>   <span class="number">732</span>  <span class="number">2169</span> E QC_AACENC:  component init: role = OMX.qcom.audio.encoder.aac</span><br><span class="line">Line <span class="number">6182</span>: <span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.491</span>   <span class="number">732</span>   <span class="number">732</span> E OMXNodeInstance: setConfig(<span class="number">2</span>dc0041:qcom.encoder.aac, ConfigPriority(<span class="number">0x6f800002</span>)) ERROR: UnsupportedIndex(<span class="number">0x8000101a</span>)</span><br><span class="line">Line <span class="number">6184</span>: <span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.502</span>   <span class="number">732</span>  <span class="number">2169</span> E OMXNodeInstance: setConfig(<span class="number">2</span>dc0041:qcom.encoder.aac, ConfigPriority(<span class="number">0x6f800002</span>)) ERROR: UnsupportedIndex(<span class="number">0x8000101a</span>)</span><br><span class="line">Line <span class="number">6193</span>: <span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.537</span>   <span class="number">741</span>  <span class="number">6363</span> I CameraSource: Using encoder format: <span class="number">0x22</span></span><br><span class="line">Line <span class="number">6194</span>: <span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.537</span>   <span class="number">741</span>  <span class="number">6363</span> I CameraSource: Using encoder data space: <span class="number">0x104</span></span><br><span class="line">Line <span class="number">7431</span>: <span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">56.472</span>   <span class="number">741</span>  <span class="number">6347</span> I MediaCodecSource: encoder (video) stopping</span><br><span class="line">Line <span class="number">7456</span>: <span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">56.611</span>   <span class="number">741</span>  <span class="number">6347</span> I MediaCodecSource: encoder (video) stopped</span><br><span class="line">Line <span class="number">7494</span>: <span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">56.677</span>   <span class="number">741</span>  <span class="number">6347</span> I MediaCodecSource: encoder (audio) stopping</span><br><span class="line">Line <span class="number">7534</span>: <span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">56.800</span>   <span class="number">741</span>  <span class="number">6347</span> I MediaCodecSource: encoder (audio) stopped</span><br></pre></td></tr></table></figure><h4 id="（五）、音视频混合MediaMuxer源码分析"><a href="#（五）、音视频混合MediaMuxer源码分析" class="headerlink" title="（五）、音视频混合MediaMuxer源码分析"></a>（五）、音视频混合MediaMuxer源码分析</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;MediaWriter&gt; mWriter;</span><br><span class="line">[-&gt;\android\frameworks\av\media\libstagefright\MediaMuxer.cpp]</span><br><span class="line"><span class="keyword">status_t</span> MediaMuxer::start() &#123;</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(mMuxerLock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (mState == INITIALIZED) &#123;</span><br><span class="line">        mState = STARTED;</span><br><span class="line">        mFileMeta-&gt;setInt32(kKeyRealTimeRecording, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> mWriter-&gt;start(mFileMeta.get());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ALOGE(<span class="string">"start() is called in invalid state %d"</span>, mState);</span><br><span class="line">        <span class="keyword">return</span> INVALID_OPERATION;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到具体还是调用的MediaWriter实现的。我们来分析具体实例：MPEG4Writer.cpp，即MP4文件的格式封装过程。</p><p>1)       录制开始时，写入文件头部。</p><p>2)       录制进行时，实时写入音视频轨迹的数据块。</p><p>3)       录制结束时，写入索引信息并更新头部参数。</p><p>  索引负责描述音视频轨迹的特征，会随着音视频轨迹的存储而变化，所以通常做法会将录像文件索引信息放在音视频轨迹流后面，在媒体流数据写完（录像结束）后才能写入。可以看到，存放音视频数据的mdat box是位于第二位的，而负责检索音视频的moov box是位于最后的，这与通常的MP4封装的排列顺序不同，当然这是为了符合录制而产生的结果。因为 moov的大小是随着 mdat 变化的，而我们录制视频的时间预先是不知道的，所以需要先将mdat 数据写入，最后再写入moov，完成封装。 </p><p>  现有Android系统上录像都是录制是MP4或3GP格式，底层就是使用MPEG4Writer组合器类来完成的，它将编码后的音视频轨迹按照MPEG4规范进行封装，填入各个参数，就组合成完整的MP4格式文件。MPEG4Writer的组合功能主要由两种线程完成，一种是负责音视频数据写入封装文件的写线程（WriterThread），一种是音视频数据读取处理的轨迹线程（TrackThread）。轨迹线程一般有两个：视频轨迹数据读取线程和音频轨迹数据读取线程，而写线程只有一个，负责将轨迹线程中打包成Chunk的数据写入封装文件。</p><p>  如下图所示，轨迹线程是以帧为单位获取数据帧（Sample），并将每帧中的信息及系统环境信息提取汇总存储在内存的trak表中，其中需要维持的信息有Chunk写入文件的偏移地址Stco（Chunk Offset）、Sample与Chunk的映射关系Stsc（Sample-to-Chunk）、关键帧Stss（Sync Sample）、每一帧的持续时间Stts（Time-to-Sample）等，这些信息是跟每一帧的信息密切相关的，由图可以看出trak表由各自的线程维护，当录像结束时trak表会就会写入封装文件。而每一帧的数据流会先存入一个链表缓存中，当帧的数量达到一定值时，轨迹线程会将这些帧数据打包成块（Chunk）并通知写线程写入到封装文件。写线程接到Chunk已准备好的通知后就马上搜索Chunk链表（链表个数与轨迹线程个数相关，一般有两个，音视频轨迹线程各有一个），将找到的第一个Chunk后便写入封装文件，并会将写入的偏移地址更新到相应的trak表的Stco项（但trak表中其它数据是由轨迹线程更新）。音视频的Chunk数据是存储于同一mdat box中，按添加到Chunk链表时间先后顺序排列。等到录像结束时，录像应用会调用MPEG4Writer的stop方法，此时就会将音视频的trak表分别写入moov。</p><p>  <img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/VS-03-03-MPEG4Writer.png" alt="Alt text"></p><p> 其实看完上面的内容，应该对Android录制视频过程中，录制的视频的封装过程有一个大体了解，我们平时所说的视频后缀名.mp4/.mkv等等就是视频封装的各种格式。<br>先看看构造函数：在这里将实现一些参数的初始化，fd是传进来的录制文件的文件描述符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\android\frameworks\av\media\libstagefright\MPEG4Writer.cpp]</span><br><span class="line">MPEG4Writer::MPEG4Writer(<span class="keyword">int</span> fd)</span><br><span class="line">    : mFd(dup(fd)),</span><br><span class="line">      mInitCheck(mFd &lt; <span class="number">0</span>? NO_INIT: OK),</span><br><span class="line">      mIsRealTimeRecording(<span class="literal">true</span>),</span><br><span class="line">      mUse4ByteNalLength(<span class="literal">true</span>),</span><br><span class="line">      mUse32BitOffset(<span class="literal">true</span>),</span><br><span class="line">      mIsFileSizeLimitExplicitlyRequested(<span class="literal">false</span>),</span><br><span class="line">      mPaused(<span class="literal">false</span>),</span><br><span class="line">      mStarted(<span class="literal">false</span>),</span><br><span class="line">      mWriterThreadStarted(<span class="literal">false</span>),</span><br><span class="line">      mOffset(<span class="number">0</span>),</span><br><span class="line">      mMdatOffset(<span class="number">0</span>),</span><br><span class="line">      mMoovBoxBuffer(<span class="literal">NULL</span>),</span><br><span class="line">      mMoovBoxBufferOffset(<span class="number">0</span>),</span><br><span class="line">      mWriteMoovBoxToMemory(<span class="literal">false</span>),</span><br><span class="line">      mFreeBoxOffset(<span class="number">0</span>),</span><br><span class="line">      mStreamableFile(<span class="literal">false</span>),</span><br><span class="line">      mEstimatedMoovBoxSize(<span class="number">0</span>),</span><br><span class="line">      mMoovExtraSize(<span class="number">0</span>),</span><br><span class="line">      mInterleaveDurationUs(<span class="number">1000000</span>),</span><br><span class="line">      mTimeScale(<span class="number">-1</span>),</span><br><span class="line">      mStartTimestampUs(<span class="number">-1l</span>l),</span><br><span class="line">      mLatitudex10000(<span class="number">0</span>),</span><br><span class="line">      mLongitudex10000(<span class="number">0</span>),</span><br><span class="line">      mAreGeoTagsAvailable(<span class="literal">false</span>),</span><br><span class="line">      mStartTimeOffsetMs(<span class="number">-1</span>),</span><br><span class="line">      mMetaKeys(<span class="keyword">new</span> AMessage()),</span><br><span class="line">      mIsAudioAMR(<span class="literal">false</span>) &#123;</span><br><span class="line">    addDeviceMeta();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Verify mFd is seekable</span></span><br><span class="line">    <span class="keyword">off64_t</span> off = lseek64(mFd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">    <span class="keyword">if</span> (off &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"cannot seek mFd: %s (%d)"</span>, strerror(errno), errno);</span><br><span class="line">        release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着从 MPEG4Writer.cpp 的start()函数开始：<br>在start部分，我们看到在这一部分，writeFtypBox(param) 将实现录制文件文件头部信息的相关信息的写入操作；startWriterThread() 开启封装视频文件的写线程；startTracks(param) 开启视频数据的读线程，也就是前面文件部分所说的轨迹线程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">status_t MPEG4Writer::start(MetaData *param) &#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    if (mStarted) &#123;</span><br><span class="line">        if (mPaused) &#123;</span><br><span class="line">            mPaused = false;</span><br><span class="line">            return startTracks(param);</span><br><span class="line">        &#125;</span><br><span class="line">        return OK;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    mWriteMoovBoxToMemory = false;</span><br><span class="line">    mMoovBoxBuffer = NULL;</span><br><span class="line">    mMoovBoxBufferOffset = 0;</span><br><span class="line"></span><br><span class="line">    writeFtypBox(param);</span><br><span class="line"></span><br><span class="line">    mFreeBoxOffset = mOffset;</span><br><span class="line"></span><br><span class="line">    if (mEstimatedMoovBoxSize == 0) &#123;</span><br><span class="line">        int32_t bitRate = -1;</span><br><span class="line">        if (param) &#123;</span><br><span class="line">            param-&gt;findInt32(kKeyBitRate, &amp;bitRate);</span><br><span class="line">        &#125;</span><br><span class="line">        mEstimatedMoovBoxSize = estimateMoovBoxSize(bitRate);</span><br><span class="line">    &#125;</span><br><span class="line">    CHECK_GE(mEstimatedMoovBoxSize, 8);</span><br><span class="line">    if (mStreamableFile) &#123;</span><br><span class="line">        // Reserve a &apos;free&apos; box only for streamable file</span><br><span class="line">        lseek64(mFd, mFreeBoxOffset, SEEK_SET);</span><br><span class="line">        writeInt32(mEstimatedMoovBoxSize);</span><br><span class="line">        write(&quot;free&quot;, 4);</span><br><span class="line">        mMdatOffset = mFreeBoxOffset + mEstimatedMoovBoxSize;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mMdatOffset = mOffset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mOffset = mMdatOffset;</span><br><span class="line">    lseek64(mFd, mMdatOffset, SEEK_SET);</span><br><span class="line">   ......</span><br><span class="line"></span><br><span class="line">    status_t err = startWriterThread();</span><br><span class="line">   ......</span><br><span class="line"></span><br><span class="line">    err = startTracks(param);</span><br><span class="line">   ......</span><br><span class="line">    mStarted = true;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  继续看下 startWriterThread（）部分，在startWriterThread（）函数中，将真正建立新的子线程，并在子线程中执行ThreadWrappe函数中的操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> MPEG4Writer::startWriterThread() &#123;</span><br><span class="line">    ALOGV(<span class="string">"startWriterThread"</span>);</span><br><span class="line"></span><br><span class="line">    mDone = <span class="literal">false</span>;</span><br><span class="line">    mIsFirstChunk = <span class="literal">true</span>;</span><br><span class="line">    mDriftTimeUs = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (List&lt;Track *&gt;::iterator it = mTracks.begin();</span><br><span class="line">         it != mTracks.end(); ++it) &#123;</span><br><span class="line">        ChunkInfo info;</span><br><span class="line">        info.mTrack = *it;</span><br><span class="line">        info.mPrevChunkTimestampUs = <span class="number">0</span>;</span><br><span class="line">        info.mMaxInterChunkDurUs = <span class="number">0</span>;</span><br><span class="line">        mChunkInfos.push_back(info);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line">    pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE);</span><br><span class="line">    pthread_create(&amp;mThread, &amp;attr, ThreadWrapper, <span class="keyword">this</span>);</span><br><span class="line">    pthread_attr_destroy(&amp;attr);</span><br><span class="line">    mWriterThreadStarted = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着继续看 ThreadWrapper（）函数,在这里new 了一个MPEGWriter对象，真正的操作在threadFunc()中体现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *MPEG4Writer::ThreadWrapper(<span class="keyword">void</span> *me) &#123;</span><br><span class="line">    ALOGV(<span class="string">"ThreadWrapper: %p"</span>, me);</span><br><span class="line">    MPEG4Writer *writer = <span class="keyword">static_cast</span>&lt;MPEG4Writer *&gt;(me);</span><br><span class="line">    writer-&gt;threadFunc();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面看下threadFun()。在这个函数中，将根据变量mDone 进行while循环，一直检测是否有数据块Chunk可写。轨迹线程是一直将读数据的数据往buffer中写入，buffer到了一定量后，就是chunk,这时就会通过信号量 mChunkReadyCondition来通知封装文件的写线程去检测链表，然后将检索到的Chunk数据写入文件的数据区，当然写之前，肯定会去判断下是否真的有数据可写。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MPEG4Writer::threadFunc() &#123;</span><br><span class="line">    ALOGV(<span class="string">"threadFunc"</span>);</span><br><span class="line"></span><br><span class="line">    prctl(PR_SET_NAME, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="string">"MPEG4Writer"</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(mLock)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (!mDone) &#123;</span><br><span class="line">        Chunk chunk;</span><br><span class="line">        <span class="keyword">bool</span> chunkFound = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!mDone &amp;&amp; !(chunkFound = findChunkToWrite(&amp;chunk))) &#123;</span><br><span class="line">            mChunkReadyCondition.wait(mLock);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (chunkFound) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mIsRealTimeRecording) &#123;</span><br><span class="line">                mLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            writeChunkToFile(&amp;chunk);</span><br><span class="line">            <span class="keyword">if</span> (mIsRealTimeRecording) &#123;</span><br><span class="line">                mLock.lock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    writeAllChunks();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 下面看下writerChunkToFile(&amp;chunk);轨迹线程读数据时是以数据帧Sample为单位，所以这里将Chunk写入封装文件，也是以Sample为单位，遍历整个链表，将数据写入封装文件，真正的写入操作是addSamole_l(*it);</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MPEG4Writer::writeAllChunks() &#123;</span><br><span class="line">    ALOGV(<span class="string">"writeAllChunks"</span>);</span><br><span class="line">    <span class="keyword">size_t</span> outstandingChunks = <span class="number">0</span>;</span><br><span class="line">    Chunk chunk;</span><br><span class="line">    <span class="keyword">while</span> (findChunkToWrite(&amp;chunk)) &#123;</span><br><span class="line">        writeChunkToFile(&amp;chunk);</span><br><span class="line">        ++outstandingChunks;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sendSessionSummary();</span><br><span class="line"></span><br><span class="line">    mChunkInfos.clear();</span><br><span class="line">    ALOGD(<span class="string">"%zu chunks are written in the last batch"</span>, outstandingChunks);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MPEG4Writer::writeChunkToFile(Chunk* chunk) &#123;</span><br><span class="line">    ALOGV(<span class="string">"writeChunkToFile: %"</span> PRId64 <span class="string">" from %s track"</span>,</span><br><span class="line">        chunk-&gt;mTimeStampUs, chunk-&gt;mTrack-&gt;isAudio()? <span class="string">"audio"</span>: <span class="string">"video"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int32_t</span> isFirstSample = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!chunk-&gt;mSamples.empty()) &#123;</span><br><span class="line">        List&lt;MediaBuffer *&gt;::iterator it = chunk-&gt;mSamples.begin();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">off64_t</span> offset = (chunk-&gt;mTrack-&gt;isAvc() || chunk-&gt;mTrack-&gt;isHevc())</span><br><span class="line">                                ? addMultipleLengthPrefixedSamples_l(*it)</span><br><span class="line">                                : addSample_l(*it);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isFirstSample) &#123;</span><br><span class="line">            chunk-&gt;mTrack-&gt;addChunkOffset(offset);</span><br><span class="line">            isFirstSample = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        (*it)-&gt;release();</span><br><span class="line">        (*it) = <span class="literal">NULL</span>;</span><br><span class="line">        chunk-&gt;mSamples.erase(it);</span><br><span class="line">    &#125;</span><br><span class="line">    chunk-&gt;mSamples.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  下面看下addSamole_l(*it) 函数，wirte写入操作，mFd 是上层设置录制的文件路径传下来的文件描述符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">off64_t</span> MPEG4Writer::addSample_l(MediaBuffer *buffer) &#123;</span><br><span class="line">    <span class="keyword">off64_t</span> old_offset = mOffset;</span><br><span class="line"></span><br><span class="line">    ::write(mFd,</span><br><span class="line">          (<span class="keyword">const</span> <span class="keyword">uint8_t</span> *)buffer-&gt;data() + buffer-&gt;range_offset(),</span><br><span class="line">          buffer-&gt;range_length());</span><br><span class="line"></span><br><span class="line">    mOffset += buffer-&gt;range_length();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> old_offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  到此，封装文件的写入线程的操作大体走完，下面看轨迹线程的操作。</p><hr><p>   startTracks(param) 轨迹线程的开启。文件的录制过程中是有2条轨迹线程，一个是视频的轨迹线程，另一条则是音频的轨迹线程，在starTrack（param）中是在for 循环中start了两条轨迹线程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> MPEG4Writer::startTracks(MetaData *params) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mTracks.empty()) &#123;</span><br><span class="line">        ALOGE(<span class="string">"No source added"</span>);</span><br><span class="line">        <span class="keyword">return</span> INVALID_OPERATION;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (List&lt;Track *&gt;::iterator it = mTracks.begin();</span><br><span class="line">         it != mTracks.end(); ++it) &#123;</span><br><span class="line">        <span class="keyword">status_t</span> err = (*it)-&gt;start(params);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">            <span class="keyword">for</span> (List&lt;Track *&gt;::iterator it2 = mTracks.begin();</span><br><span class="line">                 it2 != it; ++it2) &#123;</span><br><span class="line">                (*it2)-&gt;stop();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（<em>it)-&gt;start(params) 将会执行status_t MPEG4Writer::Track::start(MetaData </em>params) {} 。在这边也是同样新建子线程，在子线程中执行轨迹线程的相应操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> MPEG4Writer::Track::start(MetaData *params) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int64_t</span> startTimeUs;</span><br><span class="line">    ......</span><br><span class="line">    mStartTimeRealUs = startTimeUs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int32_t</span> rotationDegrees;</span><br><span class="line">    ......</span><br><span class="line">    initTrackingProgressStatus(params);</span><br><span class="line"></span><br><span class="line">    sp&lt;MetaData&gt; meta = <span class="keyword">new</span> MetaData;</span><br><span class="line">    <span class="keyword">if</span> (mOwner-&gt;isRealTimeRecording() &amp;&amp; mOwner-&gt;numTracks() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int64_t</span> startTimeOffsetUs = mOwner-&gt;getStartTimeOffsetMs() * <span class="number">1000L</span>L;</span><br><span class="line">        <span class="keyword">if</span> (startTimeOffsetUs &lt; <span class="number">0</span>) &#123;  <span class="comment">// Start time offset was not set</span></span><br><span class="line">            startTimeOffsetUs = kInitialDelayTimeUs;</span><br><span class="line">        &#125;</span><br><span class="line">        startTimeUs += startTimeOffsetUs;</span><br><span class="line">        ALOGI(<span class="string">"Start time offset: %"</span> PRId64 <span class="string">" us"</span>, startTimeOffsetUs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    meta-&gt;setInt64(kKeyTime, startTimeUs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err = mSource-&gt;start(meta.get());</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line">    pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE);</span><br><span class="line"></span><br><span class="line">    mDone = <span class="literal">false</span>;</span><br><span class="line">    mStarted = <span class="literal">true</span>;</span><br><span class="line">    mTrackDurationUs = <span class="number">0</span>;</span><br><span class="line">    mReachedEOS = <span class="literal">false</span>;</span><br><span class="line">    mEstimatedTrackSizeBytes = <span class="number">0</span>;</span><br><span class="line">    mMdatSizeBytes = <span class="number">0</span>;</span><br><span class="line">    mMaxChunkDurationUs = <span class="number">0</span>;</span><br><span class="line">    mLastDecodingTimeUs = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;mThread, &amp;attr, ThreadWrapper, <span class="keyword">this</span>);</span><br><span class="line">    pthread_attr_destroy(&amp;attr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面看下上面ThreadWrapper函数,真正的操作又是放到了threadEntry()中去执行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *MPEG4Writer::Track::ThreadWrapper(<span class="keyword">void</span> *me) &#123;</span><br><span class="line"> </span><br><span class="line">    Track *track = <span class="keyword">static_cast</span>&lt;Track *&gt;(me);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">status_t</span> err = track-&gt;threadEntry();</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *) err;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">status_t</span> MPEG4Writer::Track::threadEntry() &#123;</span><br><span class="line">    <span class="keyword">int32_t</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int64_t</span> interleaveDurationUs = mOwner-&gt;interleaveDuration();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> hasMultipleTracks = (mOwner-&gt;numTracks() &gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int64_t</span> chunkTimestampUs = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int32_t</span> nChunks = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int32_t</span> nActualFrames = <span class="number">0</span>;        <span class="comment">// frames containing non-CSD data (non-0 length)</span></span><br><span class="line">    <span class="keyword">int32_t</span> nZeroLengthFrames = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int64_t</span> lastTimestampUs = <span class="number">0</span>;      <span class="comment">// Previous sample time stamp</span></span><br><span class="line">    <span class="keyword">int64_t</span> lastDurationUs = <span class="number">0</span>;       <span class="comment">// Between the previous two samples</span></span><br><span class="line">    <span class="keyword">int64_t</span> currDurationTicks = <span class="number">0</span>;    <span class="comment">// Timescale based ticks</span></span><br><span class="line">    <span class="keyword">int64_t</span> lastDurationTicks = <span class="number">0</span>;    <span class="comment">// Timescale based ticks</span></span><br><span class="line">    <span class="keyword">int32_t</span> sampleCount = <span class="number">1</span>;          <span class="comment">// Sample count in the current stts table entry</span></span><br><span class="line">    <span class="keyword">uint32_t</span> previousSampleSize = <span class="number">0</span>;  <span class="comment">// Size of the previous sample</span></span><br><span class="line">    <span class="keyword">int64_t</span> previousPausedDurationUs = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int64_t</span> timestampUs = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int64_t</span> cttsOffsetTimeUs = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int64_t</span> currCttsOffsetTimeTicks = <span class="number">0</span>;   <span class="comment">// Timescale based ticks</span></span><br><span class="line">    <span class="keyword">int64_t</span> lastCttsOffsetTimeTicks = <span class="number">-1</span>;  <span class="comment">// Timescale based ticks</span></span><br><span class="line">    <span class="keyword">int32_t</span> cttsSampleCount = <span class="number">0</span>;           <span class="comment">// Sample count in the current ctts table entry</span></span><br><span class="line">    <span class="keyword">uint32_t</span> lastSamplesPerChunk = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mIsAudio) &#123;</span><br><span class="line">        prctl(PR_SET_NAME, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="string">"AudioTrackEncoding"</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prctl(PR_SET_NAME, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="string">"VideoTrackEncoding"</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mOwner-&gt;isRealTimeRecording()) &#123;</span><br><span class="line">        androidSetThreadPriority(<span class="number">0</span>, ANDROID_PRIORITY_AUDIO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;MetaData&gt; meta_data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err = OK;</span><br><span class="line">    MediaBuffer *buffer;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *trackName = mIsAudio ? <span class="string">"Audio"</span> : <span class="string">"Video"</span>;</span><br><span class="line">    <span class="keyword">while</span> (!mDone &amp;&amp; (err = mSource-&gt;read(&amp;buffer)) == OK) &#123;</span><br><span class="line">        <span class="keyword">if</span> (buffer-&gt;range_length() == <span class="number">0</span>) &#123;</span><br><span class="line">            buffer-&gt;release();</span><br><span class="line">            buffer = <span class="literal">NULL</span>;</span><br><span class="line">            ++nZeroLengthFrames;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the codec specific data has not been received yet, delay pause.</span></span><br><span class="line">        <span class="comment">// After the codec specific data is received, discard what we received</span></span><br><span class="line">        <span class="comment">// when the track is to be paused.</span></span><br><span class="line">        <span class="keyword">if</span> (mPaused &amp;&amp; !mResumed) &#123;</span><br><span class="line">            buffer-&gt;release();</span><br><span class="line">            buffer = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ++count;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int32_t</span> isCodecConfig;</span><br><span class="line">        <span class="keyword">if</span> (buffer-&gt;meta_data()-&gt;findInt32(kKeyIsCodecConfig, &amp;isCodecConfig)</span><br><span class="line">                &amp;&amp; isCodecConfig) &#123;</span><br><span class="line">            <span class="comment">// if config format (at track addition) already had CSD, keep that</span></span><br><span class="line">            <span class="comment">// UNLESS we have not received any frames yet.</span></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> for now the entire CSD has to come in one frame for encoders, even though</span></span><br><span class="line">            <span class="comment">// they need to be spread out for decoders.</span></span><br><span class="line">            <span class="keyword">if</span> (mGotAllCodecSpecificData &amp;&amp; nActualFrames &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ALOGI(<span class="string">"ignoring additional CSD for video track after first frame"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mMeta = mSource-&gt;getFormat(); <span class="comment">// get output format after format change</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (mIsAvc) &#123;</span><br><span class="line">                    <span class="keyword">status_t</span> err = makeAVCCodecSpecificData(</span><br><span class="line">                            (<span class="keyword">const</span> <span class="keyword">uint8_t</span> *)buffer-&gt;data()</span><br><span class="line">                                + buffer-&gt;range_offset(),</span><br><span class="line">                            buffer-&gt;range_length());</span><br><span class="line">                    CHECK_EQ((<span class="keyword">status_t</span>)OK, err);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mIsHevc) &#123;</span><br><span class="line">                    <span class="keyword">status_t</span> err = makeHEVCCodecSpecificData(</span><br><span class="line">                            (<span class="keyword">const</span> <span class="keyword">uint8_t</span> *)buffer-&gt;data()</span><br><span class="line">                                + buffer-&gt;range_offset(),</span><br><span class="line">                            buffer-&gt;range_length());</span><br><span class="line">                    CHECK_EQ((<span class="keyword">status_t</span>)OK, err);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mIsMPEG4) &#123;</span><br><span class="line">                    copyCodecSpecificData((<span class="keyword">const</span> <span class="keyword">uint8_t</span> *)buffer-&gt;data() + buffer-&gt;range_offset(),</span><br><span class="line">                            buffer-&gt;range_length());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!mIsAudio) &#123;</span><br><span class="line">                <span class="keyword">int32_t</span> fps;</span><br><span class="line">                mMeta-&gt;findInt32(kKeyFrameRate, &amp;fps);</span><br><span class="line">                <span class="keyword">int64_t</span> cttsOffsetTimeUs = <span class="number">1000000L</span>L/fps;</span><br><span class="line">                mCttsOffsetTimeUs = cttsOffsetTimeUs + kMinCttsOffsetTimeUs; <span class="comment">//delta factor</span></span><br><span class="line">            &#125;</span><br><span class="line">            buffer-&gt;release();</span><br><span class="line">            buffer = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">            mGotAllCodecSpecificData = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ++nActualFrames;</span><br><span class="line"></span><br><span class="line">        MediaBuffer *copy = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// Check if the upstream source hints it is OK to hold on to the</span></span><br><span class="line">        <span class="comment">// buffer without releasing immediately and avoid cloning the buffer</span></span><br><span class="line">        <span class="keyword">if</span> (AVUtils::get()-&gt;canDeferRelease(buffer-&gt;meta_data())) &#123;</span><br><span class="line">            copy = buffer;</span><br><span class="line">            meta_data = <span class="keyword">new</span> MetaData(*buffer-&gt;meta_data().get());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Make a deep copy of the MediaBuffer and Metadata and release</span></span><br><span class="line">            <span class="comment">// the original as soon as we can</span></span><br><span class="line">            copy = <span class="keyword">new</span> MediaBuffer(buffer-&gt;range_length());</span><br><span class="line">            <span class="built_in">memcpy</span>(copy-&gt;data(), (<span class="keyword">uint8_t</span> *)buffer-&gt;data() + buffer-&gt;range_offset(),</span><br><span class="line">                    buffer-&gt;range_length());</span><br><span class="line">            copy-&gt;set_range(<span class="number">0</span>, buffer-&gt;range_length());</span><br><span class="line">            meta_data = <span class="keyword">new</span> MetaData(*buffer-&gt;meta_data().get());</span><br><span class="line">            buffer-&gt;release();</span><br><span class="line">            buffer = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mIsAvc || mIsHevc) StripStartcode(copy);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">size_t</span> sampleSize = copy-&gt;range_length();</span><br><span class="line">        <span class="keyword">if</span> (mIsAvc || mIsHevc) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mOwner-&gt;useNalLengthFour()) &#123;</span><br><span class="line">                sampleSize += <span class="number">4</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sampleSize += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Max file size or duration handling</span></span><br><span class="line">        mMdatSizeBytes += sampleSize;</span><br><span class="line">        updateTrackSizeEstimate();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mOwner-&gt;exceedsFileSizeLimit()) &#123;</span><br><span class="line">            ALOGW(<span class="string">"Recorded file size exceeds limit %"</span> PRId64 <span class="string">"bytes"</span>,</span><br><span class="line">                    mOwner-&gt;mMaxFileSizeLimitBytes);</span><br><span class="line">            mOwner-&gt;notify(MEDIA_RECORDER_EVENT_INFO, MEDIA_RECORDER_INFO_MAX_FILESIZE_REACHED, <span class="number">0</span>);</span><br><span class="line">            copy-&gt;release();</span><br><span class="line">            mSource-&gt;stop();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mOwner-&gt;exceedsFileDurationLimit()) &#123;</span><br><span class="line">            ALOGW(<span class="string">"Recorded file duration exceeds limit %"</span> PRId64 <span class="string">"microseconds"</span>,</span><br><span class="line">                    mOwner-&gt;mMaxFileDurationLimitUs);</span><br><span class="line">            mOwner-&gt;notify(MEDIA_RECORDER_EVENT_INFO, MEDIA_RECORDER_INFO_MAX_DURATION_REACHED, <span class="number">0</span>);</span><br><span class="line">            copy-&gt;release();</span><br><span class="line">            mSource-&gt;stop();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int32_t</span> isSync = <span class="literal">false</span>;</span><br><span class="line">        meta_data-&gt;findInt32(kKeyIsSyncFrame, &amp;isSync);</span><br><span class="line">        CHECK(meta_data-&gt;findInt64(kKeyTime, &amp;timestampUs));</span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line">        <span class="keyword">if</span> (mStszTableEntries-&gt;count() == <span class="number">0</span>) &#123;</span><br><span class="line">            mFirstSampleTimeRealUs = systemTime() / <span class="number">1000</span>;</span><br><span class="line">            mStartTimestampUs = timestampUs;</span><br><span class="line">            mOwner-&gt;setStartTimestampUs(mStartTimestampUs);</span><br><span class="line">            previousPausedDurationUs = mStartTimestampUs;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mResumed) &#123;</span><br><span class="line">            <span class="keyword">int64_t</span> durExcludingEarlierPausesUs = timestampUs - previousPausedDurationUs;</span><br><span class="line">            <span class="keyword">if</span> (WARN_UNLESS(durExcludingEarlierPausesUs &gt;= <span class="number">0l</span>l, <span class="string">"for %s track"</span>, trackName)) &#123;</span><br><span class="line">                copy-&gt;release();</span><br><span class="line">                mSource-&gt;stop();</span><br><span class="line">                mIsMalformed = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int64_t</span> pausedDurationUs = durExcludingEarlierPausesUs - mTrackDurationUs;</span><br><span class="line">            <span class="keyword">if</span> (WARN_UNLESS(pausedDurationUs &gt;= lastDurationUs, <span class="string">"for %s track"</span>, trackName)) &#123;</span><br><span class="line">                copy-&gt;release();</span><br><span class="line">                mSource-&gt;stop();</span><br><span class="line">                mIsMalformed = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            previousPausedDurationUs += pausedDurationUs - lastDurationUs;</span><br><span class="line">            mResumed = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        timestampUs -= previousPausedDurationUs;</span><br><span class="line">        <span class="keyword">if</span> (WARN_UNLESS(timestampUs &gt;= <span class="number">0l</span>l, <span class="string">"for %s track"</span>, trackName)) &#123;</span><br><span class="line">            copy-&gt;release();</span><br><span class="line">            mSource-&gt;stop();</span><br><span class="line">            mIsMalformed = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mIsAudio) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Composition time: timestampUs</span></span><br><span class="line"><span class="comment">             * Decoding time: decodingTimeUs</span></span><br><span class="line"><span class="comment">             * Composition time offset = composition time - decoding time</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">int64_t</span> decodingTimeUs;</span><br><span class="line">            CHECK(meta_data-&gt;findInt64(kKeyDecodingTime, &amp;decodingTimeUs));</span><br><span class="line">            decodingTimeUs -= previousPausedDurationUs;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ensure non-negative, monotonic decoding time</span></span><br><span class="line">            <span class="keyword">if</span> (mLastDecodingTimeUs &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                decodingTimeUs = <span class="built_in">std</span>::max((<span class="keyword">int64_t</span>)<span class="number">0</span>, decodingTimeUs);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// increase decoding time by at least 1 tick</span></span><br><span class="line">                decodingTimeUs = <span class="built_in">std</span>::max(</span><br><span class="line">                        mLastDecodingTimeUs + divUp(<span class="number">1000000</span>, mTimeScale), decodingTimeUs);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mLastDecodingTimeUs = decodingTimeUs;</span><br><span class="line">            cttsOffsetTimeUs =</span><br><span class="line">                    timestampUs + mCttsOffsetTimeUs - decodingTimeUs;</span><br><span class="line">            <span class="keyword">if</span> (cttsOffsetTimeUs &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                cttsOffsetTimeUs = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (WARN_UNLESS(cttsOffsetTimeUs &gt;= <span class="number">0l</span>l, <span class="string">"for %s track"</span>, trackName)) &#123;</span><br><span class="line">                copy-&gt;release();</span><br><span class="line">                mSource-&gt;stop();</span><br><span class="line">                mIsMalformed = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            timestampUs = decodingTimeUs;</span><br><span class="line">            ALOGV(<span class="string">"decoding time: %"</span> PRId64 <span class="string">" and ctts offset time: %"</span> PRId64,</span><br><span class="line">                timestampUs, cttsOffsetTimeUs);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Update ctts box table if necessary</span></span><br><span class="line">            currCttsOffsetTimeTicks =</span><br><span class="line">                    (cttsOffsetTimeUs * mTimeScale + <span class="number">500000L</span>L) / <span class="number">1000000L</span>L;</span><br><span class="line">            <span class="keyword">if</span> (WARN_UNLESS(currCttsOffsetTimeTicks &lt;= <span class="number">0x0FFFFFFFF</span>LL, <span class="string">"for %s track"</span>, trackName)) &#123;</span><br><span class="line">                copy-&gt;release();</span><br><span class="line">                mSource-&gt;stop();</span><br><span class="line">                mIsMalformed = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mStszTableEntries-&gt;count() == <span class="number">0</span>) &#123;</span><br><span class="line">                lastCttsOffsetTimeTicks = currCttsOffsetTimeTicks;</span><br><span class="line">                <span class="comment">//addOneCttsTableEntry(1, currCttsOffsetTimeTicks);</span></span><br><span class="line">                <span class="comment">//cttsSampleCount = 0;      // No sample in ctts box is pending</span></span><br><span class="line">                cttsSampleCount = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (currCttsOffsetTimeTicks != lastCttsOffsetTimeTicks) &#123;</span><br><span class="line">                    addOneCttsTableEntry(cttsSampleCount, lastCttsOffsetTimeTicks);</span><br><span class="line">                    lastCttsOffsetTimeTicks = currCttsOffsetTimeTicks;</span><br><span class="line">                    cttsSampleCount = <span class="number">1</span>;  <span class="comment">// One sample in ctts box is pending</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ++cttsSampleCount;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Update ctts time offset range</span></span><br><span class="line">            <span class="keyword">if</span> (mStszTableEntries-&gt;count() == <span class="number">0</span>) &#123;</span><br><span class="line">                mMinCttsOffsetTimeUs = currCttsOffsetTimeTicks;</span><br><span class="line">                mMaxCttsOffsetTimeUs = currCttsOffsetTimeTicks;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (currCttsOffsetTimeTicks &gt; mMaxCttsOffsetTimeUs) &#123;</span><br><span class="line">                    mMaxCttsOffsetTimeUs = currCttsOffsetTimeTicks;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currCttsOffsetTimeTicks &lt; mMinCttsOffsetTimeUs) &#123;</span><br><span class="line">                    mMinCttsOffsetTimeUs = currCttsOffsetTimeTicks;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mOwner-&gt;isRealTimeRecording()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mIsAudio) &#123;</span><br><span class="line">                updateDriftTime(meta_data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (WARN_UNLESS(timestampUs &gt;= <span class="number">0l</span>l, <span class="string">"for %s track"</span>, trackName)) &#123;</span><br><span class="line">            copy-&gt;release();</span><br><span class="line">            mSource-&gt;stop();</span><br><span class="line">            mIsMalformed = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ALOGV(<span class="string">"%s media time stamp: %"</span> PRId64 <span class="string">" and previous paused duration %"</span> PRId64,</span><br><span class="line">                trackName, timestampUs, previousPausedDurationUs);</span><br><span class="line">        <span class="keyword">if</span> (timestampUs &gt; mTrackDurationUs) &#123;</span><br><span class="line">            mTrackDurationUs = timestampUs;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We need to use the time scale based ticks, rather than the</span></span><br><span class="line">        <span class="comment">// timestamp itself to determine whether we have to use a new</span></span><br><span class="line">        <span class="comment">// stts entry, since we may have rounding errors.</span></span><br><span class="line">        <span class="comment">// The calculation is intended to reduce the accumulated</span></span><br><span class="line">        <span class="comment">// rounding errors.</span></span><br><span class="line">        currDurationTicks =</span><br><span class="line">            ((timestampUs * mTimeScale + <span class="number">500000L</span>L) / <span class="number">1000000L</span>L -</span><br><span class="line">                (lastTimestampUs * mTimeScale + <span class="number">500000L</span>L) / <span class="number">1000000L</span>L);</span><br><span class="line">        <span class="keyword">if</span> (currDurationTicks &lt; <span class="number">0l</span>l) &#123;</span><br><span class="line">            ALOGE(<span class="string">"do not support out of order frames (timestamp: %lld &lt; last: %lld for %s track"</span>,</span><br><span class="line">                    (<span class="keyword">long</span> <span class="keyword">long</span>)timestampUs, (<span class="keyword">long</span> <span class="keyword">long</span>)lastTimestampUs, trackName);</span><br><span class="line">            copy-&gt;release();</span><br><span class="line">            mSource-&gt;stop();</span><br><span class="line">            mIsMalformed = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if the duration is different for this sample, see if it is close enough to the previous</span></span><br><span class="line">        <span class="comment">// duration that we can fudge it and use the same value, to avoid filling the stts table</span></span><br><span class="line">        <span class="comment">// with lots of near-identical entries.</span></span><br><span class="line">        <span class="comment">// "close enough" here means that the current duration needs to be adjusted by less</span></span><br><span class="line">        <span class="comment">// than 0.1 milliseconds</span></span><br><span class="line">        <span class="keyword">if</span> (lastDurationTicks &amp;&amp; (currDurationTicks != lastDurationTicks)) &#123;</span><br><span class="line">            <span class="keyword">int64_t</span> deltaUs = ((lastDurationTicks - currDurationTicks) * <span class="number">1000000L</span>L</span><br><span class="line">                    + (mTimeScale / <span class="number">2</span>)) / mTimeScale;</span><br><span class="line">            <span class="keyword">if</span> (deltaUs &gt; <span class="number">-100</span> &amp;&amp; deltaUs &lt; <span class="number">100</span>) &#123;</span><br><span class="line">                <span class="comment">// use previous ticks, and adjust timestamp as if it was actually that number</span></span><br><span class="line">                <span class="comment">// of ticks</span></span><br><span class="line">                currDurationTicks = lastDurationTicks;</span><br><span class="line">                timestampUs += deltaUs;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mStszTableEntries-&gt;add(htonl(sampleSize));</span><br><span class="line">        <span class="keyword">if</span> (mStszTableEntries-&gt;count() &gt; <span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Force the first sample to have its own stts entry so that</span></span><br><span class="line">            <span class="comment">// we can adjust its value later to maintain the A/V sync.</span></span><br><span class="line">            <span class="keyword">if</span> (mStszTableEntries-&gt;count() == <span class="number">3</span> || currDurationTicks != lastDurationTicks) &#123;</span><br><span class="line">                addOneSttsTableEntry(sampleCount, lastDurationTicks);</span><br><span class="line">                sampleCount = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ++sampleCount;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mSamplesHaveSameSize) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mStszTableEntries-&gt;count() &gt;= <span class="number">2</span> &amp;&amp; previousSampleSize != sampleSize) &#123;</span><br><span class="line">                mSamplesHaveSameSize = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            previousSampleSize = sampleSize;</span><br><span class="line">        &#125;</span><br><span class="line">        ALOGV(<span class="string">"%s timestampUs/lastTimestampUs: %"</span> PRId64 <span class="string">"/%"</span> PRId64,</span><br><span class="line">                trackName, timestampUs, lastTimestampUs);</span><br><span class="line">        lastDurationUs = timestampUs - lastTimestampUs;</span><br><span class="line">        lastDurationTicks = currDurationTicks;</span><br><span class="line">        lastTimestampUs = timestampUs;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isSync != <span class="number">0</span>) &#123;</span><br><span class="line">            addOneStssTableEntry(mStszTableEntries-&gt;count());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mTrackingProgressStatus) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mPreviousTrackTimeUs &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                mPreviousTrackTimeUs = mStartTimestampUs;</span><br><span class="line">            &#125;</span><br><span class="line">            trackProgressStatus(timestampUs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!hasMultipleTracks) &#123;</span><br><span class="line">            <span class="keyword">off64_t</span> offset = (mIsAvc || mIsHevc) ? mOwner-&gt;addMultipleLengthPrefixedSamples_l(copy)</span><br><span class="line">                                 : mOwner-&gt;addSample_l(copy);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">uint32_t</span> count = (mOwner-&gt;use32BitFileOffset()</span><br><span class="line">                        ? mStcoTableEntries-&gt;count()</span><br><span class="line">                        : mCo64TableEntries-&gt;count());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                addChunkOffset(offset);</span><br><span class="line">            &#125;</span><br><span class="line">            copy-&gt;release();</span><br><span class="line">            copy = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mChunkSamples.push_back(copy);</span><br><span class="line">        <span class="keyword">if</span> (interleaveDurationUs == <span class="number">0</span>) &#123;</span><br><span class="line">            addOneStscTableEntry(++nChunks, <span class="number">1</span>);</span><br><span class="line">            bufferChunk(timestampUs);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (chunkTimestampUs == <span class="number">0</span>) &#123;</span><br><span class="line">                chunkTimestampUs = timestampUs;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int64_t</span> chunkDurationUs = timestampUs - chunkTimestampUs;</span><br><span class="line">                <span class="keyword">if</span> (chunkDurationUs &gt; interleaveDurationUs) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (chunkDurationUs &gt; mMaxChunkDurationUs) &#123;</span><br><span class="line">                        mMaxChunkDurationUs = chunkDurationUs;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ++nChunks;</span><br><span class="line">                    <span class="keyword">if</span> (nChunks == <span class="number">1</span> ||  <span class="comment">// First chunk</span></span><br><span class="line">                        lastSamplesPerChunk != mChunkSamples.size()) &#123;</span><br><span class="line">                        lastSamplesPerChunk = mChunkSamples.size();</span><br><span class="line">                        addOneStscTableEntry(nChunks, lastSamplesPerChunk);</span><br><span class="line">                    &#125;</span><br><span class="line">                    bufferChunk(timestampUs);</span><br><span class="line">                    chunkTimestampUs = timestampUs;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isTrackMalFormed()) &#123;</span><br><span class="line">        err = ERROR_MALFORMED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mOwner-&gt;trackProgressStatus(mTrackId, <span class="number">-1</span>, err);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Last chunk</span></span><br><span class="line">    <span class="keyword">if</span> (!hasMultipleTracks) &#123;</span><br><span class="line">        addOneStscTableEntry(<span class="number">1</span>, mStszTableEntries-&gt;count());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mChunkSamples.empty()) &#123;</span><br><span class="line">        addOneStscTableEntry(++nChunks, mChunkSamples.size());</span><br><span class="line">        bufferChunk(timestampUs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We don't really know how long the last frame lasts, since</span></span><br><span class="line">    <span class="comment">// there is no frame time after it, just repeat the previous</span></span><br><span class="line">    <span class="comment">// frame's duration.</span></span><br><span class="line">    <span class="keyword">if</span> (mStszTableEntries-&gt;count() == <span class="number">1</span>) &#123;</span><br><span class="line">        lastDurationUs = <span class="number">0</span>;  <span class="comment">// A single sample's duration</span></span><br><span class="line">        lastDurationTicks = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ++sampleCount;  <span class="comment">// Count for the last sample</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mStszTableEntries-&gt;count() &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        addOneSttsTableEntry(<span class="number">1</span>, lastDurationTicks);</span><br><span class="line">        <span class="keyword">if</span> (sampleCount - <span class="number">1</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            addOneSttsTableEntry(sampleCount - <span class="number">1</span>, lastDurationTicks);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addOneSttsTableEntry(sampleCount, lastDurationTicks);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The last ctts box may not have been written yet, and this</span></span><br><span class="line">    <span class="comment">// is to make sure that we write out the last ctts box.</span></span><br><span class="line">    <span class="keyword">if</span> (currCttsOffsetTimeTicks == lastCttsOffsetTimeTicks) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cttsSampleCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            addOneCttsTableEntry(cttsSampleCount, lastCttsOffsetTimeTicks);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mTrackDurationUs += lastDurationUs;</span><br><span class="line">    mReachedEOS = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    sendTrackSummary(hasMultipleTracks);</span><br><span class="line"></span><br><span class="line">    ALOGI(<span class="string">"Received total/0-length (%d/%d) buffers and encoded %d frames. - %s"</span>,</span><br><span class="line">            count, nZeroLengthFrames, mStszTableEntries-&gt;count(), trackName);</span><br><span class="line">    <span class="keyword">if</span> (mIsAudio) &#123;</span><br><span class="line">        ALOGI(<span class="string">"Audio track drift time: %"</span> PRId64 <span class="string">" us"</span>, mOwner-&gt;getDriftTimeUs());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if err is ERROR_IO (ex: during SSR), return OK to save the</span></span><br><span class="line">    <span class="comment">// recorded file successfully. Session tear down will happen as part of</span></span><br><span class="line">    <span class="comment">// client callback</span></span><br><span class="line">    <span class="keyword">if</span> ((err == ERROR_IO) || (err == ERROR_END_OF_STREAM)) &#123;</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p> 下面看下，录制文件结束时的一些操作。录制文件结束时，上层应用分别是调用 MediaRecorder的stop()、reset()和release()法，下面看下MPEG4Writer.cpp中相对应的操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> MPEG4Writer::Track::stop() &#123;</span><br><span class="line">    ALOGD(<span class="string">"%s track stopping"</span>, mIsAudio? <span class="string">"Audio"</span>: <span class="string">"Video"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!mStarted) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Stop() called but track is not started"</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR_END_OF_STREAM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mDone) &#123;</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">    mDone = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    ALOGD(<span class="string">"%s track source stopping"</span>, mIsAudio? <span class="string">"Audio"</span>: <span class="string">"Video"</span>);</span><br><span class="line">    mSource-&gt;stop();</span><br><span class="line">    ALOGD(<span class="string">"%s track source stopped"</span>, mIsAudio? <span class="string">"Audio"</span>: <span class="string">"Video"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *dummy;</span><br><span class="line">    pthread_join(mThread, &amp;dummy);</span><br><span class="line">    <span class="keyword">status_t</span> err = <span class="keyword">static_cast</span>&lt;<span class="keyword">status_t</span>&gt;(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(dummy));</span><br><span class="line"></span><br><span class="line">    ALOGD(<span class="string">"%s track stopped"</span>, mIsAudio? <span class="string">"Audio"</span>: <span class="string">"Video"</span>);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> MPEG4Writer::release() &#123;</span><br><span class="line">    close(mFd);</span><br><span class="line">    mFd = <span class="number">-1</span>;</span><br><span class="line">    mInitCheck = NO_INIT;</span><br><span class="line">    mStarted = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">free</span>(mMoovBoxBuffer);</span><br><span class="line">    mMoovBoxBuffer = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（六）、参考资料-特别感谢各位前辈的分析和图示-："><a href="#（六）、参考资料-特别感谢各位前辈的分析和图示-：" class="headerlink" title="（六）、参考资料(特别感谢各位前辈的分析和图示)："></a>（六）、参考资料(特别感谢各位前辈的分析和图示)：</h4><p><a href="https://developer.android.com/guide/topics/media/camera#capture-video" target="_blank" rel="noopener">Camera#capture-video</a><br><a href="http://www.cnblogs.com/tocy/tag/%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6/" target="_blank" rel="noopener">Android NuPlayer播放框架 </a><br><a href="https://blog.csdn.net/dfhuang09/article/details/54926526" target="_blank" rel="noopener">android ACodec MediaCodec NuPlayer flow - CSDN博客</a><br><a href="https://blog.csdn.net/dfhuang09/article/details/60132620" target="_blank" rel="noopener">android MediaCodec ACodec - CSDN博客</a><br><a href="https://blog.csdn.net/column/details/16222.html" target="_blank" rel="noopener">ffmpeg开发之旅(1)-(7)（总共七篇）</a><br><a href="https://blog.csdn.net/nonmarking/article/category/6746500" target="_blank" rel="noopener">深入理解Android音视频同步机制（总共五篇）</a><br><a href="https://blog.csdn.net/junzia/article/details/54018671" target="_blank" rel="noopener">Android硬编码——音频编码、视频编码及音视频混合</a><br><a href="https://blog.csdn.net/mr_zjc/article/details/46822833" target="_blank" rel="noopener">Android 高通平台Camera录制–MPEG4Writer.cpp 简单跟读</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;amp;&amp;amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内
      
    
    </summary>
    
      <category term="Android" scheme="http://zhoujinjian.cc/categories/Android/"/>
    
    
      <category term="Android" scheme="http://zhoujinjian.cc/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android Video System（2）：音视频分离MediaExtractor、解码Decoder、渲染Renderer源码分析</title>
    <link href="http://zhoujinjian.cc/2018/06/06/Android%20Video%20System%EF%BC%882%EF%BC%89%EF%BC%9A%E9%9F%B3%E8%A7%86%E9%A2%91%E5%88%86%E7%A6%BBMediaExtractor%E3%80%81%E8%A7%A3%E7%A0%81Decoder%E3%80%81%E6%B8%B2%E6%9F%93Renderer%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://zhoujinjian.cc/2018/06/06/Android Video System（2）：音视频分离MediaExtractor、解码Decoder、渲染Renderer源码分析/</id>
    <published>2018-06-05T16:00:00.000Z</published>
    <updated>2018-05-17T16:23:42.126Z</updated>
    
    <content type="html"><![CDATA[<hr><p>注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;&amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除，禁止转载（©Qualcomm Technologies, Inc. 版权所有），谢谢。</p><p><a href="https://github.com/izhoujinjian/zhoujinjian.cc/tree/master/video.system" target="_blank" rel="noopener">【博客原图链接】</a><br><a href="http://www.cnblogs.com/tocy/tag/%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6/" target="_blank" rel="noopener">【特别感谢 -  Android NuPlayer播放框架】</a><br><a href="https://blog.csdn.net/dfhuang09/article/details/54926526" target="_blank" rel="noopener">【特别感谢 -  android ACodec MediaCodec NuPlayer flow】</a><br>Google Pixel、Pixel XL 内核代码（文章基于 Kernel-3.18）：<br> <a href="https://github.com/matthewdalex/marlin" target="_blank" rel="noopener">Kernel source for Pixel and Pixel XL - GitHub</a></p><p>AOSP 源码（文章基于 Android 7.1.2）：<br> <a href="https://testerhome.com/topics/2229" target="_blank" rel="noopener"> Android 系统全套源代码分享 (更新到 8.1.0_r1)</a></p><hr><p>☯ V4l2 框架代码<br>☯ kernel/drivers/media/v4l2-core/（文件前缀为 videobuf2）</p><p>☯ MSM 视频驱动程序文件<br>☯ kernel/drivers/media/platform/msm/vidc/</p><p>☯ 设备树<br>☯ /kernel/arch/arm/boot/dts/qcom（Venus 的寄存器基址，时钟频率）</p><p>☯ Stagefright、libmedia、libmediaplayerservice、mediaserver<br>☯ /frameworks/av/media/</p><p>☯ OMX<br>☯ /hardware/qcom/media/mam8996/mm-video-v4l2/vidc/</p><p>☯ OMX 核心<br>☯ /hardware/qcom/media/mm-core</p><p>☯ 软件编解码器路径<br>☯ /vendor/qcom/proprietary/mm-video/omx_vpp(?)→ 解码器代码<br>☯ /vendor/qcom/proprietary/mm-video/omx_vpp(?) → 编码器代码</p><hr><p>Android在Java层中提供了一个MediaPlayer的类来作为播放媒体资源的接口，在使用中我们通常会编写以下的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mMediaPlayer = <span class="keyword">new</span> MediaPlayer();</span><br><span class="line">mMediaPlayer.setDataSource(Environment.getExternalStorageDirectory()+<span class="string">"/test_video.mp4"</span>);</span><br><span class="line">mMediaPlayer.setDisplay(...);</span><br><span class="line">mMediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);</span><br><span class="line">mMediaPlayer.prepareAsync();</span><br><span class="line">mMediaPlayer.start();</span><br><span class="line">mediaPlayer.pause(); </span><br><span class="line">mediaPlayer.stop();</span><br><span class="line">mediaPlayer.reset();</span><br><span class="line">mediaPlayer.release();</span><br></pre></td></tr></table></figure><p>前面第一章节已经分析过mMediaPlayer.setDataSource()、mMediaPlayer.setDisplay()下来的分析尝试分析解答如下疑问：</p><blockquote><p><strong>不同格式的多媒体文件如何探测并解析的？音视频数据缓冲区在哪里？（Source）</strong><br><strong>音频解码线程、视频解码线程在哪里？ （DecoderBase）</strong><br><strong>视频如何显示的？音频如何播放的？音视频同步在哪里？（Renderer）</strong></p></blockquote><h4 id="（一）、多媒体文件解析-MediaExtractor分离音视频"><a href="#（一）、多媒体文件解析-MediaExtractor分离音视频" class="headerlink" title="（一）、多媒体文件解析 - MediaExtractor分离音视频"></a>（一）、多媒体文件解析 - MediaExtractor分离音视频</h4><p>接下来继续分析mMediaPlayer.prepareAsync()</p><h5 id="1-1、mMediaPlayer-prepareAsync"><a href="#1-1、mMediaPlayer-prepareAsync" class="headerlink" title="1.1、mMediaPlayer.prepareAsync()"></a>1.1、mMediaPlayer.prepareAsync()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\media\java\android\media\MediaPlayer.java]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">prepareAsync</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException</span>;</span><br></pre></td></tr></table></figure><p>通过JNI调用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\media\jni\android_media_MediaPlayer.cpp]</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">android_media_MediaPlayer_prepareAsync(JNIEnv *env, jobject thiz)</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;MediaPlayer&gt; mp = getMediaPlayer(env, thiz);</span><br><span class="line">    <span class="keyword">if</span> (mp == <span class="literal">NULL</span> ) &#123;</span><br><span class="line">        jniThrowException(env, <span class="string">"java/lang/IllegalStateException"</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle the case where the display surface was set before the mp was</span></span><br><span class="line">    <span class="comment">// initialized. We try again to make it stick.</span></span><br><span class="line">    sp&lt;IGraphicBufferProducer&gt; st = getVideoSurfaceTexture(env, thiz);</span><br><span class="line">    mp-&gt;setVideoSurfaceTexture(st);</span><br><span class="line"></span><br><span class="line">    process_media_player_call( env, thiz, mp-&gt;prepareAsync(), <span class="string">"java/io/IOException"</span>, <span class="string">"Prepare Async failed."</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先设置视频的 display surface（关于IGraphicBufferProducer相关知识请参考：Android 7.1.2 (Android N) Android Graphics 系统 分析 [i.wonder~]），</p><h5 id="1-1-1、MediaPlayer-setVideoSurfaceTexture"><a href="#1-1-1、MediaPlayer-setVideoSurfaceTexture" class="headerlink" title="1.1.1、MediaPlayer.setVideoSurfaceTexture()"></a>1.1.1、MediaPlayer.setVideoSurfaceTexture()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmedia\mediaplayer.cpp]</span><br><span class="line"><span class="keyword">status_t</span> MediaPlayer::setVideoSurfaceTexture(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;IGraphicBufferProducer&gt;&amp; bufferProducer)</span><br><span class="line">&#123;</span><br><span class="line">    ALOGV(<span class="string">"setVideoSurfaceTexture"</span>);</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    <span class="keyword">if</span> (mPlayer == <span class="number">0</span>) <span class="keyword">return</span> NO_INIT;</span><br><span class="line">    <span class="keyword">return</span> mPlayer-&gt;setVideoSurfaceTexture(bufferProducer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面setDataSource()分析过，此处会调用NuPlayer的setVideoSurfaceTexture()函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayer.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::setVideoSurfaceTextureAsync(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;IGraphicBufferProducer&gt; &amp;bufferProducer) &#123;</span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage(kWhatSetVideoSurface, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bufferProducer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        msg-&gt;setObject(<span class="string">"surface"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        msg-&gt;setObject(<span class="string">"surface"</span>, <span class="keyword">new</span> Surface(bufferProducer, <span class="literal">true</span> <span class="comment">/* controlledByApp */</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msg-&gt;post();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处首先构造了一个AMessage消息，然后new Surface()，接下来看看消息处理过程。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayer.cpp]</span><br><span class="line"><span class="keyword">case</span> kWhatSetVideoSurface:</span><br><span class="line">        &#123;</span><br><span class="line">            sp&lt;RefBase&gt; obj;</span><br><span class="line">            CHECK(msg-&gt;findObject(<span class="string">"surface"</span>, &amp;obj));</span><br><span class="line">            sp&lt;Surface&gt; surface = <span class="keyword">static_cast</span>&lt;Surface *&gt;(obj.get());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mSource == <span class="literal">NULL</span> || !mStarted || mSource-&gt;getFormat(<span class="literal">false</span> <span class="comment">/* audio */</span>) == <span class="literal">NULL</span></span><br><span class="line">                    <span class="comment">// <span class="doctag">NOTE:</span> mVideoDecoder's mSurface is always non-null</span></span><br><span class="line">                    || (mVideoDecoder != <span class="literal">NULL</span> &amp;&amp; mVideoDecoder-&gt;setVideoSurface(surface) == OK)) &#123;</span><br><span class="line">                performSetSurface(surface);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mDeferredActions.push_back(</span><br><span class="line">                    <span class="keyword">new</span> FlushDecoderAction(FLUSH_CMD_FLUSH <span class="comment">/* audio */</span>,</span><br><span class="line">                                           FLUSH_CMD_SHUTDOWN <span class="comment">/* video */</span>));</span><br><span class="line"></span><br><span class="line">            mDeferredActions.push_back(<span class="keyword">new</span> SetSurfaceAction(surface));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (obj != <span class="literal">NULL</span> || mAudioDecoder != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mStarted) &#123;</span><br><span class="line">                    <span class="keyword">int64_t</span> currentPositionUs = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span> (getCurrentPosition(&amp;currentPositionUs) == OK) &#123;</span><br><span class="line">                        mDeferredActions.push_back(</span><br><span class="line">                                <span class="keyword">new</span> SeekAction(currentPositionUs));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                mDeferredActions.push_back(</span><br><span class="line">                        <span class="keyword">new</span> SimpleAction(&amp;NuPlayer::performScanSources));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mDeferredActions.push_back(</span><br><span class="line">                    <span class="keyword">new</span> ResumeDecoderAction(<span class="literal">false</span> <span class="comment">/* needNotify */</span>));</span><br><span class="line"></span><br><span class="line">            processDeferredActions();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> NuPlayer::performSetSurface(<span class="keyword">const</span> sp&lt;Surface&gt; &amp;surface) &#123;</span><br><span class="line">    ALOGV(<span class="string">"performSetSurface"</span>);</span><br><span class="line"></span><br><span class="line">    mSurface = surface;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// XXX - ignore error from setVideoScalingMode for now</span></span><br><span class="line">    setVideoScalingMode(mVideoScalingMode);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mDriver != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        sp&lt;NuPlayerDriver&gt; driver = mDriver.promote();</span><br><span class="line">        <span class="keyword">if</span> (driver != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            driver-&gt;notifySetSurfaceComplete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到将surface 赋值给NuPlayer的mSurface ，待视频解码后就可以在此surface 上渲染画面了，<br>这个稍后再作分析。</p><h5 id="1-1-2、MediaPlayer-prepareAsync"><a href="#1-1-2、MediaPlayer-prepareAsync" class="headerlink" title="1.1.2、MediaPlayer.prepareAsync()"></a>1.1.2、MediaPlayer.prepareAsync()</h5><p>然后接着调用MediaPlayer prepareAsync()函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmedia\mediaplayer.cpp]</span><br><span class="line"><span class="keyword">status_t</span> MediaPlayer::prepareAsync()</span><br><span class="line">&#123;</span><br><span class="line">    ALOGV(<span class="string">"prepareAsync"</span>);</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    <span class="keyword">return</span> prepareAsync_l();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> MediaPlayer::prepareAsync_l()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( (mPlayer != <span class="number">0</span>) &amp;&amp; ( mCurrentState &amp; (MEDIA_PLAYER_INITIALIZED | MEDIA_PLAYER_STOPPED) ) ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mAudioAttributesParcel != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            mPlayer-&gt;setParameter(KEY_PARAMETER_AUDIO_ATTRIBUTES, *mAudioAttributesParcel);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mPlayer-&gt;setAudioStreamType(mStreamType);</span><br><span class="line">        &#125;</span><br><span class="line">        mCurrentState = MEDIA_PLAYER_PREPARING;</span><br><span class="line">        <span class="keyword">return</span> mPlayer-&gt;prepareAsync();</span><br><span class="line">    &#125;</span><br><span class="line">    ALOGE(<span class="string">"prepareAsync called in state %d, mPlayer(%p)"</span>, mCurrentState, mPlayer.get());</span><br><span class="line">    <span class="keyword">return</span> INVALID_OPERATION;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此处会调用NuPlayer的prepareAsync()函数，prepareAsync()发送了一个kWhatPrepare的AMessage，我们直接看看消息处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayer.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::prepareAsync() &#123;</span><br><span class="line">    (<span class="keyword">new</span> AMessage(kWhatPrepare, <span class="keyword">this</span>))-&gt;post();</span><br><span class="line">&#125;        </span><br><span class="line"><span class="keyword">case</span> kWhatPrepare:</span><br><span class="line">&#123;</span><br><span class="line">    mSource-&gt;prepareAsync();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处又调用了GenericSource的prepareAsync()函数，发送了一个kWhatPrepareAsync消息。直接看看GenericSource如何处理的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\GenericSource.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::GenericSource::prepareAsync() &#123;</span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mLooper = <span class="keyword">new</span> ALooper;</span><br><span class="line">        mLooper-&gt;setName(<span class="string">"generic"</span>);</span><br><span class="line">        mLooper-&gt;start();</span><br><span class="line"></span><br><span class="line">        mLooper-&gt;registerHandler(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage(kWhatPrepareAsync, <span class="keyword">this</span>);</span><br><span class="line">    msg-&gt;post();</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">switch</span> (msg-&gt;what()) &#123;</span><br><span class="line">      <span class="keyword">case</span> kWhatPrepareAsync:</span><br><span class="line">      &#123;</span><br><span class="line">          onPrepareAsync();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="keyword">void</span> NuPlayer::GenericSource::onPrepareAsync() &#123;</span><br><span class="line">    <span class="comment">// delayed data source creation</span></span><br><span class="line">    <span class="keyword">if</span> (mDataSource == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// set to false first, if the extractor</span></span><br><span class="line">        <span class="comment">// comes back as secure, set it to true then.</span></span><br><span class="line">        mIsSecure = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mUri.empty()) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span>* uri = mUri.c_str();</span><br><span class="line">            String8 contentType;</span><br><span class="line">            mIsWidevine = !strncasecmp(uri, <span class="string">"widevine://"</span>, <span class="number">11</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!strncasecmp(<span class="string">"http://"</span>, uri, <span class="number">7</span>)</span><br><span class="line">                    || !strncasecmp(<span class="string">"https://"</span>, uri, <span class="number">8</span>)</span><br><span class="line">                    || mIsWidevine) &#123;</span><br><span class="line">                mHttpSource = DataSource::CreateMediaHTTP(mHTTPService);</span><br><span class="line">                ......</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mDataSource = DataSource::CreateFromURI(</span><br><span class="line">                   mHTTPService, uri, &amp;mUriHeaders, &amp;contentType,</span><br><span class="line">                   <span class="keyword">static_cast</span>&lt;HTTPBase *&gt;(mHttpSource.get()));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mIsWidevine = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            mDataSource = <span class="keyword">new</span> FileSource(mFd, mOffset, mLength);</span><br><span class="line">            mFd = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mDataSource-&gt;flags() &amp; DataSource::kIsCachingDataSource) &#123;</span><br><span class="line">        mCachedSource = <span class="keyword">static_cast</span>&lt;NuCachedSource2 *&gt;(mDataSource.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mIsStreaming = (mIsWidevine || mCachedSource != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// init extractor from data source</span></span><br><span class="line">    <span class="keyword">status_t</span> err = initFromDataSource();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mVideoTrack.mSource != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        sp&lt;MetaData&gt; meta = doGetFormatMeta(<span class="literal">false</span> <span class="comment">/* audio */</span>);</span><br><span class="line">        sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage;</span><br><span class="line">        err = convertMetaDataToMessage(meta, &amp;msg);</span><br><span class="line">        ......</span><br><span class="line">        notifyVideoSizeChanged(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (mIsSecure) &#123;</span><br><span class="line">        <span class="comment">// secure decoders must be instantiated before starting widevine source</span></span><br><span class="line">        sp&lt;AMessage&gt; reply = <span class="keyword">new</span> AMessage(kWhatSecureDecodersInstantiated, <span class="keyword">this</span>);</span><br><span class="line">        notifyInstantiateSecureDecoders(reply);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        finishPrepareAsync();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先构造了  mDataSource = new FileSource，然后调用了initFromDataSource()，这里面包含多媒体文件格式探测，。</p><h5 id="1-1-3、GenericSource-initFromDataSource"><a href="#1-1-3、GenericSource-initFromDataSource" class="headerlink" title="1.1.3、GenericSource.initFromDataSource()"></a>1.1.3、GenericSource.initFromDataSource()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\GenericSource.cpp]</span><br><span class="line"><span class="keyword">status_t</span> NuPlayer::GenericSource::initFromDataSource() &#123;</span><br><span class="line">    sp&lt;IMediaExtractor&gt; extractor;</span><br><span class="line">    String8 mimeType;</span><br><span class="line">    <span class="keyword">float</span> confidence;</span><br><span class="line">    sp&lt;AMessage&gt; dummy;</span><br><span class="line">    <span class="keyword">bool</span> isWidevineStreaming = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    CHECK(mDataSource != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mIsWidevine) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mIsStreaming) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mDataSource-&gt;sniff(&amp;mimeType, &amp;confidence, &amp;dummy)) &#123;</span><br><span class="line">            <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">        isWidevineStreaming = !strcasecmp(</span><br><span class="line">                mimeType.<span class="built_in">string</span>(), MEDIA_MIMETYPE_CONTAINER_WVM);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isWidevineStreaming) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        extractor = MediaExtractor::Create(mDataSource,</span><br><span class="line">                mimeType.isEmpty() ? <span class="literal">NULL</span> : mimeType.<span class="built_in">string</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (extractor-&gt;getDrmFlag()) &#123;</span><br><span class="line">        checkDrmStatus(mDataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mFileMeta = extractor-&gt;getMetaData();</span><br><span class="line">    <span class="keyword">if</span> (mFileMeta != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">int64_t</span> duration;</span><br><span class="line">        <span class="keyword">if</span> (mFileMeta-&gt;findInt64(kKeyDuration, &amp;duration)) &#123;</span><br><span class="line">            mDurationUs = duration;</span><br><span class="line">        &#125;......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int32_t</span> totalBitrate = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> numtracks = extractor-&gt;countTracks();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; numtracks; ++i) &#123;</span><br><span class="line">        sp&lt;IMediaSource&gt; track = extractor-&gt;getTrack(i);</span><br><span class="line">        </span><br><span class="line">        sp&lt;MetaData&gt; meta = extractor-&gt;getTrackMetaData(i);</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *mime;</span><br><span class="line">        CHECK(meta-&gt;findCString(kKeyMIMEType, &amp;mime));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Do the string compare immediately with "mime",</span></span><br><span class="line">        <span class="comment">// we can't assume "mime" would stay valid after another</span></span><br><span class="line">        <span class="comment">// extractor operation, some extractors might modify meta</span></span><br><span class="line">        <span class="comment">// during getTrack() and make it invalid.</span></span><br><span class="line">        <span class="keyword">if</span> (!strncasecmp(mime, <span class="string">"audio/"</span>, <span class="number">6</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mAudioTrack.mSource == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                mAudioTrack.mIndex = i;</span><br><span class="line">                mAudioTrack.mSource = track;</span><br><span class="line">                mAudioTrack.mPackets =</span><br><span class="line">                    <span class="keyword">new</span> AnotherPacketSource(mAudioTrack.mSource-&gt;getFormat());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_VORBIS)) &#123;</span><br><span class="line">                    mAudioIsVorbis = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mAudioIsVorbis = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strncasecmp(mime, <span class="string">"video/"</span>, <span class="number">6</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mVideoTrack.mSource == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                mVideoTrack.mIndex = i;</span><br><span class="line">                mVideoTrack.mSource = track;</span><br><span class="line">                mVideoTrack.mPackets =</span><br><span class="line">                    <span class="keyword">new</span> AnotherPacketSource(mVideoTrack.mSource-&gt;getFormat());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// check if the source requires secure buffers</span></span><br><span class="line">                <span class="keyword">int32_t</span> secure;</span><br><span class="line">                <span class="keyword">if</span> (meta-&gt;findInt32(kKeyRequiresSecureBuffers, &amp;secure)</span><br><span class="line">                        &amp;&amp; secure) &#123;</span><br><span class="line">                    mIsSecure = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (mUIDValid) &#123;</span><br><span class="line">                        extractor-&gt;setUID(mUID);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mSources.push(track);</span><br><span class="line">        <span class="keyword">int64_t</span> durationUs;</span><br><span class="line">        <span class="keyword">if</span> (meta-&gt;findInt64(kKeyDuration, &amp;durationUs)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (durationUs &gt; mDurationUs) &#123;</span><br><span class="line">                mDurationUs = durationUs;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int32_t</span> bitrate;</span><br><span class="line">        <span class="keyword">if</span> (totalBitrate &gt;= <span class="number">0</span> &amp;&amp; meta-&gt;findInt32(kKeyBitRate, &amp;bitrate)) &#123;</span><br><span class="line">            totalBitrate += bitrate;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            totalBitrate = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   ......</span><br><span class="line">    mBitrate = totalBitrate;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到通过MediaExtractor::Create()得到MediaExtractor，然后将数据解析成track 赋值给mAudioTrack.mSource、mVideoTrack.mSource。</p><h5 id="1-1-4、MediaExtractor-Create"><a href="#1-1-4、MediaExtractor-Create" class="headerlink" title="1.1.4、MediaExtractor::Create()"></a>1.1.4、MediaExtractor::Create()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\MediaExtractor.cpp]</span><br><span class="line">sp&lt;IMediaExtractor&gt; MediaExtractor::Create(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;DataSource&gt; &amp;source, <span class="keyword">const</span> <span class="keyword">char</span> *mime) &#123;</span><br><span class="line">    ALOGV(<span class="string">"MediaExtractor::Create %s"</span>, mime);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> value[PROPERTY_VALUE_MAX];</span><br><span class="line">    <span class="keyword">if</span> (property_get(<span class="string">"media.stagefright.extractremote"</span>, value, <span class="literal">NULL</span>)</span><br><span class="line">            &amp;&amp; (!<span class="built_in">strcmp</span>(<span class="string">"0"</span>, value) || !strcasecmp(<span class="string">"false"</span>, value))) &#123;</span><br><span class="line">        <span class="comment">// local extractor</span></span><br><span class="line">        ALOGW(<span class="string">"creating media extractor in calling process"</span>);</span><br><span class="line">        <span class="keyword">return</span> CreateFromService(source, mime);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Check if it's WVM, since WVMExtractor needs to be created in the media server process,</span></span><br><span class="line">        <span class="comment">// not the extractor process.</span></span><br><span class="line">        String8 mime8;</span><br><span class="line">        <span class="keyword">float</span> confidence;</span><br><span class="line">        sp&lt;AMessage&gt; meta;</span><br><span class="line">        <span class="keyword">if</span> (SniffWVM(source, &amp;mime8, &amp;confidence, &amp;meta) &amp;&amp;</span><br><span class="line">                !strcasecmp(mime8, MEDIA_MIMETYPE_CONTAINER_WVM)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> WVMExtractor(source);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (SniffDRM(source, &amp;mime8, &amp;confidence, &amp;meta)) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *drmMime = mime8.<span class="built_in">string</span>();</span><br><span class="line">            ALOGV(<span class="string">"Detected media content as '%s' with confidence %.2f"</span>, drmMime, confidence);</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(drmMime, <span class="string">"drm+es_based+"</span>, <span class="number">13</span>)) &#123;</span><br><span class="line">                <span class="comment">// DRMExtractor sets container metadata kKeyIsDRM to 1</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> DRMExtractor(source, drmMime + <span class="number">14</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// remote extractor</span></span><br><span class="line">        ALOGV(<span class="string">"get service manager"</span>);</span><br><span class="line">        sp&lt;IBinder&gt; binder = defaultServiceManager()-&gt;getService(String16(<span class="string">"media.extractor"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (binder != <span class="number">0</span>) &#123;</span><br><span class="line">            sp&lt;IMediaExtractorService&gt; mediaExService(interface_cast&lt;IMediaExtractorService&gt;(binder));</span><br><span class="line">            sp&lt;IMediaExtractor&gt; ex = mediaExService-&gt;makeExtractor(RemoteDataSource::wrap(source), mime);</span><br><span class="line">            <span class="keyword">return</span> ex;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到通过Binder通信获取”media.extractor”服务得到一个Extractor。</p><h5 id="1-1-5、IMediaExtractor-gt-getTrack"><a href="#1-1-5、IMediaExtractor-gt-getTrack" class="headerlink" title="1.1.5、IMediaExtractor-&gt;getTrack()"></a>1.1.5、IMediaExtractor-&gt;getTrack()</h5><p>根据不同类别解析出不同的Track</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\]</span><br><span class="line"></span><br><span class="line">AACExtractor.cpp sp&lt;IMediaSource&gt; AACExtractor::getTrack(<span class="keyword">size_t</span> index)</span><br><span class="line">AMRExtractor.cpp sp&lt;IMediaSource&gt; AMRExtractor::getTrack(<span class="keyword">size_t</span> index)</span><br><span class="line">MP3Extractor.cpp sp&lt;IMediaSource&gt; MP3Extractor::getTrack(<span class="keyword">size_t</span> index)</span><br><span class="line">NuMediaExtractor.cpp sp&lt;IMediaSource&gt; source = mImpl-&gt;getTrack(index)</span><br><span class="line">WAVExtractor.cpp sp&lt;IMediaSource&gt; WAVExtractor::getTrack(<span class="keyword">size_t</span> index)</span><br><span class="line">FLACExtractor.cpp sp&lt;IMediaSource&gt; FLACExtractor::getTrack(<span class="keyword">size_t</span> index) </span><br><span class="line">StagefrightMetadataRetriever.cpp sp&lt;IMediaSource&gt; source = mExtractor-&gt;getTrack(i)</span><br><span class="line">AVIExtractor.cpp sp&lt;MediaSource&gt; AVIExtractor::getTrack(<span class="keyword">size_t</span> index)</span><br><span class="line">OggExtractor.cpp sp&lt;IMediaSource&gt; OggExtractor::getTrack(<span class="keyword">size_t</span> index)</span><br><span class="line">MPEG4Extractor.cpp sp&lt;IMediaSource&gt; MPEG4Extractor::getTrack(<span class="keyword">size_t</span> index)</span><br><span class="line"></span><br><span class="line"><span class="comment">//MP3</span></span><br><span class="line">sp&lt;IMediaSource&gt; MP3Extractor::getTrack(<span class="keyword">size_t</span> index) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MP3Source(</span><br><span class="line">            mMeta, mDataSource, mFirstFramePos, mFixedHeader,</span><br><span class="line">            mSeeker);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//MPEG4</span></span><br><span class="line">sp&lt;IMediaSource&gt; MPEG4Extractor::getTrack(<span class="keyword">size_t</span> index) &#123;</span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line">    ......</span><br><span class="line">    Track *track = mFirstTrack;</span><br><span class="line">    <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (track == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        track = track-&gt;next;</span><br><span class="line">        --index;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    Trex *trex = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int32_t</span> trackId;</span><br><span class="line">    <span class="keyword">if</span> (track-&gt;meta-&gt;findInt32(kKeyTrackID, &amp;trackId)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mTrex.size(); i++) &#123;</span><br><span class="line">            Trex *t = &amp;mTrex.editItemAt(i);</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;track_ID == (<span class="keyword">uint32_t</span>) trackId) &#123;</span><br><span class="line">                trex = t;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *mime;</span><br><span class="line">    .......</span><br><span class="line">    <span class="keyword">if</span> (!strcasecmp(mime, MEDIA_MIMETYPE_VIDEO_AVC)) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> type;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">void</span> *data;</span><br><span class="line">        <span class="keyword">size_t</span> size;</span><br><span class="line">        <span class="keyword">if</span> (!track-&gt;meta-&gt;findData(kKeyAVCC, &amp;type, &amp;data, &amp;size)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">uint8_t</span> *ptr = (<span class="keyword">const</span> <span class="keyword">uint8_t</span> *)data;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(mime, MEDIA_MIMETYPE_VIDEO_HEVC)) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> type;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">void</span> *data;</span><br><span class="line">        <span class="keyword">size_t</span> size;</span><br><span class="line">        <span class="keyword">if</span> (!track-&gt;meta-&gt;findData(kKeyHVCC, &amp;type, &amp;data, &amp;size)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">uint8_t</span> *ptr = (<span class="keyword">const</span> <span class="keyword">uint8_t</span> *)data;</span><br><span class="line">       ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MPEG4Source(<span class="keyword">this</span>,</span><br><span class="line">            track-&gt;meta, mDataSource, track-&gt;timescale, track-&gt;sampleTable,</span><br><span class="line">            mSidxEntries, trex, mMoofOffset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到不同格式的 MP3Extractor、MPEG4Source ……</p><p>还记的前面提出的第一点疑问吗，现在我们知道了如何分离音视频了并且得到了相应的文件Source了。<br>图示（红线部分）：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/02-01-source-demux-decoder-output-MediaExtractor.jpg" alt="Alt text"></p><h4 id="（二）、多媒体文件-音视频解码（Decoder）"><a href="#（二）、多媒体文件-音视频解码（Decoder）" class="headerlink" title="（二）、多媒体文件 - 音视频解码（Decoder）"></a>（二）、多媒体文件 - 音视频解码（Decoder）</h4><p>音频解码、视频解码在何处，答案就在mMediaPlayer.start()流程当中，先看看start()总体时序图，然后一步步分析</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/02-02-NuPlayer-Start-instantiateDecoder.png" alt="Alt text"></p><p>由于从Java层到JNI前面已多次分析，这里直接从NuPlayer::start()开始分析</p><h5 id="2-1、NuPlayer-start"><a href="#2-1、NuPlayer-start" class="headerlink" title="2.1、NuPlayer::start()"></a>2.1、NuPlayer::start()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayer.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::start() &#123;</span><br><span class="line">    (<span class="keyword">new</span> AMessage(kWhatStart, <span class="keyword">this</span>))-&gt;post();</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">case</span> kWhatStart:</span><br><span class="line">        &#123;</span><br><span class="line">            ALOGV(<span class="string">"kWhatStart"</span>);</span><br><span class="line">            <span class="keyword">if</span> (mStarted) &#123;</span><br><span class="line">                <span class="comment">// do not resume yet if the source is still buffering</span></span><br><span class="line">                <span class="keyword">if</span> (!mPausedForBuffering) &#123;</span><br><span class="line">                    onResume();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                onStart();</span><br><span class="line">            &#125;</span><br><span class="line">            mPausedByClient = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">void</span> NuPlayer::onStart(<span class="keyword">int64_t</span> startPositionUs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mSourceStarted) &#123;</span><br><span class="line">        mSourceStarted = <span class="literal">true</span>;</span><br><span class="line">        mSource-&gt;start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (startPositionUs &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        performSeek(startPositionUs);</span><br><span class="line">        <span class="keyword">if</span> (mSource-&gt;getFormat(<span class="literal">false</span> <span class="comment">/* audio */</span>) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mOffloadAudio = <span class="literal">false</span>;</span><br><span class="line">    mAudioEOS = <span class="literal">false</span>;</span><br><span class="line">    mVideoEOS = <span class="literal">false</span>;</span><br><span class="line">    mStarted = <span class="literal">true</span>;</span><br><span class="line">    mPaused = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mSource-&gt;isRealTime()) &#123;</span><br><span class="line">        flags |= Renderer::FLAG_REAL_TIME;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;MetaData&gt; audioMeta = mSource-&gt;getFormatMeta(<span class="literal">true</span> <span class="comment">/* audio */</span>);</span><br><span class="line">    sp&lt;MetaData&gt; videoMeta = mSource-&gt;getFormatMeta(<span class="literal">false</span> <span class="comment">/* audio */</span>);</span><br><span class="line">    ......</span><br><span class="line">    ALOGV_IF(audioMeta == <span class="literal">NULL</span>, <span class="string">"no metadata for audio source"</span>);  <span class="comment">// video only stream</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">audio_stream_type_t</span> streamType = AUDIO_STREAM_MUSIC;</span><br><span class="line">    <span class="keyword">if</span> (mAudioSink != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        streamType = mAudioSink-&gt;getAudioStreamType();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; videoFormat = mSource-&gt;getFormat(<span class="literal">false</span> <span class="comment">/* audio */</span>);</span><br><span class="line"></span><br><span class="line">    mOffloadAudio =</span><br><span class="line">        canOffloadStream(audioMeta, (videoFormat != <span class="literal">NULL</span>), mSource-&gt;isStreaming(), streamType)</span><br><span class="line">                &amp;&amp; (mPlaybackSettings.mSpeed == <span class="number">1.f</span> &amp;&amp; mPlaybackSettings.mPitch == <span class="number">1.f</span>);</span><br><span class="line">    <span class="keyword">if</span> (mOffloadAudio) &#123;</span><br><span class="line">        flags |= Renderer::FLAG_OFFLOAD_AUDIO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; notify = <span class="keyword">new</span> AMessage(kWhatRendererNotify, <span class="keyword">this</span>);</span><br><span class="line">    ++mRendererGeneration;</span><br><span class="line">    notify-&gt;setInt32(<span class="string">"generation"</span>, mRendererGeneration);</span><br><span class="line">    mRenderer = <span class="keyword">new</span> Renderer(mAudioSink, notify, flags);</span><br><span class="line">    mRendererLooper = <span class="keyword">new</span> ALooper;</span><br><span class="line">    mRendererLooper-&gt;setName(<span class="string">"NuPlayerRenderer"</span>);</span><br><span class="line">    mRendererLooper-&gt;start(<span class="literal">false</span>, <span class="literal">false</span>, ANDROID_PRIORITY_AUDIO);</span><br><span class="line">    mRendererLooper-&gt;registerHandler(mRenderer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err = mRenderer-&gt;setPlaybackSettings(mPlaybackSettings);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">float</span> rate = getFrameRate();</span><br><span class="line">    <span class="keyword">if</span> (rate &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        mRenderer-&gt;setVideoFrameRate(rate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mVideoDecoder != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mVideoDecoder-&gt;setRenderer(mRenderer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mAudioDecoder != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mAudioDecoder-&gt;setRenderer(mRenderer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    postScanSources();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里创建了名为NuPlayerRenderer的Renderer对象，然后启动循环，看看初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayerRenderer.cpp]</span><br><span class="line">NuPlayer::Renderer::Renderer(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;MediaPlayerBase::AudioSink&gt; &amp;sink,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;AMessage&gt; &amp;notify,</span><br><span class="line">        <span class="keyword">uint32_t</span> flags)</span><br><span class="line">    : mAudioSink(sink),</span><br><span class="line">      mUseVirtualAudioSink(<span class="literal">false</span>),</span><br><span class="line">      mNotify(notify),</span><br><span class="line">      mFlags(flags),</span><br><span class="line">      mNumFramesWritten(<span class="number">0</span>),</span><br><span class="line">      mDrainAudioQueuePending(<span class="literal">false</span>),</span><br><span class="line">      mDrainVideoQueuePending(<span class="literal">false</span>),</span><br><span class="line">      mAudioQueueGeneration(<span class="number">0</span>),</span><br><span class="line">      mVideoQueueGeneration(<span class="number">0</span>),</span><br><span class="line">      mAudioDrainGeneration(<span class="number">0</span>),</span><br><span class="line">      mVideoDrainGeneration(<span class="number">0</span>),</span><br><span class="line">      mAudioEOSGeneration(<span class="number">0</span>),</span><br><span class="line">      mPlaybackSettings(AUDIO_PLAYBACK_RATE_DEFAULT),</span><br><span class="line">      ......</span><br><span class="line">      mWakeLock(<span class="keyword">new</span> AWakeLock()) &#123;</span><br><span class="line">    mMediaClock = <span class="keyword">new</span> MediaClock;</span><br><span class="line">    mPlaybackRate = mPlaybackSettings.mSpeed;</span><br><span class="line">    mMediaClock-&gt;setPlaybackRate(mPlaybackRate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-2、postScanSources"><a href="#2-2、postScanSources" class="headerlink" title="2.2、postScanSources()"></a>2.2、postScanSources()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayer.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::postScanSources() &#123;</span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage(kWhatScanSources, <span class="keyword">this</span>);</span><br><span class="line">    msg-&gt;setInt32(<span class="string">"generation"</span>, mScanSourcesGeneration);</span><br><span class="line">    msg-&gt;post();</span><br><span class="line"></span><br><span class="line">    mScanSourcesPending = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> kWhatScanSources:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int32_t</span> generation;</span><br><span class="line">            mScanSourcesPending = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">bool</span> mHadAnySourcesBefore =</span><br><span class="line">                (mAudioDecoder != <span class="literal">NULL</span>) || (mVideoDecoder != <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">bool</span> rescan = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// initialize video before audio because successful initialization of</span></span><br><span class="line">            <span class="comment">// video may change deep buffer mode of audio.</span></span><br><span class="line">            <span class="keyword">if</span> (mSurface != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instantiateDecoder(<span class="literal">false</span>, &amp;mVideoDecoder) == -EWOULDBLOCK) &#123;</span><br><span class="line">                    rescan = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Don't try to re-open audio sink if there's an existing decoder.</span></span><br><span class="line">            <span class="keyword">if</span> (mAudioSink != <span class="literal">NULL</span> &amp;&amp; mAudioDecoder == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instantiateDecoder(<span class="literal">true</span>, &amp;mAudioDecoder) == -EWOULDBLOCK) &#123;</span><br><span class="line">                    rescan = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>此处调用了instantiateDecoder()来初始化音视频解码器Decoder</p><h5 id="2-3、instantiateDecoder"><a href="#2-3、instantiateDecoder" class="headerlink" title="2.3、instantiateDecoder()"></a>2.3、instantiateDecoder()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayer.cpp]</span><br><span class="line"><span class="keyword">status_t</span> NuPlayer::instantiateDecoder(</span><br><span class="line">        <span class="keyword">bool</span> audio, sp&lt;DecoderBase&gt; *decoder, <span class="keyword">bool</span> checkAudioModeChange) &#123;</span><br><span class="line">    ......</span><br><span class="line">    sp&lt;AMessage&gt; format = mSource-&gt;getFormat(audio);</span><br><span class="line"></span><br><span class="line">    format-&gt;setInt32(<span class="string">"priority"</span>, <span class="number">0</span> <span class="comment">/* realtime */</span>);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (audio) &#123;</span><br><span class="line">        sp&lt;AMessage&gt; notify = <span class="keyword">new</span> AMessage(kWhatAudioNotify, <span class="keyword">this</span>);</span><br><span class="line">        ++mAudioDecoderGeneration;</span><br><span class="line">        notify-&gt;setInt32(<span class="string">"generation"</span>, mAudioDecoderGeneration);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (checkAudioModeChange) &#123;</span><br><span class="line">            determineAudioModeChange(format);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mOffloadAudio) &#123;</span><br><span class="line">            mSource-&gt;setOffloadAudio(<span class="literal">true</span> <span class="comment">/* offload */</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">bool</span> hasVideo = (mSource-&gt;getFormat(<span class="literal">false</span> <span class="comment">/*audio */</span>) != <span class="literal">NULL</span>);</span><br><span class="line">            format-&gt;setInt32(<span class="string">"has-video"</span>, hasVideo);</span><br><span class="line">            *decoder = <span class="keyword">new</span> DecoderPassThrough(notify, mSource, mRenderer);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mSource-&gt;setOffloadAudio(<span class="literal">false</span> <span class="comment">/* offload */</span>);</span><br><span class="line"></span><br><span class="line">            *decoder = <span class="keyword">new</span> Decoder(notify, mSource, mPID, mRenderer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sp&lt;AMessage&gt; notify = <span class="keyword">new</span> AMessage(kWhatVideoNotify, <span class="keyword">this</span>);</span><br><span class="line">        ++mVideoDecoderGeneration;</span><br><span class="line">        notify-&gt;setInt32(<span class="string">"generation"</span>, mVideoDecoderGeneration);</span><br><span class="line"></span><br><span class="line">        *decoder = <span class="keyword">new</span> Decoder(</span><br><span class="line">                notify, mSource, mPID, mRenderer, mSurface, mCCDecoder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// enable FRC if high-quality AV sync is requested, even if not</span></span><br><span class="line">        <span class="comment">// directly queuing to display, as this will even improve textureview</span></span><br><span class="line">        <span class="comment">// playback.</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> value[PROPERTY_VALUE_MAX];</span><br><span class="line">            <span class="keyword">if</span> (property_get(<span class="string">"persist.sys.media.avsync"</span>, value, <span class="literal">NULL</span>) &amp;&amp;</span><br><span class="line">                    (!<span class="built_in">strcmp</span>(<span class="string">"1"</span>, value) || !strcasecmp(<span class="string">"true"</span>, value))) &#123;</span><br><span class="line">                format-&gt;setInt32(<span class="string">"auto-frc"</span>, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    (*decoder)-&gt;init();</span><br><span class="line">    (*decoder)-&gt;configure(format);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-1、创建音视频解码器new-Decoder"><a href="#2-3-1、创建音视频解码器new-Decoder" class="headerlink" title="2.3.1、创建音视频解码器new Decoder()"></a>2.3.1、创建音视频解码器new Decoder()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayerDecoder.cpp]</span><br><span class="line">NuPlayer::Decoder::Decoder(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;AMessage&gt; &amp;notify,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Source&gt; &amp;source,</span><br><span class="line">        <span class="keyword">pid_t</span> pid,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Renderer&gt; &amp;renderer,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Surface&gt; &amp;surface,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;CCDecoder&gt; &amp;ccDecoder)</span><br><span class="line">    : DecoderBase(notify),</span><br><span class="line">      mSurface(surface),</span><br><span class="line">      mSource(source),</span><br><span class="line">      mRenderer(renderer),</span><br><span class="line">      mCCDecoder(ccDecoder),</span><br><span class="line">      ......</span><br><span class="line">      mVideoWidth(<span class="number">0</span>),</span><br><span class="line">      mVideoHeight(<span class="number">0</span>),</span><br><span class="line">      mIsAudio(<span class="literal">true</span>),</span><br><span class="line">      ......</span><br><span class="line">      mComponentName(<span class="string">"decoder"</span>) &#123;</span><br><span class="line">    mCodecLooper = <span class="keyword">new</span> ALooper;</span><br><span class="line">    mCodecLooper-&gt;setName(<span class="string">"NPDecoder-CL"</span>);</span><br><span class="line">    mCodecLooper-&gt;start(<span class="literal">false</span>, <span class="literal">false</span>, ANDROID_PRIORITY_AUDIO);</span><br><span class="line">    mVideoTemporalLayerAggregateFps[<span class="number">0</span>] = mFrameRateTotal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建音视频解码器（NuPlayer::Decoder），为其创建名为NPDecoder-CL的mCodecLooper 【其父类NuPlayer::DecoderBase的构造中则会创建NPDecoder】</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayerDecoderBase.cpp]</span><br><span class="line">NuPlayer::DecoderBase::DecoderBase(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;notify)</span><br><span class="line">    :  mNotify(notify),</span><br><span class="line">       mBufferGeneration(<span class="number">0</span>),</span><br><span class="line">       mPaused(<span class="literal">false</span>),</span><br><span class="line">       mStats(<span class="keyword">new</span> AMessage),</span><br><span class="line">       mRequestInputBuffersPending(<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="comment">// Every decoder has its own looper because MediaCodec operations</span></span><br><span class="line">    <span class="comment">// are blocking, but NuPlayer needs asynchronous operations.</span></span><br><span class="line">    mDecoderLooper = <span class="keyword">new</span> ALooper;</span><br><span class="line">    mDecoderLooper-&gt;setName(<span class="string">"NPDecoder"</span>);</span><br><span class="line">    mDecoderLooper-&gt;start(<span class="literal">false</span>, <span class="literal">false</span>, ANDROID_PRIORITY_AUDIO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-2、初始化Decoder-gt-init"><a href="#2-3-2、初始化Decoder-gt-init" class="headerlink" title="2.3.2、初始化Decoder-&gt;init()"></a>2.3.2、初始化Decoder-&gt;init()</h5><p>对该解码器进行init()操作，调用NuPlayer::DecoderBase::init()为mDecoderLooper注册handler【init()和configure()都是NuPlayerDecoder继承自NuPlayer::DecoderBase的方法】</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayerDecoderBase.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::DecoderBase::configure(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;format) &#123;</span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage(kWhatConfigure, <span class="keyword">this</span>);</span><br><span class="line">    msg-&gt;setMessage(<span class="string">"format"</span>, format);</span><br><span class="line">    msg-&gt;post();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> NuPlayer::DecoderBase::init() &#123;</span><br><span class="line">    mDecoderLooper-&gt;registerHandler(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> kWhatConfigure:</span><br><span class="line">        &#123;</span><br><span class="line">            sp&lt;AMessage&gt; format;</span><br><span class="line">            CHECK(msg-&gt;findMessage(<span class="string">"format"</span>, &amp;format));</span><br><span class="line">            onConfigure(format);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>对该解码器进行configure(format)操作，调用NuPlayer::DecoderBase::configure(…)产生一个kWhatConfigure消息，然后消息处理中调用NuPlayer::Decoder::onConfigure(…)</p><h5 id="2-3-3、配置Decoder-gt-configure"><a href="#2-3-3、配置Decoder-gt-configure" class="headerlink" title="2.3.3、配置Decoder-&gt;configure()"></a>2.3.3、配置Decoder-&gt;configure()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayerDecoder.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::Decoder::onConfigure(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;format) &#123;</span><br><span class="line">  </span><br><span class="line">    mFormatChangePending = <span class="literal">false</span>;</span><br><span class="line">    mTimeChangePending = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    ++mBufferGeneration;</span><br><span class="line"></span><br><span class="line">    AString mime;</span><br><span class="line"></span><br><span class="line">    mIsAudio = !strncasecmp(<span class="string">"audio/"</span>, mime.c_str(), <span class="number">6</span>);</span><br><span class="line">    mIsVideoAVC = !strcasecmp(MEDIA_MIMETYPE_VIDEO_AVC, mime.c_str());</span><br><span class="line"></span><br><span class="line">    mComponentName = mime;</span><br><span class="line">    mComponentName.append(<span class="string">" decoder"</span>);</span><br><span class="line">    ALOGV(<span class="string">"[%s] onConfigure (surface=%p)"</span>, mComponentName.c_str(), mSurface.get());</span><br><span class="line"></span><br><span class="line">    mCodec = MediaCodec::CreateByType(</span><br><span class="line">            mCodecLooper, mime.c_str(), <span class="literal">false</span> <span class="comment">/* encoder */</span>, <span class="literal">NULL</span> <span class="comment">/* err */</span>, mPid);</span><br><span class="line">    <span class="keyword">int32_t</span> secure = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (format-&gt;findInt32(<span class="string">"secure"</span>, &amp;secure) &amp;&amp; secure != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCodec != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            mCodec-&gt;getName(&amp;mComponentName);</span><br><span class="line">            mComponentName.append(<span class="string">".secure"</span>);</span><br><span class="line">            mCodec-&gt;release();</span><br><span class="line">            ALOGI(<span class="string">"[%s] creating"</span>, mComponentName.c_str());</span><br><span class="line">            mCodec = MediaCodec::CreateByComponentName(</span><br><span class="line">                    mCodecLooper, mComponentName.c_str(), <span class="literal">NULL</span> <span class="comment">/* err */</span>, mPid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    mIsSecure = secure;</span><br><span class="line"></span><br><span class="line">    mCodec-&gt;getName(&amp;mComponentName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line">    <span class="keyword">if</span> (mSurface != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// disconnect from surface as MediaCodec will reconnect</span></span><br><span class="line">        err = native_window_api_disconnect(</span><br><span class="line">                mSurface.get(), NATIVE_WINDOW_API_MEDIA);</span><br><span class="line">        <span class="comment">// We treat this as a warning, as this is a preparatory step.</span></span><br><span class="line">        <span class="comment">// Codec will try to connect to the surface, which is where</span></span><br><span class="line">        <span class="comment">// any error signaling will occur.</span></span><br><span class="line">        ALOGW_IF(err != OK, <span class="string">"failed to disconnect from surface: %d"</span>, err);</span><br><span class="line">    &#125;</span><br><span class="line">    err = mCodec-&gt;configure(</span><br><span class="line">            format, mSurface, <span class="literal">NULL</span> <span class="comment">/* crypto */</span>, <span class="number">0</span> <span class="comment">/* flags */</span>);</span><br><span class="line">    ......</span><br><span class="line">    rememberCodecSpecificData(format);</span><br><span class="line">    mStats-&gt;setString(<span class="string">"mime"</span>, mime.c_str());</span><br><span class="line">    mStats-&gt;setString(<span class="string">"component-name"</span>, mComponentName.c_str());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mIsAudio) &#123;</span><br><span class="line">        <span class="keyword">int32_t</span> width, height;</span><br><span class="line">        <span class="keyword">if</span> (mOutputFormat-&gt;findInt32(<span class="string">"width"</span>, &amp;width)</span><br><span class="line">                &amp;&amp; mOutputFormat-&gt;findInt32(<span class="string">"height"</span>, &amp;height)) &#123;</span><br><span class="line">            mStats-&gt;setInt32(<span class="string">"width"</span>, width);</span><br><span class="line">            mStats-&gt;setInt32(<span class="string">"height"</span>, height);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; reply = <span class="keyword">new</span> AMessage(kWhatCodecNotify, <span class="keyword">this</span>);</span><br><span class="line">    mCodec-&gt;setCallback(reply);</span><br><span class="line"></span><br><span class="line">    err = mCodec-&gt;start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    releaseAndResetMediaBuffers();</span><br><span class="line"></span><br><span class="line">    mPaused = <span class="literal">false</span>;</span><br><span class="line">    mResumePending = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在onConfigure中，首先会调用MediaCodec::CreateByType(…)或者MediaCodec::CreateByComponentName(…)根据情况创建MediaCodec，接着调用MediaCodec::init(…)，随后调用MediaCodec::configure(…)对MediaCodec进行配置使其转入Configured状态;然后又调用MediaCodec::start()使MediaCodec转入Executing状态。</p><h5 id="2-3-4、MediaCodec-init-…"><a href="#2-3-4、MediaCodec-init-…" class="headerlink" title="2.3.4、MediaCodec::init(…)"></a>2.3.4、MediaCodec::init(…)</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\MediaCodec.cpp]</span><br><span class="line">sp&lt;MediaCodec&gt; MediaCodec::CreateByType(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;ALooper&gt; &amp;looper, <span class="keyword">const</span> AString &amp;mime, <span class="keyword">bool</span> encoder, <span class="keyword">status_t</span> *err, <span class="keyword">pid_t</span> pid) &#123;</span><br><span class="line">    sp&lt;MediaCodec&gt; codec = <span class="keyword">new</span> MediaCodec(looper, pid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">status_t</span> ret = codec-&gt;init(mime, <span class="literal">true</span> <span class="comment">/* nameIsType */</span>, encoder);</span><br><span class="line">    <span class="keyword">return</span> ret == OK ? codec : <span class="literal">NULL</span>; <span class="comment">// NULL deallocates codec.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sp&lt;MediaCodec&gt; MediaCodec::CreateByComponentName(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;ALooper&gt; &amp;looper, <span class="keyword">const</span> AString &amp;name, <span class="keyword">status_t</span> *err, <span class="keyword">pid_t</span> pid) &#123;</span><br><span class="line">    sp&lt;MediaCodec&gt; codec = <span class="keyword">new</span> MediaCodec(looper, pid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">status_t</span> ret = codec-&gt;init(name, <span class="literal">false</span> <span class="comment">/* nameIsType */</span>, <span class="literal">false</span> <span class="comment">/* encoder */</span>);</span><br><span class="line">    <span class="keyword">return</span> ret == OK ? codec : <span class="literal">NULL</span>; <span class="comment">// NULL deallocates codec.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sp&lt;MediaCodec&gt; MediaCodec::CreateByType(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;ALooper&gt; &amp;looper, <span class="keyword">const</span> AString &amp;mime, <span class="keyword">bool</span> encoder, <span class="keyword">status_t</span> *err, <span class="keyword">pid_t</span> pid) &#123;</span><br><span class="line">    sp&lt;MediaCodec&gt; codec = <span class="keyword">new</span> MediaCodec(looper, pid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">status_t</span> ret = codec-&gt;init(mime, <span class="literal">true</span> <span class="comment">/* nameIsType */</span>, encoder);</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *err = ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret == OK ? codec : <span class="literal">NULL</span>; <span class="comment">// NULL deallocates codec.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">status_t</span> MediaCodec::init(<span class="keyword">const</span> AString &amp;name, <span class="keyword">bool</span> nameIsType, <span class="keyword">bool</span> encoder) &#123;</span><br><span class="line">    mResourceManagerService-&gt;init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// save init parameters for reset</span></span><br><span class="line">    mInitName = name;</span><br><span class="line">    mInitNameIsType = nameIsType;</span><br><span class="line">    mInitIsEncoder = encoder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Current video decoders do not return from OMX_FillThisBuffer</span></span><br><span class="line">    <span class="comment">// quickly, violating the OpenMAX specs, until that is remedied</span></span><br><span class="line">    <span class="comment">// we need to invest in an extra looper to free the main event</span></span><br><span class="line">    <span class="comment">// queue.</span></span><br><span class="line"></span><br><span class="line">    mCodec = GetCodecBase(name, nameIsType);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> secureCodec = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (nameIsType &amp;&amp; !strncasecmp(name.c_str(), <span class="string">"video/"</span>, <span class="number">6</span>)) &#123;</span><br><span class="line">        mIsVideo = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        AString tmp = name;</span><br><span class="line">        <span class="keyword">if</span> (tmp.endsWith(<span class="string">".secure"</span>)) &#123;</span><br><span class="line">            secureCodec = <span class="literal">true</span>;</span><br><span class="line">            tmp.erase(tmp.size() - <span class="number">7</span>, <span class="number">7</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> sp&lt;IMediaCodecList&gt; mcl = MediaCodecList::getInstance();</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">ssize_t</span> codecIdx = mcl-&gt;findCodecByName(tmp.c_str());</span><br><span class="line">        <span class="keyword">if</span> (codecIdx &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> sp&lt;MediaCodecInfo&gt; info = mcl-&gt;getCodecInfo(codecIdx);</span><br><span class="line">            Vector&lt;AString&gt; mimes;</span><br><span class="line">            info-&gt;getSupportedMimes(&amp;mimes);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mimes.size(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mimes[i].startsWith(<span class="string">"video/"</span>)) &#123;</span><br><span class="line">                    mIsVideo = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mIsVideo) &#123;</span><br><span class="line">        <span class="comment">// video codec needs dedicated looper</span></span><br><span class="line">        <span class="keyword">if</span> (mCodecLooper == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            mCodecLooper = <span class="keyword">new</span> ALooper;</span><br><span class="line">            mCodecLooper-&gt;setName(<span class="string">"CodecLooper"</span>);</span><br><span class="line">            mCodecLooper-&gt;start(<span class="literal">false</span>, <span class="literal">false</span>, ANDROID_PRIORITY_AUDIO);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mCodecLooper-&gt;registerHandler(mCodec);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mLooper-&gt;registerHandler(mCodec);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mLooper-&gt;registerHandler(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    mCodec-&gt;setNotificationMessage(<span class="keyword">new</span> AMessage(kWhatCodecNotify, <span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage(kWhatInit, <span class="keyword">this</span>);</span><br><span class="line">    msg-&gt;setString(<span class="string">"name"</span>, name);</span><br><span class="line">    msg-&gt;setInt32(<span class="string">"nameIsType"</span>, nameIsType);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nameIsType) &#123;</span><br><span class="line">        msg-&gt;setInt32(<span class="string">"encoder"</span>, encoder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line">    Vector&lt;MediaResource&gt; resources;</span><br><span class="line">    MediaResource::Type type =</span><br><span class="line">            secureCodec ? MediaResource::kSecureCodec : MediaResource::kNonSecureCodec;</span><br><span class="line">    MediaResource::SubType subtype =</span><br><span class="line">            mIsVideo ? MediaResource::kVideoCodec : MediaResource::kAudioCodec;</span><br><span class="line">    resources.push_back(MediaResource(type, subtype, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= kMaxRetry; ++i) &#123;</span><br><span class="line">        </span><br><span class="line">        sp&lt;AMessage&gt; response;</span><br><span class="line">        err = PostAndAwaitResponse(msg, &amp;response);</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-4-1、GetCodecBase"><a href="#2-3-4-1、GetCodecBase" class="headerlink" title="2.3.4.1、GetCodecBase"></a>2.3.4.1、GetCodecBase</h5><p>当编解码以”omx.”开头则创建ACodec对象。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\MediaCodec.cpp]</span><br><span class="line">sp&lt;CodecBase&gt; MediaCodec::GetCodecBase(<span class="keyword">const</span> AString &amp;name, <span class="keyword">bool</span> nameIsType) &#123;</span><br><span class="line">    <span class="comment">// at this time only ACodec specifies a mime type.</span></span><br><span class="line">    <span class="keyword">if</span> (nameIsType || name.startsWithIgnoreCase(<span class="string">"omx."</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ACodec;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.startsWithIgnoreCase(<span class="string">"android.filter."</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MediaFilter;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="2-3-4-2、MediaCodecList-getInstance"><a href="#2-3-4-2、MediaCodecList-getInstance" class="headerlink" title="2.3.4.2、MediaCodecList::getInstance()"></a>2.3.4.2、MediaCodecList::getInstance()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\MediaCodecList.cpp]</span><br><span class="line">sp&lt;IMediaCodecList&gt; MediaCodecList::getInstance() &#123;</span><br><span class="line">    Mutex::Autolock _l(sRemoteInitMutex);</span><br><span class="line">    <span class="keyword">if</span> (sRemoteList == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        sp&lt;IBinder&gt; binder =</span><br><span class="line">            defaultServiceManager()-&gt;getService(String16(<span class="string">"media.player"</span>));</span><br><span class="line">        sp&lt;IMediaPlayerService&gt; service =</span><br><span class="line">            interface_cast&lt;IMediaPlayerService&gt;(binder);</span><br><span class="line">        <span class="keyword">if</span> (service.get() != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            sRemoteList = service-&gt;getCodecList();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sRemoteList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过Binder通信获取MediaCodec列表。getCodecList()函数实现在</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\MediaPlayerService.cpp]</span><br><span class="line">sp&lt;IMediaCodecList&gt; MediaPlayerService::getCodecList() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> MediaCodecList::getLocalInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\MediaCodecList.cpp]</span><br><span class="line">sp&lt;IMediaCodecList&gt; MediaCodecList::getLocalInstance() &#123;</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(sInitMutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (sCodecList == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        MediaCodecList *codecList = <span class="keyword">new</span> MediaCodecList;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sCodecList;</span><br><span class="line">&#125;</span><br><span class="line">MediaCodecList::MediaCodecList()</span><br><span class="line">    : mInitCheck(NO_INIT),</span><br><span class="line">      mUpdate(<span class="literal">false</span>),</span><br><span class="line">      mGlobalSettings(<span class="keyword">new</span> AMessage()) &#123;</span><br><span class="line">    parseTopLevelXMLFile(<span class="string">"/etc/media_codecs.xml"</span>);</span><br><span class="line">    parseTopLevelXMLFile(<span class="string">"/etc/media_codecs_performance.xml"</span>, <span class="literal">true</span><span class="comment">/* ignore_errors */</span>);</span><br><span class="line">    parseTopLevelXMLFile(kProfilingResults, <span class="literal">true</span><span class="comment">/* ignore_errors */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>O(∩_∩)O哈哈~，终于分析到Codecs加载的地方了。还记得第一章节分析的附录吗，高通的音视频硬解码，这里再贴一下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">[AOSP/device/qcom/msm8996/media_codecs.xml(system/etc/media_codecs.xml)]</span><br><span class="line"></span><br><span class="line">    &lt;Decoders&gt;</span><br><span class="line">       &lt;!-- Video Hardware  --&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.avc"</span> type=<span class="string">"video/avc"</span> &gt;</span><br><span class="line">            &lt;Quirk name=<span class="string">"requires-allocate-on-input-ports"</span> /&gt;</span><br><span class="line">            &lt;Quirk name=<span class="string">"requires-allocate-on-output-ports"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"size"</span> min=<span class="string">"64x64"</span> max=<span class="string">"4096x2160"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"alignment"</span> value=<span class="string">"2x2"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"block-size"</span> value=<span class="string">"16x16"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"blocks-per-second"</span> min=<span class="string">"1"</span> max=<span class="string">"1958400"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"bitrate"</span> range=<span class="string">"1-100000000"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"frame-rate"</span> range=<span class="string">"1-240"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"vt-version"</span> value=<span class="string">"65537"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"vt-low-latency"</span> value=<span class="string">"1"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"vt-max-macroblock-processing-rate"</span> value=<span class="string">"972000"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"vt-max-level"</span> value=<span class="string">"52"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"vt-max-instances"</span> value=<span class="string">"16"</span> /&gt;</span><br><span class="line">            &lt;Feature name=<span class="string">"adaptive-playback"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"concurrent-instances"</span> max=<span class="string">"16"</span> /&gt;</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.avc.secure"</span> type=<span class="string">"video/avc"</span> &gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.mpeg4"</span> type=<span class="string">"video/mp4v-es"</span> &gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.h263"</span> type=<span class="string">"video/3gpp"</span> &gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.vc1"</span> type=<span class="string">"video/x-ms-wmv"</span> &gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.vc1.secure"</span> type=<span class="string">"video/x-ms-wmv"</span> &gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.divx"</span> type=<span class="string">"video/divx"</span> &gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.divx311"</span> type=<span class="string">"video/divx311"</span> &gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.divx4"</span> type=<span class="string">"video/divx4"</span> &gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.vp8"</span> type=<span class="string">"video/x-vnd.on2.vp8"</span> &gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.vp9"</span> type=<span class="string">"video/x-vnd.on2.vp9"</span> &gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.vp9.secure"</span> type=<span class="string">"video/x-vnd.on2.vp9"</span> &gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.hevc"</span> type=<span class="string">"video/hevc"</span> &gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.hevc.secure"</span> type=<span class="string">"video/hevc"</span> &gt;</span><br><span class="line">        &lt;!-- Audio Software  --&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qti.audio.decoder.flac"</span> type=<span class="string">"audio/flac"</span> /&gt;</span><br><span class="line">    &lt;/Decoders&gt;</span><br><span class="line">    &lt;Include href=<span class="string">"media_codecs_google_video.xml"</span> /&gt;</span><br></pre></td></tr></table></figure><h5 id="2-3-5、MediaCodec-gt-configure"><a href="#2-3-5、MediaCodec-gt-configure" class="headerlink" title="2.3.5、MediaCodec-&gt;configure()"></a>2.3.5、MediaCodec-&gt;configure()</h5><p>产生kWhatConfigure消息，在消息处理中调用ACodec::initiateConfigureComponent(…)又产生消息kWhatConfigureComponent，然后该消息处理中又调用了ACodec::LoadedState::onConfigureComponent(…)。然后在其中又会先调用ACodec::configureCodec(…)，在configureCodec中会对IOMX进行一系列的设置以及配置操作，通过Binder通信就对OMXNodeInstance进行相应的设置和配置操作，最终就对OMX组件进行了相应的设置和配置。然后向MediaCodec发送kWhatComponentConfigured消息，在消息处理中将MediaCodec状态设为CONFIGURED；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\MediaCodec.cpp]</span><br><span class="line"><span class="keyword">status_t</span> MediaCodec::configure(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;AMessage&gt; &amp;format,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Surface&gt; &amp;surface,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;ICrypto&gt; &amp;crypto,</span><br><span class="line">        <span class="keyword">uint32_t</span> flags) &#123;</span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage(kWhatConfigure, <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">case</span> kWhatConfigure:</span><br><span class="line">        &#123;</span><br><span class="line">            sp&lt;AReplyToken&gt; replyID;</span><br><span class="line">            ......</span><br><span class="line">            sp&lt;RefBase&gt; obj;</span><br><span class="line">            sp&lt;AMessage&gt; format;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">if</span> (obj != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                format-&gt;setObject(<span class="string">"native-window"</span>, obj);</span><br><span class="line">                <span class="keyword">status_t</span> err = handleSetSurface(<span class="keyword">static_cast</span>&lt;Surface *&gt;(obj.get()));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                handleSetSurface(<span class="literal">NULL</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mReplyID = replyID;</span><br><span class="line">            setState(CONFIGURING);</span><br><span class="line">            ......</span><br><span class="line">            extractCSD(format);</span><br><span class="line"></span><br><span class="line">            mCodec-&gt;initiateConfigureComponent(format);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\ACodec.cpp]</span><br><span class="line"><span class="keyword">void</span> ACodec::initiateConfigureComponent(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg) &#123;</span><br><span class="line">    msg-&gt;setWhat(kWhatConfigureComponent);</span><br><span class="line">    msg-&gt;setTarget(<span class="keyword">this</span>);</span><br><span class="line">    msg-&gt;post();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> ACodec::kWhatConfigureComponent:</span><br><span class="line">        &#123;</span><br><span class="line">            onConfigureComponent(msg);</span><br><span class="line">            handled = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">bool</span> ACodec::LoadedState::onConfigureComponent(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg) &#123;</span><br><span class="line">    <span class="keyword">status_t</span> err = OK;</span><br><span class="line">    AString mime;</span><br><span class="line">    <span class="keyword">if</span> (!msg-&gt;findString(<span class="string">"mime"</span>, &amp;mime)) &#123;</span><br><span class="line">        err = BAD_VALUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        err = mCodec-&gt;configureCodec(mime.c_str(), msg);</span><br><span class="line">    &#125;</span><br><span class="line">   ......</span><br><span class="line">    &#123;</span><br><span class="line">        sp&lt;AMessage&gt; notify = mCodec-&gt;mNotify-&gt;dup();</span><br><span class="line">        notify-&gt;setInt32(<span class="string">"what"</span>, CodecBase::kWhatComponentConfigured);</span><br><span class="line">        notify-&gt;setMessage(<span class="string">"input-format"</span>, mCodec-&gt;mInputFormat);</span><br><span class="line">        notify-&gt;setMessage(<span class="string">"output-format"</span>, mCodec-&gt;mOutputFormat);</span><br><span class="line">        notify-&gt;post();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-6、MediaCodec-gt-start"><a href="#2-3-6、MediaCodec-gt-start" class="headerlink" title="2.3.6、MediaCodec-&gt;start()"></a>2.3.6、MediaCodec-&gt;start()</h5><p>产生kWhatStart消息，消息处理中先将MediaCodec状态设为STARTING，然后调用ACodec::initiateStart()产生kWhatStart消息，在其消息处理中又调用ACodec::LoadedState::onStart()，然后在其中首先向IOMX发送状态转换命令，经过OMXNodeInstance最终对将OMX组件状态转换成Idle（转换完成时OMX会发送OMX_EventCmdComplete事件），接着对ACodec进行changeState至LoadedToIdleState。而在changeState过程中会调用ACodec::LoadedToIdleState::stateEntered() =&gt;  ACodec::LoadedToIdleState::allocateBuffers() =&gt; ACodec::allocateBuffersOnPort(…)，其中会为OMX组件端口分配缓冲，并向MediaCodec发送消息kWhatBuffersAllocated，消息处理中将MediaCodec状态设为STARTED而若allocateBuffers失败则由IOMX经OMXNodeInstance将OMX组件转换回Loaded状态，同时把ACodec状态转换回LoadedState</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\MediaCodec.cpp]</span><br><span class="line"><span class="keyword">status_t</span> MediaCodec::start() &#123;</span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage(kWhatStart, <span class="keyword">this</span>);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">case</span> kWhatStart:</span><br><span class="line">        &#123;</span><br><span class="line">            sp&lt;AReplyToken&gt; replyID;</span><br><span class="line">            ......</span><br><span class="line">            setState(STARTING);</span><br><span class="line"></span><br><span class="line">            mCodec-&gt;initiateStart();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\ACodec.cpp]</span><br><span class="line"><span class="keyword">void</span> ACodec::initiateStart() &#123;</span><br><span class="line">    (<span class="keyword">new</span> AMessage(kWhatStart, <span class="keyword">this</span>))-&gt;post();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> ACodec::kWhatStart:</span><br><span class="line">        &#123;</span><br><span class="line">            onStart();</span><br><span class="line">            handled = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> ACodec::LoadedState::onStart() &#123;</span><br><span class="line">    <span class="keyword">status_t</span> err = mCodec-&gt;mOMX-&gt;sendCommand(mCodec-&gt;mNode, OMX_CommandStateSet, OMX_StateIdle);</span><br><span class="line">    <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">        mCodec-&gt;signalError(OMX_ErrorUndefined, makeNoSideEffectStatus(err));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mCodec-&gt;changeState(mCodec-&gt;mLoadedToIdleState);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦缓冲区成功分配到输入和输出端口，OMX组件（编解码）会为Loaded-to-Idle状态生成OMX_EventCmdComplete事件转换并使用EventHandlerCallback将其发送给客户端。</p><h4 id="（三）、音视频解码数据处理"><a href="#（三）、音视频解码数据处理" class="headerlink" title="（三）、音视频解码数据处理"></a>（三）、音视频解码数据处理</h4><h5 id="3-1、音视频解码数据处理-emptyBuffer"><a href="#3-1、音视频解码数据处理-emptyBuffer" class="headerlink" title="3.1、音视频解码数据处理-emptyBuffer"></a>3.1、音视频解码数据处理-emptyBuffer</h5><p>还是老样子，先看看时序图，然后一步步分析</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/02-03-acodec-emptyBuffer.png" alt="Alt text"></p><p>1、    MediaCodec::start()之后ACodec是在LoadedToIdleState状态，此时若ACodec::LoadedToIdleState::onOMXEvent(…)接收到组件转换至Idle状态后的OMX_EventCmdComplete事件，会向IOMX发送状态转换命令，经过OMXNodeInstance最终对将OMX组件状态转换成Executing状态（这里OMX会发送OMX_EventCmdComplete事件），然后ACodec进行changeState至IdleToExecutingState。<br>2、    此时ACodec::IdleToExecutingState::onOMXEvent(…)检测到上面的OMX_EventCmdComplete事件后，会首先调用函数ACodec::ExecutingState::resume()，然后对ACodec进行changeState至ExecutingState。</p><h5 id="3-1-1、ACodec-ExecutingState-resume"><a href="#3-1-1、ACodec-ExecutingState-resume" class="headerlink" title="3.1.1、ACodec::ExecutingState::resume()"></a>3.1.1、ACodec::ExecutingState::resume()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\ACodec.cpp]</span><br><span class="line"><span class="keyword">void</span> ACodec::ExecutingState::resume() &#123;</span><br><span class="line">    submitOutputBuffers();</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mCodec-&gt;mBuffers[kPortIndexInput].size(); i++) &#123;</span><br><span class="line">        BufferInfo *info = &amp;mCodec-&gt;mBuffers[kPortIndexInput].editItemAt(i);</span><br><span class="line">        <span class="keyword">if</span> (info-&gt;mStatus == BufferInfo::OWNED_BY_US) &#123;</span><br><span class="line">            postFillThisBuffer(info);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mActive = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> ACodec::BaseState::postFillThisBuffer(BufferInfo *info) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mCodec-&gt;mPortEOS[kPortIndexInput]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CHECK_EQ((<span class="keyword">int</span>)info-&gt;mStatus, (<span class="keyword">int</span>)BufferInfo::OWNED_BY_US);</span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; notify = mCodec-&gt;mNotify-&gt;dup();</span><br><span class="line">    notify-&gt;setInt32(<span class="string">"what"</span>, CodecBase::kWhatFillThisBuffer);</span><br><span class="line">    notify-&gt;setInt32(<span class="string">"buffer-id"</span>, info-&gt;mBufferID);</span><br><span class="line"></span><br><span class="line">    info-&gt;mData-&gt;meta()-&gt;clear();</span><br><span class="line">    notify-&gt;setBuffer(<span class="string">"buffer"</span>, info-&gt;mData);</span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; reply = <span class="keyword">new</span> AMessage(kWhatInputBufferFilled, mCodec);</span><br><span class="line">    reply-&gt;setInt32(<span class="string">"buffer-id"</span>, info-&gt;mBufferID);</span><br><span class="line"></span><br><span class="line">    notify-&gt;setMessage(<span class="string">"reply"</span>, reply);</span><br><span class="line"></span><br><span class="line">    notify-&gt;post();</span><br><span class="line"></span><br><span class="line">    info-&gt;mStatus = BufferInfo::OWNED_BY_UPSTREAM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数ACodec::ExecutingState::resume()中会调用ACodec::BaseState::postFillThisBuffer(…)，然后其中会先向MediaCodec发送kWhatFillThisBuffer消息，消息处理中在满足相应的条件下就会去调用函数MediaCodec::onInputBufferAvailable()来通知NuPlayer::Decoder有可用的inputbuffer；然后再生成kWhatInputBufferFilled消息，消息处理中调用ACodec::BaseState::onInputBufferFilled(…)。<br>【产生两个消息，一个向上(MediaCodec)处理，一个向下(OMX)处理】</p><h5 id="3-1-1-1、kWhatFillThisBuffer消息处理"><a href="#3-1-1-1、kWhatFillThisBuffer消息处理" class="headerlink" title="3.1.1.1、kWhatFillThisBuffer消息处理"></a>3.1.1.1、kWhatFillThisBuffer消息处理</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\MediaCodec.cpp]</span><br><span class="line">                <span class="keyword">case</span> CodecBase::kWhatFillThisBuffer:</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* size_t index = */</span>updateBuffers(kPortIndexInput, msg);</span><br><span class="line">                    ......</span><br><span class="line">                    <span class="keyword">if</span> (mFlags &amp; kFlagIsAsync) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!mHaveInputSurface) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (mState == FLUSHED) &#123;</span><br><span class="line">                                mHavePendingInputBuffers = <span class="literal">true</span>;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                onInputBufferAvailable();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mFlags &amp; kFlagDequeueInputPending) &#123;</span><br><span class="line">                        ++mDequeueInputTimeoutGeneration;</span><br><span class="line">                        mFlags &amp;= ~kFlagDequeueInputPending;</span><br><span class="line">                        mDequeueInputReplyID = <span class="number">0</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        postActivityNotificationIfPossible();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="keyword">void</span> MediaCodec::onInputBufferAvailable() &#123;</span><br><span class="line">    <span class="keyword">int32_t</span> index;</span><br><span class="line">    <span class="keyword">while</span> ((index = dequeuePortBuffer(kPortIndexInput)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        sp&lt;AMessage&gt; msg = mCallback-&gt;dup();</span><br><span class="line">        msg-&gt;setInt32(<span class="string">"callbackID"</span>, CB_INPUT_AVAILABLE);</span><br><span class="line">        msg-&gt;setInt32(<span class="string">"index"</span>, index);</span><br><span class="line">        msg-&gt;post();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>P.S. 1：MediaCodec::onInputBufferAvailable()的调用：<br>其中会先调用函数MediaCodec::dequeuePortBuffer(…)获取buffer的索引，然后将一个新消息发送给NuPlayer::Decoder，并设置消息的callbackID为CB_INPUT_AVAILABLE，同时设置index，接着NuPlayer::Decoder接收到该CB_INPUT_AVAILABLE消息，在消息处理中调用NuPlayer::Decoder::handleAnInputBuffer(…)，其会：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayerDecoder.cpp]</span><br><span class="line"><span class="keyword">case</span> MediaCodec::CB_INPUT_AVAILABLE:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> index;</span><br><span class="line">    CHECK(msg-&gt;findInt32(<span class="string">"index"</span>, &amp;index));</span><br><span class="line"></span><br><span class="line">    handleAnInputBuffer(index);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> NuPlayer::Decoder::handleAnInputBuffer(<span class="keyword">size_t</span> index) &#123;</span><br><span class="line">    sp&lt;ABuffer&gt; buffer;</span><br><span class="line">    mCodec-&gt;getInputBuffer(index, &amp;buffer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= mInputBuffers.size()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = mInputBuffers.size(); i &lt;= index; ++i) &#123;</span><br><span class="line">            mInputBuffers.add();</span><br><span class="line">            mMediaBuffers.add();</span><br><span class="line">            mInputBufferIsDequeued.add();</span><br><span class="line">            mMediaBuffers.editItemAt(i) = <span class="literal">NULL</span>;</span><br><span class="line">            mInputBufferIsDequeued.editItemAt(i) = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mInputBuffers.editItemAt(index) = buffer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mMediaBuffers[index] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mMediaBuffers[index]-&gt;release();</span><br><span class="line">        mMediaBuffers.editItemAt(index) = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mInputBufferIsDequeued.editItemAt(index) = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mCSDsToSubmit.isEmpty()) &#123;</span><br><span class="line">        sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage();</span><br><span class="line">        msg-&gt;setSize(<span class="string">"buffer-ix"</span>, index);</span><br><span class="line"></span><br><span class="line">        sp&lt;ABuffer&gt; buffer = mCSDsToSubmit.itemAt(<span class="number">0</span>);</span><br><span class="line">        msg-&gt;setBuffer(<span class="string">"buffer"</span>, buffer);</span><br><span class="line">        mCSDsToSubmit.removeAt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!mPendingInputMessages.empty()) &#123;</span><br><span class="line">        sp&lt;AMessage&gt; msg = *mPendingInputMessages.begin();</span><br><span class="line">        <span class="keyword">if</span> (!onInputBufferFetched(msg)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mPendingInputMessages.erase(mPendingInputMessages.begin());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mInputBufferIsDequeued.editItemAt(index)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mDequeuedInputBuffers.push_back(index);</span><br><span class="line"></span><br><span class="line">    onRequestInputBuffers();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>○1、先通过MediaCodec::getInputBuffer(…) -&gt; MediaCodec::getBufferAndFormat(…)获取该buffer</p><p>○2、然后调用NuPlayer::Decoder::onInputBufferFetched(…)执行内存拷贝将buffer拷贝到编解码器，然后又调用了MediaCodec::queueInputBuffer(…)将buffer提交给解码器，其会产生消息kWhatQueueInputBuffer，消息处理中调用MediaCodec::onQueueInputBuffer(…)</p><p>○3、之后调用函数NuPlayer::DecoderBase::onRequestInputBuffers()，处理是否需要更多的数据。其中会调用NuPlayer::Decoder::doRequestBuffers，若返回true则需要更多的数据，则会产生新消息kWhatRequestInputBuffers，消息处理中又将调用onRequestInputBuffers。（实际获取更多缓冲的操作在下面ACodec部分完成）</p><h5 id="3-1-1-2、kWhatInputBufferFilled消息处理"><a href="#3-1-1-2、kWhatInputBufferFilled消息处理" class="headerlink" title="3.1.1.2、kWhatInputBufferFilled消息处理"></a>3.1.1.2、kWhatInputBufferFilled消息处理</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\ACodec.cpp]</span><br><span class="line">        <span class="keyword">case</span> kWhatInputBufferFilled:</span><br><span class="line">        &#123;</span><br><span class="line">            onInputBufferFilled(msg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">void</span> ACodec::BaseState::onInputBufferFilled(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg) &#123;</span><br><span class="line">    IOMX::buffer_id bufferID;</span><br><span class="line">    CHECK(msg-&gt;findInt32(<span class="string">"buffer-id"</span>, (<span class="keyword">int32_t</span>*)&amp;bufferID));</span><br><span class="line">    sp&lt;ABuffer&gt; buffer;</span><br><span class="line">    <span class="keyword">int32_t</span> err = OK;</span><br><span class="line">    <span class="keyword">bool</span> eos = <span class="literal">false</span>;</span><br><span class="line">    PortMode mode = getPortMode(kPortIndexInput);</span><br><span class="line">    <span class="keyword">int32_t</span> tmp;</span><br><span class="line">    BufferInfo *info = mCodec-&gt;findBufferByID(kPortIndexInput, bufferID);</span><br><span class="line">    BufferInfo::Status status = BufferInfo::getSafeStatus(info);</span><br><span class="line">    info-&gt;mStatus = BufferInfo::OWNED_BY_US;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (mode) &#123;</span><br><span class="line">        <span class="keyword">case</span> KEEP_BUFFERS:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (eos) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!mCodec-&gt;mPortEOS[kPortIndexInput]) &#123;</span><br><span class="line">                    mCodec-&gt;mPortEOS[kPortIndexInput] = <span class="literal">true</span>;</span><br><span class="line">                    mCodec-&gt;mInputEOSResult = err;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> RESUBMIT_BUFFERS:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (buffer != <span class="literal">NULL</span> &amp;&amp; !mCodec-&gt;mPortEOS[kPortIndexInput]) &#123;</span><br><span class="line">                <span class="keyword">int64_t</span> timeUs;</span><br><span class="line">                CHECK(buffer-&gt;meta()-&gt;findInt64(<span class="string">"timeUs"</span>, &amp;timeUs));</span><br><span class="line"></span><br><span class="line">                OMX_U32 flags = OMX_BUFFERFLAG_ENDOFFRAME;</span><br><span class="line"></span><br><span class="line">                MetadataBufferType metaType = mCodec-&gt;mInputMetadataType;</span><br><span class="line">                <span class="keyword">int32_t</span> isCSD = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (buffer-&gt;meta()-&gt;findInt32(<span class="string">"csd"</span>, &amp;isCSD) &amp;&amp; isCSD != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mCodec-&gt;mIsLegacyVP9Decoder) &#123;</span><br><span class="line">                        postFillThisBuffer(info);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    flags |= OMX_BUFFERFLAG_CODECCONFIG;</span><br><span class="line">                    metaType = kMetadataBufferTypeInvalid;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">               ......</span><br><span class="line">                <span class="keyword">if</span> (buffer != info-&gt;mCodecData) &#123;</span><br><span class="line">                    sp&lt;DataConverter&gt; converter = mCodec-&gt;mConverter[kPortIndexInput];</span><br><span class="line">                    <span class="keyword">status_t</span> err = converter-&gt;convert(buffer, info-&gt;mCodecData);</span><br><span class="line">                &#125;</span><br><span class="line">                ......</span><br><span class="line">                info-&gt;checkReadFence(<span class="string">"onInputBufferFilled"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">status_t</span> err2 = OK;</span><br><span class="line">                <span class="keyword">switch</span> (metaType) &#123;</span><br><span class="line">                <span class="keyword">case</span> kMetadataBufferTypeInvalid:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> OMX_ANDROID_COMPILE_AS_32BIT_ON_64BIT_PLATFORMS</span></span><br><span class="line">                <span class="keyword">case</span> kMetadataBufferTypeNativeHandleSource:</span><br><span class="line">                    <span class="keyword">if</span> (info-&gt;mCodecData-&gt;size() &gt;= <span class="keyword">sizeof</span>(VideoNativeHandleMetadata)) &#123;</span><br><span class="line">                        VideoNativeHandleMetadata *vnhmd =</span><br><span class="line">                            (VideoNativeHandleMetadata*)info-&gt;mCodecData-&gt;base();</span><br><span class="line">                        err2 = mCodec-&gt;mOMX-&gt;updateNativeHandleInMeta(</span><br><span class="line">                                mCodec-&gt;mNode, kPortIndexInput,</span><br><span class="line">                                NativeHandle::create(vnhmd-&gt;pHandle, <span class="literal">false</span> <span class="comment">/* ownsHandle */</span>),</span><br><span class="line">                                bufferID);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> kMetadataBufferTypeANWBuffer:</span><br><span class="line">                    <span class="keyword">if</span> (info-&gt;mCodecData-&gt;size() &gt;= <span class="keyword">sizeof</span>(VideoNativeMetadata)) &#123;</span><br><span class="line">                        VideoNativeMetadata *vnmd = (VideoNativeMetadata*)info-&gt;mCodecData-&gt;base();</span><br><span class="line">                        err2 = mCodec-&gt;mOMX-&gt;updateGraphicBufferInMeta(</span><br><span class="line">                                mCodec-&gt;mNode, kPortIndexInput,</span><br><span class="line">                                <span class="keyword">new</span> GraphicBuffer(vnmd-&gt;pBuffer, <span class="literal">false</span> <span class="comment">/* keepOwnership */</span>),</span><br><span class="line">                                bufferID);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    err2 = ERROR_UNSUPPORTED;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (err2 == OK) &#123;</span><br><span class="line">                    err2 = mCodec-&gt;mOMX-&gt;emptyBuffer(</span><br><span class="line">                        mCodec-&gt;mNode,</span><br><span class="line">                        bufferID,</span><br><span class="line">                        <span class="number">0</span>,</span><br><span class="line">                        info-&gt;mCodecData-&gt;size(),</span><br><span class="line">                        flags,</span><br><span class="line">                        timeUs,</span><br><span class="line">                        info-&gt;mFenceFd);</span><br><span class="line">                &#125;</span><br><span class="line">                info-&gt;mFenceFd = <span class="number">-1</span>;</span><br><span class="line">                ......</span><br><span class="line">                info-&gt;mStatus = BufferInfo::OWNED_BY_COMPONENT;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!eos &amp;&amp; err == OK) &#123;</span><br><span class="line">                    getMoreInputDataIfPossible();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ALOGV(<span class="string">"[%s] Signalled EOS (%d) on the input port"</span>,</span><br><span class="line">                         mCodec-&gt;mComponentName.c_str(), err);</span><br><span class="line"></span><br><span class="line">                    mCodec-&gt;mPortEOS[kPortIndexInput] = <span class="literal">true</span>;</span><br><span class="line">                    mCodec-&gt;mInputEOSResult = err;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mCodec-&gt;mPortEOS[kPortIndexInput]) &#123;</span><br><span class="line">                ......</span><br><span class="line"></span><br><span class="line">                info-&gt;checkReadFence(<span class="string">"onInputBufferFilled"</span>);</span><br><span class="line">                <span class="keyword">status_t</span> err2 = mCodec-&gt;mOMX-&gt;emptyBuffer(</span><br><span class="line">                        mCodec-&gt;mNode,</span><br><span class="line">                        bufferID,</span><br><span class="line">                        <span class="number">0</span>,</span><br><span class="line">                        <span class="number">0</span>,</span><br><span class="line">                        OMX_BUFFERFLAG_EOS,</span><br><span class="line">                        <span class="number">0</span>,</span><br><span class="line">                        info-&gt;mFenceFd);</span><br><span class="line">                info-&gt;mFenceFd = <span class="number">-1</span>;</span><br><span class="line">                ......</span><br><span class="line">                info-&gt;mStatus = BufferInfo::OWNED_BY_COMPONENT;</span><br><span class="line"></span><br><span class="line">                mCodec-&gt;mPortEOS[kPortIndexInput] = <span class="literal">true</span>;</span><br><span class="line">                mCodec-&gt;mInputEOSResult = err;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>P.S. 2：ACodec::BaseState::onInputBufferFilled(…)的调用：<br>因为当前ACodec在ExecutingState，所以PortMode为RESUBMIT_BUFFERS，故会调用IOMX的emptyBuffer(…)方法，经过进程间通信调用到OMX::emptyBuffer(…)，并最终调用OMXNodeInstance::emptyBuffer(…)，其中又会调用到函数OMXNodeInstance::emptyBuffer_l(…)，其则会调用OMX_EmptyThisBuffer宏对OMX组件进行相关的操作（根据需要选择相应的软解组件或者硬解组件）。对于软解组件SoftOMXComponent</p><p>○1、其的构造函数的初始化列表中有mComponent-&gt;EmptyThisBuffer = EmptyThisBufferWrapper;故实际会调用其EmptyThisBufferWrapper(…)函数，而其中调用SoftOMXComponent的虚函数emptyThisBuffer。</p><p>○2、所以调用子类的emptyThisBuffer即SimpleSoftOMXComponent::emptyThisBuffer(…)产生kWhatEmptyThisBuffer消息，消息处理中实际的解码器就要调用onQueueFilled(…)函数【实际组件继承自SimpleSoftOMXComponent】</p><p>○3、接着会调用SoftOMXComponent::notifyEmptyBufferDone(…)使用OMX的回调机制，闭环发送消息到OMX客户端ACodec。</p><p>○4、调用到OMXNodeInstance::OnEmptyBufferDone(…)，其又会调用OMX::OnEmptyBufferDone(…)，然后在其中会发送omx_message::EMPTY_BUFFER_DONE消息，ACodec中收到该消息【CodecObserver中先收到，但只设置消息】调用ACodec::BaseState::onOMXEmptyBufferDone(…)</p><p>○5、在onOMXEmptyBufferDone中获取PortMode，为RESUBMIT_BUFFERS则ACodec::BaseState::postFillThisBuffer(…)被调用，从而又从3中的postFillThisBuffer开始循环执行相关操作以处理更多的输入缓冲。</p><h5 id="3-2、音视频解码数据处理-fillBuffer"><a href="#3-2、音视频解码数据处理-fillBuffer" class="headerlink" title="3.2、音视频解码数据处理-fillBuffer"></a>3.2、音视频解码数据处理-fillBuffer</h5><p>还是老样子，先看看时序图，然后一步步分析</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/02-04-acodec-fillBuffer.png" alt="Alt text"></p><h5 id="3-2-1、ACodec-ExecutingState-resume"><a href="#3-2-1、ACodec-ExecutingState-resume" class="headerlink" title="3.2.1、ACodec::ExecutingState::resume()"></a>3.2.1、ACodec::ExecutingState::resume()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\ACodec.cpp]</span><br><span class="line"><span class="keyword">void</span> ACodec::ExecutingState::resume() &#123;</span><br><span class="line">    submitOutputBuffers();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mCodec-&gt;mBuffers[kPortIndexInput].size(); i++) &#123;</span><br><span class="line">        BufferInfo *info = &amp;mCodec-&gt;mBuffers[kPortIndexInput].editItemAt(i);</span><br><span class="line">        <span class="keyword">if</span> (info-&gt;mStatus == BufferInfo::OWNED_BY_US) &#123;</span><br><span class="line">            postFillThisBuffer(info);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mActive = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> ACodec::ExecutingState::submitOutputBuffers() &#123;</span><br><span class="line">    submitRegularOutputBuffers();</span><br><span class="line">    <span class="keyword">if</span> (mCodec-&gt;storingMetadataInDecodedBuffers()) &#123;</span><br><span class="line">        submitOutputMetaBuffers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> ACodec::ExecutingState::submitRegularOutputBuffers() &#123;</span><br><span class="line">    <span class="keyword">bool</span> failed = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mCodec-&gt;mBuffers[kPortIndexOutput].size(); ++i) &#123;</span><br><span class="line">        BufferInfo *info = &amp;mCodec-&gt;mBuffers[kPortIndexOutput].editItemAt(i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mCodec-&gt;mNativeWindow != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        info-&gt;checkWriteFence(<span class="string">"submitRegularOutputBuffers"</span>);</span><br><span class="line">        <span class="keyword">status_t</span> err = mCodec-&gt;mOMX-&gt;fillBuffer(mCodec-&gt;mNode, info-&gt;mBufferID, info-&gt;mFenceFd);</span><br><span class="line">        info-&gt;mFenceFd = <span class="number">-1</span>;</span><br><span class="line">        ......</span><br><span class="line">        info-&gt;mStatus = BufferInfo::OWNED_BY_COMPONENT;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、ACodec::ExecutingState::resume()函数，在resume()中调用ACodec::BaseState::postFillThisBuffer(…)前会先调用函数ACodec::ExecutingState::submitOutputBuffers()，即在获取输入数据前会先把输出端的数据提交出去。</p><p>2、在submitOutputBuffers()中调用ACodec::ExecutingState::submitRegularOutputBuffers()，其中又会调用到IOMX的fillBuffer (…)方法，经过进程间通信调用到OMX:: fillBuffer (…)，并最终调用OMXNodeInstance:: fillBuffer (…)，其中又会调用到OMX_FillThisBuffer宏对OMX组件进行相关的操作（同样根据需要选择相应的软解组件或者硬解组件）。对于软解组件SoftOMXComponent：（下面的操作与emptyBuffer时类似）</p><p>○1、在其构造函数的初始化列表中有mComponent-&gt;FillThisBuffer = FillThisBufferWrapper;所以实际会调用到其FillThisBufferWrapper (…)函数<br>○2、然后调用SimpleSoftOMXComponent::fillThisBuffer(…)产生kWhatFillThisBuffer消息，消息处理中实际的组件就要调用onQueueFilled(…)函数【实际组件继承自SimpleSoftOMXComponent】</p><p>○3、接着会调用SoftOMXComponent::notifyFillBufferDone(…)使用OMX的回调机制，闭环发送消息到OMX客户端ACodec。<br>○4之后调用到OMXNodeInstance:: OnFillBufferDone (…)函数，其又会调用OMX:: OnFillBufferDone (…)，然后在其中会发送omx_message:: FILL_BUFFER_DONE消息，ACodec中收到该消息【CodecObserver中先收到，但只设置消息】调用ACodec::BaseState:: onOMXFillBufferDone (…)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\ACodec.cpp]</span><br><span class="line"><span class="keyword">bool</span> ACodec::BaseState::onOMXFillBufferDone(</span><br><span class="line">        IOMX::buffer_id bufferID,</span><br><span class="line">        <span class="keyword">size_t</span> rangeOffset, <span class="keyword">size_t</span> rangeLength,</span><br><span class="line">        OMX_U32 flags,</span><br><span class="line">        <span class="keyword">int64_t</span> timeUs,</span><br><span class="line">        <span class="keyword">int</span> fenceFd) &#123;</span><br><span class="line">    ALOGV(<span class="string">"[%s] onOMXFillBufferDone %u time %"</span> PRId64 <span class="string">" us, flags = 0x%08x"</span>,</span><br><span class="line">         mCodec-&gt;mComponentName.c_str(), bufferID, timeUs, flags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ssize_t</span> index;</span><br><span class="line">    <span class="keyword">status_t</span> err= OK;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TRACK_BUFFER_TIMING</span></span><br><span class="line">    index = mCodec-&gt;mBufferStats.indexOfKey(timeUs);</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        ACodec::BufferStats *stats = &amp;mCodec-&gt;mBufferStats.editValueAt(index);</span><br><span class="line">        stats-&gt;mFillBufferDoneTimeUs = ALooper::GetNowUs();</span><br><span class="line"></span><br><span class="line">        ALOGI(<span class="string">"frame PTS %lld: %lld"</span>,</span><br><span class="line">                timeUs,</span><br><span class="line">                stats-&gt;mFillBufferDoneTimeUs - stats-&gt;mEmptyBufferTimeUs);</span><br><span class="line"></span><br><span class="line">        mCodec-&gt;mBufferStats.removeItemsAt(index);</span><br><span class="line">        stats = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    BufferInfo *info =</span><br><span class="line">        mCodec-&gt;findBufferByID(kPortIndexOutput, bufferID, &amp;index);</span><br><span class="line">    BufferInfo::Status status = BufferInfo::getSafeStatus(info);</span><br><span class="line">    <span class="keyword">if</span> (status != BufferInfo::OWNED_BY_COMPONENT) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Wrong ownership in FBD: %s(%d) buffer #%u"</span>, _asString(status), status, bufferID);</span><br><span class="line">        mCodec-&gt;dumpBuffers(kPortIndexOutput);</span><br><span class="line">        mCodec-&gt;signalError(OMX_ErrorUndefined, FAILED_TRANSACTION);</span><br><span class="line">        <span class="keyword">if</span> (fenceFd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            ::close(fenceFd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    info-&gt;mDequeuedAt = ++mCodec-&gt;mDequeueCounter;</span><br><span class="line">    info-&gt;mStatus = BufferInfo::OWNED_BY_US;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (info-&gt;mRenderInfo != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// The fence for an emptied buffer must have signaled, but there still could be queued</span></span><br><span class="line">        <span class="comment">// or out-of-order dequeued buffers in the render queue prior to this buffer. Drop these,</span></span><br><span class="line">        <span class="comment">// as we will soon requeue this buffer to the surface. While in theory we could still keep</span></span><br><span class="line">        <span class="comment">// track of buffers that are requeued to the surface, it is better to add support to the</span></span><br><span class="line">        <span class="comment">// buffer-queue to notify us of released buffers and their fences (in the future).</span></span><br><span class="line">        mCodec-&gt;notifyOfRenderedFrames(<span class="literal">true</span> <span class="comment">/* dropIncomplete */</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// byte buffers cannot take fences, so wait for any fence now</span></span><br><span class="line">    <span class="keyword">if</span> (mCodec-&gt;mNativeWindow == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        (<span class="keyword">void</span>)mCodec-&gt;waitForFence(fenceFd, <span class="string">"onOMXFillBufferDone"</span>);</span><br><span class="line">        fenceFd = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    info-&gt;setReadFence(fenceFd, <span class="string">"onOMXFillBufferDone"</span>);</span><br><span class="line"></span><br><span class="line">    PortMode mode = getPortMode(kPortIndexOutput);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (mode) &#123;</span><br><span class="line">        <span class="keyword">case</span> KEEP_BUFFERS:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> RESUBMIT_BUFFERS:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (rangeLength == <span class="number">0</span> &amp;&amp; (!(flags &amp; OMX_BUFFERFLAG_EOS)</span><br><span class="line">                    || mCodec-&gt;mPortEOS[kPortIndexOutput])) &#123;</span><br><span class="line">                ......</span><br><span class="line">                err = mCodec-&gt;mOMX-&gt;fillBuffer(mCodec-&gt;mNode, info-&gt;mBufferID, info-&gt;mFenceFd);</span><br><span class="line">                info-&gt;mFenceFd = <span class="number">-1</span>;</span><br><span class="line">                ......</span><br><span class="line">                info-&gt;mStatus = BufferInfo::OWNED_BY_COMPONENT;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            sp&lt;AMessage&gt; reply =</span><br><span class="line">                <span class="keyword">new</span> AMessage(kWhatOutputBufferDrained, mCodec);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mCodec-&gt;mOutputFormat != mCodec-&gt;mLastOutputFormat &amp;&amp; rangeLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// pretend that output format has changed on the first frame (we used to do this)</span></span><br><span class="line">                <span class="keyword">if</span> (mCodec-&gt;mBaseOutputFormat == mCodec-&gt;mOutputFormat) &#123;</span><br><span class="line">                    mCodec-&gt;onOutputFormatChanged(mCodec-&gt;mOutputFormat);</span><br><span class="line">                &#125;</span><br><span class="line">                mCodec-&gt;addKeyFormatChangesToRenderBufferNotification(reply);</span><br><span class="line">                mCodec-&gt;sendFormatChange();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rangeLength &gt; <span class="number">0</span> &amp;&amp; mCodec-&gt;mNativeWindow != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">// If potentially rendering onto a surface, always save key format data (crop &amp;</span></span><br><span class="line">                <span class="comment">// data space) so that we can set it if and once the buffer is rendered.</span></span><br><span class="line">                mCodec-&gt;addKeyFormatChangesToRenderBufferNotification(reply);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mCodec-&gt;usingMetadataOnEncoderOutput()) &#123;</span><br><span class="line">                <span class="keyword">native_handle_t</span> *handle = <span class="literal">NULL</span>;</span><br><span class="line">                VideoNativeHandleMetadata &amp;nativeMeta =</span><br><span class="line">                    *(VideoNativeHandleMetadata *)info-&gt;mData-&gt;data();</span><br><span class="line">                <span class="keyword">if</span> (info-&gt;mData-&gt;size() &gt;= <span class="keyword">sizeof</span>(nativeMeta)</span><br><span class="line">                        &amp;&amp; nativeMeta.eType == kMetadataBufferTypeNativeHandleSource) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> OMX_ANDROID_COMPILE_AS_32BIT_ON_64BIT_PLATFORMS</span></span><br><span class="line">                    <span class="comment">// handle is only valid on 32-bit/mediaserver process</span></span><br><span class="line">                    handle = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">                    handle = (<span class="keyword">native_handle_t</span> *)nativeMeta.pHandle;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                &#125;</span><br><span class="line">                info-&gt;mData-&gt;meta()-&gt;setPointer(<span class="string">"handle"</span>, handle);</span><br><span class="line">                info-&gt;mData-&gt;meta()-&gt;setInt32(<span class="string">"rangeOffset"</span>, rangeOffset);</span><br><span class="line">                info-&gt;mData-&gt;meta()-&gt;setInt32(<span class="string">"rangeLength"</span>, rangeLength);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (info-&gt;mData == info-&gt;mCodecData) &#123;</span><br><span class="line">                info-&gt;mData-&gt;setRange(rangeOffset, rangeLength);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                info-&gt;mCodecData-&gt;setRange(rangeOffset, rangeLength);</span><br><span class="line">                <span class="comment">// in this case we know that mConverter is not null</span></span><br><span class="line">                <span class="keyword">status_t</span> err = mCodec-&gt;mConverter[kPortIndexOutput]-&gt;convert(</span><br><span class="line">                        info-&gt;mCodecData, info-&gt;mData);</span><br><span class="line">                <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">                    mCodec-&gt;signalError(OMX_ErrorUndefined, makeNoSideEffectStatus(err));</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mCodec-&gt;mSkipCutBuffer != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                mCodec-&gt;mSkipCutBuffer-&gt;submit(info-&gt;mData);</span><br><span class="line">            &#125;</span><br><span class="line">            info-&gt;mData-&gt;meta()-&gt;setInt64(<span class="string">"timeUs"</span>, timeUs);</span><br><span class="line"></span><br><span class="line">            sp&lt;AMessage&gt; notify = mCodec-&gt;mNotify-&gt;dup();</span><br><span class="line">            notify-&gt;setInt32(<span class="string">"what"</span>, CodecBase::kWhatDrainThisBuffer);</span><br><span class="line">            notify-&gt;setInt32(<span class="string">"buffer-id"</span>, info-&gt;mBufferID);</span><br><span class="line">            notify-&gt;setBuffer(<span class="string">"buffer"</span>, info-&gt;mData);</span><br><span class="line">            notify-&gt;setInt32(<span class="string">"flags"</span>, flags);</span><br><span class="line"></span><br><span class="line">            reply-&gt;setInt32(<span class="string">"buffer-id"</span>, info-&gt;mBufferID);</span><br><span class="line"></span><br><span class="line">            notify-&gt;setMessage(<span class="string">"reply"</span>, reply);</span><br><span class="line"></span><br><span class="line">            notify-&gt;post();</span><br><span class="line"></span><br><span class="line">            info-&gt;mStatus = BufferInfo::OWNED_BY_DOWNSTREAM;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (flags &amp; OMX_BUFFERFLAG_EOS) &#123;</span><br><span class="line">                ALOGV(<span class="string">"[%s] saw output EOS"</span>, mCodec-&gt;mComponentName.c_str());</span><br><span class="line"></span><br><span class="line">                sp&lt;AMessage&gt; notify = mCodec-&gt;mNotify-&gt;dup();</span><br><span class="line">                notify-&gt;setInt32(<span class="string">"what"</span>, CodecBase::kWhatEOS);</span><br><span class="line">                notify-&gt;setInt32(<span class="string">"err"</span>, mCodec-&gt;mInputEOSResult);</span><br><span class="line">                notify-&gt;post();</span><br><span class="line"></span><br><span class="line">                mCodec-&gt;mPortEOS[kPortIndexOutput] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> FREE_BUFFERS:</span><br><span class="line">            err = mCodec-&gt;freeBuffer(kPortIndexOutput, index);</span><br><span class="line">            <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">                mCodec-&gt;signalError(OMX_ErrorUndefined, makeNoSideEffectStatus(err));</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            ALOGE(<span class="string">"Invalid port mode: %d"</span>, mode);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>○5、在onOMXFillBufferDone中获取PortMode，为RESUBMIT_BUFFERS则首先如果需要继续调用到IOMX的fillBuffer (…)填充输出缓冲重复做相关操作，接着ACodec又会生成一个kWhatOutputBufferDrained消息存在reply中，作为kWhatDrainThisBuffer消息的返回消息【notify-&gt;setMessage(“reply”, reply);】，然后向MediaCodec发送消息kWhatDrainThisBuffer，消息处理中调用函数MediaCodec::onOutputBufferAvailable()通知NuPlayer::Decoder有可用的output buffer，其中会设置消息的callbackID为CB_OUTPUT_AVAILABLE，同时设置index，接着NuPlayer::Decoder接收到该CB_OUTPUT_AVAILABLE消息，在消息处理中调用NuPlayer::Decoder::handleAnOutputBuffer(…)，在其中会进行如下处理：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\MediaCodec.cpp]</span><br><span class="line"><span class="keyword">void</span> MediaCodec::onOutputBufferAvailable() &#123;</span><br><span class="line">    <span class="keyword">int32_t</span> index;</span><br><span class="line">    <span class="keyword">while</span> ((index = dequeuePortBuffer(kPortIndexOutput)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> sp&lt;ABuffer&gt; &amp;buffer =</span><br><span class="line">            mPortBuffers[kPortIndexOutput].itemAt(index).mData;</span><br><span class="line">        sp&lt;AMessage&gt; msg = mCallback-&gt;dup();</span><br><span class="line">        msg-&gt;setInt32(<span class="string">"callbackID"</span>, CB_OUTPUT_AVAILABLE);</span><br><span class="line">        msg-&gt;setInt32(<span class="string">"index"</span>, index);</span><br><span class="line">        msg-&gt;setSize(<span class="string">"offset"</span>, buffer-&gt;offset());</span><br><span class="line">        msg-&gt;setSize(<span class="string">"size"</span>, buffer-&gt;size());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int64_t</span> timeUs;</span><br><span class="line">        CHECK(buffer-&gt;meta()-&gt;findInt64(<span class="string">"timeUs"</span>, &amp;timeUs));</span><br><span class="line"></span><br><span class="line">        msg-&gt;setInt64(<span class="string">"timeUs"</span>, timeUs);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int32_t</span> omxFlags;</span><br><span class="line">        CHECK(buffer-&gt;meta()-&gt;findInt32(<span class="string">"omxFlags"</span>, &amp;omxFlags));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">uint32_t</span> flags = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (omxFlags &amp; OMX_BUFFERFLAG_SYNCFRAME) &#123;</span><br><span class="line">            flags |= BUFFER_FLAG_SYNCFRAME;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (omxFlags &amp; OMX_BUFFERFLAG_CODECCONFIG) &#123;</span><br><span class="line">            flags |= BUFFER_FLAG_CODECCONFIG;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (omxFlags &amp; OMX_BUFFERFLAG_EOS) &#123;</span><br><span class="line">            flags |= BUFFER_FLAG_EOS;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg-&gt;setInt32(<span class="string">"flags"</span>, flags);</span><br><span class="line"></span><br><span class="line">        msg-&gt;post();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（四）、多媒体文件-音视频渲染（Renderer）"><a href="#（四）、多媒体文件-音视频渲染（Renderer）" class="headerlink" title="（四）、多媒体文件 - 音视频渲染（Renderer）"></a>（四）、多媒体文件 - 音视频渲染（Renderer）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayerDecoder.cpp]</span><br><span class="line"><span class="keyword">bool</span> NuPlayer::Decoder::handleAnOutputBuffer(</span><br><span class="line">        <span class="keyword">size_t</span> index,</span><br><span class="line">        <span class="keyword">size_t</span> offset,</span><br><span class="line">        <span class="keyword">size_t</span> size,</span><br><span class="line">        <span class="keyword">int64_t</span> timeUs,</span><br><span class="line">        <span class="keyword">int32_t</span> flags) &#123;</span><br><span class="line">    sp&lt;ABuffer&gt; buffer;</span><br><span class="line">    mCodec-&gt;getOutputBuffer(index, &amp;buffer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= mOutputBuffers.size()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = mOutputBuffers.size(); i &lt;= index; ++i) &#123;</span><br><span class="line">            mOutputBuffers.add();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mOutputBuffers.editItemAt(index) = buffer;</span><br><span class="line"></span><br><span class="line">    buffer-&gt;setRange(offset, size);</span><br><span class="line">    buffer-&gt;meta()-&gt;clear();</span><br><span class="line">    buffer-&gt;meta()-&gt;setInt64(<span class="string">"timeUs"</span>, timeUs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> eos = flags &amp; MediaCodec::BUFFER_FLAG_EOS;</span><br><span class="line">    <span class="comment">// we do not expect CODECCONFIG or SYNCFRAME for decoder</span></span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; reply = <span class="keyword">new</span> AMessage(kWhatRenderBuffer, <span class="keyword">this</span>);</span><br><span class="line">    reply-&gt;setSize(<span class="string">"buffer-ix"</span>, index);</span><br><span class="line">    reply-&gt;setInt32(<span class="string">"generation"</span>, mBufferGeneration);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (eos) &#123;</span><br><span class="line">        buffer-&gt;meta()-&gt;setInt32(<span class="string">"eos"</span>, <span class="literal">true</span>);</span><br><span class="line">        reply-&gt;setInt32(<span class="string">"eos"</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mSkipRenderingUntilMediaTimeUs &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (timeUs &lt; mSkipRenderingUntilMediaTimeUs) &#123;</span><br><span class="line">            reply-&gt;post();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mSkipRenderingUntilMediaTimeUs = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mNumFramesTotal += !mIsAudio;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait until 1st frame comes out to signal resume complete</span></span><br><span class="line">    notifyResumeCompleteIfNecessary();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mRenderer != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// send the buffer to renderer.</span></span><br><span class="line">        mRenderer-&gt;queueBuffer(mIsAudio, buffer, reply);</span><br><span class="line">        <span class="keyword">if</span> (eos &amp;&amp; !isDiscontinuityPending()) &#123;</span><br><span class="line">            mRenderer-&gt;queueEOS(mIsAudio, ERROR_END_OF_STREAM);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>a.    在kWhatRenderBuffer消息处理中会调用NuPlayer::Decoder::onRenderBuffer(…)，在其中根据情况调用函数MediaCodec::renderOutputBufferAndRelease(..)渲染并释放，或者调用MediaCodec::releaseOutputBuffer(…)不渲染直接释放，两中情况都会产生kWhatReleaseOutputBuffer消息，该消息处理中调用函数MediaCodec::onReleaseOutputBuffer(…)，其中判断若SoftRenderer非空则进行软件渲染，不然就会通过○5中的reply让ACodec去硬件渲染，在kWhatOutputBufferDrained消息处理就会中调用到函数ACodec::BaseState::onOutputBufferDrained(…)进行真正的硬件渲染。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayerDecoder.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::Decoder::onRenderBuffer(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg) &#123;</span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line">    <span class="keyword">int32_t</span> render;</span><br><span class="line">    <span class="keyword">size_t</span> bufferIx;</span><br><span class="line">    <span class="keyword">int32_t</span> eos;</span><br><span class="line">    CHECK(msg-&gt;findSize(<span class="string">"buffer-ix"</span>, &amp;bufferIx));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mIsAudio) &#123;</span><br><span class="line">        <span class="keyword">int64_t</span> timeUs;</span><br><span class="line">        sp&lt;ABuffer&gt; buffer = mOutputBuffers[bufferIx];</span><br><span class="line">        buffer-&gt;meta()-&gt;findInt64(<span class="string">"timeUs"</span>, &amp;timeUs);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mCCDecoder != <span class="literal">NULL</span> &amp;&amp; mCCDecoder-&gt;isSelected()) &#123;</span><br><span class="line">            mCCDecoder-&gt;display(timeUs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (msg-&gt;findInt32(<span class="string">"render"</span>, &amp;render) &amp;&amp; render) &#123;</span><br><span class="line">        <span class="keyword">int64_t</span> timestampNs;</span><br><span class="line">        CHECK(msg-&gt;findInt64(<span class="string">"timestampNs"</span>, &amp;timestampNs));</span><br><span class="line">        err = mCodec-&gt;renderOutputBufferAndRelease(bufferIx, timestampNs);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mNumOutputFramesDropped += !mIsAudio;</span><br><span class="line">        err = mCodec-&gt;releaseOutputBuffer(bufferIx);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b.    MediaCodec:: getOutputBuffer (…) -&gt; MediaCodec::getBufferAndFormat(…)获取该buffer的信息<br>c.    若Renderer非空则会调用NuPlayer::Renderer::queueBuffer(…)进行Renderer的相关处理同时消耗产生的kWhatRenderBuffer消息。queueBuffer()会产生kWhatQueueBuffer消息，消息处理中会调用函数NuPlayer::Renderer::onQueueBuffer(…) –&gt; NuPlayer::Renderer::postDrainVideoQueue() 【另外有audio的相关处理】，其中产生kWhatDrainVideoQueue消息，消息处理中调用先NuPlayer::Renderer::onDrainVideoQueue()在VideoQueue中取相关数据，再调用NuPlayer::Renderer::postDrainVideoQueue()循环取video数据，接着还会发送kWhatRenderBuffer消息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayerRenderer.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::Renderer::onQueueBuffer(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg) &#123;</span><br><span class="line">    <span class="keyword">int32_t</span> audio;</span><br><span class="line">    <span class="keyword">if</span> (audio) &#123;</span><br><span class="line">        mHasAudio = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mHasVideo = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mHasVideo) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mVideoScheduler == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            mVideoScheduler = <span class="keyword">new</span> VideoFrameScheduler();</span><br><span class="line">            mVideoScheduler-&gt;init();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;ABuffer&gt; buffer;</span><br><span class="line">    CHECK(msg-&gt;findBuffer(<span class="string">"buffer"</span>, &amp;buffer));</span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; notifyConsumed;</span><br><span class="line">    CHECK(msg-&gt;findMessage(<span class="string">"notifyConsumed"</span>, &amp;notifyConsumed));</span><br><span class="line"></span><br><span class="line">    QueueEntry entry;</span><br><span class="line">    entry.mBuffer = buffer;</span><br><span class="line">    entry.mNotifyConsumed = notifyConsumed;</span><br><span class="line">    entry.mOffset = <span class="number">0</span>;</span><br><span class="line">    entry.mFinalResult = OK;</span><br><span class="line">    entry.mBufferOrdinal = ++mTotalBuffersQueued;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (audio) &#123;</span><br><span class="line">        Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(mLock)</span></span>;</span><br><span class="line">        mAudioQueue.push_back(entry);</span><br><span class="line">        postDrainAudioQueue_l();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mVideoQueue.push_back(entry);</span><br><span class="line">        postDrainVideoQueue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(mLock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!mSyncQueues || mAudioQueue.empty() || mVideoQueue.empty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;ABuffer&gt; firstAudioBuffer = (*mAudioQueue.begin()).mBuffer;</span><br><span class="line">    sp&lt;ABuffer&gt; firstVideoBuffer = (*mVideoQueue.begin()).mBuffer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (firstAudioBuffer == <span class="literal">NULL</span> || firstVideoBuffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        syncQueuesDone_l();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int64_t</span> firstAudioTimeUs;</span><br><span class="line">    <span class="keyword">int64_t</span> firstVideoTimeUs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int64_t</span> diff = firstVideoTimeUs - firstAudioTimeUs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (diff &gt; <span class="number">100000l</span>l) &#123;</span><br><span class="line">        (*mAudioQueue.begin()).mNotifyConsumed-&gt;post();</span><br><span class="line">        mAudioQueue.erase(mAudioQueue.begin());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    syncQueuesDone_l();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/02-05-source-demux-decoder-output-render.jpg" alt="Alt text"></p><h4 id="（五）、视频解码输出到SurfaceFlinger"><a href="#（五）、视频解码输出到SurfaceFlinger" class="headerlink" title="（五）、视频解码输出到SurfaceFlinger"></a>（五）、视频解码输出到SurfaceFlinger</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\ACodec.cpp]</span><br><span class="line"><span class="keyword">void</span> ACodec::BaseState::onOutputBufferDrained(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg) &#123;</span><br><span class="line">    IOMX::buffer_id bufferID;</span><br><span class="line">    CHECK(msg-&gt;findInt32(<span class="string">"buffer-id"</span>, (<span class="keyword">int32_t</span>*)&amp;bufferID));</span><br><span class="line">    <span class="keyword">ssize_t</span> index;</span><br><span class="line">    BufferInfo *info = mCodec-&gt;findBufferByID(kPortIndexOutput, bufferID, &amp;index);</span><br><span class="line">    BufferInfo::Status status = BufferInfo::getSafeStatus(info);</span><br><span class="line">    <span class="keyword">if</span> (status != BufferInfo::OWNED_BY_DOWNSTREAM) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Wrong ownership in OBD: %s(%d) buffer #%u"</span>, _asString(status), status, bufferID);</span><br><span class="line">        mCodec-&gt;dumpBuffers(kPortIndexOutput);</span><br><span class="line">        mCodec-&gt;signalError(OMX_ErrorUndefined, FAILED_TRANSACTION);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">android_native_rect_t</span> crop;</span><br><span class="line">    <span class="keyword">if</span> (msg-&gt;findRect(<span class="string">"crop"</span>, &amp;crop.left, &amp;crop.top, &amp;crop.right, &amp;crop.bottom)</span><br><span class="line">            &amp;&amp; <span class="built_in">memcmp</span>(&amp;crop, &amp;mCodec-&gt;mLastNativeWindowCrop, <span class="keyword">sizeof</span>(crop)) != <span class="number">0</span>) &#123;</span><br><span class="line">        mCodec-&gt;mLastNativeWindowCrop = crop;</span><br><span class="line">        <span class="keyword">status_t</span> err = native_window_set_crop(mCodec-&gt;mNativeWindow.get(), &amp;crop);</span><br><span class="line">        ALOGW_IF(err != NO_ERROR, <span class="string">"failed to set crop: %d"</span>, err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int32_t</span> dataSpace;</span><br><span class="line">    <span class="keyword">if</span> (msg-&gt;findInt32(<span class="string">"dataspace"</span>, &amp;dataSpace)</span><br><span class="line">            &amp;&amp; dataSpace != mCodec-&gt;mLastNativeWindowDataSpace) &#123;</span><br><span class="line">        <span class="keyword">status_t</span> err = native_window_set_buffers_data_space(</span><br><span class="line">                mCodec-&gt;mNativeWindow.get(), (android_dataspace)dataSpace);</span><br><span class="line">        mCodec-&gt;mLastNativeWindowDataSpace = dataSpace;</span><br><span class="line">        ALOGW_IF(err != NO_ERROR, <span class="string">"failed to set dataspace: %d"</span>, err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int32_t</span> render;</span><br><span class="line">    <span class="keyword">if</span> (mCodec-&gt;mNativeWindow != <span class="literal">NULL</span></span><br><span class="line">            &amp;&amp; msg-&gt;findInt32(<span class="string">"render"</span>, &amp;render) &amp;&amp; render != <span class="number">0</span></span><br><span class="line">            &amp;&amp; info-&gt;mData != <span class="literal">NULL</span> &amp;&amp; info-&gt;mData-&gt;size() != <span class="number">0</span>) &#123;</span><br><span class="line">        ATRACE_NAME(<span class="string">"render"</span>);</span><br><span class="line">        <span class="comment">// The client wants this buffer to be rendered.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// save buffers sent to the surface so we can get render time when they return</span></span><br><span class="line">        <span class="keyword">int64_t</span> mediaTimeUs = <span class="number">-1</span>;</span><br><span class="line">        info-&gt;mData-&gt;meta()-&gt;findInt64(<span class="string">"timeUs"</span>, &amp;mediaTimeUs);</span><br><span class="line">        <span class="keyword">if</span> (mediaTimeUs &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            mCodec-&gt;mRenderTracker.onFrameQueued(</span><br><span class="line">                    mediaTimeUs, info-&gt;mGraphicBuffer, <span class="keyword">new</span> Fence(::dup(info-&gt;mFenceFd)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int64_t</span> timestampNs = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!msg-&gt;findInt64(<span class="string">"timestampNs"</span>, &amp;timestampNs)) &#123;</span><br><span class="line">            <span class="comment">// use media timestamp if client did not request a specific render timestamp</span></span><br><span class="line">            <span class="keyword">if</span> (info-&gt;mData-&gt;meta()-&gt;findInt64(<span class="string">"timeUs"</span>, &amp;timestampNs)) &#123;</span><br><span class="line">                ALOGV(<span class="string">"using buffer PTS of %lld"</span>, (<span class="keyword">long</span> <span class="keyword">long</span>)timestampNs);</span><br><span class="line">                timestampNs *= <span class="number">1000</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">status_t</span> err;</span><br><span class="line">        err = native_window_set_buffers_timestamp(mCodec-&gt;mNativeWindow.get(), timestampNs);</span><br><span class="line">        ALOGW_IF(err != NO_ERROR, <span class="string">"failed to set buffer timestamp: %d"</span>, err);</span><br><span class="line"></span><br><span class="line">        info-&gt;checkReadFence(<span class="string">"onOutputBufferDrained before queueBuffer"</span>);</span><br><span class="line">        err = mCodec-&gt;mNativeWindow-&gt;queueBuffer(</span><br><span class="line">                    mCodec-&gt;mNativeWindow.get(), info-&gt;mGraphicBuffer.get(), info-&gt;mFenceFd);</span><br><span class="line">        info-&gt;mFenceFd = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (err == OK) &#123;</span><br><span class="line">            info-&gt;mStatus = BufferInfo::OWNED_BY_NATIVE_WINDOW;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ALOGE(<span class="string">"queueBuffer failed in onOutputBufferDrained: %d"</span>, err);</span><br><span class="line">            mCodec-&gt;signalError(OMX_ErrorUndefined, makeNoSideEffectStatus(err));</span><br><span class="line">            info-&gt;mStatus = BufferInfo::OWNED_BY_US;</span><br><span class="line">            <span class="comment">// keeping read fence as write fence to avoid clobbering</span></span><br><span class="line">            info-&gt;mIsReadFence = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCodec-&gt;mNativeWindow != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">            (info-&gt;mData == <span class="literal">NULL</span> || info-&gt;mData-&gt;size() != <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="comment">// move read fence into write fence to avoid clobbering</span></span><br><span class="line">            info-&gt;mIsReadFence = <span class="literal">false</span>;</span><br><span class="line">            ATRACE_NAME(<span class="string">"frame-drop"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        info-&gt;mStatus = BufferInfo::OWNED_BY_US;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-1、Surfaceflinger-视频解码缓存申请"><a href="#5-1、Surfaceflinger-视频解码缓存申请" class="headerlink" title="5.1、Surfaceflinger 视频解码缓存申请"></a>5.1、Surfaceflinger 视频解码缓存申请</h5><p>前面2.3.6、MediaCodec-&gt;start()分析过：<br>产生kWhatStart消息，消息处理中先将MediaCodec状态设为STARTING，然后调用ACodec::initiateStart()产生kWhatStart消息，在其消息处理中又调用ACodec::LoadedState::onStart()，然后在其中首先向IOMX发送状态转换命令，经过OMXNodeInstance最终对将OMX组件状态转换成Idle（转换完成时OMX会发送OMX_EventCmdComplete事件），接着对ACodec进行changeState至LoadedToIdleState。而在changeState过程中会调用ACodec::LoadedToIdleState::stateEntered() =&gt;  ACodec::LoadedToIdleState::allocateBuffers() =&gt; ACodec::allocateBuffersOnPort(…)，其中会为OMX组件端口分配缓冲，并向MediaCodec发送消息kWhatBuffersAllocated，消息处理中将MediaCodec状态设为STARTED而若allocateBuffers失败则由IOMX经OMXNodeInstance将OMX组件转换回Loaded状态，同时把ACodec状态转换回LoadedState<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\ACodec.cpp]</span><br><span class="line"><span class="comment">//使用surface渲染，为输出分配图形缓存GraphicBuffer  </span></span><br><span class="line"><span class="keyword">status_t</span> ACodec::LoadedToIdleState::allocateBuffers() &#123;</span><br><span class="line">    <span class="keyword">status_t</span> err = mCodec-&gt;allocateBuffersOnPort(kPortIndexInput);</span><br><span class="line">    <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mCodec-&gt;allocateBuffersOnPort(kPortIndexOutput);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">status_t</span> ACodec::allocateBuffersOnPort(OMX_U32 portIndex) &#123;</span><br><span class="line">    CHECK(portIndex == kPortIndexInput || portIndex == kPortIndexOutput);</span><br><span class="line"></span><br><span class="line">    CHECK(mDealer[portIndex] == <span class="literal">NULL</span>);</span><br><span class="line">    CHECK(mBuffers[portIndex].isEmpty());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line">    <span class="keyword">if</span> (mNativeWindow != <span class="literal">NULL</span> &amp;&amp; portIndex == kPortIndexOutput) &#123;</span><br><span class="line">        <span class="keyword">if</span> (storingMetadataInDecodedBuffers()) &#123;</span><br><span class="line">            err = allocateOutputMetadataBuffers();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            err = allocateOutputBuffersFromNativeWindow();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="5-1-1、allocateOutputBuffersFromNativeWindow-的实现"><a href="#5-1-1、allocateOutputBuffersFromNativeWindow-的实现" class="headerlink" title="5.1.1、allocateOutputBuffersFromNativeWindow()的实现"></a>5.1.1、allocateOutputBuffersFromNativeWindow()的实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\ACodec.cpp]</span><br><span class="line"><span class="keyword">status_t</span> ACodec::allocateOutputBuffersFromNativeWindow() &#123;</span><br><span class="line">    OMX_U32 bufferCount, bufferSize, minUndequeuedBuffers;</span><br><span class="line">    <span class="keyword">status_t</span> err = configureOutputBuffersFromNativeWindow(</span><br><span class="line">            &amp;bufferCount, &amp;bufferSize, &amp;minUndequeuedBuffers, <span class="literal">true</span> <span class="comment">/* preregister */</span>);</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    mNumUndequeuedBuffers = minUndequeuedBuffers;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!storingMetadataInDecodedBuffers()) &#123;</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;Surface*&gt;(mNativeWindow.get())</span><br><span class="line">                -&gt;getIGraphicBufferProducer()-&gt;allowAllocation(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// Dequeue buffers and send them to OMX</span></span><br><span class="line">    <span class="keyword">for</span> (OMX_U32 i = <span class="number">0</span>; i &lt; bufferCount; i++) &#123;</span><br><span class="line">        ANativeWindowBuffer *buf;</span><br><span class="line">        <span class="keyword">int</span> fenceFd;</span><br><span class="line">        err = mNativeWindow-&gt;dequeueBuffer(mNativeWindow.get(), &amp;buf, &amp;fenceFd);</span><br><span class="line">        ......</span><br><span class="line">        sp&lt;GraphicBuffer&gt; graphicBuffer(<span class="keyword">new</span> GraphicBuffer(buf, <span class="literal">false</span>));</span><br><span class="line">        BufferInfo info;</span><br><span class="line">        info.mStatus = BufferInfo::OWNED_BY_US;</span><br><span class="line">        info.mFenceFd = fenceFd;</span><br><span class="line">        info.mIsReadFence = <span class="literal">false</span>;</span><br><span class="line">        info.mRenderInfo = <span class="literal">NULL</span>;</span><br><span class="line">        info.mData = <span class="keyword">new</span> ABuffer(<span class="literal">NULL</span> <span class="comment">/* data */</span>, bufferSize <span class="comment">/* capacity */</span>);</span><br><span class="line">        info.mCodecData = info.mData;</span><br><span class="line">        info.mGraphicBuffer = graphicBuffer;</span><br><span class="line">        mBuffers[kPortIndexOutput].push(info);</span><br><span class="line"></span><br><span class="line">        IOMX::buffer_id bufferId;</span><br><span class="line">        err = mOMX-&gt;useGraphicBuffer(mNode, kPortIndexOutput, graphicBuffer,</span><br><span class="line">                &amp;bufferId);</span><br><span class="line">        ......</span><br><span class="line">        mBuffers[kPortIndexOutput].editItemAt(i).mBufferID = bufferId;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-1-1-1、首先为视频编码输出准备Surface"><a href="#5-1-1-1、首先为视频编码输出准备Surface" class="headerlink" title="5.1.1.1、首先为视频编码输出准备Surface"></a>5.1.1.1、首先为视频编码输出准备Surface</h5><p>此处通过Binder通信使用IGraphicBufferProducer请求分配一个Native Surface<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static_cast</span>&lt;Surface*&gt;(mNativeWindow.get())</span><br><span class="line">        -&gt;getIGraphicBufferProducer()-&gt;allowAllocation(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure></p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/02-06-Surface-ANativeWindow.png" alt="Alt text"></p><h5 id="5-1-1-2、Surface-gt-dequeueBuffer"><a href="#5-1-1-2、Surface-gt-dequeueBuffer" class="headerlink" title="5.1.1.2、Surface-&gt;dequeueBuffer"></a>5.1.1.2、Surface-&gt;dequeueBuffer</h5><p>为Surface分配Buffer，提供给视频解码后数据使用<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\ACodec.cpp]</span><br><span class="line"><span class="keyword">status_t</span> ACodec::allocateOutputBuffersFromNativeWindow() &#123;</span><br><span class="line">    <span class="keyword">for</span> (OMX_U32 i = <span class="number">0</span>; i &lt; bufferCount; i++) &#123;</span><br><span class="line">        ANativeWindowBuffer *buf;</span><br><span class="line">        <span class="keyword">int</span> fenceFd;</span><br><span class="line">        err = mNativeWindow-&gt;dequeueBuffer(mNativeWindow.get(), &amp;buf, &amp;fenceFd);</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="5-2、Surface-gt-queueBuffer"><a href="#5-2、Surface-gt-queueBuffer" class="headerlink" title="5.2、Surface-&gt;queueBuffer()"></a>5.2、Surface-&gt;queueBuffer()</h5><p>待视频解码后，使用queueBuffer()交给SurfaceFlinger渲染，就可以在屏幕上看到视频画面了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\ACodec.cpp]</span><br><span class="line"><span class="keyword">void</span> ACodec::BaseState::onOutputBufferDrained(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg) &#123;</span><br><span class="line">        err = mCodec-&gt;mNativeWindow-&gt;queueBuffer(</span><br><span class="line">                    mCodec-&gt;mNativeWindow.get(), info-&gt;mGraphicBuffer.get(), info-&gt;mFenceFd);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/02-07-OpenMax-Based video decode-surfaceflinger.png" alt="Alt text"></p><p>关于SurfaceFlinger的知识请参考：【Android 7.1.2 (Android N) Android Graphics 系统分析】</p><p><strong>（ ͡° ͜ʖ ͡°）、（ಡωಡ）累~~~，有时间再继续Todo的分析吧，(๑乛◡乛๑) ！！！</strong><br><strong>Todo：Android OpenMax机制 实现分析</strong><br><strong>Todo：Android 音视频同步机制 源码分析</strong><br><strong>Todo：Android 音视频录制（Recoder）、编码（Encode）、混合（MediaMuxer）源码分析</strong></p><h4 id="（六）、参考资料-特别感谢各位前辈的分析和图示-："><a href="#（六）、参考资料-特别感谢各位前辈的分析和图示-：" class="headerlink" title="（六）、参考资料(特别感谢各位前辈的分析和图示)："></a>（六）、参考资料(特别感谢各位前辈的分析和图示)：</h4><p><a href="http://www.cnblogs.com/tocy/tag/%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6/" target="_blank" rel="noopener">Android NuPlayer播放框架 </a><br><a href="https://blog.csdn.net/column/details/12812.html" target="_blank" rel="noopener">专栏：MultiMedia框架总结(基于6.0源码) - CSDN博客</a><br><a href="windrunnerlihuan.com">Android多媒体开发-归档 | April is your lie</a><br><a href="https://blog.csdn.net/miaomiao12345678/article/details/57415505" target="_blank" rel="noopener">Android-7.0-Nuplayer概述 - CSDN博客</a><br><a href="https://blog.csdn.net/miaomiao12345678/article/details/57409783" target="_blank" rel="noopener">Android-7.0-MediaPlayer状态机 - CSDN博客</a><br><a href="https://blog.csdn.net/miaomiao12345678/article/details/56961370" target="_blank" rel="noopener">Android-7.0-Nuplayer-启动流程 - CSDN博客</a><br><a href="https://zh.wikipedia.org/wiki/YUV" target="_blank" rel="noopener">YUV - 维基百科，自由的百科全书</a><br><a href="https://blog.csdn.net/harman_zjc/article/details/53386010" target="_blank" rel="noopener">Android Media Player 框架分析-Nuplayer（1） - CSDN博客</a><br><a href="https://blog.csdn.net/harman_zjc/article/details/53397945" target="_blank" rel="noopener">Android Media Player 框架分析-AHandler AMessage ALooper - CSDN博客</a><br><a href="https://blog.csdn.net/gzzaigcnforever/article/category/2135451/1?" target="_blank" rel="noopener">Android 4.2.2 stagefright架构 - CSDN博客</a><br><a href="https://blog.csdn.net/gzzaigcnforever/article/details/26849549" target="_blank" rel="noopener">android4.2.2的stagefright架构下基于SurfaceFlinger的视频解码输出缓存创建机制 - CSDN博客</a><br><a href="https://blog.csdn.net/dfhuang09/article/category/7610722" target="_blank" rel="noopener">husanlim 的专栏 参考 - CSDN博客</a><br><a href="https://blog.csdn.net/dfhuang09/article/details/54926526" target="_blank" rel="noopener">android ACodec MediaCodec NuPlayer flow - CSDN博客</a><br><a href="https://blog.csdn.net/dfhuang09/article/details/60132620" target="_blank" rel="noopener">android MediaCodec ACodec - CSDN博客</a><br><a href="https://blog.csdn.net/column/details/16222.html" target="_blank" rel="noopener">ffmpeg开发之旅(1)-(7)（总共七篇）</a><br><a href="https://blog.csdn.net/nonmarking/article/category/6746500" target="_blank" rel="noopener">深入理解Android音视频同步机制（总共五篇）</a><br><a href="https://blog.csdn.net/junzia/article/details/54018671" target="_blank" rel="noopener">Android硬编码——音频编码、视频编码及音视频混合</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;amp;&amp;amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内
      
    
    </summary>
    
      <category term="Android" scheme="http://zhoujinjian.cc/categories/Android/"/>
    
    
      <category term="Android" scheme="http://zhoujinjian.cc/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android Video System（1）：Video System(视频系统)框架分析</title>
    <link href="http://zhoujinjian.cc/2018/06/01/Android%20Video%20System%EF%BC%881%EF%BC%89%EF%BC%9AVideo%20System%5B%E8%A7%86%E9%A2%91%E7%B3%BB%E7%BB%9F%5D%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/"/>
    <id>http://zhoujinjian.cc/2018/06/01/Android Video System（1）：Video System[视频系统]框架分析/</id>
    <published>2018-05-31T16:00:00.000Z</published>
    <updated>2018-05-17T16:21:51.537Z</updated>
    
    <content type="html"><![CDATA[<hr><p>注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;&amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除，禁止转载（©Qualcomm Technologies, Inc. 版权所有），谢谢。</p><p><a href="https://github.com/izhoujinjian/zhoujinjian.cc/tree/master/video.system" target="_blank" rel="noopener">【博客原图链接】</a><br><a href="http://www.cnblogs.com/tocy/tag/%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6/" target="_blank" rel="noopener">【特别感谢 -  Android NuPlayer播放框架】</a><br><a href="https://blog.csdn.net/dfhuang09/article/details/54926526" target="_blank" rel="noopener">【特别感谢 -  android ACodec MediaCodec NuPlayer flow】</a></p><p>Google Pixel、Pixel XL 内核代码（文章基于 Kernel-3.18）：<br> <a href="https://github.com/matthewdalex/marlin" target="_blank" rel="noopener">Kernel source for Pixel and Pixel XL - GitHub</a></p><p>AOSP 源码（文章基于 Android 7.1.2）：<br> <a href="https://testerhome.com/topics/2229" target="_blank" rel="noopener"> Android 系统全套源代码分享 (更新到 8.1.0_r1)</a></p><hr><p>☯ V4l2 框架代码<br>☯ kernel/drivers/media/v4l2-core/（文件前缀为 videobuf2）</p><p>☯ MSM 视频驱动程序文件<br>☯ kernel/drivers/media/platform/msm/vidc/</p><p>☯ 设备树<br>☯ /kernel/arch/arm/boot/dts/qcom（Venus 的寄存器基址，时钟频率）</p><p>☯ Stagefright、libmedia、libmediaplayerservice、mediaserver<br>☯ /frameworks/av/media/</p><p>☯ OMX<br>☯ /hardware/qcom/media/mam8996/mm-video-v4l2/vidc/</p><p>☯ OMX 核心<br>☯ /hardware/qcom/media/mm-core</p><p>☯ 软件编解码器路径<br>☯ /vendor/qcom/proprietary/mm-video/omx_vpp(?)→ 解码器代码<br>☯ /vendor/qcom/proprietary/mm-video/omx_vpp(?) → 编码器代码</p><hr><h4 id="一-、Android-Video-Overview"><a href="#一-、Android-Video-Overview" class="headerlink" title="(一)、Android Video Overview"></a>(一)、Android Video Overview</h4><p>基于 OpenMAX 的视频解码 – 数据流<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/01-01-OpenMax-Based video decode - data flow.png" alt="Alt text"></p><blockquote><p>YUV，是一种颜色编码方法。常使用在各个视频处理组件中。 YUV在对照片或视频编码时，考虑到人类的感知能力，允许降低色度的带宽。<a href="https://zh.wikipedia.org/wiki/YUV" target="_blank" rel="noopener">YUV</a><br>VPU，Video processing unit </p></blockquote><p>基于 OpenMAX 的视频编码 – 数据流<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/01-02-OpenMax-Based video encode - data flow.png.png" alt="Alt text"></p><p>视频框架：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/01-03-Video Architecture Software Stack.png" alt="Alt text"></p><p>组件描述：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/01-04-Q Component Description.png" alt="Alt text"></p><p>总结：<br>    从视频框架可以了解到。视频文件先经Stagefright传到OMX decoder解码（软解或硬解）、OMX decoder将解码后的YUV数据回传到Stagefright，不断循环播放同时经由SurfaceFlinger渲染到LCD屏幕上。</p><h4 id="二-、Android-MediaPlayer-amp-Nuplayer-框架分析"><a href="#二-、Android-MediaPlayer-amp-Nuplayer-框架分析" class="headerlink" title="(二)、Android MediaPlayer &amp; Nuplayer 框架分析"></a>(二)、Android MediaPlayer &amp; Nuplayer 框架分析</h4><h5 id="2-1、MediaPlayer"><a href="#2-1、MediaPlayer" class="headerlink" title="2.1、MediaPlayer"></a>2.1、MediaPlayer</h5><p>Android在Java层中提供了一个MediaPlayer的类来作为播放媒体资源的接口，在使用中我们通常会编写以下的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mMediaPlayer = <span class="keyword">new</span> MediaPlayer();</span><br><span class="line">mMediaPlayer.setDataSource(Environment.getExternalStorageDirectory()+<span class="string">"/test_video.mp4"</span>);</span><br><span class="line">mMediaPlayer.setDisplay(...);</span><br><span class="line">mMediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);</span><br><span class="line">mMediaPlayer.prepareAsync();</span><br><span class="line">mMediaPlayer.start();</span><br><span class="line">mediaPlayer.pause(); </span><br><span class="line">mediaPlayer.stop();</span><br><span class="line">mediaPlayer.reset();</span><br><span class="line">mediaPlayer.release();</span><br></pre></td></tr></table></figure><p>通常MediaPlayer的调用逻辑是，构造函数-&gt; setDataSource -&gt; SetVideoSurfaceTexture-&gt; prepare/prepareAsync -&gt; start-&gt; stop-&gt; reset-&gt; 析构函数，按照实际需求还会调用pause、isPlaying、getDuration、getCurrentPosition、setLooping、seekTo等方法。</p><h5 id="2-1-1、MediaPlayer状态图"><a href="#2-1-1、MediaPlayer状态图" class="headerlink" title="2.1.1、MediaPlayer状态图:"></a>2.1.1、MediaPlayer状态图:</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/01-05-MediaPlayer-status-turn-.png" alt="Alt text"></p><p>☯ Idle状态<br>调用new或reset()方法创建MediaPlayer后进入空闲<br>☯ End状态<br>调用release()后就结束<br>☯ Error状态<br>播放控制操作出错或无效状态下调用播放控制操作<br>☯ Initialized状态</p><p>调用setDataSource之后完成初始化<br>☯ Prepared状态<br>同步prepare()或异步prepareAsync()完成准备<br>☯ Preparing状态<br>是一种瞬时状态，调用prepareAsync()时会先进入此状态<br>☯ Started  状态<br>要开始播放必须调用start()<br>☯ Paused  状态<br>调用pause()并成功返回后播放可以被暂停<br>☯ Stopped状态<br>调用stop()会停止播放<br>☯ PlaybackCompleted状态<br>当播放到达流末端时，播放完成</p><h5 id="2-1-2、MediaPlayer和MediaPlayerService"><a href="#2-1-2、MediaPlayer和MediaPlayerService" class="headerlink" title="2.1.2、MediaPlayer和MediaPlayerService"></a>2.1.2、MediaPlayer和MediaPlayerService</h5><p>mediaserver 启动后会把media相关一些服务添加到servicemanager中，其中就有mediaPlayerService。这样应用启动前，系统就有了mediaPlayerService这个服务程序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\mediaserver\main_mediaserver.cpp]</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/01-06-Main_mediaserver.png" alt="Alt text"></p><h5 id="2-1-3、创建MediaPlayer"><a href="#2-1-3、创建MediaPlayer" class="headerlink" title="2.1.3、创建MediaPlayer"></a>2.1.3、创建MediaPlayer</h5><p>☯ Java应用程序中创建MediaPlayer对象<br>MediaPlayer mediaPlayer = new MediaPlayer();<br>☯ MediaPlayer的构造函数中比较重要的就是本地的native函数：native_setup()其对应的JNI函数为<br>android_media_MediaPlayer_native_setup()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\media\jni\android_media_MediaPlayer.cpp]</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/01-07-android_media_MediaPlayer_native_setup.png" alt="Alt text"></p><p>构造Native层的MediaPlayer对象的时候【MediaPlayer.cpp】，也会构造其父类的对象。在MediaPlayer的父类IMediaDeathNotifier中有个很重要的方法getMediaPlayerService()来获取MediaPlayerService，其关系到MediaPlayer和MediaPlayerService之间的通信。</p><h5 id="2-1-4、setDataSource-设置播放资源"><a href="#2-1-4、setDataSource-设置播放资源" class="headerlink" title="2.1.4、setDataSource()设置播放资源"></a>2.1.4、setDataSource()设置播放资源</h5><p>在整个应用程序的进程中，Mediaplayer.cpp 中 setDataSource会从service manager中获得mediaPlayerService 服务，然后通过服务来创建player，这个player就是播放器的真实实例，同时也使MediaPlayer和MediaPlayerService建立了联系。<br>在java层MediaPlayer.java中的setDataSource最终会调用_setDataSource方法，对应native层MediaPlayer.cpp中的setDataSource方法。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/01-08-mp_setDataSource.png" alt="Alt text"></p><p>通过 getMediaPlayerService 得到的BpMediaPlayerService类型的service，和mediaPlayerService进程中的BnMediaPlayerService 相对应负责binder通讯。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/01-09-MediaPlayerService_Create.png" alt="Alt text"></p><p>在create函数中创建了一个MediaPlayerService::Client的实例，是MediaPlayerService的内部类，也就是说MediaPlayerService会为每个client应用进程创建一个相应的MediaPlayerService::Client的实例，来实现播放以及播放过程的控制，向MediaPlayer发事件通知。到这里，在Server端的对象就创建完成了。</p><p>然后在MediaPlayer.cpp中就得到了一个sever端的player实例，它和本地其他类的实例没什么用法上的区别，而实际上则是通过binder机制运行在另外一个进程中的。获得此实例后继续player-&gt;setDataSource操作。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/01-10-player-setDataSource.png" alt="Alt text"></p><p>小结：<br>Java应用程序中使用MediaPlayer.java的setDataSource()会传递到Native层中MediaPlayer.cpp的setDataSource()去执行，而MediaPlayer.cpp又会把这个方法交给MediaPlayerservice去执行。MediaPlayerService则是使用NuPlayer实现的，最后， setDataSource还是交给了NuPlayer去执行了。这个过程把MediaPlayer和MediaPlayerService之间的联系建立起来，同时又把MediaPlayerService和NuPlayer的关系建立了起来。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/01-11-GenericSource-setDataSource.png" alt="Alt text"></p><h5 id="2-1-5、setDisplay"><a href="#2-1-5、setDisplay" class="headerlink" title="2.1.5、setDisplay()"></a>2.1.5、setDisplay()</h5><p> 下一步就是java层的setDisplay，依然查看java层MediaPlayer：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\media\java\android\media\MediaPlayer.java]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDisplay</span><span class="params">(SurfaceHolder sh)</span> </span>&#123;</span><br><span class="line">        mSurfaceHolder = sh;</span><br><span class="line">        Surface surface;</span><br><span class="line">        <span class="keyword">if</span> (sh != null) &#123;</span><br><span class="line">            surface = sh.getSurface();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            surface = null;</span><br><span class="line">        &#125;</span><br><span class="line">        _setVideoSurface(surface);</span><br><span class="line">        updateSurfaceScreenOn();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>最后会调用本地方法_setVideoSurface，我们继续找到它的jni实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\media\jni\android_media_MediaPlayer.cpp]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_media_MediaPlayer_setVideoSurface</span><span class="params">(JNIEnv *env, jobject thiz, jobject jsurface)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    setVideoSurface(env, thiz, jsurface, <span class="literal">true</span> <span class="comment">/* mediaPlayerMustBeAlive */</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setVideoSurface</span><span class="params">(JNIEnv *env, jobject thiz, jobject jsurface, jboolean mediaPlayerMustBeAlive)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sp&lt;MediaPlayer&gt; mp = getMediaPlayer(env, thiz);<span class="comment">//获取C++的MediaPlayer</span></span><br><span class="line">    <span class="keyword">if</span> (mp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mediaPlayerMustBeAlive) &#123;</span><br><span class="line">            jniThrowException(env, <span class="string">"java/lang/IllegalStateException"</span>, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//将旧的IGraphicBufferProducer的强引用减一</span></span><br><span class="line">    decVideoSurfaceRef(env, thiz);</span><br><span class="line"><span class="comment">//IGraphicBufferProducer图层缓冲区合成器</span></span><br><span class="line">    sp&lt;IGraphicBufferProducer&gt; new_st;</span><br><span class="line">    <span class="keyword">if</span> (jsurface) &#123;</span><br><span class="line">    <span class="comment">//得到java层的surface</span></span><br><span class="line">        sp&lt;Surface&gt; surface(android_view_Surface_getSurface(env, jsurface));</span><br><span class="line">        <span class="keyword">if</span> (surface != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//获取IGraphicBufferProducer</span></span><br><span class="line">            new_st = surface-&gt;getIGraphicBufferProducer();</span><br><span class="line">            <span class="keyword">if</span> (new_st == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                jniThrowException(env, <span class="string">"java/lang/IllegalArgumentException"</span>,</span><br><span class="line">                    <span class="string">"The surface does not have a binding SurfaceTexture!"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//增加IGraphicBufferProducer的强引用+1</span></span><br><span class="line">            new_st-&gt;incStrong((<span class="keyword">void</span>*)decVideoSurfaceRef);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            jniThrowException(env, <span class="string">"java/lang/IllegalArgumentException"</span>,</span><br><span class="line">                    <span class="string">"The surface has been released"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//上面我们在native_init方法中将java层mNativeSurfaceTexture查找给了jni层，正好，在这里将IGraphicBufferProducer赋给它</span></span><br><span class="line">    env-&gt;SetLongField(thiz, fields.surface_texture, (jlong)new_st.get());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This will fail if the media player has not been initialized yet. This</span></span><br><span class="line">    <span class="comment">// can be the case if setDisplay() on MediaPlayer.java has been called</span></span><br><span class="line">    <span class="comment">// before setDataSource(). The redundant call to setVideoSurfaceTexture()</span></span><br><span class="line">    <span class="comment">// in prepare/prepareAsync covers for this case.</span></span><br><span class="line">    <span class="comment">//如果MediaPlayer没有初始化，这一步会失败。原因可能是setDisplay在setDataSource之前。如果在prepare/prepareAsync 时想规避这个错误而去调用setVideoSurfaceTexture是多余的。</span></span><br><span class="line">    <span class="comment">//最终会调用C++层的setVideoSurfaceTexture方法，下一节在分析</span></span><br><span class="line">    mp-&gt;setVideoSurfaceTexture(new_st);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将旧的IGraphicBufferProducer的强引用减一</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">decVideoSurfaceRef</span><span class="params">(JNIEnv *env, jobject thiz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sp&lt;MediaPlayer&gt; mp = getMediaPlayer(env, thiz);</span><br><span class="line">    <span class="keyword">if</span> (mp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;IGraphicBufferProducer&gt; old_st = getVideoSurfaceTexture(env, thiz);</span><br><span class="line">    <span class="keyword">if</span> (old_st != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        old_st-&gt;decStrong((<span class="keyword">void</span>*)decVideoSurfaceRef);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一步主要是对图像显示的surface的保存，然后将旧的IGraphicBufferProducer强引用减一，再获得新的IGraphicBufferProducer，最后会调用C++的MediaPlayer的setVideoSurfaceTexture将它折纸进去。</p><p>IGraphicBufferProducer是SurfaceFlinger的内容，一个UI完全显示到diplay的过程，SurfaceFlinger扮演着重要的角色但是它的职责是“Flinger”，即把系统中所有应用程序的最终的“绘图结果”进行“混合”，然后统一显示到物理屏幕上，而其他方面比如各个程序的绘画过程，就由其他东西来担任了。这个光荣的任务自然而然地落在了BufferQueue的肩膀上，它是每个应用程序“一对一”的辅导老师，指导着UI程序的“画板申请”、“作画流程”等一系列细节。下面的图描述了这三者的关系：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/01-12-IGraphicBufferProducer.png" alt="Alt text"></p><p>   虽说是三者的关系，但是他们所属的层却只有两个，app属于Java层，BufferQueue/SurfaceFlinger属于native层。也就是说BufferQueue也是隶属SurfaceFlinger，所有工作围绕SurfaceFlinger展开。<br>       这里IGraphicBufferProducer就是app和BufferQueue重要桥梁，GraphicBufferProducer承担着单个应用进程中的UI显示需求，与BufferQueue打交道的就是它。</p><h5 id="2-1-6、播放器基本模型"><a href="#2-1-6、播放器基本模型" class="headerlink" title="2.1.6、播放器基本模型"></a>2.1.6、播放器基本模型</h5><p>NuPlayer不管有多么神秘，说到底还是个播放器。在播放器的基本模型上，他与VCL、mplayer、ffmpeg等开源的结构是一致的。只是组织实现的方式不同。<br>深入了解NuPlayer之前，把播放器的基本模型总结一下，然后按照模型的各个部分来深入研究NuPlayer的实现方式。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/01-13-source-demux-decoder-output.jpg" alt="Alt text"></p><p>☯ datasource数据源：数据源，数据的来源不一定都是本地file，也有可能是网路上的各种协议例如：http、rtsp、HLS等。source的任务就是把数据源抽象出来，为下一个demux模块提供它需要的稳定的数据流。demux不用关信数据到底是从什么地方来的。</p><p>☯ demuxer解复用：视频文件一般情况下都是把音视频的ES流交织的通过某种规则放在一起。这种规则就是容器规则。现在有很多不同的容器格式。如ts、mp4、flv、mkv、avi、rmvb等等。demux的功能就是把音视频的ES流从容器中剥离出来，然后分别送到不同的解码器中。其实音频和视频本身就是2个独立的系统。容器把它们包在了一起。但是他们都是独立解码的，所以解码之前，需要把它分别 独立出来。demux就是干这活的，他为下一步decoder解码提供了数据流。</p><p>☯ decoder解码：解码器—-播放器的核心模块。分为音频和视频解码器。影像在录制后, 原始的音视频都是占用大量空间, 而且是冗余度较高的数据. 因此, 通常会在制作的时候就会进行某种压缩 ( 压缩技术就是将数据中的冗余信息去除数据之间的相关性 ). 这就是我们熟知的音视频编码格式, 包括MPEG1（VCD）\ MPEG2（DVD）\ MPEG4 \ H.264 等等. 音视频解码器的作用就是把这些压缩了的数据还原成原始的音视频数据. 当然, 编码解码过程基本上都是有损的 .解码器的作用就是把编码后的数据还原成原始数据。</p><p>☯ output输出：输出部分分为音频和视频输出。解码后的音频（pcm）和视频（yuv）的原始数据需要得到音视频的output模块的支持才能真正的让人的感官系统（眼和耳）辨识到。</p><p>所以，播放器大致分成上述4部分。怎么抽象的实现这4大部分、以及找到一种合理的方式将这几部分组织并运动起来。是每个播放器不同的实现方式而已。接下来就围绕这4大部分做深入学习，看看NuPlayer的工作原理。</p><h5 id="2-2、NuPlayer分析"><a href="#2-2、NuPlayer分析" class="headerlink" title="2.2、NuPlayer分析"></a>2.2、NuPlayer分析</h5><h5 id="2-2-0、NuPlayer简介"><a href="#2-2-0、NuPlayer简介" class="headerlink" title="2.2.0、NuPlayer简介"></a>2.2.0、NuPlayer简介</h5><p>Android2.3时引入流媒体框架，而流媒体框架的核心是NuPlayer。在之前的版本中一般认为Local Playback就用Stagefrightplayer+Awesomeplayer，流媒体用NuPlayer。Android4.0之后HttpLive和RTSP协议开始使用NuPlayer播放器，Android5.0（L版本）之后本地播放也开始使用NuPlayer播放器。 Android7.0(N版本)则完全去掉了Awesomeplayer。<br>通俗点说，NuPlayer是AOSP中提供的多媒体播放框架，能够支持本地文件、HTTP（HLS）、RTSP等协议的播放，通常支持H.264、H.265/HEVC、AAC编码格式，支持MP4、MPEG-TS封装。<br>在实现上NuPlayer和Awesomeplayer不同，NuPlayer基于StagefrightPlayer的基础类构建，利用了更底层的ALooper/AHandler机制来异步地处理请求，ALooper列队消息请求，AHandler中去处理，所以有更少的Mutex/Lock在NuPlayer中。Awesomeplayer中利用了omxcodec而NuPlayer中利用了Acodec。</p><h5 id="2-2-1、NuPlayer整体类关系图"><a href="#2-2-1、NuPlayer整体类关系图" class="headerlink" title="2.2.1、NuPlayer整体类关系图"></a>2.2.1、NuPlayer整体类关系图</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/01-14-NuPlayer-arc.jpg" alt="Alt text"></p><p>NuPlayer由NuPlayerDriver封装，利用了底层的ALooper/AHandler机制来异步地处理请求，ALooper保存消息请求，然后在AHandler中处理。另外，NuPlayer中利用到了Acodec。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/01-15-NuPlayer-class.jpg" alt="Alt text"></p><p>☯ NuPlayer::Source<br>解析模块（parser，功能类似FFmpeg的avformat）。其接口与MediaExtractor和<br>MediaSource组合的接口差不多，同时提供了用于快速定位的seekTo接口。</p><p>☯ NuPlayer::Decoder<br>解码模块（decoder，功能类似FFmpeg的avcodec），封装了用于AVC、AAC解码的接口，<br>通过ACodec实现解码（包含OMX硬解码和软解码）。</p><p>☯ NuPlayer::Render<br>渲染模块（render，功能类似声卡驱动和显卡驱动），主要用于音视频渲染和同步，与<br>NativeWindow有关。</p><p>☯ NuPlayer  是播放框架中连接Source、Decoder、Renderer的纽带</p><p>☯ NuPlayerDriver<br>作为NuPlayer类的封装，直接调用NuPlayer。</p><p>NuPlayer框架中最顶层的类是NuPlayerDriver，继承自MediaPlayerInterface，主要提供一个状态转换机制，作为NuPlayer类的Wrapper。NuPlayerDriver类中最重要的成员是以下几个：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; State mState 播放器状体标志 </span><br><span class="line">&gt; sp &lt;ALooper&gt; mLooper 内部消息驱动机制 </span><br><span class="line">&gt; sp &lt;NuPlayer&gt;  mPlayer 真正完成播放器的类</span><br></pre></td></tr></table></figure><p>NuPlayerDriver主要是 构造函数-&gt; setDataSource -&gt; SetVideoSurfaceTexture-&gt; prepare/prepareAsync -&gt; start-&gt; stop-&gt; reset-&gt; 析构函数，实际需求pause、isPlaying、getDuration、getCurrentPosition、setLooping、seekTo等方法</p><h5 id="2-2-2、NuPlayer框架需要关注知识点"><a href="#2-2-2、NuPlayer框架需要关注知识点" class="headerlink" title="2.2.2、NuPlayer框架需要关注知识点"></a>2.2.2、NuPlayer框架需要关注知识点</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NuPlayer的框架，其内部实现逻辑。那么最终就落实到如何从一个类中提取出需要的框架及知识点。那么一个类的对外接口部分通常包括：</span><br><span class="line">--- 构造函数和析构函数</span><br><span class="line">--- 必须调用的接口</span><br><span class="line">--- 可选的调用接口</span><br><span class="line"></span><br><span class="line">在多媒体播放中，通过关注的点有：</span><br><span class="line">--- 如何实现解复用，得到音频、视频、字幕等数据</span><br><span class="line">--- 如何实现解码</span><br><span class="line">--- 如何实现音视频同步</span><br><span class="line">--- 如何渲染视频</span><br><span class="line">--- 如何播放音频</span><br><span class="line">--- 如何实现快速定位</span><br></pre></td></tr></table></figure><h4 id="三-、Android-MediaPlayer框架分析-AHandler-AMessage-ALooper"><a href="#三-、Android-MediaPlayer框架分析-AHandler-AMessage-ALooper" class="headerlink" title="(三)、Android MediaPlayer框架分析 - AHandler AMessage ALooper"></a>(三)、Android MediaPlayer框架分析 - AHandler AMessage ALooper</h4><p>前文中提到过NuPlayer基于StagefrightPlayer的基础类构建，利用了更底层的ALooper/AHandler机制来<strong>异步地处理请求</strong>，ALooper保存消息请求，然后调用AHandler接口去处理。<br>实际上在代码中NuPlayer本身继承自AHandler类，而ALooper对象保存在NuPlayerDriver中。<br>ALooper/AHandler机制是模拟的消息循环处理方式，通常有三个主要部分：消息（message，通常包含Handler）、消息队列（queue）、消息处理线程（looper thread）。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/01-16-AHandler-ALooper-AMessage.png" alt="Alt text"></p><p>对于handler消息机制，构成就必须包括一个Loop，message。那么对应的AHandler，也应该有对应的ALooper、AMessage。<br>因此本小节主要涉及到三个类ALooper、AHandler、AMessage。</p><h5 id="3-1、AHandler接口分析（消息处理类）"><a href="#3-1、AHandler接口分析（消息处理类）" class="headerlink" title="3.1、AHandler接口分析（消息处理类）"></a>3.1、AHandler接口分析（消息处理类）</h5><p>下面代码是AHandler接口:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"./frameworks/av/include/media/stagefright/AHandler.h"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AHandler</span> :</span> <span class="keyword">public</span> RefBase &#123;</span><br><span class="line">    AHandler();</span><br><span class="line"></span><br><span class="line">    ALooper::<span class="function">handler_id <span class="title">id</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    sp&lt;ALooper&gt; looper() <span class="keyword">const</span>;</span><br><span class="line">    wp&lt;ALooper&gt; getLooper() <span class="keyword">const</span>;</span><br><span class="line">    wp&lt;AHandler&gt; getHandler() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onMessageReceived</span><span class="params">(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">struct</span> <span class="title">AMessage</span>;</span>      <span class="comment">// deliverMessage()</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">struct</span> <span class="title">ALooperRoster</span>;</span> <span class="comment">// setID()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> mMessageCounter;</span><br><span class="line">    KeyedVector&lt;<span class="keyword">uint32_t</span>, <span class="keyword">uint32_t</span>&gt; mMessages;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setID</span><span class="params">(ALooper::handler_id id, wp&lt;ALooper&gt; looper)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deliverMessage</span><span class="params">(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看上面接口，初步印象是AHandler没有直接对外的接口（只有获取成员变量的接口），基本上只有一个onMessageReceived用于子类继承，deliverMessage用于给类AMessage使用，setID用于给友元类ALooperRoster使用。从这点来说，真正代码应该在AMessage里边。</p><h5 id="3-2、AMessage接口分析（消息载体）"><a href="#3-2、AMessage接口分析（消息载体）" class="headerlink" title="3.2、AMessage接口分析（消息载体）"></a>3.2、AMessage接口分析（消息载体）</h5><p>下面代码是AMessage的声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"./frameworks/av/include/media/stagefright/AMessage.h"</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AMessage</span> :</span> <span class="keyword">public</span> RefBase &#123;</span><br><span class="line">    AMessage();</span><br><span class="line">    AMessage(<span class="keyword">uint32_t</span> what, <span class="keyword">const</span> sp&lt;<span class="keyword">const</span> AHandler&gt; &amp;handler); <span class="comment">// 代码中常用的构造函数</span></span><br><span class="line">    <span class="keyword">static</span> sp&lt;AMessage&gt; FromParcel(<span class="keyword">const</span> Parcel &amp;parcel, <span class="keyword">size_t</span> maxNestingLevel = <span class="number">255</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write this AMessage to a parcel.</span></span><br><span class="line">    <span class="comment">// All items in the AMessage must have types that are recognized by</span></span><br><span class="line">    <span class="comment">// FromParcel(); otherwise, TRESPASS error will occur.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel *parcel)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setWhat</span><span class="params">(<span class="keyword">uint32_t</span> what)</span></span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> what() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意这是一个AHandler，通过这个可以获得ALooper对象引用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setTarget</span><span class="params">(<span class="keyword">const</span> sp&lt;<span class="keyword">const</span> AHandler&gt; &amp;handler)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除所有设置的消息属性参数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 一系列设置/获取 Message 属性的函数。。。</span></span><br><span class="line">    <span class="keyword">void</span> setInt32/setInt64/setSize/setFloat/setDouble/setPointer/setPointer/setString/setRect/setObject/setBuffer/setMessage(...);</span><br><span class="line">    <span class="keyword">bool</span> findInt32/findInt64/findSize/findFloat/findDouble/findPointer/findString/findObject/findBuffer/findMessage/findRect(...) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过这个函数检索下指定名称的消息属性是否存在</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">contains</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 投递消息的接口，顾名思义直接投递给构造函数的ALooper，注意支持延时消息，但不支持提前消息，delayUS &gt; 0</span></span><br><span class="line">    <span class="keyword">status_t</span> post(<span class="keyword">int64_t</span> delayUs = <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 投递消息并等待执行结束后发送response消息</span></span><br><span class="line">    <span class="keyword">status_t</span> postAndAwaitResponse(sp&lt;AMessage&gt; *response);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this returns true, the sender of this message is synchronously</span></span><br><span class="line">    <span class="comment">// awaiting a response and the reply token is consumed from the message</span></span><br><span class="line">    <span class="comment">// and stored into replyID. The reply token must be used to send the response</span></span><br><span class="line">    <span class="comment">// using "postReply" below.</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">senderAwaitsResponse</span><span class="params">(sp&lt;AReplyToken&gt; *replyID)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Posts the message as a response to a reply token.  A reply token can</span></span><br><span class="line">    <span class="comment">// only be used once. Returns OK if the response could be posted; otherwise,</span></span><br><span class="line">    <span class="comment">// an error.</span></span><br><span class="line">    <span class="keyword">status_t</span> postReply(<span class="keyword">const</span> sp&lt;AReplyToken&gt; &amp;replyID);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 深拷贝</span></span><br><span class="line">    sp&lt;AMessage&gt; dup() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较两个消息，并返回差异</span></span><br><span class="line">    sp&lt;AMessage&gt; changesFrom(<span class="keyword">const</span> sp&lt;<span class="keyword">const</span> AMessage&gt; &amp;other, <span class="keyword">bool</span> deep = <span class="literal">false</span>) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取消息属性存储的个数及特定索引上的消息属性参数</span></span><br><span class="line">    <span class="keyword">size_t</span> countEntries() <span class="keyword">const</span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">getEntryNameAt</span><span class="params">(<span class="keyword">size_t</span> index, Type *type)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~AMessage();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">struct</span> <span class="title">ALooper</span>;</span> <span class="comment">// deliver()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> mWhat;</span><br><span class="line"></span><br><span class="line">    wp&lt;AHandler&gt; mHandler;</span><br><span class="line">    wp&lt;ALooper&gt; mLooper;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用于ALooper调用的，发送消息的接口</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deliver</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从上面的接口可以看出在使用AMessage是只需要指定消息的id和要处理该消息的AHandler即可，可以通过构造函数，也可以单独调用setWhat和setTarget接口。AMessage构造完成之后，可以调用setXXX设置对应的参数，通过findXXX获取传递的参数。最后通过post即可将消息投递到AHandler的消息队列中。</p><h5 id="3-3、ALooper接口分析（消息处理循环及后台线程）"><a href="#3-3、ALooper接口分析（消息处理循环及后台线程）" class="headerlink" title="3.3、ALooper接口分析（消息处理循环及后台线程）"></a>3.3、ALooper接口分析（消息处理循环及后台线程）</h5><p>其简化的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"./frameworks/av/include/media/stagefright/ALooper.h"</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ALooper</span> :</span> <span class="keyword">public</span> RefBase &#123;</span><br><span class="line">    ALooper();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Takes effect in a subsequent call to start().</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">handler_id <span class="title">registerHandler</span><span class="params">(<span class="keyword">const</span> sp&lt;AHandler&gt; &amp;handler)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unregisterHandler</span><span class="params">(handler_id handlerID)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> start(<span class="keyword">bool</span> runOnCallingThread = <span class="literal">false</span>,</span><br><span class="line">            <span class="keyword">bool</span> canCallJava = <span class="literal">false</span>, <span class="keyword">int32_t</span> priority = PRIORITY_DEFAULT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> stop();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> int64_t <span class="title">GetNowUs</span><span class="params">()</span></span>;    </span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~ALooper();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">struct</span> <span class="title">AMessage</span>;</span>       <span class="comment">// post()</span></span><br><span class="line"></span><br><span class="line">    AString mName;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Event</span> &#123;</span></span><br><span class="line">        <span class="keyword">int64_t</span> mWhenUs;</span><br><span class="line">        sp&lt;AMessage&gt; mMessage;</span><br><span class="line">    &#125;;</span><br><span class="line">    List&lt;Event&gt; mEventQueue;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LooperThread</span>;</span></span><br><span class="line">    sp&lt;LooperThread&gt; mThread;</span><br><span class="line">    <span class="keyword">bool</span> mRunningLocally;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// START --- methods used only by AMessage</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// posts a message on this looper with the given timeout</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">post</span><span class="params">(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg, <span class="keyword">int64_t</span> delayUs)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// creates a reply token to be used with this looper</span></span><br><span class="line">    sp&lt;AReplyToken&gt; createReplyToken();</span><br><span class="line">    <span class="comment">// waits for a response for the reply token.  If status is OK, the response</span></span><br><span class="line">    <span class="comment">// is stored into the supplied variable.  Otherwise, it is unchanged.</span></span><br><span class="line">    <span class="keyword">status_t</span> awaitResponse(<span class="keyword">const</span> sp&lt;AReplyToken&gt; &amp;replyToken, sp&lt;AMessage&gt; *response);</span><br><span class="line">    <span class="comment">// posts a reply for a reply token.  If the reply could be successfully posted,</span></span><br><span class="line">    <span class="comment">// it returns OK. Otherwise, it returns an error value.</span></span><br><span class="line">    <span class="keyword">status_t</span> postReply(<span class="keyword">const</span> sp&lt;AReplyToken&gt; &amp;replyToken, <span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// END --- methods used only by AMessage</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">loop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>ALooper对外接口比较简单，通常就是NuPlayerDriver构造函数中的调用逻辑。先创建一个ALooper对象，然后调用setName和start接口，之后调用registerHandler设置一个AHandler，这样就完成了初始化。在析构之前需要调用stop接口。<br>这里需要说明下，ALooper::start接口会启动一个线程，并调用ALooper::loop函数，该函数主要实现消息的实际执行。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> ALooper::loop() &#123;</span><br><span class="line">    Event event;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(mLock)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (mThread == <span class="literal">NULL</span> &amp;&amp; !mRunningLocally) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从mEventQueue取出消息，判断是否需要执行，不需要的话就等待</span></span><br><span class="line">        <span class="comment">// 需要的话就调用handler执行，并删除对应消息</span></span><br><span class="line">        <span class="keyword">if</span> (mEventQueue.empty()) &#123;</span><br><span class="line">            mQueueChangedCondition.wait(mLock);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int64_t</span> whenUs = (*mEventQueue.begin()).mWhenUs;</span><br><span class="line">        <span class="keyword">int64_t</span> nowUs = GetNowUs();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (whenUs &gt; nowUs) &#123;</span><br><span class="line">            <span class="keyword">int64_t</span> delayUs = whenUs - nowUs;</span><br><span class="line">            mQueueChangedCondition.waitRelative(mLock, delayUs * <span class="number">1000l</span>l);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        event = *mEventQueue.begin();</span><br><span class="line">        mEventQueue.erase(mEventQueue.begin());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    event.mMessage-&gt;deliver();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么消息是通过那个函数添加进来的呢？ 这就是友元类AMessage的作用，通过调用ALooper::post接口，将AMessage添加到mEventQueue中。</p><h5 id="3-4、一个调用实例"><a href="#3-4、一个调用实例" class="headerlink" title="3.4、一个调用实例"></a>3.4、一个调用实例</h5><p>以NuPlayer::setVideoSurfaceTextureAsync为示例分析下ALooper/AHandler机制。<br>这里不解释ALooper的初始化过程，有兴趣的可以参考资料Android Native层异步消息处理框架的内容。<br>下面是setVideoSurfaceTextureAsync的代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayer.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::setVideoSurfaceTextureAsync(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;IGraphicBufferProducer&gt; &amp;bufferProducer) &#123;</span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage(kWhatSetVideoSurface, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bufferProducer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        msg-&gt;setObject(<span class="string">"surface"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        msg-&gt;setObject(<span class="string">"surface"</span>, <span class="keyword">new</span> Surface(bufferProducer, <span class="literal">true</span> <span class="comment">/* controlledByApp */</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msg-&gt;post();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码功能很简单，创建一个AMessage对象，并设置下参数，参数类型为Object，名称是”surface”，然后通过AMessage::post接口，间接调用ALooper::post接口，将消息发送给ALooper-NuPlayerDriver::mLooper；ALooper的消息循环线程检测到这个消息，在ALooper::loop函数中通过AMessage的deliver接口，调用AHandler::deliverMessage接口，这个函数会调动NuPlayer::onMessageReceived（通过继承机制实现）接口。这样绕了一圈。我们就可以通过ALooper/AHandler机制处理消息了。<br>具体处理代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayer.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::onMessageReceived(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (msg-&gt;what()) &#123;</span><br><span class="line">        <span class="keyword">case</span> kWhatSetVideoSurface:</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            sp&lt;RefBase&gt; obj;</span><br><span class="line">            CHECK(msg-&gt;findObject(<span class="string">"surface"</span>, &amp;obj));</span><br><span class="line">            sp&lt;Surface&gt; surface = <span class="keyword">static_cast</span>&lt;Surface *&gt;(obj.get());</span><br><span class="line"></span><br><span class="line">            ALOGD(<span class="string">"onSetVideoSurface(%p video decoder)"</span>, surface.get());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Need to check mStarted before calling mSource-&gt;getFormat because NuPlayer might</span></span><br><span class="line">            <span class="comment">// be in preparing state and it could take long time.</span></span><br><span class="line">            <span class="comment">// When mStarted is true, mSource must have been set.</span></span><br><span class="line">            <span class="keyword">if</span> (mSource == <span class="literal">NULL</span> || !mStarted || mSource-&gt;getFormat(<span class="literal">false</span> <span class="comment">/* audio */</span>) == <span class="literal">NULL</span></span><br><span class="line">                    <span class="comment">// <span class="doctag">NOTE:</span> mVideoDecoder's mSurface is always non-null</span></span><br><span class="line">                    || (mVideoDecoder != <span class="literal">NULL</span> &amp;&amp; mVideoDecoder-&gt;setVideoSurface(surface) == OK)) &#123;</span><br><span class="line">                performSetSurface(surface);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ... 省略其他部分代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="四-、NuPlayer源码分析"><a href="#四-、NuPlayer源码分析" class="headerlink" title="(四)、NuPlayer源码分析"></a>(四)、NuPlayer源码分析</h4><p>这次我们需要深入分析的是NuPlayer类，相比于NuPlayerDriver的接口功能，NuPlayer继承自AHandler类，是AOSP播放框架中连接Source、Decoder、Render的纽带。</p><h5 id="4-1、主要接口和核心的类成员"><a href="#4-1、主要接口和核心的类成员" class="headerlink" title="4.1、主要接口和核心的类成员"></a>4.1、主要接口和核心的类成员</h5><p>NuPlayer类被NuPlayerDriver直接调用，其主要接口如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// code from NuPlayer.h (~/frameworks/av/media/libmediaplayerservice/nuplayer/)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NuPlayer</span> :</span> <span class="keyword">public</span> AHandler &#123;</span><br><span class="line">    NuPlayer(<span class="keyword">pid_t</span> pid);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setUID</span><span class="params">(<span class="keyword">uid_t</span> uid)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setDriver</span><span class="params">(<span class="keyword">const</span> wp&lt;NuPlayerDriver&gt; &amp;driver)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setDataSourceAsync</span><span class="params">(...)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">prepareAsync</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setVideoSurfaceTextureAsync</span><span class="params">(<span class="keyword">const</span> sp&lt;IGraphicBufferProducer&gt; &amp;bufferProducer)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pause</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Will notify the driver through "notifyResetComplete" once finished.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resetAsync</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Will notify the driver through "notifySeekComplete" once finished</span></span><br><span class="line">    <span class="comment">// and needNotify is true.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">seekToAsync</span><span class="params">(<span class="keyword">int64_t</span> seekTimeUs, <span class="keyword">bool</span> needNotify = <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> setVideoScalingMode(<span class="keyword">int32_t</span> mode);</span><br><span class="line">    <span class="keyword">status_t</span> getTrackInfo(Parcel* reply) <span class="keyword">const</span>;</span><br><span class="line">    <span class="keyword">status_t</span> getSelectedTrack(<span class="keyword">int32_t</span> type, Parcel* reply) <span class="keyword">const</span>;</span><br><span class="line">    <span class="keyword">status_t</span> selectTrack(<span class="keyword">size_t</span> trackIndex, <span class="keyword">bool</span> select, <span class="keyword">int64_t</span> timeUs);</span><br><span class="line">    <span class="keyword">status_t</span> getCurrentPosition(<span class="keyword">int64_t</span> *mediaUs);</span><br><span class="line"></span><br><span class="line">    sp&lt;MetaData&gt; getFileMeta();</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getFrameRate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~NuPlayer();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onMessageReceived</span><span class="params">(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口分类下，无外乎几个分类：</p><p>☯ 用于初始化的（比如构造函数、setDriver/setDataSourceAsync/prepareAsync/setVideoSurfaceTextureAsync）<br>☯ 用于销毁的（比如析构函数、resetAsync）<br>☯ 用于播放控制的（比如start/pause/seekToAsync）<br>☯ 用于状态获取的（比如getCurrentPosition/getFileMeta）<br>下面是主要的类成员部分</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayer.h]</span><br><span class="line">wp&lt;NuPlayerDriver&gt; mDriver; <span class="comment">// 接口调用方</span></span><br><span class="line">sp&lt;Source&gt; mSource; <span class="comment">// 相当于FFmpeg中的demuxer</span></span><br><span class="line">sp&lt;Surface&gt; mSurface; <span class="comment">// 显示用的Surface</span></span><br><span class="line">sp&lt;DecoderBase&gt; mVideoDecoder; <span class="comment">// 视频解码器</span></span><br><span class="line">sp&lt;DecoderBase&gt; mAudioDecoder; <span class="comment">// 音频解码器</span></span><br><span class="line">sp&lt;CCDecoder&gt; mCCDecoder; </span><br><span class="line">sp&lt;Renderer&gt; mRenderer; <span class="comment">// 渲染器</span></span><br><span class="line">sp&lt;ALooper&gt; mRendererLooper;</span><br></pre></td></tr></table></figure><h5 id="4-2、setDataSourceAsync-现分析"><a href="#4-2、setDataSourceAsync-现分析" class="headerlink" title="4.2、setDataSourceAsync()现分析"></a>4.2、setDataSourceAsync()现分析</h5><p>这个函数有多重不同的重载形式，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayer.h]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDataSourceAsync</span><span class="params">(<span class="keyword">const</span> sp&lt;IStreamSource&gt; &amp;source)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDataSourceAsync</span><span class="params">(<span class="keyword">const</span> sp&lt;IMediaHTTPService&gt; &amp;httpService, <span class="keyword">const</span> <span class="keyword">char</span> *url,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> KeyedVector&lt;String8, String8&gt; *headers)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDataSourceAsync</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int64_t</span> offset, <span class="keyword">int64_t</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDataSourceAsync</span><span class="params">(<span class="keyword">const</span> sp&lt;DataSource&gt; &amp;source)</span></span>;</span><br></pre></td></tr></table></figure><p>需要根据实际情况选择，这里以第三个接口为例，说明下多本地媒体文件是如何处理的。<br>下面是这个函数的实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayer.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::setDataSourceAsync(<span class="keyword">int</span> fd, <span class="keyword">int64_t</span> offset, <span class="keyword">int64_t</span> length) &#123;</span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage(kWhatSetDataSource, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; notify = <span class="keyword">new</span> AMessage(kWhatSourceNotify, <span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 创建对象用于读取本地文件</span></span><br><span class="line">    sp&lt;GenericSource&gt; source =</span><br><span class="line">            <span class="keyword">new</span> GenericSource(notify, mUIDValid, mUID);</span><br><span class="line">    <span class="comment">// 实际干活的的代码</span></span><br><span class="line">    <span class="keyword">status_t</span> err = source-&gt;setDataSource(fd, offset, length);</span><br><span class="line">    </span><br><span class="line">    msg-&gt;setObject(<span class="string">"source"</span>, source);</span><br><span class="line">    msg-&gt;post();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看实现很简单，创建GenericSource对象，并调用其setDataSource接口，然后发送kWhatSetDataSource消息。<br>我们看看如何处理然后发送kWhatSetDataSource消息呢？代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayer.cpp]</span><br><span class="line"><span class="keyword">case</span> kWhatSetDataSource:</span><br><span class="line">&#123;</span><br><span class="line">    CHECK(mSource == <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err = OK;</span><br><span class="line">    sp&lt;RefBase&gt; obj;</span><br><span class="line">    CHECK(msg-&gt;findObject(<span class="string">"source"</span>, &amp;obj));</span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(mSourceLock)</span></span>;</span><br><span class="line">        mSource = <span class="keyword">static_cast</span>&lt;Source *&gt;(obj.get());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        err = UNKNOWN_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通知Driver函数调用完成</span></span><br><span class="line">    CHECK(mDriver != <span class="literal">NULL</span>);</span><br><span class="line">    sp&lt;NuPlayerDriver&gt; driver = mDriver.promote();</span><br><span class="line">    <span class="keyword">if</span> (driver != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        driver-&gt;notifySetDataSourceCompleted(err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看到这里发现，其实没做什么就是直接通知NuPlayerDriver。我们还注意到这里构建了一个特殊消息（AMessage）notify，这个消息用于在Source和NuPlayer直接传递。下面这是消息循环中的处理函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayer.cpp]</span><br><span class="line"><span class="keyword">case</span> kWhatSourceNotify:</span><br><span class="line">&#123;</span><br><span class="line">    onSourceNotify(msg);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在后续讨论Source的时候详细说明这个消息通知的意义。</p><h5 id="4-3、prepareAsync"><a href="#4-3、prepareAsync" class="headerlink" title="4.3、prepareAsync()"></a>4.3、prepareAsync()</h5><p>这个函数实现的功能对应于MediaPlayerBase::prepare/prepareAsync接口，实现异步的prepare功能，一般就是做一些额外的初始化工作。那么直接看一下实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayer.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::prepareAsync() &#123;</span><br><span class="line">    (<span class="keyword">new</span> AMessage(kWhatPrepare, <span class="keyword">this</span>))-&gt;post();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码就是发了一个kWhatPrepare的消息。接下来是如何处理这个消息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> kWhatPrepare:</span><br><span class="line">&#123;</span><br><span class="line">    mSource-&gt;prepareAsync();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终还是调用了Source::prepareAsync接口。后面会解释其功能。（这里面可能会解析下码流，读取音频、视频、字幕流信息，读取时长、元数据等）。</p><h5 id="4-4、setVideoSurfaceTextureAsync"><a href="#4-4、setVideoSurfaceTextureAsync" class="headerlink" title="4.4、setVideoSurfaceTextureAsync()"></a>4.4、setVideoSurfaceTextureAsync()</h5><p>调用这个接口主要为了设置视频渲染窗口。其实现相对简单，创建一个Surface，然后发送异步的kWhatSetVideoSurface消息。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> NuPlayer::setVideoSurfaceTextureAsync( <span class="keyword">const</span> sp&lt;IGraphicBufferProducer&gt; &amp;bufferProducer) &#123;</span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage(kWhatSetVideoSurface, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bufferProducer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        msg-&gt;setObject(<span class="string">"surface"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        msg-&gt;setObject(<span class="string">"surface"</span>, <span class="keyword">new</span> Surface(bufferProducer, <span class="literal">true</span> <span class="comment">/* controlledByApp */</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msg-&gt;post();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么看看如何处理kWhatSetVideoSurface消息呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> kWhatSetVideoSurface: &#123;</span><br><span class="line">    sp&lt;RefBase&gt; obj;</span><br><span class="line">    CHECK(msg-&gt;findObject(<span class="string">"surface"</span>, &amp;obj));</span><br><span class="line">    sp&lt;Surface&gt; surface = <span class="keyword">static_cast</span>&lt;Surface *&gt;(obj.get());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Need to check mStarted before calling mSource-&gt;getFormat because NuPlayer might</span></span><br><span class="line">    <span class="comment">// be in preparing state and it could take long time.</span></span><br><span class="line">    <span class="comment">// When mStarted is true, mSource must have been set.</span></span><br><span class="line">    <span class="keyword">if</span> (mSource == <span class="literal">NULL</span> || !mStarted || mSource-&gt;getFormat(<span class="literal">false</span> <span class="comment">/* audio */</span>) == <span class="literal">NULL</span></span><br><span class="line">            <span class="comment">// <span class="doctag">NOTE:</span> mVideoDecoder's mSurface is always non-null</span></span><br><span class="line">            || (mVideoDecoder != <span class="literal">NULL</span> &amp;&amp; mVideoDecoder-&gt;setVideoSurface(surface) == OK)) &#123;</span><br><span class="line">        performSetSurface(surface); <span class="comment">// 通知NuPlayerDriver设置完成</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清空音频、视频缓冲</span></span><br><span class="line">    mDeferredActions.push_back(</span><br><span class="line">            <span class="keyword">new</span> FlushDecoderAction(FLUSH_CMD_FLUSH <span class="comment">/* audio */</span>,FLUSH_CMD_SHUTDOWN <span class="comment">/* video */</span>));</span><br><span class="line">    <span class="comment">// 最终调用NuPlayer::performSetSurface接口</span></span><br><span class="line">    mDeferredActions.push_back(<span class="keyword">new</span> SetSurfaceAction(surface));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="literal">NULL</span> || mAudioDecoder != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mStarted) &#123;</span><br><span class="line">            <span class="comment">// Issue a seek to refresh the video screen only if started otherwise</span></span><br><span class="line">            <span class="comment">// the extractor may not yet be started and will assert.</span></span><br><span class="line">            <span class="comment">// If the video decoder is not set (perhaps audio only in this case)</span></span><br><span class="line">            <span class="comment">// do not perform a seek as it is not needed.</span></span><br><span class="line">            <span class="keyword">int64_t</span> currentPositionUs = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (getCurrentPosition(&amp;currentPositionUs) == OK) &#123;</span><br><span class="line">                mDeferredActions.push_back(</span><br><span class="line">                        <span class="keyword">new</span> SeekAction(currentPositionUs));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于新的surface设置，重置下解码器</span></span><br><span class="line">        mDeferredActions.push_back(<span class="keyword">new</span> SimpleAction(&amp;NuPlayer::performScanSources));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// After a flush without shutdown, decoder is paused.</span></span><br><span class="line">    <span class="comment">// Don't resume it until source seek is done, otherwise it could</span></span><br><span class="line">    <span class="comment">// start pulling stale data too soon.</span></span><br><span class="line">    mDeferredActions.push_back(</span><br><span class="line">            <span class="keyword">new</span> ResumeDecoderAction(<span class="literal">false</span> <span class="comment">/* needNotify */</span>));</span><br><span class="line">    <span class="comment">// 把上面mDeferredActions中缓存的所有Action处理下，并清空</span></span><br><span class="line">    processDeferredActions();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的代码相对复杂点，涉及到很多，其实主要是为了设置Surface之后，可以正常解码显示，因为某些情况下解码器初始化需要依赖于具体的Surface。当然，里边还涉及到NuPlayer状态及初始化判断。</p><h5 id="4-5、start-pause"><a href="#4-5、start-pause" class="headerlink" title="4.5、start()/pause()"></a>4.5、start()/pause()</h5><p>start函数实现很简单，实际就发送了kWhatStart消息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> NuPlayer::start() &#123;</span><br><span class="line">    (<span class="keyword">new</span> AMessage(kWhatStart, <span class="keyword">this</span>))-&gt;post();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在消息处理函数中的处理如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> kWhatStart:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mStarted) &#123;</span><br><span class="line">        <span class="comment">// do not resume yet if the source is still buffering</span></span><br><span class="line">        <span class="keyword">if</span> (!mPausedForBuffering) &#123;</span><br><span class="line">            onResume();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        onStart();</span><br><span class="line">    &#125;</span><br><span class="line">    mPausedByClient = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接调用了OnStart/OnResume函数。<br>pause函数实现类似，只是发送的是kWhatPause消息。在消息处理函数中的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> kWhatPause:</span><br><span class="line">&#123;</span><br><span class="line">    onPause();</span><br><span class="line">    mPausedByClient = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接调用的onPause函数。下面单独分析下这三个函数。先从简单的函数开始OnPause/onResume</p><p>NuPlayer::onPause<br>这个函数实现暂停功能，总体来说就是把Source和Render暂停就可以了，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> NuPlayer::onPause() &#123;</span><br><span class="line">    <span class="keyword">if</span> (mPaused) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mPaused = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (mSource != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mSource-&gt;pause();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mRenderer != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mRenderer-&gt;pause();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NuPlayer::onResume<br>这个函数实现恢复功能，代码逻辑跟onPause差不多，把Source和Render恢复，还可能涉及其它操作。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> NuPlayer::onResume() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mPaused || mResetting) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mPaused = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (mSource != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mSource-&gt;resume();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// |mAudioDecoder| may have been released due to the pause timeout, so re-create it if</span></span><br><span class="line">    <span class="comment">// needed.</span></span><br><span class="line">    <span class="keyword">if</span> (audioDecoderStillNeeded() &amp;&amp; mAudioDecoder == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        instantiateDecoder(<span class="literal">true</span> <span class="comment">/* audio */</span>, &amp;mAudioDecoder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mRenderer != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mRenderer-&gt;resume();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NuPlayer::onStart<br>这个接口实现启动的操作，相对复杂点，需要初始化解码器、初始化Render、设置Source状态，并将三者关联起来。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> NuPlayer::onStart(<span class="keyword">int64_t</span> startPositionUs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mSourceStarted) &#123;</span><br><span class="line">        mSourceStarted = <span class="literal">true</span>;</span><br><span class="line">        mSource-&gt;start(); <span class="comment">// 设置Source状态</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... (省略部分代码)</span></span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; notify = <span class="keyword">new</span> AMessage(kWhatRendererNotify, <span class="keyword">this</span>);</span><br><span class="line">    ++mRendererGeneration; <span class="comment">// 创建Render和RenderLooper，属性设置、与解码器关联</span></span><br><span class="line">    notify-&gt;setInt32(<span class="string">"generation"</span>, mRendererGeneration);</span><br><span class="line">    mRenderer = <span class="keyword">new</span> Renderer(mAudioSink, notify, flags);</span><br><span class="line">    mRendererLooper = <span class="keyword">new</span> ALooper;</span><br><span class="line">    mRendererLooper-&gt;setName(<span class="string">"NuPlayerRenderer"</span>);</span><br><span class="line">    mRendererLooper-&gt;start(<span class="literal">false</span>, <span class="literal">false</span>, ANDROID_PRIORITY_AUDIO);</span><br><span class="line">    mRendererLooper-&gt;registerHandler(mRenderer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err = mRenderer-&gt;setPlaybackSettings(mPlaybackSettings);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> rate = getFrameRate();</span><br><span class="line">    <span class="keyword">if</span> (rate &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        mRenderer-&gt;setVideoFrameRate(rate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mVideoDecoder != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mVideoDecoder-&gt;setRenderer(mRenderer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mAudioDecoder != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mAudioDecoder-&gt;setRenderer(mRenderer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    postScanSources();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中没有解码器的初始化，那只能继续看看postScanSources代码了。看实现发现就是发送了kWhatScanSources消息。那么消息循环里边是怎么处理的呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> kWhatScanSources:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> generation;</span><br><span class="line">    CHECK(msg-&gt;findInt32(<span class="string">"generation"</span>, &amp;generation));</span><br><span class="line">    <span class="keyword">if</span> (generation != mScanSourcesGeneration) &#123;</span><br><span class="line">        <span class="comment">// Drop obsolete msg.</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mScanSourcesPending = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> mHadAnySourcesBefore = (mAudioDecoder != <span class="literal">NULL</span>) || (mVideoDecoder != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">bool</span> rescan = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialize video before audio because successful initialization of</span></span><br><span class="line">    <span class="comment">// video may change deep buffer mode of audio.</span></span><br><span class="line">    <span class="keyword">if</span> (mSurface != <span class="literal">NULL</span>) &#123; <span class="comment">// 初始化视频解码器</span></span><br><span class="line">        <span class="keyword">if</span> (instantiateDecoder(<span class="literal">false</span>, &amp;mVideoDecoder) == -EWOULDBLOCK) &#123;</span><br><span class="line">            rescan = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Don't try to re-open audio sink if there's an existing decoder.</span></span><br><span class="line">    <span class="keyword">if</span> (mAudioSink != <span class="literal">NULL</span> &amp;&amp; mAudioDecoder == <span class="literal">NULL</span>) &#123; <span class="comment">// 初始化音频解码器</span></span><br><span class="line">        <span class="keyword">if</span> (instantiateDecoder(<span class="literal">true</span>, &amp;mAudioDecoder) == -EWOULDBLOCK) &#123;</span><br><span class="line">            rescan = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mHadAnySourcesBefore &amp;&amp; (mAudioDecoder != <span class="literal">NULL</span> || mVideoDecoder != <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="comment">// This is the first time we've found anything playable.</span></span><br><span class="line">        <span class="comment">// 设置定期查询时长</span></span><br><span class="line">        <span class="keyword">if</span> (mSourceFlags &amp; Source::FLAG_DYNAMIC_DURATION) &#123;</span><br><span class="line">            schedulePollDuration();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err; <span class="comment">// 一些异常处理逻辑</span></span><br><span class="line">    <span class="keyword">if</span> ((err = mSource-&gt;feedMoreTSData()) != OK) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mAudioDecoder == <span class="literal">NULL</span> &amp;&amp; mVideoDecoder == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// We're not currently decoding anything (no audio or</span></span><br><span class="line">            <span class="comment">// video tracks found) and we just ran out of input data.</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (err == ERROR_END_OF_STREAM) &#123;</span><br><span class="line">                notifyListener(MEDIA_PLAYBACK_COMPLETE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                notifyListener(MEDIA_ERROR, MEDIA_ERROR_UNKNOWN, err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果需要的话，重新扫描Source</span></span><br><span class="line">    <span class="keyword">if</span> (rescan) &#123;</span><br><span class="line">        msg-&gt;post(<span class="number">100000l</span>l);</span><br><span class="line">        mScanSourcesPending = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外还有seekToAsync()、resetAsync()、getCurrentPosition()、getFileMeta()。由于实现类似，就不一一介绍了。</p><h5 id="4-6、小结结和疑问"><a href="#4-6、小结结和疑问" class="headerlink" title="4.6、小结结和疑问"></a>4.6、小结结和疑问</h5><p>到这里，我们已经把NuPlayer主要的函数分析完了，但是问题依旧在。比如下面几个：</p><blockquote><p><strong>不同格式的多媒体文件如何探测并解析的？音视频数据缓冲区在哪里？（Source）</strong><br><strong>视频如何显示的？音频如何播放的？音视频同步在哪里？（Renderer）</strong><br><strong>音频解码线程、视频解码线程在哪里？ （DecoderBase）</strong></p></blockquote><p>我想接下来的分析就是解决这些疑问的。</p><h5 id="4-7、Codec-Encoder-、Decoder列表附录"><a href="#4-7、Codec-Encoder-、Decoder列表附录" class="headerlink" title="4.7、Codec Encoder 、Decoder列表附录"></a>4.7、Codec Encoder 、Decoder列表附录</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">[AOSP/device/qcom/msm8996/media_codecs.xml(system/etc/media_codecs.xml)]</span><br><span class="line">&lt;!--</span><br><span class="line"> <span class="number">8996</span> Decoder capabilities</span><br><span class="line"> __________________________________________________________________</span><br><span class="line"> | Codec    | W       H       fps     Mbps    MB/s    | Secure-dec |</span><br><span class="line"> |__________|_________________________________________|____________|</span><br><span class="line"> | h264     | <span class="number">3840</span>    <span class="number">2160</span>    <span class="number">60</span>      <span class="number">100</span>     <span class="number">1958400</span> |  Y         |</span><br><span class="line"> |          | (<span class="number">4096</span>)  (<span class="number">2160</span>)  (<span class="number">56</span>)    (<span class="number">100</span>)           |            |</span><br><span class="line"> | hevc     | <span class="number">3840</span>    <span class="number">2160</span>    <span class="number">60</span>      <span class="number">100</span>     <span class="number">1958400</span> |  Y         |</span><br><span class="line"> |          | (<span class="number">4096</span>)  (<span class="number">2160</span>)  (<span class="number">56</span>)    (<span class="number">100</span>)           |            |</span><br><span class="line"> | mpeg4    | <span class="number">1920</span>    <span class="number">1088</span>    <span class="number">60</span>      <span class="number">60</span>      <span class="number">489600</span>  |  N         |</span><br><span class="line"> | vc1      | <span class="number">1920</span>    <span class="number">1088</span>    <span class="number">60</span>      <span class="number">60</span>      <span class="number">489600</span>  |  Y         |</span><br><span class="line"> | vp8      | <span class="number">3840</span>    <span class="number">2160</span>    <span class="number">30</span>      <span class="number">100</span>     <span class="number">979200</span>  |  N         |</span><br><span class="line"> | vp9      | <span class="number">3840</span>    <span class="number">2160</span>    <span class="number">30</span>      <span class="number">100</span>     <span class="number">979200</span>  |  Y         |</span><br><span class="line"> | divx3    | <span class="number">720</span>     <span class="number">480</span>     <span class="number">30</span>      <span class="number">2</span>       <span class="number">40500</span>   |  N         |</span><br><span class="line"> | div4/<span class="number">5</span>/<span class="number">6</span> | <span class="number">1920</span>    <span class="number">1088</span>    <span class="number">30</span>      <span class="number">10</span>      <span class="number">244800</span>  |  N         |</span><br><span class="line"> | h263     | <span class="number">864</span>     <span class="number">480</span>     <span class="number">30</span>      <span class="number">2</span>       <span class="number">48600</span>   |  N         |</span><br><span class="line"> | mpeg2    | <span class="number">1920</span>    <span class="number">1088</span>    <span class="number">30</span>      <span class="number">40</span>      <span class="number">244800</span>  |  Y         |</span><br><span class="line"> |__________|_________________________________________|____________|</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="number">8996</span> Encoder capabilities</span><br><span class="line"> ______________________________________________________</span><br><span class="line"> | Codec    | W       H       fps     Mbps    MB/s    |</span><br><span class="line"> |__________|_________________________________________|</span><br><span class="line"> | h264     | <span class="number">3840</span>    <span class="number">2160</span>    <span class="number">30</span>      <span class="number">100</span>     <span class="number">979200</span>  |</span><br><span class="line"> | hevc     | <span class="number">3840</span>    <span class="number">2160</span>    <span class="number">30</span>      <span class="number">100</span>     <span class="number">979200</span>  |</span><br><span class="line"> | mpeg4    | <span class="number">1920</span>    <span class="number">1088</span>    <span class="number">60</span>      <span class="number">60</span>      <span class="number">489600</span>  |</span><br><span class="line"> | vp8      | <span class="number">3840</span>    <span class="number">2160</span>    <span class="number">30</span>      <span class="number">100</span>     <span class="number">979200</span>  |</span><br><span class="line"> | h263     | <span class="number">864</span>     <span class="number">480</span>     <span class="number">30</span>      <span class="number">2</span>       <span class="number">48600</span>   |</span><br><span class="line"> |__________|_________________________________________|</span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">&lt;MediaCodecs&gt;</span><br><span class="line">    &lt;Include href=<span class="string">"media_codecs_google_audio.xml"</span> /&gt;</span><br><span class="line">    &lt;Include href=<span class="string">"media_codecs_google_telephony.xml"</span> /&gt;</span><br><span class="line">    &lt;Settings&gt;</span><br><span class="line">        &lt;Setting name=<span class="string">"max-video-encoder-input-buffers"</span> value=<span class="string">"11"</span> /&gt;</span><br><span class="line">    &lt;/Settings&gt;</span><br><span class="line">    &lt;Encoders&gt;</span><br><span class="line">        &lt;!-- Audio Hardware  --&gt;</span><br><span class="line">        &lt;!-- Audio Software  --&gt;</span><br><span class="line">        &lt;!-- Video Hardware  --&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.encoder.avc"</span> type=<span class="string">"video/avc"</span> &gt;</span><br><span class="line">            &lt;Quirk name=<span class="string">"requires-allocate-on-input-ports"</span> /&gt;</span><br><span class="line">            &lt;Quirk name=<span class="string">"requires-allocate-on-output-ports"</span> /&gt;</span><br><span class="line">            &lt;Quirk name=<span class="string">"requires-loaded-to-idle-after-allocation"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"size"</span> min=<span class="string">"96x64"</span> max=<span class="string">"4096x2160"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"alignment"</span> value=<span class="string">"2x2"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"block-size"</span> value=<span class="string">"16x16"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"blocks-per-second"</span> min=<span class="string">"1"</span> max=<span class="string">"979200"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"bitrate"</span> range=<span class="string">"1-100000000"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"frame-rate"</span> range=<span class="string">"1-240"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"concurrent-instances"</span> max=<span class="string">"16"</span> /&gt;</span><br><span class="line">          ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.encoder.mpeg4"</span> type=<span class="string">"video/mp4v-es"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.encoder.h263"</span> type=<span class="string">"video/3gpp"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.encoder.vp8"</span> type=<span class="string">"video/x-vnd.on2.vp8"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.encoder.hevc"</span> type=<span class="string">"video/hevc"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">    &lt;/Encoders&gt;</span><br><span class="line">    &lt;Decoders&gt;</span><br><span class="line">       &lt;!-- Video Hardware  --&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.avc"</span> type=<span class="string">"video/avc"</span> &gt;</span><br><span class="line">            &lt;Quirk name=<span class="string">"requires-allocate-on-input-ports"</span> /&gt;</span><br><span class="line">            &lt;Quirk name=<span class="string">"requires-allocate-on-output-ports"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"size"</span> min=<span class="string">"64x64"</span> max=<span class="string">"4096x2160"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"alignment"</span> value=<span class="string">"2x2"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"block-size"</span> value=<span class="string">"16x16"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"blocks-per-second"</span> min=<span class="string">"1"</span> max=<span class="string">"1958400"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"bitrate"</span> range=<span class="string">"1-100000000"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"frame-rate"</span> range=<span class="string">"1-240"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"vt-version"</span> value=<span class="string">"65537"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"vt-low-latency"</span> value=<span class="string">"1"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"vt-max-macroblock-processing-rate"</span> value=<span class="string">"972000"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"vt-max-level"</span> value=<span class="string">"52"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"vt-max-instances"</span> value=<span class="string">"16"</span> /&gt;</span><br><span class="line">            &lt;Feature name=<span class="string">"adaptive-playback"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"concurrent-instances"</span> max=<span class="string">"16"</span> /&gt;</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.avc.secure"</span> type=<span class="string">"video/avc"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.mpeg4"</span> type=<span class="string">"video/mp4v-es"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.mpeg2"</span> type=<span class="string">"video/mpeg2"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.mpeg2.secure"</span> type=<span class="string">"video/mpeg2"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.h263"</span> type=<span class="string">"video/3gpp"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.vc1"</span> type=<span class="string">"video/x-ms-wmv"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.vc1.secure"</span> type=<span class="string">"video/x-ms-wmv"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.divx"</span> type=<span class="string">"video/divx"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.divx311"</span> type=<span class="string">"video/divx311"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.divx4"</span> type=<span class="string">"video/divx4"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.vp8"</span> type=<span class="string">"video/x-vnd.on2.vp8"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.vp9"</span> type=<span class="string">"video/x-vnd.on2.vp9"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.vp9.secure"</span> type=<span class="string">"video/x-vnd.on2.vp9"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.hevc"</span> type=<span class="string">"video/hevc"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.hevc.secure"</span> type=<span class="string">"video/hevc"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;!-- Audio Software  --&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qti.audio.decoder.flac"</span> type=<span class="string">"audio/flac"</span> /&gt;</span><br><span class="line">    &lt;/Decoders&gt;</span><br><span class="line">    &lt;Include href=<span class="string">"media_codecs_google_video.xml"</span> /&gt;</span><br><span class="line">&lt;/MediaCodecs&gt;</span><br></pre></td></tr></table></figure><h4 id="（五）、参考资料-特别感谢各位前辈的分析和图示-："><a href="#（五）、参考资料-特别感谢各位前辈的分析和图示-：" class="headerlink" title="（五）、参考资料(特别感谢各位前辈的分析和图示)："></a>（五）、参考资料(特别感谢各位前辈的分析和图示)：</h4><p><a href="http://www.cnblogs.com/tocy/tag/%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6/" target="_blank" rel="noopener">Android NuPlayer播放框架 </a><br><a href="https://blog.csdn.net/column/details/12812.html" target="_blank" rel="noopener">专栏：MultiMedia框架总结(基于6.0源码) - CSDN博客</a><br><a href="windrunnerlihuan.com">Android多媒体开发-归档 | April is your lie</a><br><a href="https://blog.csdn.net/miaomiao12345678/article/details/57415505" target="_blank" rel="noopener">Android-7.0-Nuplayer概述 - CSDN博客</a><br><a href="https://blog.csdn.net/miaomiao12345678/article/details/57409783" target="_blank" rel="noopener">Android-7.0-MediaPlayer状态机 - CSDN博客</a><br><a href="https://blog.csdn.net/miaomiao12345678/article/details/56961370" target="_blank" rel="noopener">Android-7.0-Nuplayer-启动流程 - CSDN博客</a><br><a href="https://zh.wikipedia.org/wiki/YUV" target="_blank" rel="noopener">YUV - 维基百科，自由的百科全书</a><br><a href="https://blog.csdn.net/harman_zjc/article/details/53386010" target="_blank" rel="noopener">Android Media Player 框架分析-Nuplayer（1） - CSDN博客</a><br><a href="https://blog.csdn.net/harman_zjc/article/details/53397945" target="_blank" rel="noopener">Android Media Player 框架分析-AHandler AMessage ALooper - CSDN博客</a><br><a href="https://blog.csdn.net/gzzaigcnforever/article/category/2135451/1?" target="_blank" rel="noopener">Android 4.2.2 stagefright架构 - CSDN博客</a><br><a href="https://blog.csdn.net/gzzaigcnforever/article/details/26849549" target="_blank" rel="noopener">android4.2.2的stagefright架构下基于SurfaceFlinger的视频解码输出缓存创建机制 - CSDN博客</a><br><a href="https://blog.csdn.net/dfhuang09/article/category/7610722" target="_blank" rel="noopener">husanlim 的专栏 参考 - CSDN博客</a><br><a href="https://blog.csdn.net/dfhuang09/article/details/54926526" target="_blank" rel="noopener">android ACodec MediaCodec NuPlayer flow - CSDN博客</a><br><a href="https://blog.csdn.net/dfhuang09/article/details/60132620" target="_blank" rel="noopener">android MediaCodec ACodec - CSDN博客</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;amp;&amp;amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内
      
    
    </summary>
    
      <category term="Android" scheme="http://zhoujinjian.cc/categories/Android/"/>
    
    
      <category term="Android" scheme="http://zhoujinjian.cc/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Audio System（3）：Android audio system(音频系统)分析</title>
    <link href="http://zhoujinjian.cc/2018/05/25/Audio%20System%EF%BC%883%EF%BC%89%EF%BC%9AAndroid%20audio%20system%5B%E9%9F%B3%E9%A2%91%E7%B3%BB%E7%BB%9F%5D%E5%88%86%E6%9E%90/"/>
    <id>http://zhoujinjian.cc/2018/05/25/Audio System（3）：Android audio system[音频系统]分析/</id>
    <published>2018-05-24T16:00:00.000Z</published>
    <updated>2018-05-09T15:03:52.335Z</updated>
    
    <content type="html"><![CDATA[<hr><p>注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;&amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除，禁止转载（©Qualcomm Technologies, Inc. 版权所有），谢谢。</p><p><a href="https://github.com/izhoujinjian/zhoujinjian.cc/tree/master/audio.system" target="_blank" rel="noopener">【博客原图链接】</a><br><a href="https://blog.csdn.net/xuesen_lin/article/category/1390680" target="_blank" rel="noopener">【特别感谢 - 林学森的Android专栏】</a><br><a href="https://blog.csdn.net/yangwen123/article/category/2589087" target="_blank" rel="noopener">【特别感谢 - Yangwen123 - 深入剖析Android音频系统】</a><br><a href="https://blog.csdn.net/yangwen123/article/category/2589087" target="_blank" rel="noopener">【特别感谢 - Zyuanyun - Android 音频系统：从 AudioTrack 到 AudioFlinger】</a><br>Google Pixel、Pixel XL 内核代码（Kernel-3.18）：<br> <a href="https://github.com/matthewdalex/marlin" target="_blank" rel="noopener">Kernel source for Pixel and Pixel XL - GitHub</a></p><p>AOSP 源码（文章基于 Android 7.1.2）：<br> <a href="https://testerhome.com/topics/2229" target="_blank" rel="noopener"> Android 系统全套源代码分享 (更新到 8.1.0_r1)</a></p><hr><p>源码（主要源码路径）：</p><blockquote><p>User space audio code 源码：</p></blockquote><p>• <strong>/hardware/qcom/audio/hal/ – (Audio 高通HAL 源码)</strong> </p><p>• <strong>/libhardware/modules/audio/ – (Audio 原生HAL 源码)</strong> </p><p>• <strong>/external/tinyalsa/ –  (tinymix, tinyplay, tinycap 源码)</strong></p><p>• <strong>/vendor/qcom/proprietary/mm-audio/ – (QTI OMX  audio encoder and decoders 源码，未公开)</strong></p><p>• <strong>/frameworks/av/media/audioserver/ – (Audioserver 源码)</strong></p><p>• <strong>/hardware/libhardware_legacy/audio – (Audio legacy 源码)</strong></p><p>• <strong>/frameworks/av/media/libstagefright/ – (Google Stagefright 多媒体框架源码)</strong></p><p>• <strong>/frameworks/av/services/audioflinger/ – (Audioflinger 相关源码)</strong></p><p>• <strong>/external/bluetooth/bluedroid/ – (A2DP audio HAL 相关源码)</strong>/</p><p>• <strong>/hardware/libhardware/modules/usbaudio/ – (USB HAL 源码)</strong>/</p><p>• <strong>/vendor/qcom/proprietary/wfd/mm/source/framework/src/ – (Wi-Fi Display (WFD)、 WFDMMSourceAudioSource.cpp，未公开)</strong></p><p>• <strong>/system/core/include/system/ – (audio.h)</strong>/</p><h4 id="一-、深入剖析Android音频之AudioFlinger"><a href="#一-、深入剖析Android音频之AudioFlinger" class="headerlink" title="(一)、深入剖析Android音频之AudioFlinger"></a>(一)、深入剖析Android音频之AudioFlinger</h4><h5 id="1-0、总体框架图"><a href="#1-0、总体框架图" class="headerlink" title="1.0、总体框架图"></a>1.0、总体框架图</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/31-Audio-system-Android-Linux-arc.png" alt="Alt text"></p><p>系统启动时将执行 /system/etc/init/audioserver.rc ，运行 /system/bin/ 目录下的 audioserver 服务。audioserver.rc 内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\audioserver\audioserver.rc]</span><br><span class="line">service audioserver /system/bin/audioserver</span><br><span class="line">    class main</span><br><span class="line">    user audioserver</span><br><span class="line">    # media gid needed for /dev/fm (radio ) and for  /data/misc/media (tee)</span><br><span class="line">    group audio radio camera drmpc inet media mediarm net_bt net_bt_admin net_bw_acct</span><br><span class="line">    ioprio rt 4</span><br><span class="line">    writepid /dev/cpuset/forground/tasks /dev/stune/foreground/tasks</span><br></pre></td></tr></table></figure><p>audioserver 是由同目录下main_audioserver编译生成的。</p><h5 id="1-1、AudioFlinger"><a href="#1-1、AudioFlinger" class="headerlink" title="1.1、AudioFlinger"></a>1.1、AudioFlinger</h5><p>AudioFlinger是整个音频系统的核心与难点。作为Android系统中的音频中枢，它同时也是一个系统服务，启到承上(为上层提供访问接口)启下(通过HAL来管理音频设备)的作用。只有理解了AudioFlinger，才能以此为基础更好地深入到其它模块，并且Audioserver最先启动的也是AudioFlinger，因而我们把它放在前面进行分析。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\audioserver\main_audioserver.cpp]</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc __unused, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (doLog &amp;&amp; (childPid = fork()) != <span class="number">0</span>) &#123;</span><br><span class="line">    ......</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// all other services</span></span><br><span class="line">        <span class="keyword">if</span> (doLog) &#123;</span><br><span class="line">            prctl(PR_SET_PDEATHSIG, SIGKILL);   <span class="comment">// if parent media.log dies before me, kill me also</span></span><br><span class="line">            setpgid(<span class="number">0</span>, <span class="number">0</span>);                      <span class="comment">// but if I die first, don't kill my parent</span></span><br><span class="line">        &#125;</span><br><span class="line">        sp&lt;ProcessState&gt; proc(ProcessState::self());</span><br><span class="line">        sp&lt;IServiceManager&gt; sm = defaultServiceManager();</span><br><span class="line">        ALOGI(<span class="string">"ServiceManager: %p"</span>, sm.get());</span><br><span class="line">        AudioFlinger::instantiate();</span><br><span class="line">        AudioPolicyService::instantiate();</span><br><span class="line">        RadioService::instantiate();</span><br><span class="line">        SoundTriggerHwService::instantiate();</span><br><span class="line">        ProcessState::self()-&gt;startThreadPool();</span><br><span class="line">        IPCThreadState::self()-&gt;joinThreadPool();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AudioFlinger继承了模板类BinderService，该类用于注册native service。<br>BinderService是一个模板类，该类的publish函数就是完成向ServiceManager注册服务。<br>AudioFlinger注册名为”media.audio_flinger”的服务。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getServiceName</span><span class="params">()</span> ANDROID_API </span>&#123; <span class="keyword">return</span> <span class="string">"media.audio_flinger"</span>; &#125;</span><br></pre></td></tr></table></figure></p><h5 id="1-1-1-AudioFlinger服务的启动和运行"><a href="#1-1-1-AudioFlinger服务的启动和运行" class="headerlink" title="1.1.1 AudioFlinger服务的启动和运行"></a>1.1.1 AudioFlinger服务的启动和运行</h5><p>AudioFlinger的构造函数，发现它只是简单地为内部一些变量做了初始化，除此之外就没有任何代码了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\AudioFlinger.cpp]</span><br><span class="line">AudioFlinger::AudioFlinger()</span><br><span class="line">    : BnAudioFlinger(),</span><br><span class="line">      mPrimaryHardwareDev(<span class="literal">NULL</span>),</span><br><span class="line">      mAudioHwDevs(<span class="literal">NULL</span>),</span><br><span class="line">      mHardwareStatus(AUDIO_HW_IDLE),</span><br><span class="line">      mMasterVolume(<span class="number">1.0f</span>),</span><br><span class="line">      mMasterMute(<span class="literal">false</span>),</span><br><span class="line">      <span class="comment">// mNextUniqueId(AUDIO_UNIQUE_ID_USE_MAX),</span></span><br><span class="line">      mMode(AUDIO_MODE_INVALID),</span><br><span class="line">      mBtNrecIsOff(<span class="literal">false</span>),</span><br><span class="line">      mIsLowRamDevice(<span class="literal">true</span>),</span><br><span class="line">      mIsDeviceTypeKnown(<span class="literal">false</span>),</span><br><span class="line">      mGlobalEffectEnableTime(<span class="number">0</span>),</span><br><span class="line">      mSystemReady(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// unsigned instead of audio_unique_id_use_t, because ++ operator is unavailable for enum</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> use = AUDIO_UNIQUE_ID_USE_UNSPECIFIED; use &lt; AUDIO_UNIQUE_ID_USE_MAX; use++) &#123;</span><br><span class="line">        <span class="comment">// zero ID has a special meaning, so unavailable</span></span><br><span class="line">        mNextUniqueIds[use] = AUDIO_UNIQUE_ID_USE_MAX;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BnAudioFlinger是由RefBase层层继承而来的，并且IServiceManager::addService的第二个参数实际上是一个强指针引用(constsp<ibinder>&amp;),因而AudioFlinger具备了强指针被第一次引用时调用onFirstRef的程序逻辑。</ibinder></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\AudioFlinger.cpp]</span><br><span class="line"><span class="keyword">void</span> AudioFlinger::onFirstRef()</span><br><span class="line">&#123;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* <span class="doctag">TODO:</span> move all this work into an Init() function */</span></span><br><span class="line">    <span class="keyword">char</span> val_str[PROPERTY_VALUE_MAX] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">if</span> (property_get(<span class="string">"ro.audio.flinger_standbytime_ms"</span>, val_str, <span class="literal">NULL</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> int_val;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1</span> == <span class="built_in">sscanf</span>(val_str, <span class="string">"%u"</span>, &amp;int_val)) &#123;</span><br><span class="line">            mStandbyTimeInNsecs = milliseconds(int_val);</span><br><span class="line">            ALOGI(<span class="string">"Using %u mSec as standby time."</span>, int_val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mStandbyTimeInNsecs = kDefaultStandbyTimeInNsecs;</span><br><span class="line">            ALOGI(<span class="string">"Using default %u mSec as standby time."</span>,</span><br><span class="line">                    (<span class="keyword">uint32_t</span>)(mStandbyTimeInNsecs / <span class="number">1000000</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mPatchPanel = <span class="keyword">new</span> PatchPanel(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    mMode = AUDIO_MODE_NORMAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这时开始，AudioFlinger就是一个“有意义”的实体了</p><h5 id="1-2、音频设备的管理"><a href="#1-2、音频设备的管理" class="headerlink" title="1.2、音频设备的管理"></a>1.2、音频设备的管理</h5><p>虽然AudioFlinger实体已经成功创建并初始化，但到目前为止它还是一块静态的内存空间，没有涉及到具体的工作。</p><p>从职能分布上来讲，AudioPolicyService是策略的制定者，比如什么时候打开音频接口设备、某种Stream类型的音频对应什么设备等等。而AudioFlinger则是策略的执行者，例如具体如何与音频设备通信，如何维护现有系统中的音频设备，以及多个音频流的混音如何处理等等都得由它来完成。</p><p>目前Audio系统中支持的音频设备接口(Audio Interface)分为三大类，即：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\AudioFlinger.cpp]</span><br><span class="line">static const char * const audio_interfaces[] = &#123;</span><br><span class="line">    AUDIO_HARDWARE_MODULE_ID_PRIMARY,</span><br><span class="line">    AUDIO_HARDWARE_MODULE_ID_A2DP,</span><br><span class="line">    AUDIO_HARDWARE_MODULE_ID_USB,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每种音频设备接口由一个对应的so库提供支持。那么AudioFlinger怎么会知道当前设备中支持上述的哪些接口，每种接口又支持哪些具体的音频设备呢？这是AudioPolicyService的责任之一，即根据用户配置来指导AudioFlinger加载设备接口。</p><p>当AudioPolicyManagerBase(AudioPolicyService中持有的Policy管理者，后面小节有详细介绍)构造时，它会读取厂商关于音频设备的描述文件(audio_policy.conf)，然后据此来打开以上三类音频接口(如果存在的话)。这一过程最终会调用loadHwModule@AudioFlinger，如下所示：</p><h5 id="1-2-1、加载设备loadHwModule"><a href="#1-2-1、加载设备loadHwModule" class="headerlink" title="1.2.1、加载设备loadHwModule()"></a>1.2.1、加载设备loadHwModule()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\AudioFlinger.cpp]</span><br><span class="line">/*name就是前面audio_interfaces 数组成员中的字符串*/</span><br><span class="line">audio_module_handle_t AudioFlinger::loadHwModule(const char *name)</span><br><span class="line">&#123;</span><br><span class="line">    if (name == NULL) &#123;</span><br><span class="line">        return AUDIO_MODULE_HANDLE_NONE;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!settingsAllowed()) &#123;</span><br><span class="line">        return AUDIO_MODULE_HANDLE_NONE;</span><br><span class="line">    &#125;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    return loadHwModule_l(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数没有做实质性的工作，只是执行了加锁动作，然后接着调用下面的函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\AudioFlinger.cpp]</span><br><span class="line">// loadHwModule_l() must be called with AudioFlinger::mLock held</span><br><span class="line">audio_module_handle_t AudioFlinger::loadHwModule_l(const char *name)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    /* Step 1. 是否已经添加了这个interface ? */</span><br><span class="line">    for (size_t i = 0; i &lt; mAudioHwDevs.size(); i++) &#123;</span><br><span class="line">        if (strncmp(mAudioHwDevs.valueAt(i)-&gt;moduleName(), name, strlen(name)) == 0) &#123;</span><br><span class="line">            ALOGW(&quot;loadHwModule() module %s already loaded&quot;, name);</span><br><span class="line">            return mAudioHwDevs.keyAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    audio_hw_device_t *dev;</span><br><span class="line">    /* Step 2. 加载audio interface */</span><br><span class="line">    int rc = load_audio_interface(name, &amp;dev);</span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    /* Step 3. 初始化 */</span><br><span class="line">    mHardwareStatus = AUDIO_HW_INIT;</span><br><span class="line">    rc = dev-&gt;init_check(dev);</span><br><span class="line">    mHardwareStatus = AUDIO_HW_IDLE;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">    /* Step 4. 添加到全局变量中 */</span><br><span class="line">    audio_module_handle_t handle = (audio_module_handle_t) nextUniqueId(AUDIO_UNIQUE_ID_USE_MODULE);</span><br><span class="line">    mAudioHwDevs.add(handle, new AudioHwDevice(handle, name, dev, flags));</span><br><span class="line"></span><br><span class="line">    return handle;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step1@ loadHwModule_l. 首先查找mAudioHwDevs是否已经添加了变量name所指示的audio interface，如果是的话直接返回。第一次进入时mAudioHwDevs的size为0，所以还会继续往下执行。</p><p>Step2@ loadHwModule_l. 加载指定的audiointerface，比如“primary”、“a2dp”或者“usb”。函数load_audio_interface用来加载设备所需的库文件，然后打开设备并创建一个audio_hw_device_t实例。音频接口设备所对应的库文件名称是有一定格式的，比如a2dp的模块名可能是audio.a2dp.so或者audio.a2dp.default.so等等。查找路径主要有两个，即：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\libhardware\hardware.c]</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAL_LIBRARY_PATH1 <span class="meta-string">"/system/lib64/hw"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAL_LIBRARY_PATH2 <span class="meta-string">"/vendor/lib64/hw"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAL_LIBRARY_PATH3 <span class="meta-string">"/odm/lib64/hw"</span></span></span><br></pre></td></tr></table></figure><p>当然，因为Android是完全开源的，各开发商可以根据自己的需要来进行相应的修改，比如下面是Google pixel 设备的音频库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">adb shell &amp;&amp; cd system/lib64/hw &amp;&amp; ls -l</span><br><span class="line">-rw-r--r-- 1 root root   30440 2009-01-01 00:00 audio.a2dp.default.so</span><br><span class="line">-rw-r--r-- 1 root root   18156 2009-01-01 00:00 audio.primary.default.so</span><br><span class="line">-rw-r--r-- 1 root root  275612 2009-01-01 00:00 audio.primary.msm8996.so</span><br><span class="line">-rw-r--r-- 1 root root   34540 2009-01-01 00:00 audio.r_submix.default.so</span><br><span class="line">-rw-r--r-- 1 root root   22248 2009-01-01 00:00 audio.usb.default.so</span><br><span class="line">-rw-r--r-- 1 root root   96096 2009-01-01 00:00 audio_policy.default.so</span><br><span class="line">-rw-r--r-- 1 root root 1637208 2009-01-01 00:00 bluetooth.default.so</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>Step3@ loadHwModule_l，进行初始化操作。其中init_check是为了确定这个audio interface是否已经成功初始化，0是成功，其它值表示失败。接下来如果这个device支持主音量，我们还需要通过set_master_volume进行设置。在每次操作device前，都要先改变mHardwareStatus的状态值，操作结束后将其复原为AUDIO_HW_IDLE(根据源码中的注释，这样做是为了方便dump时正确输出内部状态，这里我们就不去深究了)。</p><p>Step4@ loadHwModule_l. 把加载后的设备添加入mAudioHwDevs键值对中，其中key的值是由nextUniqueId生成的，这样做保证了这个audiointerface拥有全局唯一的id号。</p><p>完成了audiointerface的模块加载只是万里长征的第一步。因为每一个interface包含的设备通常不止一个，Android系统目前支持的音频设备如下列表所示：<br> Android系统支持的音频设备列表(输出)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\libhardware_legacy\audio\audio_hw_hal.cpp]</span><br><span class="line">static uint32_t audio_device_conv_table[][HAL_API_REV_NUM] =</span><br><span class="line">&#123;</span><br><span class="line">    /* output devices */</span><br><span class="line">    &#123; AudioSystem::DEVICE_OUT_EARPIECE, AUDIO_DEVICE_OUT_EARPIECE &#125;,//</span><br><span class="line">    &#123; AudioSystem::DEVICE_OUT_SPEAKER, AUDIO_DEVICE_OUT_SPEAKER &#125;,//SPEAKER</span><br><span class="line">    &#123; AudioSystem::DEVICE_OUT_WIRED_HEADSET, AUDIO_DEVICE_OUT_WIRED_HEADSET &#125;,//HEADSET</span><br><span class="line">    &#123; AudioSystem::DEVICE_OUT_WIRED_HEADPHONE, AUDIO_DEVICE_OUT_WIRED_HEADPHONE &#125;,//HEADPHONE</span><br><span class="line">    &#123; AudioSystem::DEVICE_OUT_BLUETOOTH_SCO, AUDIO_DEVICE_OUT_BLUETOOTH_SCO &#125;,</span><br><span class="line">    &#123; AudioSystem::DEVICE_OUT_BLUETOOTH_SCO_HEADSET, AUDIO_DEVICE_OUT_BLUETOOTH_SCO_HEADSET &#125;,</span><br><span class="line">    &#123; AudioSystem::DEVICE_OUT_BLUETOOTH_SCO_CARKIT, AUDIO_DEVICE_OUT_BLUETOOTH_SCO_CARKIT &#125;,</span><br><span class="line">    &#123; AudioSystem::DEVICE_OUT_BLUETOOTH_A2DP, AUDIO_DEVICE_OUT_BLUETOOTH_A2DP &#125;,</span><br><span class="line">    &#123; AudioSystem::DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES, AUDIO_DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES &#125;,</span><br><span class="line">    &#123; AudioSystem::DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER, AUDIO_DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER &#125;,</span><br><span class="line">    &#123; AudioSystem::DEVICE_OUT_AUX_DIGITAL, AUDIO_DEVICE_OUT_AUX_DIGITAL &#125;,</span><br><span class="line">    &#123; AudioSystem::DEVICE_OUT_ANLG_DOCK_HEADSET, AUDIO_DEVICE_OUT_ANLG_DOCK_HEADSET &#125;,</span><br><span class="line">    &#123; AudioSystem::DEVICE_OUT_DGTL_DOCK_HEADSET, AUDIO_DEVICE_OUT_DGTL_DOCK_HEADSET &#125;,</span><br><span class="line">    &#123; AudioSystem::DEVICE_OUT_DEFAULT, AUDIO_DEVICE_OUT_DEFAULT &#125;,//默认设备</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家可能会有疑问：</p><p>Ø 这么多的输出设备，那么当我们回放音频流(录音也是类似的情况)时，该选择哪一种呢？</p><p>Ø 而且当前系统中audio interface也很可能不止一个，应该如何选择？</p><p>显然这些决策工作将由AudioPolicyService来完成，我们会在下一小节做详细阐述。这里先给大家分析下，AudioFlinger是如何打开一个Output通道的(一个audiointerface可能包含若干个output)。</p><h5 id="1-2-2、打开音频输出通道openOutput"><a href="#1-2-2、打开音频输出通道openOutput" class="headerlink" title="1.2.2、打开音频输出通道openOutput()"></a>1.2.2、打开音频输出通道openOutput()</h5><p>打开音频输出通道(output)在AudioFlinger中对应的接口是openOutput()，即：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\AudioFlinger.cpp]</span><br><span class="line"><span class="keyword">status_t</span> AudioFlinger::openOutput(<span class="keyword">audio_module_handle_t</span> <span class="keyword">module</span>,</span><br><span class="line">                                  <span class="keyword">audio_io_handle_t</span> *output,</span><br><span class="line">                                  <span class="keyword">audio_config_t</span> *config,</span><br><span class="line">                                  <span class="keyword">audio_devices_t</span> *devices,</span><br><span class="line">                                  <span class="keyword">const</span> String8&amp; address,</span><br><span class="line">                                  <span class="keyword">uint32_t</span> *latencyMs,</span><br><span class="line">                                  <span class="keyword">audio_output_flags_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line"></span><br><span class="line">    sp&lt;PlaybackThread&gt; thread = openOutput_l(<span class="keyword">module</span>, output, config, *devices, address, flags);</span><br><span class="line">    <span class="keyword">if</span> (thread != <span class="number">0</span>) &#123;</span><br><span class="line">        *latencyMs = thread-&gt;latency();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// notify client processes of the new output creation</span></span><br><span class="line">        thread-&gt;ioConfigChanged(AUDIO_OUTPUT_OPENED);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// the first primary output opened designates the primary hw device</span></span><br><span class="line">        <span class="keyword">if</span> ((mPrimaryHardwareDev == <span class="literal">NULL</span>) &amp;&amp; (flags &amp; AUDIO_OUTPUT_FLAG_PRIMARY)) &#123;</span><br><span class="line">            ALOGI(<span class="string">"Using module %d has the primary audio interface"</span>, <span class="keyword">module</span>);</span><br><span class="line">            mPrimaryHardwareDev = thread-&gt;getOutput()-&gt;audioHwDev;</span><br><span class="line"></span><br><span class="line">            <span class="function">AutoMutex <span class="title">lock</span><span class="params">(mHardwareLock)</span></span>;</span><br><span class="line">            mHardwareStatus = AUDIO_HW_SET_MODE;</span><br><span class="line">            mPrimaryHardwareDev-&gt;hwDevice()-&gt;set_mode(mPrimaryHardwareDev-&gt;hwDevice(), mMode);</span><br><span class="line">            mHardwareStatus = AUDIO_HW_IDLE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_INIT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续调用 openOutput_l()函数从处理。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\AudioFlinger.cpp]</span><br><span class="line">sp&lt;AudioFlinger::PlaybackThread&gt; AudioFlinger::openOutput_l(<span class="keyword">audio_module_handle_t</span> <span class="keyword">module</span>,</span><br><span class="line">                                                            <span class="keyword">audio_io_handle_t</span> *output,</span><br><span class="line">                                                            <span class="keyword">audio_config_t</span> *config,</span><br><span class="line">                                                            <span class="keyword">audio_devices_t</span> devices,</span><br><span class="line">                                                            <span class="keyword">const</span> String8&amp; address,</span><br><span class="line">                                                            <span class="keyword">audio_output_flags_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*Step 1. 查找相应的audio interface</span></span><br><span class="line"><span class="comment">    AudioHwDevice *outHwDev = findSuitableHwDev_l(module, devices);</span></span><br><span class="line"><span class="comment">    ......</span></span><br><span class="line"><span class="comment">    mHardwareStatus = AUDIO_HW_OUTPUT_OPEN;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     ......</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    AudioStreamOut *outputStream = NULL;</span></span><br><span class="line"><span class="comment">     /*Step 2. 为设备打开一个输出流*/</span></span><br><span class="line">    <span class="keyword">status_t</span> status = outHwDev-&gt;openOutputStream(</span><br><span class="line">            &amp;outputStream,</span><br><span class="line">            *output,</span><br><span class="line">            devices,</span><br><span class="line">            flags,</span><br><span class="line">            config,</span><br><span class="line">            address.<span class="built_in">string</span>());</span><br><span class="line"></span><br><span class="line">    mHardwareStatus = AUDIO_HW_IDLE;</span><br><span class="line">    <span class="comment">/*Step 3.创建PlaybackThread*/</span></span><br><span class="line">    <span class="keyword">if</span> (status == NO_ERROR) &#123;</span><br><span class="line"></span><br><span class="line">        PlaybackThread *thread;</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD) &#123;</span><br><span class="line">            thread = <span class="keyword">new</span> OffloadThread(<span class="keyword">this</span>, outputStream, *output, devices, mSystemReady);</span><br><span class="line">            ALOGV(<span class="string">"openOutput_l() created offload output: ID %d thread %p"</span>, *output, thread);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((flags &amp; AUDIO_OUTPUT_FLAG_DIRECT)</span><br><span class="line">                || !isValidPcmSinkFormat(config-&gt;format)</span><br><span class="line">                || !isValidPcmSinkChannelMask(config-&gt;channel_mask)) &#123;</span><br><span class="line">            thread = <span class="keyword">new</span> DirectOutputThread(<span class="keyword">this</span>, outputStream, *output, devices, mSystemReady);</span><br><span class="line">            ALOGV(<span class="string">"openOutput_l() created direct output: ID %d thread %p"</span>, *output, thread);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            thread = <span class="keyword">new</span> MixerThread(<span class="keyword">this</span>, outputStream, *output, devices, mSystemReady);</span><br><span class="line">            ALOGV(<span class="string">"openOutput_l() created mixer output: ID %d thread %p"</span>, *output, thread);</span><br><span class="line">        &#125;</span><br><span class="line">        mPlaybackThreads.add(*output, thread);</span><br><span class="line">        <span class="keyword">return</span> thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面这段代码中，颜色加深的部分是我们接下来分析的重点，主要还是围绕outHwDev这个变量所做的一系列操作，即：</p><p>·        查找合适的音频接口设备( findSuitableHwDev_l() )</p><p>·        创建音频输出流( 通过openOutputStream()创建AudioStreamOut )</p><p>·        创建播放线程( PlaybackThread )</p><p>outHwDev用于记录一个打开的音频接口设备，它的数据类型是audio_hw_device_t，是由HAL规定的一个音频接口设备所应具有的属性集合，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\AudioHwDevice.h]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AudioHwDevice</span> &#123;</span></span><br><span class="line">......</span><br><span class="line">    <span class="keyword">audio_module_handle_t</span> handle() <span class="keyword">const</span> &#123; <span class="keyword">return</span> mHandle; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">moduleName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> mModuleName; &#125;</span><br><span class="line">    <span class="keyword">audio_hw_device_t</span> *hwDevice() <span class="keyword">const</span> &#123; <span class="keyword">return</span> mHwDevice; &#125;</span><br><span class="line">    <span class="keyword">uint32_t</span> version() <span class="keyword">const</span> &#123; <span class="keyword">return</span> mHwDevice-&gt;common.version; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">status_t</span> openOutputStream(</span><br><span class="line">            AudioStreamOut **ppStreamOut,</span><br><span class="line">            <span class="keyword">audio_io_handle_t</span> handle,</span><br><span class="line">            <span class="keyword">audio_devices_t</span> devices,</span><br><span class="line">            <span class="keyword">audio_output_flags_t</span> flags,</span><br><span class="line">            struct audio_config *config,</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *address);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">audio_module_handle_t</span> mHandle;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span>          mModuleName;</span><br><span class="line">    <span class="keyword">audio_hw_device_t</span> * <span class="keyword">const</span>   mHwDevice;</span><br><span class="line">    <span class="keyword">const</span> Flags                 mFlags;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中common代表了HAL层所有设备的共有属性;set_master_volume、set_mode、open_output_stream分别为我们设置audio interface的主音量、设置音频模式类型(比如AUDIO_MODE_RINGTONE、AUDIO_MODE_IN_CALL等等)、打开输出数据流提供了接口。</p><p>接下来我们分步来阐述。</p><h5 id="1-2-2-1、查找合适的音频接口设备findSuitableHwDev-l"><a href="#1-2-2-1、查找合适的音频接口设备findSuitableHwDev-l" class="headerlink" title="1.2.2.1、查找合适的音频接口设备findSuitableHwDev_l()"></a>1.2.2.1、查找合适的音频接口设备findSuitableHwDev_l()</h5><p>Step1@ AudioFlinger::openOutput. 在openOutput中，设备outHwDev是通过查找当前系统来得到的，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\AudioFlinger.cpp]</span><br><span class="line">AudioHwDevice* AudioFlinger::findSuitableHwDev_l(</span><br><span class="line">        <span class="keyword">audio_module_handle_t</span> <span class="keyword">module</span>,</span><br><span class="line">        <span class="keyword">audio_devices_t</span> devices)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// if module is 0, the request comes from an old policy manager and we should load</span></span><br><span class="line">    <span class="comment">// well known modules</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">module</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGW(<span class="string">"findSuitableHwDev_l() loading well know audio hw modules"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; ARRAY_SIZE(audio_interfaces); i++) &#123;</span><br><span class="line">            loadHwModule_l(audio_interfaces[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// then try to find a module supporting the requested device.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mAudioHwDevs.size(); i++) &#123;</span><br><span class="line">            AudioHwDevice *audioHwDevice = mAudioHwDevs.valueAt(i);</span><br><span class="line">            <span class="keyword">audio_hw_device_t</span> *dev = audioHwDevice-&gt;hwDevice();</span><br><span class="line">            <span class="keyword">if</span> ((dev-&gt;get_supported_devices != <span class="literal">NULL</span>) &amp;&amp;</span><br><span class="line">                    (dev-&gt;get_supported_devices(dev) &amp; devices) == devices)</span><br><span class="line">                <span class="keyword">return</span> audioHwDevice;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// check a match for the requested module handle</span></span><br><span class="line">        AudioHwDevice *audioHwDevice = mAudioHwDevs.valueFor(<span class="keyword">module</span>);</span><br><span class="line">        <span class="keyword">if</span> (audioHwDevice != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> audioHwDevice;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量module值为0的情况，是为了兼容之前的Audio Policy而特别做的处理。当module等于0时，首先加载所有已知的音频接口设备，然后再根据devices来确定其中符合要求的。入参devices的值实际上来源于“ Android系统支持的音频设备列表(输出)”所示的设备。可以看到，enum中每个设备类型都对应一个特定的比特位，因而上述代码段中可以通过“与运算”来找到匹配的设备。</p><p>当modules为非0值时，说明Audio Policy指定了具体的设备id号，这时就通过查找全局的mAudioHwDevs变量来确认是否存在符合要求的设备。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\AudioFlinger.h]</span><br><span class="line">DefaultKeyedVector&lt;audio_module_handle_t, AudioHwDevice*&gt;  mAudioHwDevs;</span><br></pre></td></tr></table></figure><p>变量mAudioHwDevs是一个Vector，以audio_module_handle_t为key，每一个handle值唯一确定了已经添加的音频设备。那么在什么时候添加设备呢？</p><p>一种情况就是前面看到的modules为0时，会load所有潜在设备，另一种情况就是AudioPolicyManagerBase在构造时会预加载所有audio_policy.conf中所描述的output。不管是哪一种情况，最终都会调用loadHwModuleàloadHwModule_l，这个函数我们开头就分析过了。</p><p>如果modules为非0，且从mAudioHwDevs中也找不到符合要求的设备，程序并不会就此终结——它会退而求其次，遍历数组中的所有元素寻找支持devices的任何一个audio interface。</p><h5 id="1-2-2-2、创建音频输出流openOutputStream"><a href="#1-2-2-2、创建音频输出流openOutputStream" class="headerlink" title="1.2.2.2、创建音频输出流openOutputStream()"></a>1.2.2.2、创建音频输出流openOutputStream()</h5><p>Step2@ AudioFlinger::openOutput，调用openOutputStream()函数打开一个AudioStreamOut 。源码实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\AudioHwDevice.cpp]</span><br><span class="line">status_t AudioHwDevice::openOutputStream(</span><br><span class="line">        AudioStreamOut **ppStreamOut,</span><br><span class="line">        audio_io_handle_t handle,</span><br><span class="line">        audio_devices_t devices,</span><br><span class="line">        audio_output_flags_t flags,</span><br><span class="line">        struct audio_config *config,</span><br><span class="line">        const char *address)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    struct audio_config originalConfig = *config;</span><br><span class="line">    AudioStreamOut *outputStream = new AudioStreamOut(this, flags);</span><br><span class="line">    </span><br><span class="line">    status_t status = outputStream-&gt;open(handle, devices, config, address);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    *ppStreamOut = outputStream;</span><br><span class="line">    return status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成AudioStreamOut对象并赋值给ppStreamOut ，进一步调用了AudioStreamOut-&gt;open()函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\AudioStreamOut.cpp]</span><br><span class="line">status_t AudioStreamOut::open(</span><br><span class="line">        audio_io_handle_t handle,</span><br><span class="line">        audio_devices_t devices,</span><br><span class="line">        struct audio_config *config,</span><br><span class="line">        const char *address)</span><br><span class="line">&#123;</span><br><span class="line">    audio_stream_out_t *outStream;</span><br><span class="line">    .......</span><br><span class="line">    int status = hwDev()-&gt;open_output_stream(</span><br><span class="line">            hwDev(),</span><br><span class="line">            handle,</span><br><span class="line">            devices,</span><br><span class="line">            customFlags,</span><br><span class="line">            config,</span><br><span class="line">            &amp;outStream,</span><br><span class="line">            address);</span><br><span class="line">    ......</span><br><span class="line">    return status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即会通过audio_hw_device_t-&gt;-&gt;open_output_stream()创建音频输出流</p><h5 id="1-2-2-2-1、audio-hw-device-t-gt-gt-open-output-stream"><a href="#1-2-2-2-1、audio-hw-device-t-gt-gt-open-output-stream" class="headerlink" title="1.2.2.2.1、audio_hw_device_t-&gt;-&gt;open_output_stream()"></a>1.2.2.2.1、audio_hw_device_t-&gt;-&gt;open_output_stream()</h5><p>我们先看一下HAL层代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\qcom\audio\hal\audio_hw.c]</span><br><span class="line">static int adev_open(const hw_module_t *module, const char *name,</span><br><span class="line">                     hw_device_t **device)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    adev = calloc(1, sizeof(struct audio_device));</span><br><span class="line"></span><br><span class="line">    pthread_mutex_init(&amp;adev-&gt;lock, (const pthread_mutexattr_t *) NULL);</span><br><span class="line"></span><br><span class="line">    adev-&gt;device.common.tag = HARDWARE_DEVICE_TAG;</span><br><span class="line">    adev-&gt;device.common.version = AUDIO_DEVICE_API_VERSION_2_0;</span><br><span class="line">    adev-&gt;device.common.module = (struct hw_module_t *)module;</span><br><span class="line">    adev-&gt;device.common.close = adev_close;</span><br><span class="line"></span><br><span class="line">    adev-&gt;device.init_check = adev_init_check;</span><br><span class="line">    adev-&gt;device.set_voice_volume = adev_set_voice_volume;</span><br><span class="line">    adev-&gt;device.set_master_volume = adev_set_master_volume;</span><br><span class="line">    adev-&gt;device.get_master_volume = adev_get_master_volume;</span><br><span class="line">    adev-&gt;device.set_master_mute = adev_set_master_mute;</span><br><span class="line">    adev-&gt;device.get_master_mute = adev_get_master_mute;</span><br><span class="line">    adev-&gt;device.set_mode = adev_set_mode;</span><br><span class="line">    adev-&gt;device.set_mic_mute = adev_set_mic_mute;</span><br><span class="line">    adev-&gt;device.get_mic_mute = adev_get_mic_mute;</span><br><span class="line">    adev-&gt;device.set_parameters = adev_set_parameters;</span><br><span class="line">    adev-&gt;device.get_parameters = adev_get_parameters;</span><br><span class="line">    adev-&gt;device.get_input_buffer_size = adev_get_input_buffer_size;</span><br><span class="line">    adev-&gt;device.open_output_stream = adev_open_output_stream;</span><br><span class="line">    adev-&gt;device.close_output_stream = adev_close_output_stream;</span><br><span class="line">    adev-&gt;device.open_input_stream = adev_open_input_stream;</span><br><span class="line">    adev-&gt;device.close_input_stream = adev_close_input_stream;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到当调用open_output_stream 就会调用adev_open_output_stream。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\qcom\audio\hal\audio_hw.c]</span><br><span class="line">static int adev_open_output_stream(struct audio_hw_device *dev,</span><br><span class="line">                                   audio_io_handle_t handle,</span><br><span class="line">                                   audio_devices_t devices,</span><br><span class="line">                                   audio_output_flags_t flags,</span><br><span class="line">                                   struct audio_config *config,</span><br><span class="line">                                   struct audio_stream_out **stream_out,</span><br><span class="line">                                   const char *address __unused)</span><br><span class="line">&#123;</span><br><span class="line">    struct audio_device *adev = (struct audio_device *)dev;</span><br><span class="line">    struct stream_out *out;</span><br><span class="line">    int i, ret;</span><br><span class="line">    </span><br><span class="line">    *stream_out = NULL;</span><br><span class="line">    out = (struct stream_out *)calloc(1, sizeof(struct stream_out));</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    out-&gt;stream.common.get_sample_rate = out_get_sample_rate;</span><br><span class="line">    out-&gt;stream.common.set_sample_rate = out_set_sample_rate;</span><br><span class="line">    out-&gt;stream.common.get_buffer_size = out_get_buffer_size;</span><br><span class="line">    out-&gt;stream.common.get_channels = out_get_channels;</span><br><span class="line">    out-&gt;stream.common.get_format = out_get_format;</span><br><span class="line">    out-&gt;stream.common.set_format = out_set_format;</span><br><span class="line">    out-&gt;stream.common.standby = out_standby;</span><br><span class="line">    out-&gt;stream.common.dump = out_dump;</span><br><span class="line">    out-&gt;stream.common.set_parameters = out_set_parameters;</span><br><span class="line">    out-&gt;stream.common.get_parameters = out_get_parameters;</span><br><span class="line">    out-&gt;stream.common.add_audio_effect = out_add_audio_effect;</span><br><span class="line">    out-&gt;stream.common.remove_audio_effect = out_remove_audio_effect;</span><br><span class="line">    out-&gt;stream.get_latency = out_get_latency;</span><br><span class="line">    out-&gt;stream.set_volume = out_set_volume;</span><br><span class="line">#ifdef NO_AUDIO_OUT</span><br><span class="line">    out-&gt;stream.write = out_write_for_no_output;</span><br><span class="line">#else</span><br><span class="line">    out-&gt;stream.write = out_write;</span><br><span class="line">#endif</span><br><span class="line">    out-&gt;stream.get_render_position = out_get_render_position;</span><br><span class="line">    out-&gt;stream.get_next_write_timestamp = out_get_next_write_timestamp;</span><br><span class="line">    out-&gt;stream.get_presentation_position = out_get_presentation_position;</span><br><span class="line"></span><br><span class="line">    out-&gt;af_period_multiplier  = out-&gt;realtime ? af_period_multiplier : 1;</span><br><span class="line">    out-&gt;standby = 1;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    *stream_out = &amp;out-&gt;stream;</span><br><span class="line">    ALOGV(&quot;%s: exit&quot;, __func__);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据音频流的熟悉做一系列初始化操作。转了一大圈，继续看看</p><h5 id="1-2-2-3、创建播放线程-PlaybackThread"><a href="#1-2-2-3、创建播放线程-PlaybackThread" class="headerlink" title="1.2.2.3、创建播放线程(PlaybackThread)"></a>1.2.2.3、创建播放线程(PlaybackThread)</h5><p>Step3@ AudioFlinger::openOutput. 既然通道已经打开，那么由谁来往通道里放东西呢？这就是PlaybackThread。这里分三种不同的情况：<br>·        OffloadThread</p><p>·        DirectOutput</p><p>如果不需要混音</p><p>·        Mixer</p><p>需要混音</p><p>这三种情况分别对应DirectOutputThread、OffloadThread和MixerThread两种线程。我们以后者为例来分析下PlaybackThread的工作模式，也会后面小节打下基础。回放线程（PlaybackThread 及其派生的子类）和录制线程（RecordThread）进行的，先简单看看回放线程和录制线程类关系：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/32-Audio-system-mixerthread.jpg" alt="Alt text"></p><p>·       ThreadBase：PlaybackThread 和 RecordThread 的基类<br>·       RecordThread：录制线程类，由 ThreadBase 派生<br>·       PlaybackThread：回放线程基类，同由 ThreadBase 派生<br>·       MixerThread：混音回放线程类，由 PlaybackThread 派生，负责处理标识为 AUDIO_OUTPUT_FLAG_PRIMARY、AUDIO_OUTPUT_FLAG_FAST、AUDIO_OUTPUT_FLAG_DEEP_BUFFER 的音频流，MixerThread 可以把多个音轨的数据混音后再输出<br>·       DirectOutputThread：直输回放线程类，由 PlaybackThread 派生，负责处理标识为 AUDIO_OUTPUT_FLAG_DIRECT 的音频流，这种音频流数据不需要软件混音，直接输出到音频设备即可<br>·       DuplicatingThread：复制回放线程类，由 MixerThread 派生，负责复制音频流数据到其他输出设备，使用场景如主声卡设备、蓝牙耳机设备、USB 声卡设备同时输出<br>·       OffloadThread：硬解回放线程类，由 DirectOutputThread 派生，负责处理标识为 AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD 的音频流，这种音频流未经软件解码的（一般是 MP3、AAC 等格式的数据），需要输出到硬件解码器，由硬件解码器解码成 PCM 数据</p><p>PlaybackThread 中有个极为重要的函数 threadLoop()，当 PlaybackThread 被强引用时，threadLoop() 会真正运行起来进入循环主体，处理音频流数据相关事务，threadLoop() 大致流程如下（以 MixerThread 为例）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\Threads.cpp]</span><br><span class="line">bool AudioFlinger::PlaybackThread::threadLoop()</span><br><span class="line">&#123;</span><br><span class="line">    // ......</span><br><span class="line"></span><br><span class="line">    while (!exitPending())</span><br><span class="line">    &#123;</span><br><span class="line">        // ......</span><br><span class="line"></span><br><span class="line">        &#123; // scope for mLock</span><br><span class="line"></span><br><span class="line">            Mutex::Autolock _l(mLock);</span><br><span class="line"></span><br><span class="line">            processConfigEvents_l();</span><br><span class="line"></span><br><span class="line">            // ......</span><br><span class="line"></span><br><span class="line">            if ((!mActiveTracks.size() &amp;&amp; systemTime() &gt; mStandbyTimeNs) ||</span><br><span class="line">                                   isSuspended()) &#123;</span><br><span class="line">                // put audio hardware into standby after short delay</span><br><span class="line">                if (shouldStandby_l()) &#123;</span><br><span class="line"></span><br><span class="line">                    threadLoop_standby();</span><br><span class="line"></span><br><span class="line">                    mStandby = true;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // ......</span><br><span class="line">            &#125;</span><br><span class="line">            // mMixerStatusIgnoringFastTracks is also updated internally</span><br><span class="line">            mMixerStatus = prepareTracks_l(&amp;tracksToRemove);</span><br><span class="line"></span><br><span class="line">            // ......</span><br><span class="line">        &#125; // mLock scope ends</span><br><span class="line"></span><br><span class="line">        // ......</span><br><span class="line"></span><br><span class="line">        if (mBytesRemaining == 0) &#123;</span><br><span class="line">            mCurrentWriteLength = 0;</span><br><span class="line">            if (mMixerStatus == MIXER_TRACKS_READY) &#123;</span><br><span class="line">                // threadLoop_mix() sets mCurrentWriteLength</span><br><span class="line">                threadLoop_mix();</span><br><span class="line">            &#125;</span><br><span class="line">            // ......</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // ......</span><br><span class="line"></span><br><span class="line">        if (!waitingAsyncCallback()) &#123;</span><br><span class="line">            // mSleepTimeUs == 0 means we must write to audio hardware</span><br><span class="line">            if (mSleepTimeUs == 0) &#123;</span><br><span class="line">                // ......</span><br><span class="line">                if (mBytesRemaining) &#123;</span><br><span class="line">                    // FIXME rewrite to reduce number of system calls</span><br><span class="line">                    ret = threadLoop_write();</span><br><span class="line">                    lastWriteFinished = systemTime();</span><br><span class="line">                    delta = lastWriteFinished - mLastWriteTime;</span><br><span class="line">                    if (ret &lt; 0) &#123;</span><br><span class="line">                        mBytesRemaining = 0;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        mBytesWritten += ret;</span><br><span class="line">                        mBytesRemaining -= ret;</span><br><span class="line">                        mFramesWritten += ret / mFrameSize;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                // ......</span><br><span class="line">            &#125;</span><br><span class="line">            // ......</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Finally let go of removed track(s), without the lock held</span><br><span class="line">        // since we can&apos;t guarantee the destructors won&apos;t acquire that</span><br><span class="line">        // same lock.  This will also mutate and push a new fast mixer state.</span><br><span class="line">        threadLoop_removeTracks(tracksToRemove);</span><br><span class="line">        tracksToRemove.clear();</span><br><span class="line"></span><br><span class="line">        // ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    threadLoop_exit();</span><br><span class="line"></span><br><span class="line">    if (!mStandby) &#123;</span><br><span class="line">        threadLoop_standby();</span><br><span class="line">        mStandby = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ......</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>threadLoop() 循环的条件是 exitPending() 返回 false，如果想要 PlaybackThread 结束循环，则可以调用 requestExit() 来请求退出；<br>processConfigEvents_l() ：处理配置事件；当有配置改变的事件发生时，需要调用 sendConfigEvent_l() 来通知 PlaybackThread，这样 PlaybackThread 才能及时处理配置事件；常见的配置事件是切换音频通路；<br>检查此时此刻是否符合 standby 条件，比如当前并没有 ACTIVE 状态的 Track（mActiveTracks.size() = 0），那么调用 threadLoop_standby() 关闭音频硬件设备以节省能耗；<br>prepareTracks_l()： 准备音频流和混音器，该函数非常复杂，这里不详细分析了，仅列一下流程要点：<br>遍历 mActiveTracks，逐个处理 mActiveTracks 上的 Track，检查该 Track 是否为 ACTIVE 状态；<br>如果 Track 设置是 ACTIVE 状态，则再检查该 Track 的数据是否准备就绪了；<br>根据音频流的音量值、格式、声道数、音轨的采样率、硬件设备的采样率，配置好混音器参数；<br>如果 Track 的状态是 PAUSED 或 STOPPED，则把该 Track 添加到 tracksToRemove 向量中；<br>threadLoop_mix()：读取所有置了 ACTIVE 状态的音频流数据，混音器开始处理这些数据；<br>threadLoop_write()： 把混音器处理后的数据写到输出流设备；<br>threadLoop_removeTracks()： 把 tracksToRemove 上的所有 Track 从 mActiveTracks 中移除出来；这样下一次循环时就不会处理这些 Track 了。<br>这里说说 PlaybackThread 与输出流设备的关系：PlaybackThread 实例与输出流设备是一一对应的，比方说 OffloadThread 只会将音频数据输出到 compress_offload 设备中，MixerThread(with FastMixer) 只会将音频数据输出到 low_latency 设备中。</p><p>从 Audio HAL 中，我们通常看到如下 4 种输出流设备，分别对应着不同的播放场景：</p><p>primary_out：主输出流设备，用于铃声类声音输出，对应着标识为 AUDIO_OUTPUT_FLAG_PRIMARY 的音频流和一个 MixerThread 回放线程实例<br>low_latency：低延迟输出流设备，用于按键音、游戏背景音等对时延要求高的声音输出，对应着标识为 AUDIO_OUTPUT_FLAG_FAST 的音频流和一个 MixerThread 回放线程实例<br>deep_buffer：音乐音轨输出流设备，用于音乐等对时延要求不高的声音输出，对应着标识为 AUDIO_OUTPUT_FLAG_DEEP_BUFFER 的音频流和一个 MixerThread 回放线程实例<br>compress_offload：硬解输出流设备，用于需要硬件解码的数据输出，对应着标识为 AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD 的音频流和一个 OffloadThread 回放线程实例<br>其中 primary_out 设备是必须声明支持的，而且系统启动时就已经打开 primary_out 设备并创建好对应的 MixerThread 实例。其他类型的输出流设备并非必须声明支持的，主要是看硬件上有无这个能力。</p><p>可能有人产生这样的疑问：既然 primary_out 设备一直保持打开，那么能耗岂不是很大？这里阐释一个概念：输出流设备属于逻辑设备，并不是硬件设备。所以即使输出流设备一直保持打开，只要硬件设备不工作，那么就不会影响能耗。那么硬件设备什么时候才会打开呢？答案是 PlaybackThread 将音频数据写入到输出流设备时。</p><p>下图简单描述 AudioTrack、PlaybackThread、输出流设备三者的对应关系：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/33-Audio-system-Audio-playback-.png" alt="Alt text"></p><p>我们可以这么说：输出流设备决定了它对应的 PlaybackThread 是什么类型。怎么理解呢？意思是说：只有支持了该类型的输出流设备，那么该类型的 PlaybackThread 才有可能被创建。举个例子：只有硬件上具备硬件解码器，系统才建立 compress_offload 设备，然后播放 mp3 格式的音乐文件时，才会创建 OffloadThread 把数据输出到 compress_offload 设备上；反之，如果硬件上并不具备硬件解码器，系统则不应该建立 compress_offload 设备，那么播放 mp3 格式的音乐文件时，通过 MixerThread 把数据输出到其他输出流设备上。</p><p>那么有无可能出现这种情况：底层并不支持 compress_offload 设备，但偏偏有个标识为 AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD 的音频流送到 AudioFlinger 了呢？这是不可能的。系统启动时，会检查并保存输入输出流设备的支持信息；播放器在播放 mp3 文件时，首先看 compress_offload 设备是否支持了，如果支持，那么不进行软件解码，直接把数据标识为 AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD；如果不支持，那么先进行软件解码，然后把解码好的数据标识为 AUDIO_OUTPUT_FLAG_DEEP_BUFFER，前提是 deep_buffer 设备是支持了的；如果 deep_buffer 设备也不支持，那么把数据标识为 AUDIO_OUTPUT_FLAG_PRIMARY。</p><p>系统启动时，就已经打开 primary_out、low_latency、deep_buffer 这三种输出流设备，并创建对应的 MixerThread 了；而此时 DirectOutputThread 与 OffloadThread 不会被创建，直到标识为 AUDIO_OUTPUT_FLAG_DIRECT/AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD 的音频流需要输出时，才开始创建 DirectOutputThread/OffloadThread 和打开 direct_out/compress_offload 设备。这一点请参考如下代码，注释非常清晰：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audiopolicy\managerdefault\AudioPolicyManager.cpp]</span><br><span class="line">AudioPolicyManager::AudioPolicyManager(AudioPolicyClientInterface *clientInterface)</span><br><span class="line">    // ......</span><br><span class="line">&#123;</span><br><span class="line">    // ......</span><br><span class="line"></span><br><span class="line">    // mAvailableOutputDevices and mAvailableInputDevices now contain all attached devices</span><br><span class="line">    // open all output streams needed to access attached devices</span><br><span class="line">    // ......</span><br><span class="line">    for (size_t i = 0; i &lt; mHwModules.size(); i++) &#123;</span><br><span class="line">        // ......</span><br><span class="line">        // open all output streams needed to access attached devices</span><br><span class="line">        // except for direct output streams that are only opened when they are actually</span><br><span class="line">        // required by an app.</span><br><span class="line">        // This also validates mAvailableOutputDevices list</span><br><span class="line">        for (size_t j = 0; j &lt; mHwModules[i]-&gt;mOutputProfiles.size(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            // ......</span><br><span class="line">            if ((outProfile-&gt;getFlags() &amp; AUDIO_OUTPUT_FLAG_DIRECT) != 0) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            // ......</span><br><span class="line">            audio_io_handle_t output = AUDIO_IO_HANDLE_NONE;</span><br><span class="line">            status_t status = mpClientInterface-&gt;openOutput(outProfile-&gt;getModuleHandle(),</span><br><span class="line">                                                            &amp;output,</span><br><span class="line">                                                            &amp;config,</span><br><span class="line">                                                            &amp;outputDesc-&gt;mDevice,</span><br><span class="line">                                                            address,</span><br><span class="line">                                                            &amp;outputDesc-&gt;mLatency,</span><br><span class="line">                                                            outputDesc-&gt;mFlags);</span><br><span class="line"></span><br><span class="line">            // ......</span><br><span class="line">        &#125;</span><br><span class="line">        // open input streams needed to access attached devices to validate</span><br><span class="line">        // mAvailableInputDevices list</span><br><span class="line">        for (size_t j = 0; j &lt; mHwModules[i]-&gt;mInputProfiles.size(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            // ......</span><br><span class="line">            status_t status = mpClientInterface-&gt;openInput(inProfile-&gt;getModuleHandle(),</span><br><span class="line">                                                           &amp;input,</span><br><span class="line">                                                           &amp;config,</span><br><span class="line">                                                           &amp;inputDesc-&gt;mDevice,</span><br><span class="line">                                                           address,</span><br><span class="line">                                                           AUDIO_SOURCE_MIC,</span><br><span class="line">                                                           AUDIO_INPUT_FLAG_NONE);</span><br><span class="line"></span><br><span class="line">            // ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // ......</span><br><span class="line"></span><br><span class="line">    updateDevicesAndOutputs();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 mpClientInterface-&gt;openOutput() 最终会调用到 AudioFlinger::openOutput()：打开输出流设备，并创建 PlaybackThread 对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">status_t AudioFlinger::openOutput(audio_module_handle_t module,</span><br><span class="line">                                  audio_io_handle_t *output,</span><br><span class="line">                                  audio_config_t *config,</span><br><span class="line">                                  audio_devices_t *devices,</span><br><span class="line">                                  const String8&amp; address,</span><br><span class="line">                                  uint32_t *latencyMs,</span><br><span class="line">                                  audio_output_flags_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    // ......</span><br><span class="line"></span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line"></span><br><span class="line">    sp&lt;PlaybackThread&gt; thread = openOutput_l(module, output, config, *devices, address, flags);</span><br><span class="line">    // ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sp&lt;AudioFlinger::PlaybackThread&gt; AudioFlinger::openOutput_l(audio_module_handle_t module,</span><br><span class="line">                                                            audio_io_handle_t *output,</span><br><span class="line">                                                            audio_config_t *config,</span><br><span class="line">                                                            audio_devices_t devices,</span><br><span class="line">                                                            const String8&amp; address,</span><br><span class="line">                                                            audio_output_flags_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    // ......</span><br><span class="line">    // 分配全局唯一的 audio_io_handle_t，可以理解它是回放线程的索引号</span><br><span class="line">    if (*output == AUDIO_IO_HANDLE_NONE) &#123;</span><br><span class="line">        *output = nextUniqueId(); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mHardwareStatus = AUDIO_HW_OUTPUT_OPEN;</span><br><span class="line"></span><br><span class="line">    //......</span><br><span class="line"></span><br><span class="line">    // 打开音频输出流设备，HAL 层根据 flags 选择打开相关类型的输出流设备</span><br><span class="line">    AudioStreamOut *outputStream = NULL;</span><br><span class="line">    status_t status = outHwDev-&gt;openOutputStream(</span><br><span class="line">            &amp;outputStream,</span><br><span class="line">            *output,</span><br><span class="line">            devices,</span><br><span class="line">            flags,</span><br><span class="line">            config,</span><br><span class="line">            address.string());</span><br><span class="line"></span><br><span class="line">    mHardwareStatus = AUDIO_HW_IDLE;</span><br><span class="line"></span><br><span class="line">    if (status == NO_ERROR) &#123;</span><br><span class="line"></span><br><span class="line">        PlaybackThread *thread;</span><br><span class="line">        if (flags &amp; AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD) &#123;</span><br><span class="line">            // AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD 音频流，创建 OffloadThread 实例</span><br><span class="line">            thread = new OffloadThread(this, outputStream, *output, devices, mSystemReady);</span><br><span class="line">            ALOGV(&quot;openOutput_l() created offload output: ID %d thread %p&quot;, *output, thread);</span><br><span class="line">        &#125; else if ((flags &amp; AUDIO_OUTPUT_FLAG_DIRECT)</span><br><span class="line">                || !isValidPcmSinkFormat(config-&gt;format)</span><br><span class="line">                || !isValidPcmSinkChannelMask(config-&gt;channel_mask)) &#123;</span><br><span class="line">            // AUDIO_OUTPUT_FLAG_DIRECT 音频流，创建 DirectOutputThread 实例</span><br><span class="line">            thread = new DirectOutputThread(this, outputStream, *output, devices, mSystemReady);</span><br><span class="line">            ALOGV(&quot;openOutput_l() created direct output: ID %d thread %p&quot;, *output, thread);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 其他标识的音频流，创建 MixerThread 实例</span><br><span class="line">            thread = new MixerThread(this, outputStream, *output, devices, mSystemReady);</span><br><span class="line">            ALOGV(&quot;openOutput_l() created mixer output: ID %d thread %p&quot;, *output, thread);</span><br><span class="line">        &#125;</span><br><span class="line">        // 把 audio_io_handle_t 和 PlaybackThread 添加到键值对向量 mPlaybackThreads 中</span><br><span class="line">        // 键值对向量 mPlaybackThreads 中，由于 audio_io_handle_t 和 PlaybackThread 是一</span><br><span class="line">        // 一对应的关系，所以拿到一个 audio_io_handle_t，就能找到它对应的 PlaybackThread</span><br><span class="line">        // 所以可以理解 audio_io_handle_t 为 PlaybackThread 的索引号</span><br><span class="line">        mPlaybackThreads.add(*output, thread);</span><br><span class="line">        return thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-2-3、AudioFlinger-音频流管理"><a href="#1-2-3、AudioFlinger-音频流管理" class="headerlink" title="1.2.3、AudioFlinger 音频流管理"></a>1.2.3、AudioFlinger 音频流管理</h5><p>AudioFlinger 音频流管理由 AudioFlinger::PlaybackThread::Track 实现，Track 与 AudioTrack 是一对一的关系，一个 AudioTrack 创建后，那么 AudioFlinger 会创建一个 Track 与之对应；PlaybackThread 与 AudioTrack/Track 是一对多的关系，一个 PlaybackThread 可以挂着多个 Track。</p><p>具体来说：AudioTrack 创建后，AudioPolicyManager 根据 AudioTrack 的输出标识和流类型，找到对应的输出流设备和 PlaybackThread（如果没有找到的话，则系统会打开对应的输出流设备并新建一个 PlaybackThread），然后创建一个 Track 并挂到这个 PlaybackThread 下面。</p><p>PlaybackThread 有两个私有成员向量与此强相关：</p><p>·       mTracks：该 PlaybackThread 创建的所有 Track 均添加保存到这个向量中<br>·       mActiveTracks：只有需要播放（设置了 ACTIVE 状态）的 Track 会添加到这个向量中；PlaybackThread 会从该向量上找到所有设置了 ACTIVE 状态的 Track，把这些 Track 数据混音后写到输出流设备<br>音频流控制最常用的三个接口：</p><p>AudioFlinger::PlaybackThread::Track::start：开始播放：把该 Track 置 ACTIVE 状态，然后添加到 mActiveTracks 向量中，最后调用 AudioFlinger::PlaybackThread::broadcast_l() 告知 PlaybackThread 情况有变<br>·       AudioFlinger::PlaybackThread::Track::stop：停止播放：把该 Track 置 STOPPED 状态，最后调用 AudioFlinger::PlaybackThread::broadcast_l() 告知 PlaybackThread 情况有变<br>·       AudioFlinger::PlaybackThread::Track::pause：暂停播放：把该 Track 置 PAUSING 状态，最后调用 AudioFlinger::PlaybackThread::broadcast_l() 告知 PlaybackThread 情况有变<br>·       AudioFlinger::PlaybackThread::threadLoop() 得悉情况有变后，调用 prepareTracks_l() 重新准备音频流和混音器：ACTIVE 状态的 Track 会添加到 mActiveTracks，此外的 Track 会从 mActiveTracks 上移除出来，然后重新准备 AudioMixer。</p><p>可见这三个音频流控制接口是非常简单的，主要是设置一下 Track 的状态，然后发个事件通知 PlaybackThread 就行，复杂的处理都在 AudioFlinger::PlaybackThread::threadLoop() 中了。</p><h4 id="二-、深入剖析Android音频之AudioPolicyService"><a href="#二-、深入剖析Android音频之AudioPolicyService" class="headerlink" title="(二)、深入剖析Android音频之AudioPolicyService"></a>(二)、深入剖析Android音频之AudioPolicyService</h4><p>AudioPolicyService是策略的制定者，比如什么时候打开音频接口设备、某种Stream类型的音频对应什么设备等等。而AudioFlinger则是策略的执行者，例如具体如何与音频设备通信，如何维护现有系统中的音频设备，以及多个音频流的混音如何处理等等都得由它来完成。AudioPolicyService根据用户配置来指导AudioFlinger加载设备接口，起到路由功能</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\audioserver\main_audioserver.cpp]</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc __unused, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (doLog &amp;&amp; (childPid = fork()) != <span class="number">0</span>) &#123;</span><br><span class="line">    ......</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// all other services</span></span><br><span class="line">        <span class="keyword">if</span> (doLog) &#123;</span><br><span class="line">            prctl(PR_SET_PDEATHSIG, SIGKILL);   <span class="comment">// if parent media.log dies before me, kill me also</span></span><br><span class="line">            setpgid(<span class="number">0</span>, <span class="number">0</span>);                      <span class="comment">// but if I die first, don't kill my parent</span></span><br><span class="line">        &#125;</span><br><span class="line">        sp&lt;ProcessState&gt; proc(ProcessState::self());</span><br><span class="line">        sp&lt;IServiceManager&gt; sm = defaultServiceManager();</span><br><span class="line">        ALOGI(<span class="string">"ServiceManager: %p"</span>, sm.get());</span><br><span class="line">        AudioFlinger::instantiate();</span><br><span class="line">        AudioPolicyService::instantiate();</span><br><span class="line">        RadioService::instantiate();</span><br><span class="line">        SoundTriggerHwService::instantiate();</span><br><span class="line">        ProcessState::self()-&gt;startThreadPool();</span><br><span class="line">        IPCThreadState::self()-&gt;joinThreadPool();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AudioPolicyService继承了模板类BinderService，该类用于注册native service。<br>BinderService是一个模板类，该类的publish函数就是完成向ServiceManager注册服务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audiopolicy\service\AudioPolicyService.h]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">getServiceName</span><span class="params">()</span> ANDROID_API </span>&#123; <span class="keyword">return</span> <span class="string">"media.audio_policy"</span>; &#125;</span><br></pre></td></tr></table></figure><p>AudioPolicyService注册名为”media.audio_policy”的服务。<br>首先看看AudioPolicyService的onFirstRef()函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audiopolicy\service\AudioPolicyService.cpp]</span><br><span class="line"></span><br><span class="line">AudioPolicyService::AudioPolicyService()</span><br><span class="line">    : BnAudioPolicyService(), mpAudioPolicyDev(<span class="literal">NULL</span>), mpAudioPolicy(<span class="literal">NULL</span>),</span><br><span class="line">      mAudioPolicyManager(<span class="literal">NULL</span>), mAudioPolicyClient(<span class="literal">NULL</span>), mPhoneState(AUDIO_MODE_INVALID)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> AudioPolicyService::onFirstRef()</span><br><span class="line">&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        Mutex::Autolock _l(mLock);</span><br><span class="line">        <span class="comment">/* Step 1:创建AudioCommandThread线程 */</span></span><br><span class="line">        <span class="comment">// start tone playback thread</span></span><br><span class="line">        mTonePlaybackThread = <span class="keyword">new</span> AudioCommandThread(String8(<span class="string">"ApmTone"</span>), <span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// start audio commands thread</span></span><br><span class="line">        mAudioCommandThread = <span class="keyword">new</span> AudioCommandThread(String8(<span class="string">"ApmAudio"</span>), <span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// start output activity command thread</span></span><br><span class="line">        mOutputCommandThread = <span class="keyword">new</span> AudioCommandThread(String8(<span class="string">"ApmOutput"</span>), <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_LEGACY_AUDIO_POLICY</span></span><br><span class="line">         <span class="comment">// 使用老版本的 audio policy 初始化方式</span></span><br><span class="line">        ....</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="comment">// 使用最新的 audio policy 初始化方式</span></span><br><span class="line">        ALOGI(<span class="string">"AudioPolicyService CSTOR in new mode"</span>);</span><br><span class="line">        <span class="comment">/* Step 2:创建AudioPolicyClient、 AudioPolicyManager */</span></span><br><span class="line">        mAudioPolicyClient = <span class="keyword">new</span> AudioPolicyClient(<span class="keyword">this</span>);</span><br><span class="line">        mAudioPolicyManager = createAudioPolicyManager(mAudioPolicyClient);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// load audio processing modules</span></span><br><span class="line">    sp&lt;AudioPolicyEffects&gt;audioPolicyEffects = <span class="keyword">new</span> AudioPolicyEffects();</span><br><span class="line">    &#123;</span><br><span class="line">        Mutex::Autolock _l(mLock);</span><br><span class="line">        mAudioPolicyEffects = audioPolicyEffects;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看看总体时序图：</p><h5 id="2-1、Step-1-创建AudioCommandThread线程"><a href="#2-1、Step-1-创建AudioCommandThread线程" class="headerlink" title="2.1、Step 1:创建AudioCommandThread线程"></a>2.1、Step 1:创建AudioCommandThread线程</h5><p>在AudioPolicyService对象构造过程中，分别创建了ApmTone、ApmAudio、ApmOutput三个AudioCommandThread线程：</p><p>1、 ApmTone用于播放tone音；</p><p>2、 ApmAudio用于执行audio命令；</p><p>3、ApmOutput用于执行输出命令；</p><p>在第一次强引用AudioCommandThread线程对象时，AudioCommandThread的onFirstRef函数被回调，在此启动线程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audiopolicy\service\AudioPolicyService.cpp]</span><br><span class="line"><span class="keyword">void</span> AudioPolicyService::AudioCommandThread::onFirstRef()</span><br><span class="line">&#123;</span><br><span class="line">    run(mName.<span class="built_in">string</span>(), ANDROID_PRIORITY_AUDIO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里采用异步方式来执行audio command，当需要执行上表中的命令时，首先将命令投递到AudioCommandThread的mAudioCommands命令向量表中，然后通过mWaitWorkCV.signal()唤醒AudioCommandThread线程，被唤醒的AudioCommandThread线程执行完command后，又通过mWaitWorkCV.waitRelative(mLock, waitTime)睡眠等待命令到来。</p><h5 id="2-2、Step-2-创建AudioPolicyClient、-AudioPolicyManager"><a href="#2-2、Step-2-创建AudioPolicyClient、-AudioPolicyManager" class="headerlink" title="2.2、Step 2: 创建AudioPolicyClient、 AudioPolicyManager"></a>2.2、Step 2: 创建AudioPolicyClient、 AudioPolicyManager</h5><p>首先创建AudioPolicyClient </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audiopolicy\service\AudioPolicyService.h]</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">AudioPolicyClient</span> :</span> <span class="keyword">public</span> AudioPolicyClientInterface</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="keyword">public</span>:</span><br><span class="line">        AudioPolicyClient(AudioPolicyService *service) : mAudioPolicyService(service) &#123;&#125;</span><br><span class="line">        <span class="keyword">virtual</span> ~AudioPolicyClient() &#123;&#125;</span><br><span class="line">        <span class="comment">// loads a HW module.</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> audio_module_handle_t <span class="title">loadHwModule</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line">        ......</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> status_t <span class="title">openOutput</span><span class="params">(<span class="keyword">audio_module_handle_t</span> <span class="keyword">module</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">audio_io_handle_t</span> *output,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">audio_config_t</span> *config,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">audio_devices_t</span> *devices,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">const</span> String8&amp; address,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">uint32_t</span> *latencyMs,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">audio_output_flags_t</span> flags)</span></span>;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// opens an audio input</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> audio_io_handle_t <span class="title">openInput</span><span class="params">(<span class="keyword">audio_module_handle_t</span> <span class="keyword">module</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">audio_io_handle_t</span> *input,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">audio_config_t</span> *config,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">audio_devices_t</span> *devices,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">const</span> String8&amp; address,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">audio_source_t</span> source,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">audio_input_flags_t</span> flags)</span></span>;</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span>:</span><br><span class="line">        AudioPolicyService *mAudioPolicyService;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>createAudioPolicyManager() 函数的实现位于 frameworks/av/services/audiopolicy/manager/AudioPolicyFactory.cpp文件中。查看源码后我们会发现它实际上是直接调用了 AudioPolicyManager 的构造函数。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audiopolicy\manager\AudioPolicyFactory.cpp]</span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function">AudioPolicyInterface* <span class="title">createAudioPolicyManager</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        AudioPolicyClientInterface *clientInterface)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AudioPolicyManager(clientInterface);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3、创建AudioPolicyManager"><a href="#2-3、创建AudioPolicyManager" class="headerlink" title="2.3、创建AudioPolicyManager()"></a>2.3、创建AudioPolicyManager()</h5><p>总体流程图：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/34-Audio-system-CreateAudioPolicyManager.png" alt="Alt text"></p><p>AudioPolicyManager 的构造函数将解析音频策略配置文件，从而获取到设备所支持的音频设备信息（包括设备是否支持 Offload、Direct 模式输出，各输入输出 profile 所支持的采样率、通道数、数据格式等），加载全部 HwModule，为之创建所有非 direct 输出类型的 outputStream 和所有 inputStream，并创建相应的 playbackThread 或 recordThread 线程。需要注意的是，Android 7.0上的音频策略配置文件开始使用 XML 格式，其文件名为 audio_policy_configuration.xml，</p><p>而在之前的版本上音频策略配置文件为 audio_policy.conf。frameworks/av/services/audiopolicy/managerdefault/AudioPolicyManager.cpp 中 AudioPolicyManager 构造函数的关键代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audiopolicy\managerdefault\AudioPolicyManager.cpp]</span><br><span class="line">AudioPolicyManager::AudioPolicyManager(AudioPolicyClientInterface *clientInterface)</span><br><span class="line">    :</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> AUDIO_POLICY_TEST</span></span><br><span class="line">    Thread(<span class="literal">false</span>),</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//AUDIO_POLICY_TEST</span></span></span><br><span class="line">    mLimitRingtoneVolume(<span class="literal">false</span>), mLastVoiceVolume(<span class="number">-1.0f</span>),</span><br><span class="line">    mA2dpSuspended(<span class="literal">false</span>),</span><br><span class="line">    mAudioPortGeneration(<span class="number">1</span>),</span><br><span class="line">    mBeaconMuteRefCount(<span class="number">0</span>),</span><br><span class="line">    mBeaconPlayingRefCount(<span class="number">0</span>),</span><br><span class="line">    mBeaconMuted(<span class="literal">false</span>),</span><br><span class="line">    mTtsOutputAvailable(<span class="literal">false</span>),</span><br><span class="line">    mMasterMono(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_XML_AUDIO_POLICY_CONF</span></span><br><span class="line">    <span class="comment">// 设备使用的配置文件为 audio_policy_configuration.xml</span></span><br><span class="line">    mVolumeCurves = <span class="keyword">new</span> VolumeCurvesCollection();</span><br><span class="line">    <span class="function">AudioPolicyConfig <span class="title">config</span><span class="params">(mHwModules, mAvailableOutputDevices, mAvailableInputDevices,</span></span></span><br><span class="line"><span class="function"><span class="params">                             mDefaultOutputDevice, speakerDrcEnabled,</span></span></span><br><span class="line">                             static_cast&lt;VolumeCurvesCollection *&gt;(mVolumeCurves));</span><br><span class="line">    PolicySerializer serializer;</span><br><span class="line">    <span class="comment">// 解析 xml 配置文件，将设备支持的音频输出设备保存在 mAvailableOutputDevices 变量中，</span></span><br><span class="line">    <span class="comment">// 将设备支持的音频输入设备保存在 mAvailableInputDevices 变量中，将设备的默认音频输出</span></span><br><span class="line">    <span class="comment">// 设备保存在 mDefaultOutputDevice 变量中。</span></span><br><span class="line">    <span class="keyword">if</span> (serializer.deserialize(AUDIO_POLICY_XML_CONFIG_FILE, config) != NO_ERROR) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">// 设备使用的配置文件为 audio_policy.conf</span></span><br><span class="line">    mVolumeCurves = <span class="keyword">new</span> StreamDescriptorCollection();</span><br><span class="line">    <span class="function">AudioPolicyConfig <span class="title">config</span><span class="params">(mHwModules, mAvailableOutputDevices, mAvailableInputDevices,</span></span></span><br><span class="line"><span class="function"><span class="params">                             mDefaultOutputDevice, speakerDrcEnabled)</span></span>;</span><br><span class="line">    <span class="comment">// 优先解析 vendor 目录下的 conf 配置文件，然后解析 device 目录下的 conf 配置文件。</span></span><br><span class="line">    <span class="comment">// 将设备支持的音频输出设备保存在 mAvailableOutputDevices 变量中，</span></span><br><span class="line">    <span class="comment">// 将设备支持的音频输入设备保存在 mAvailableInputDevices 变量中，将设备的默认音频输出</span></span><br><span class="line">    <span class="comment">// 设备保存在 mDefaultOutputDevice 变量中。</span></span><br><span class="line">    <span class="keyword">if</span> ((ConfigParsingUtils::loadConfig(AUDIO_POLICY_VENDOR_CONFIG_FILE, config) != NO_ERROR) &amp;&amp;</span><br><span class="line">            (ConfigParsingUtils::loadConfig(AUDIO_POLICY_CONFIG_FILE, config) != NO_ERROR)) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        ALOGE(<span class="string">"could not load audio policy configuration file, setting defaults"</span>);</span><br><span class="line">        config.setDefault();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// must be done after reading the policy (since conditionned by Speaker Drc Enabling)</span></span><br><span class="line">    mVolumeCurves-&gt;initializeVolumeCurves(speakerDrcEnabled);    <span class="comment">// 设置音量调节曲线</span></span><br><span class="line"></span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">// 依次加载 HwModule 并打开其所含 profile 的 outputStream 及 inputStream</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mHwModules.size(); i++) &#123;</span><br><span class="line">        mHwModules[i]-&gt;mHandle = mpClientInterface-&gt;loadHwModule(mHwModules[i]-&gt;getName());</span><br><span class="line">        <span class="keyword">if</span> (mHwModules[i]-&gt;mHandle == <span class="number">0</span>) &#123;</span><br><span class="line">            ALOGW(<span class="string">"could not open HW module %s"</span>, mHwModules[i]-&gt;getName());</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// open all output streams needed to access attached devices</span></span><br><span class="line">        <span class="comment">// except for direct output streams that are only opened when they are actually</span></span><br><span class="line">        <span class="comment">// required by an app.</span></span><br><span class="line">        <span class="comment">// This also validates mAvailableOutputDevices list</span></span><br><span class="line">        <span class="comment">// 打开当前 module 下所有非 direct 类型 profile 的 outputStream</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; mHwModules[i]-&gt;mOutputProfiles.size(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">const</span> sp&lt;IOProfile&gt; outProfile = mHwModules[i]-&gt;mOutputProfiles[j];</span><br><span class="line"></span><br><span class="line">            ....</span><br><span class="line">            <span class="comment">// 如果当前操作的 module.profile 是 direct 类型，则不为其打开 outputStream</span></span><br><span class="line">            <span class="keyword">if</span> ((outProfile-&gt;getFlags() &amp; AUDIO_OUTPUT_FLAG_DIRECT) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ....</span><br><span class="line">            <span class="comment">// 获取采样率、通道数、数据格式等各音频参数</span></span><br><span class="line">            sp&lt;SwAudioOutputDescriptor&gt; outputDesc = <span class="keyword">new</span> SwAudioOutputDescriptor(outProfile,</span><br><span class="line">                                                                                 mpClientInterface);</span><br><span class="line">            <span class="keyword">const</span> DeviceVector &amp;supportedDevices = outProfile-&gt;getSupportedDevices();</span><br><span class="line">            <span class="keyword">const</span> DeviceVector &amp;devicesForType = supportedDevices.getDevicesFromType(profileType);</span><br><span class="line">            String8 address = devicesForType.size() &gt; <span class="number">0</span> ? devicesForType.itemAt(<span class="number">0</span>)-&gt;mAddress</span><br><span class="line">                    : String8(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">            outputDesc-&gt;mDevice = profileType;</span><br><span class="line">            <span class="keyword">audio_config_t</span> config = AUDIO_CONFIG_INITIALIZER;</span><br><span class="line">            config.sample_rate = outputDesc-&gt;mSamplingRate;</span><br><span class="line">            config.channel_mask = outputDesc-&gt;mChannelMask;</span><br><span class="line">            config.format = outputDesc-&gt;mFormat;</span><br><span class="line">            <span class="keyword">audio_io_handle_t</span> output = AUDIO_IO_HANDLE_NONE;</span><br><span class="line">            <span class="comment">// 为当前 module.profile 打开对应的 outputStream 并创建 playbackThread 线程</span></span><br><span class="line">            <span class="keyword">status_t</span> status = mpClientInterface-&gt;openOutput(outProfile-&gt;getModuleHandle(),</span><br><span class="line">                                                            &amp;output,</span><br><span class="line">                                                            &amp;config,</span><br><span class="line">                                                            &amp;outputDesc-&gt;mDevice,</span><br><span class="line">                                                            address,</span><br><span class="line">                                                            &amp;outputDesc-&gt;mLatency,</span><br><span class="line">                                                            outputDesc-&gt;mFlags);</span><br><span class="line"></span><br><span class="line">            ....</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// open input streams needed to access attached devices to validate</span></span><br><span class="line">        <span class="comment">// mAvailableInputDevices list</span></span><br><span class="line">        <span class="comment">// 打开当前 module 下所有 profile 的 inputStream</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; mHwModules[i]-&gt;mInputProfiles.size(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">const</span> sp&lt;IOProfile&gt; inProfile = mHwModules[i]-&gt;mInputProfiles[j];</span><br><span class="line"></span><br><span class="line">            ....</span><br><span class="line">            sp&lt;AudioInputDescriptor&gt; inputDesc =</span><br><span class="line">                    <span class="keyword">new</span> AudioInputDescriptor(inProfile);</span><br><span class="line"></span><br><span class="line">            inputDesc-&gt;mDevice = profileType;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取采样率、通道数、数据格式等各音频参数</span></span><br><span class="line">            <span class="comment">// find the address</span></span><br><span class="line">            DeviceVector inputDevices = mAvailableInputDevices.getDevicesFromType(profileType);</span><br><span class="line">            <span class="comment">//   the inputs vector must be of size 1, but we don't want to crash here</span></span><br><span class="line">            String8 address = inputDevices.size() &gt; <span class="number">0</span> ? inputDevices.itemAt(<span class="number">0</span>)-&gt;mAddress</span><br><span class="line">                    : String8(<span class="string">""</span>);</span><br><span class="line">            ALOGV(<span class="string">"  for input device 0x%x using address %s"</span>, profileType, address.<span class="built_in">string</span>());</span><br><span class="line">            ALOGE_IF(inputDevices.size() == <span class="number">0</span>, <span class="string">"Input device list is empty!"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">audio_config_t</span> config = AUDIO_CONFIG_INITIALIZER;</span><br><span class="line">            config.sample_rate = inputDesc-&gt;mSamplingRate;</span><br><span class="line">            config.channel_mask = inputDesc-&gt;mChannelMask;</span><br><span class="line">            config.format = inputDesc-&gt;mFormat;</span><br><span class="line">            <span class="keyword">audio_io_handle_t</span> input = AUDIO_IO_HANDLE_NONE;</span><br><span class="line">            <span class="comment">// 为当前 module.profile 打开对应的 inputStream 并创建 recordThread 线程</span></span><br><span class="line">            <span class="keyword">status_t</span> status = mpClientInterface-&gt;openInput(inProfile-&gt;getModuleHandle(),</span><br><span class="line">                                                           &amp;input,</span><br><span class="line">                                                           &amp;config,</span><br><span class="line">                                                           &amp;inputDesc-&gt;mDevice,</span><br><span class="line">                                                           address,</span><br><span class="line">                                                           AUDIO_SOURCE_MIC,</span><br><span class="line">                                                           AUDIO_INPUT_FLAG_NONE);</span><br><span class="line"></span><br><span class="line">            ....</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">    updateDevicesAndOutputs();    <span class="comment">// 更新系统缓存的音频输出设备信息</span></span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AudioPolicyManager对象构造过程中主要完成以下几个步骤：</p><p>1、  加载audio_policy_configuration.xml或者audio_policy.conf配置文件</p><p>2、 初始化音量调节点initializeVolumeCurves(speakerDrcEnabled)</p><p>3、  加载audio policy硬件抽象库：mpClientInterface-&gt;loadHwModule(mHwModules[i]-&gt;mName)</p><p>4、  打开对应的outputStream和inputStream  ： mpClientInterface-&gt;openOutput()、mpClientInterface-&gt;openInput</p><p>5、   更新系统缓存的音频输出设备信息updateDevicesAndOutputs()</p><h5 id="2-3-1、加载audio-policy-configuration-xml或者audio-policy-conf配置文件"><a href="#2-3-1、加载audio-policy-configuration-xml或者audio-policy-conf配置文件" class="headerlink" title="2.3.1、加载audio_policy_configuration.xml或者audio_policy.conf配置文件"></a>2.3.1、加载audio_policy_configuration.xml或者audio_policy.conf配置文件</h5><p><a href="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/audio_policy_configuration.xml" target="_blank" rel="noopener">audio_policy_configuration.xml</a><br>audio_policy.conf同时定义了多个audio 接口，每一个audio 接口包含若干output和input，而每个output和input又同时支持多种输入输出模式，每种输入输出模式又支持若干种设备。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/35-Audio-system-audio_policy.conf.png" alt="Alt text"></p><h5 id="2-3-2、初始化音量调节点initializeVolumeCurves-speakerDrcEnabled"><a href="#2-3-2、初始化音量调节点initializeVolumeCurves-speakerDrcEnabled" class="headerlink" title="2.3.2、初始化音量调节点initializeVolumeCurves(speakerDrcEnabled)"></a>2.3.2、初始化音量调节点initializeVolumeCurves(speakerDrcEnabled)</h5><p>在AudioPolicyManagerBase中定义了音量调节对应的音频流描述符数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//audio_policy_volumes.xml</span><br><span class="line">const AudioPolicyManagerBase::VolumeCurvePoint</span><br><span class="line">            *AudioPolicyManagerBase::sVolumeProfiles[AudioSystem::NUM_STREAM_TYPES]</span><br><span class="line">                                                   [AudioPolicyManagerBase::DEVICE_CATEGORY_CNT] = &#123;</span><br><span class="line">    &#123; // AUDIO_STREAM_VOICE_CALL</span><br><span class="line">        sDefaultVoiceVolumeCurve, // DEVICE_CATEGORY_HEADSET</span><br><span class="line">        sSpeakerVoiceVolumeCurve, // DEVICE_CATEGORY_SPEAKER</span><br><span class="line">        sDefaultVoiceVolumeCurve  // DEVICE_CATEGORY_EARPIECE</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123; // AUDIO_STREAM_SYSTEM</span><br><span class="line">        sHeadsetSystemVolumeCurve, // DEVICE_CATEGORY_HEADSET</span><br><span class="line">        sDefaultSystemVolumeCurve, // DEVICE_CATEGORY_SPEAKER</span><br><span class="line">        sDefaultSystemVolumeCurve  // DEVICE_CATEGORY_EARPIECE</span><br><span class="line">    &#125;,</span><br><span class="line">    ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>initializeVolumeCurves()函数就是初始化该数组元素：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;]</span><br><span class="line"><span class="keyword">void</span> AudioPolicyManagerBase::initializeVolumeCurves()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; AudioSystem::NUM_STREAM_TYPES; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; DEVICE_CATEGORY_CNT; j++) &#123;</span><br><span class="line">            mStreams[i].mVolumeCurve[j] =</span><br><span class="line">                    sVolumeProfiles[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check availability of DRC on speaker path: if available, override some of the speaker curves</span></span><br><span class="line">    <span class="keyword">if</span> (mSpeakerDrcEnabled) &#123;</span><br><span class="line">        mStreams[AUDIO_STREAM_SYSTEM].mVolumeCurve[DEVICE_CATEGORY_SPEAKER] =</span><br><span class="line">                sDefaultSystemVolumeCurveDrc;</span><br><span class="line">        mStreams[AUDIO_STREAM_RING].mVolumeCurve[DEVICE_CATEGORY_SPEAKER] =</span><br><span class="line">                sSpeakerSonificationVolumeCurveDrc;</span><br><span class="line">        mStreams[AUDIO_STREAM_ALARM].mVolumeCurve[DEVICE_CATEGORY_SPEAKER] =</span><br><span class="line">                sSpeakerSonificationVolumeCurveDrc;</span><br><span class="line">        mStreams[AUDIO_STREAM_NOTIFICATION].mVolumeCurve[DEVICE_CATEGORY_SPEAKER] =</span><br><span class="line">                sSpeakerSonificationVolumeCurveDrc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-3、加载audio-policy硬件抽象库loadHwModule"><a href="#2-3-3、加载audio-policy硬件抽象库loadHwModule" class="headerlink" title="2.3.3、加载audio policy硬件抽象库loadHwModule()"></a>2.3.3、加载audio policy硬件抽象库loadHwModule()</h5><p>我们直接分析AudioFlinger::loadHwModule_l()中的load_audio_interface()函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static int load_audio_interface(const char *if_name, audio_hw_device_t **dev)</span><br><span class="line">&#123;</span><br><span class="line">    const hw_module_t *mod;</span><br><span class="line">    int rc;</span><br><span class="line">    //根据名字加载audio_module模块  </span><br><span class="line">    rc = hw_get_module_by_class(AUDIO_HARDWARE_MODULE_ID, if_name, &amp;mod);</span><br><span class="line">    ALOGE_IF(rc, &quot;%s couldn&apos;t load audio hw module %s.%s (%s)&quot;, __func__,</span><br><span class="line">                 AUDIO_HARDWARE_MODULE_ID, if_name, strerror(-rc));</span><br><span class="line">    //打开audio_device设备</span><br><span class="line">    rc = audio_hw_device_open(mod, dev);</span><br><span class="line">    ALOGE_IF(rc, &quot;%s couldn&apos;t open audio hw device in %s.%s (%s)&quot;, __func__,</span><br><span class="line">                 AUDIO_HARDWARE_MODULE_ID, if_name, strerror(-rc));</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>[-&gt;\frameworks\av\services\audioflinger\AudioFlinger.cpp]</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">audio_hw_device_open</span><span class="params">(<span class="keyword">const</span> struct <span class="keyword">hw_module_t</span>* <span class="keyword">module</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       struct audio_hw_device** device)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">module</span>-&gt;methods-&gt;open(<span class="keyword">module</span>, AUDIO_HARDWARE_INTERFACE,</span><br><span class="line">                                 (struct <span class="keyword">hw_device_t</span>**)device);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[-&gt;\hardware\libhardware_legacy\audio\audio_hw_hal.cpp]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">static int legacy_adev_open(const hw_module_t* module, const char* name,</span><br><span class="line">                            hw_device_t** device)</span><br><span class="line">&#123;</span><br><span class="line">    struct legacy_audio_device *ladev;</span><br><span class="line">    int ret;</span><br><span class="line">    ladev = (struct legacy_audio_device *)calloc(1, sizeof(*ladev));</span><br><span class="line"></span><br><span class="line">    ladev-&gt;device.common.tag = HARDWARE_DEVICE_TAG;</span><br><span class="line">    ladev-&gt;device.common.version = AUDIO_DEVICE_API_VERSION_2_0;</span><br><span class="line">    ladev-&gt;device.common.module = const_cast&lt;hw_module_t*&gt;(module);</span><br><span class="line">    ladev-&gt;device.common.close = legacy_adev_close;</span><br><span class="line"></span><br><span class="line">    ladev-&gt;device.init_check = adev_init_check;</span><br><span class="line">    ladev-&gt;device.set_voice_volume = adev_set_voice_volume;</span><br><span class="line">    ladev-&gt;device.set_master_volume = adev_set_master_volume;</span><br><span class="line">    ladev-&gt;device.get_master_volume = adev_get_master_volume;</span><br><span class="line">    ladev-&gt;device.set_mode = adev_set_mode;</span><br><span class="line">    ladev-&gt;device.set_mic_mute = adev_set_mic_mute;</span><br><span class="line">    ladev-&gt;device.get_mic_mute = adev_get_mic_mute;</span><br><span class="line">    ladev-&gt;device.set_parameters = adev_set_parameters;</span><br><span class="line">    ladev-&gt;device.get_parameters = adev_get_parameters;</span><br><span class="line">    ladev-&gt;device.get_input_buffer_size = adev_get_input_buffer_size;</span><br><span class="line">    ladev-&gt;device.open_output_stream = adev_open_output_stream;</span><br><span class="line">    ladev-&gt;device.close_output_stream = adev_close_output_stream;</span><br><span class="line">    ladev-&gt;device.open_input_stream = adev_open_input_stream;</span><br><span class="line">    ladev-&gt;device.close_input_stream = adev_close_input_stream;</span><br><span class="line">    ladev-&gt;device.dump = adev_dump;</span><br><span class="line"></span><br><span class="line">    ladev-&gt;hwif = createAudioHardware();</span><br><span class="line"></span><br><span class="line">    *device = &amp;ladev-&gt;device.common;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此就加载完系统定义的所有音频接口，并生成相应的数据对象，如下图所示：’<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/36-Audio-system-audiohwdevice.png" alt="Alt text"></p><h5 id="2-3-4、打开对应的outputStream和inputStream"><a href="#2-3-4、打开对应的outputStream和inputStream" class="headerlink" title="2.3.4、打开对应的outputStream和inputStream"></a>2.3.4、打开对应的outputStream和inputStream</h5><p>前面一小节已经分析过outputStream，这里不再分析了<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/37-Audio-system-AudioStreamOut.png" alt="Alt text"></p><p>打开音频输出后，在AudioFlinger与AudioPolicyService中的表现形式如下：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/38-Audio-system-audiohwdevice-openoutput.png" alt="Alt text"></p><p>打开音频输入:<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/39-Audio-system-AudioStreamIn.png" alt="Alt text"><br>打开音频输入后，在AudioFlinger与AudioPolicyService中的表现形式如下：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/310-Audio-system-audiohwdevice-openinput.png" alt="Alt text"></p><h5 id="2-3-5、-更新系统缓存的音频输出设备信息updateDevicesAndOutputs"><a href="#2-3-5、-更新系统缓存的音频输出设备信息updateDevicesAndOutputs" class="headerlink" title="2.3.5、 更新系统缓存的音频输出设备信息updateDevicesAndOutputs()"></a>2.3.5、 更新系统缓存的音频输出设备信息updateDevicesAndOutputs()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audiopolicy\managerdefault\AudioPolicyManager.cpp]</span><br><span class="line"><span class="keyword">void</span> AudioPolicyManager::updateDevicesAndOutputs()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_STRATEGIES; i++) &#123;</span><br><span class="line">        mDeviceForStrategy[i] = getDeviceForStrategy((routing_strategy)i, <span class="literal">false</span> <span class="comment">/*fromCache*/</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mPreviousOutputs = mOutputs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-4、总结"><a href="#2-4、总结" class="headerlink" title="2.4、总结"></a>2.4、总结</h5><p>-&gt;打开音频输出时创建一个audio_stream_out通道，并创建AudioStreamOut对象以及新建PlaybackThread播放线程。</p><p>-&gt; 打开音频输入时创建一个audio_stream_in通道，并创建AudioStreamIn对象以及创建RecordThread录音线程。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/311-Audio-system-audio_stream_in-out.png" alt="Alt text"></p><h4 id="三-、深入剖析Android音频之AudioTrack"><a href="#三-、深入剖析Android音频之AudioTrack" class="headerlink" title="(三)、深入剖析Android音频之AudioTrack"></a>(三)、深入剖析Android音频之AudioTrack</h4><p>现在我们开始分析 AudioTrack 的创建过程，特别留意 AudioTrack 与 AudioFlinger 如何建立联系、用于 AudioTrack 与 AudioFlinger 交换数据的匿名共享内存如何分配。</p><h5 id="3-1-AudioTrack-amp-AudioFlinger-相关类"><a href="#3-1-AudioTrack-amp-AudioFlinger-相关类" class="headerlink" title="3.1. AudioTrack &amp; AudioFlinger 相关类"></a>3.1. AudioTrack &amp; AudioFlinger 相关类</h5><p>时序图：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/312-Audio-system-create_audiotrack-flow.png" alt="Alt text"></p><p>首先看一下 AudioTrack &amp; AudioFlinger 的类图，理一下 AudioFlinger 的主要类及其关系、AudioTrack 与 AudioFlinger 之间的联系，后面将以该图为脉络展开分析。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/313-Audio-system-create_audiotrack.jpg" alt="Alt text"></p><p>☯ AudioFlinger::PlaybackThread：回放线程基类，不同输出标识的音频流对应不同类型的 PlaybackThread 实例（分为四种：MixerThread、DirectOutputThread、DuplicatingThread、OffloadThread），具体见 3.4. AudioFlinger 回放录制线程 小节，所有的 PlaybackThread 实例都会添加到 AudioFlinger.mPlaybackThreads 向量中；这个向量的定义： DefaultKeyedVector&lt; audio_io_handle_t, sp<playbackthread> &gt; mPlaybackThreads;，可见 audio_io_handle_t 是与 PlaybackThread 是一一对应的，由已知的 audio_io_handle_t 就能找到对应的 PlaybackThread；audio_io_handle_t 在创建 PlaybackThread 时由系统分配，这个值是全局唯一的<br>☯ AudioFlinger::PlaybackThread::Track：音频流管理类，创建一块匿名共享内存用于 AudioTrack 与 AudioFlinger 之间的数据交换（方便起见，这块匿名共享内存，以后均简单称为 FIFO），同时实现 start()、stop()、pause() 等音频流常用控制手段；注意，多个 Track 对象可能都注册到同一个 PlaybackThread 中（尤其对于 MixerThread 而言，一个 MixerThread 往往挂着多个 Track 对象），这多个 Track 对象都会添加到 PlaybackThread.mTracks 向量中统一管理<br>☯ AudioFlinger::TrackHandle：Track 对象只负责音频流管理业务，对外并没有提供跨进程的 Binder 调用接口，而应用进程又需要对音频流进行控制，所以需要一个对象来代理 Track 的跨进程通讯，这个角色就是 TrackHandle，AudioTrack 通过它与 Track 交互<br>☯ AudioTrack：Android 音频系统对外提供的一个 API 类，负责音频流数据输出；每个音频流对应着一个 AudioTrack 实例，不同输出标识的 AudioTrack 会匹配到不同的 AudioFlinger::PlaybackThread；AudioTrack 与 AudioFlinger::PlaybackThread 之间通过 FIFO 来交换音频数据，AudioTrack 是 FIFO 生产者，AudioFlinger::PlaybackThread 是 FIFO 消费者<br>☯ AudioTrack::AudioTrackThread：数据传输模式为 TRANSFER_CALLBACK 时，需要创建该线程，它通过调用 audioCallback 回调函数主动从用户进程处索取数据并填充到 FIFO 上；数据传输模式为 TRANSFER_SYNC 时，则不需要创建这个线程，因为用户进程会持续调用 AudioTrack.write() 填充数据到 FIFO；数据传输模式为 TRANSFER_SHARED 时，也不需要创建这个线程，因为用户进程会创建一块匿名共享内存，并把要播放的音频数据一次性拷贝到这块匿名共享内存上了<br>☯ IAudioTrack：IAudioTrack 是链结 AudioTrack 与 AudioFlinger 的桥梁；它在 AudioTrack 端的对象是 BpAudioTrack，在 AudioFlinger 端的对象是 BnAudioTrack，从图中不难看出，AudioFlinger::TrackHandle 继承自 BnAudioTrack，而 AudioFlinger::TrackHandle 恰恰是AudioFlinger::PlaybackThread::Track 的代理对象，所以 AudioTrack 得到 IAudioTrack 实例后，就可以调用 IAudioTrack 的接口与 AudioFlinger::PlaybackThread::Track 交互</playbackthread></p><p><strong>audio_io_handle_t：</strong></p><p>这里再详细说明一下 audio_io_handle_t，它是 AudioTrack/AudioRecord/AudioSystem、AudioFlinger、AudioPolicyManager 之间一个重要的链结点。3.4. AudioFlinger 回放录制线程 小节在 AudioFlinger::openOutput_l() 注释中大致说明了它的来历及其作用，现在回顾下：当打开输出流设备及创建 PlaybackThread 时，系统会分配一个全局唯一的值作为 audio_io_handle_t，并把 audio_io_handle_t 和 PlaybackThread 添加到键值对向量 mPlaybackThreads 中，由于 audio_io_handle_t 和 PlaybackThread 是一一对应的关系，因此拿到一个 audio_io_handle_t，就能遍历键值对向量 mPlaybackThreads 找到它对应的 PlaybackThread，可以简单理解 audio_io_handle_t 为 PlaybackThread 的索引号或线程 id。由于 audio_io_handle_t 具有 PlaybackThread 索引特性，所以应用进程想获取 PlaybackThread 某些信息的话，只需要传入对应的 audio_io_handle_t 即可。例如 AudioFlinger::format(audio_io_handle_t output)，这是 AudioFlinger 的一个服务接口，用户进程可以通过该接口获取某个 PlaybackThread 配置的音频格式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\AudioFlinger.cpp]</span><br><span class="line"><span class="keyword">audio_format_t</span> AudioFlinger::format(<span class="keyword">audio_io_handle_t</span> output) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    <span class="comment">// checkPlaybackThread_l() 根据传入的 audio_io_handle_t，从键值对向量</span></span><br><span class="line">    <span class="comment">// mPlaybackThreads 中找到它对应的 PlaybackThread</span></span><br><span class="line">    PlaybackThread *thread = checkPlaybackThread_l(output);</span><br><span class="line">    <span class="keyword">if</span> (thread == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ALOGW(<span class="string">"format() unknown thread %d"</span>, output);</span><br><span class="line">        <span class="keyword">return</span> AUDIO_FORMAT_INVALID;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> thread-&gt;format();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AudioFlinger::PlaybackThread *AudioFlinger::checkPlaybackThread_l(<span class="keyword">audio_io_handle_t</span> output) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> mPlaybackThreads.valueFor(output).get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-2-AudioTrack-构造过程"><a href="#3-2-AudioTrack-构造过程" class="headerlink" title="3.2. AudioTrack 构造过程"></a>3.2. AudioTrack 构造过程</h5><p>当我们构造一个 AudioTrack 实例时（以 MODE_STREAM/TRANSFER_SYNC 模式为例，这也是最常用的模式了，此时 sharedBuffer 为空），系统都发生了什么事？阐述下大致流程：</p><p>如果 cbf（audioCallback 回调函数）非空，那么创建 AudioTrackThread 线程处理 audioCallback 回调函数（MODE_STREAM 模式时，cbf 为空）；<br>根据 streamType（流类型）、flags（输出标识）等参数调用 AudioSystem::getOutputForAttr()；经过一系列的调用，进入 AudioPolicyManager::getOutputForDevice()：<br>如果输出标识置了 AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD 或 AUDIO_OUTPUT_FLAG_DIRECT，那么最终调用 AudioFlinger::openOutput() 打开输出标识对应的输出流设备并创建相应的 PlaybackThread，保存该 PlaybackThread 对应的 audio_io_handle_t 给 AudioTrack；<br>如果输出标识是其他类型，那么根据策略选择一个输出流设备和 PlaybackThread，并保存该 PlaybackThread 对应的 audio_io_handle_t 给 AudioTrack；别忘了在 3.4. AudioFlinger 回放录制线程 小节中提到：系统启动时，就已经打开 primary_out、low_latency、deep_buffer 这三种输出流设备，并创建对应的 PlaybackThread 了；<br>通过 Binder 机制调用 AudioFlinger::createTrack()（注意 step2 中 AudioTrack 已经拿到一个 audio_io_handle_t 了，此时把这个 audio_io_handle_t 传入给 createTrack()）：<br>根据传入的 audio_io_handle_t 找到它对应的 PlaybackThread；<br>PlaybackThread 新建一个音频流管理对象 Track；Track 构造时会分配一块匿名共享内存用于 AudioFlinger 与 AudioTrack 的数据交换缓冲区（FIFO）及其控制块（audio_track_cblk_t），并创建一个 AudioTrackServerProxy 对象（PlaybackThread 将使用它从 FIFO 上取得可读数据的位置）；<br>最后新建一个 Track 的通讯代理 TrackHandle，并以 IAudioTrack 作为返回值给 AudioTrack（TrackHandle、BnAudioTrack、BpAudioTrack、IAudioTrack 的关系见上一个小节）；<br>通过 IAudioTrack 接口，取得 AudioFlinger 中的 FIFO 控制块（audio_track_cblk_t），由此再计算得到 FIFO 的首地址；<br>创建一个 AudioTrackClientProxy 对象（AudioTrack 将使用它从 FIFO 上取得可用空间的位置）；<br>AudioTrack 由此建立了和 AudioFlinger 的全部联系工作：</p><p>通过 IAudioTrack 接口可以控制该音轨的状态，例如 start、stop、pause<br>持续写入数据到 FIFO 上，实现音频连续播放<br>通过 audio_io_handle_t，可以找到它对应的 PlaybackThread，从而查询该 PlaybackThread 的相关信息，如所设置的采样率、格式等等<br>构造 1 个 AudioTrack 实例时，AudioFlinger 会有 1 个 PlaybackThread 实例、1 个 Track 实例、1 个 TrackHandle 实例、1 个 AudioTrackServerProxy 实例、1 块 FIFO 与之对应。</p><p>当同时构造 1 个 AudioTrack with AUDIO_OUTPUT_FLAG_PRIMARY、1 个 AudioTrack with AUDIO_OUTPUT_FLAG_FAST、3 个 AudioTrack with AUDIO_OUTPUT_FLAG_DEEP_BUFFER、1 个 AudioTrack with AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD、1 个 AudioTrack with AUDIO_OUTPUT_FLAG_DIRECT 时（事实上，Android 音频策略不允许出现这种情形的），AudioFlinger 拥有的 PlaybackThread、Track、TrackHandle 实例如下图所示：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/314-Audio-system-PlaybackThread-Track-TrackHandle.png" alt="Alt text"></p><p>最后附上相关代码的流程分析，我本意是不多贴代码的，但不上代码总觉得缺点什么，这里我尽量把代码精简，提取主干，忽略细节。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmedia\AudioTrack.cpp]</span><br><span class="line">AudioTrack::AudioTrack(</span><br><span class="line">        <span class="keyword">audio_stream_type_t</span> streamType,    <span class="comment">// 音频流类型：如 Music、Voice-Call、DTMF、Alarm 等等</span></span><br><span class="line">        <span class="keyword">uint32_t</span> sampleRate,               <span class="comment">// 采样率：如 16KHz、44.1KHz、48KHz 等等</span></span><br><span class="line">        <span class="keyword">audio_format_t</span> format,             <span class="comment">// 音频格式：如 PCM、MP3、AAC 等等</span></span><br><span class="line">        <span class="keyword">audio_channel_mask_t</span> channelMask,  <span class="comment">// 声道数：如 Mono（单声道）、Stereo（双声道）</span></span><br><span class="line">        <span class="keyword">const</span> sp&lt;IMemory&gt;&amp; sharedBuffer,   <span class="comment">// 共享内存缓冲区：数据模式是 MODE_STATIC 时使用，数据模式是 MODE_STREAM 时为空</span></span><br><span class="line">        <span class="keyword">audio_output_flags_t</span> flags,        <span class="comment">// 输出标识位，详见 AUDIO_OUTPUT_FLAG 描述</span></span><br><span class="line">        <span class="keyword">callback_t</span> cbf,                    <span class="comment">// 回调函数</span></span><br><span class="line">        <span class="keyword">void</span>* user,                        <span class="comment">// 回调函数的参数</span></span><br><span class="line">        <span class="keyword">uint32_t</span> notificationFrames,</span><br><span class="line">        <span class="keyword">int</span> sessionId,</span><br><span class="line">        transfer_type transferType,        <span class="comment">// 数据传输类型</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">audio_offload_info_t</span> *offloadInfo,</span><br><span class="line">        <span class="keyword">int</span> uid,</span><br><span class="line">        <span class="keyword">pid_t</span> pid,</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">audio_attributes_t</span>* pAttributes,</span><br><span class="line">        <span class="keyword">bool</span> doNotReconnect)</span><br><span class="line">    : mStatus(NO_INIT),</span><br><span class="line">      mIsTimed(<span class="literal">false</span>),</span><br><span class="line">      mPreviousPriority(ANDROID_PRIORITY_NORMAL),</span><br><span class="line">      mPreviousSchedulingGroup(SP_DEFAULT),</span><br><span class="line">      mPausedPosition(<span class="number">0</span>),</span><br><span class="line">      mSelectedDeviceId(AUDIO_PORT_HANDLE_NONE)</span><br><span class="line">&#123;</span><br><span class="line">    mStatus = <span class="built_in">set</span>(streamType, sampleRate, format, channelMask,</span><br><span class="line">            <span class="number">0</span> <span class="comment">/*frameCount*/</span>, flags, cbf, user, notificationFrames,</span><br><span class="line">            sharedBuffer, <span class="literal">false</span> <span class="comment">/*threadCanCallJava*/</span>, sessionId, transferType, offloadInfo,</span><br><span class="line">            uid, pid, pAttributes, doNotReconnect);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> AudioTrack::<span class="built_in">set</span>(</span><br><span class="line">        <span class="keyword">audio_stream_type_t</span> streamType,</span><br><span class="line">        <span class="keyword">uint32_t</span> sampleRate,</span><br><span class="line">        <span class="keyword">audio_format_t</span> format,</span><br><span class="line">        <span class="keyword">audio_channel_mask_t</span> channelMask,</span><br><span class="line">        <span class="keyword">size_t</span> frameCount,</span><br><span class="line">        <span class="keyword">audio_output_flags_t</span> flags,        </span><br><span class="line">        <span class="keyword">callback_t</span> cbf,</span><br><span class="line">        <span class="keyword">void</span>* user,</span><br><span class="line">        <span class="keyword">uint32_t</span> notificationFrames,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;IMemory&gt;&amp; sharedBuffer,</span><br><span class="line">        <span class="keyword">bool</span> threadCanCallJava,</span><br><span class="line">        <span class="keyword">int</span> sessionId,</span><br><span class="line">        transfer_type transferType,</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">audio_offload_info_t</span> *offloadInfo,</span><br><span class="line">        <span class="keyword">int</span> uid,</span><br><span class="line">        <span class="keyword">pid_t</span> pid,</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">audio_attributes_t</span>* pAttributes,</span><br><span class="line">        <span class="keyword">bool</span> doNotReconnect)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 参数格式合法性检查、音轨音量初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 cbf 非空，那么创建 AudioTrackThread 线程处理 audioCallback 回调函数</span></span><br><span class="line">    <span class="keyword">if</span> (cbf != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mAudioTrackThread = <span class="keyword">new</span> AudioTrackThread(*<span class="keyword">this</span>, threadCanCallJava);</span><br><span class="line">        mAudioTrackThread-&gt;run(<span class="string">"AudioTrack"</span>, ANDROID_PRIORITY_AUDIO, <span class="number">0</span> <span class="comment">/*stack*/</span>);</span><br><span class="line">        <span class="comment">// thread begins in paused state, and will not reference us until start()</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create the IAudioTrack</span></span><br><span class="line">    <span class="keyword">status_t</span> status = createTrack_l();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> AudioTrack::createTrack_l()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取 IAudioFlinger，通过 binder 请求 AudioFlinger 服务</span></span><br><span class="line">    <span class="keyword">const</span> sp&lt;IAudioFlinger&gt;&amp; audioFlinger = AudioSystem::get_audio_flinger();</span><br><span class="line">    <span class="keyword">if</span> (audioFlinger == <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Could not get audioflinger"</span>);</span><br><span class="line">        <span class="keyword">return</span> NO_INIT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// AudioSystem::getOutputForAttr() 经过一系列的调用，进入 AudioPolicyManager::getOutputForDevice()</span></span><br><span class="line">    <span class="comment">// 如果输出标识置了 AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD 或 AUDIO_OUTPUT_FLAG_DIRECT，</span></span><br><span class="line">    <span class="comment">// 那么最终调用 AudioFlinger::openOutput() 打开输出标识对应的输出流设备并创建相关的</span></span><br><span class="line">    <span class="comment">// PlaybackThread，保存该 PlaybackThread 对应的 audio_io_handle_t 给 AudioTrack；</span></span><br><span class="line">    <span class="comment">// 如果输出标识是其他类型，那么根据策略选择一个输出流设备和 PlaybackThread，并保存该</span></span><br><span class="line">    <span class="comment">// PlaybackThread 对应的 audio_io_handle_t 给 AudioTrack</span></span><br><span class="line">    <span class="keyword">audio_io_handle_t</span> output;</span><br><span class="line">    status = AudioSystem::getOutputForAttr(attr, &amp;output,</span><br><span class="line">                                           (<span class="keyword">audio_session_t</span>)mSessionId, &amp;streamType, mClientUid,</span><br><span class="line">                                           mSampleRate, mFormat, mChannelMask,</span><br><span class="line">                                           mFlags, mSelectedDeviceId, mOffloadInfo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向 AudioFlinger 发出 createTrack 请求</span></span><br><span class="line">    sp&lt;IAudioTrack&gt; track = audioFlinger-&gt;createTrack(streamType,</span><br><span class="line">                                                      mSampleRate,</span><br><span class="line">                                                      mFormat,</span><br><span class="line">                                                      mChannelMask,</span><br><span class="line">                                                      &amp;temp,</span><br><span class="line">                                                      &amp;trackFlags,</span><br><span class="line">                                                      mSharedBuffer,</span><br><span class="line">                                                      output,</span><br><span class="line">                                                      tid,</span><br><span class="line">                                                      &amp;mSessionId,</span><br><span class="line">                                                      mClientUid,</span><br><span class="line">                                                      &amp;status);</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// AudioFlinger 创建 Track 对象时会分配一个 FIFO，这里获取 FIFO 的控制块</span></span><br><span class="line">    sp&lt;IMemory&gt; iMem = track-&gt;getCblk();</span><br><span class="line">    <span class="keyword">if</span> (iMem == <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Could not get control block"</span>);</span><br><span class="line">        <span class="keyword">return</span> NO_INIT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 匿名共享内存首地址</span></span><br><span class="line">    <span class="keyword">void</span> *iMemPointer = iMem-&gt;pointer();</span><br><span class="line">    <span class="keyword">if</span> (iMemPointer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Could not get control block pointer"</span>);</span><br><span class="line">        <span class="keyword">return</span> NO_INIT;</span><br><span class="line">    &#125;</span><br><span class="line">    mAudioTrack = track; <span class="comment">// 保存 AudioFlinger::PlaybackThread::Track 的代理对象 IAudioTrack</span></span><br><span class="line">    mCblkMemory = iMem; <span class="comment">// 保存匿名共享内存首地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制块位于 AudioFlinger 分配的匿名共享内存的首部</span></span><br><span class="line">    <span class="keyword">audio_track_cblk_t</span>* cblk = <span class="keyword">static_cast</span>&lt;<span class="keyword">audio_track_cblk_t</span>*&gt;(iMemPointer);</span><br><span class="line">    mCblk = cblk;</span><br><span class="line">    mOutput = output; <span class="comment">// 保存返回的 audio_io_handle_t，用它可以找到对应的 PlaybackThread</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// update proxy</span></span><br><span class="line">    <span class="keyword">if</span> (mSharedBuffer == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当 mSharedBuffer 为空，意味着音轨数据模式为 MODE_STREAM，那么创建 AudioTrackClientProxy 对象</span></span><br><span class="line">        mStaticProxy.clear();</span><br><span class="line">        mProxy = <span class="keyword">new</span> AudioTrackClientProxy(cblk, buffers, frameCount, mFrameSize);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当 mSharedBuffer 非空，意味着音轨数据模式为 MODE_STATIC，那么创建 StaticAudioTrackClientProxy 对象</span></span><br><span class="line">        mStaticProxy = <span class="keyword">new</span> StaticAudioTrackClientProxy(cblk, buffers, frameCount, mFrameSize);</span><br><span class="line">        mProxy = mStaticProxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AudioFlinger::createTrack()，顾名思义，创建一个 Track 对象，将用于音频流的控制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\AudioFlinger.cpp]</span><br><span class="line">sp&lt;IAudioTrack&gt; AudioFlinger::createTrack(</span><br><span class="line">        audio_stream_type_t streamType,</span><br><span class="line">        uint32_t sampleRate,</span><br><span class="line">        audio_format_t format,</span><br><span class="line">        audio_channel_mask_t channelMask,</span><br><span class="line">        size_t *frameCount,</span><br><span class="line">        IAudioFlinger::track_flags_t *flags,</span><br><span class="line">        const sp&lt;IMemory&gt;&amp; sharedBuffer,</span><br><span class="line">        audio_io_handle_t output,</span><br><span class="line">        pid_t tid,</span><br><span class="line">        int *sessionId,</span><br><span class="line">        int clientUid,</span><br><span class="line">        status_t *status)</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;PlaybackThread::Track&gt; track;</span><br><span class="line">    sp&lt;TrackHandle&gt; trackHandle;</span><br><span class="line">    sp&lt;Client&gt; client;</span><br><span class="line">    status_t lStatus;</span><br><span class="line">    int lSessionId;</span><br><span class="line"></span><br><span class="line">    //......</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        Mutex::Autolock _l(mLock);</span><br><span class="line">        // 根据传入来的 audio_io_handle_t，找到对应的 PlaybackThread</span><br><span class="line">        PlaybackThread *thread = checkPlaybackThread_l(output);</span><br><span class="line">        if (thread == NULL) &#123;</span><br><span class="line">            ALOGE(&quot;no playback thread found for output handle %d&quot;, output);</span><br><span class="line">            lStatus = BAD_VALUE;</span><br><span class="line">            goto Exit;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //......</span><br><span class="line"></span><br><span class="line">        // 在 PlaybackThread 上创建一个音频流管理对象 Track</span><br><span class="line">        track = thread-&gt;createTrack_l(client, streamType, sampleRate, format,</span><br><span class="line">                channelMask, frameCount, sharedBuffer, lSessionId, flags, tid, clientUid, &amp;lStatus);</span><br><span class="line">        //......</span><br><span class="line"></span><br><span class="line">        setAudioHwSyncForSession_l(thread, (audio_session_t)lSessionId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //......</span><br><span class="line"></span><br><span class="line">    // 创建 Track 的通讯代理 TrackHandle 并返回它</span><br><span class="line">    trackHandle = new TrackHandle(track);</span><br><span class="line"></span><br><span class="line">Exit:</span><br><span class="line">    *status = lStatus;</span><br><span class="line">    return trackHandle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sp&lt;AudioFlinger::PlaybackThread::Track&gt; AudioFlinger::PlaybackThread::createTrack_l(</span><br><span class="line">        const sp&lt;AudioFlinger::Client&gt;&amp; client,</span><br><span class="line">        audio_stream_type_t streamType,</span><br><span class="line">        uint32_t sampleRate,</span><br><span class="line">        audio_format_t format,</span><br><span class="line">        audio_channel_mask_t channelMask,</span><br><span class="line">        size_t *pFrameCount,</span><br><span class="line">        const sp&lt;IMemory&gt;&amp; sharedBuffer,</span><br><span class="line">        int sessionId,</span><br><span class="line">        IAudioFlinger::track_flags_t *flags,</span><br><span class="line">        pid_t tid,</span><br><span class="line">        int uid,</span><br><span class="line">        status_t *status)</span><br><span class="line">&#123;</span><br><span class="line">    size_t frameCount = *pFrameCount;</span><br><span class="line">    sp&lt;Track&gt; track;</span><br><span class="line">    status_t lStatus;</span><br><span class="line"></span><br><span class="line">    bool isTimed = (*flags &amp; IAudioFlinger::TRACK_TIMED) != 0;</span><br><span class="line"></span><br><span class="line">    // ......</span><br><span class="line"></span><br><span class="line">    &#123; // scope for mLock</span><br><span class="line">        Mutex::Autolock _l(mLock);</span><br><span class="line"></span><br><span class="line">        // ......</span><br><span class="line"></span><br><span class="line">        if (!isTimed) &#123;</span><br><span class="line">            // 创建 Track，等会再看看 Track 构造函数干些啥</span><br><span class="line">            track = new Track(this, client, streamType, sampleRate, format,</span><br><span class="line">                              channelMask, frameCount, NULL, sharedBuffer,</span><br><span class="line">                              sessionId, uid, *flags, TrackBase::TYPE_DEFAULT);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 创建 TimedTrack，带时间戳的 Track？这里不深究</span><br><span class="line">            track = TimedTrack::create(this, client, streamType, sampleRate, format,</span><br><span class="line">                    channelMask, frameCount, sharedBuffer, sessionId, uid);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // ......</span><br><span class="line"></span><br><span class="line">        // 把创建的 Track 添加到 mTracks 向量中，方便 PlaybackThread 统一管理</span><br><span class="line">        mTracks.add(track);</span><br><span class="line"></span><br><span class="line">        // ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lStatus = NO_ERROR;</span><br><span class="line"></span><br><span class="line">Exit:</span><br><span class="line">    *status = lStatus;</span><br><span class="line">    return track;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ----------------------------------------------------------------------------</span><br><span class="line">// 如下是 TrackHandle 的相关代码，可以看到，TrackHandle 其实就是一个壳子，是 Track 的包装类</span><br><span class="line">// 所有 TrackHandle 接口都是调向 Track 的</span><br><span class="line">// Google 为什么要搞这么一则？Track 是 PlaybackThread 内部使用的，不适宜对外暴露，但应用进程</span><br><span class="line">// 又确实需要控制音频流的状态（start、stop、pause），所以就采取这么一种方式实现</span><br><span class="line"></span><br><span class="line">AudioFlinger::TrackHandle::TrackHandle(const sp&lt;AudioFlinger::PlaybackThread::Track&gt;&amp; track)</span><br><span class="line">    : BnAudioTrack(),</span><br><span class="line">      mTrack(track)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AudioFlinger::TrackHandle::~TrackHandle() &#123;</span><br><span class="line">    // just stop the track on deletion, associated resources</span><br><span class="line">    // will be freed from the main thread once all pending buffers have</span><br><span class="line">    // been played. Unless it&apos;s not in the active track list, in which</span><br><span class="line">    // case we free everything now...</span><br><span class="line">    mTrack-&gt;destroy();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sp&lt;IMemory&gt; AudioFlinger::TrackHandle::getCblk() const &#123;</span><br><span class="line">    return mTrack-&gt;getCblk();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status_t AudioFlinger::TrackHandle::start() &#123;</span><br><span class="line">    return mTrack-&gt;start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void AudioFlinger::TrackHandle::stop() &#123;</span><br><span class="line">    mTrack-&gt;stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void AudioFlinger::TrackHandle::flush() &#123;</span><br><span class="line">    mTrack-&gt;flush();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void AudioFlinger::TrackHandle::pause() &#123;</span><br><span class="line">    mTrack-&gt;pause();</span><br><span class="line">&#125;</span><br><span class="line">// ----------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>最后，我们看看 Track 的构造过程，主要分析数据 FIFO 及它的控制块是如何分配的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\AudioFlinger.cpp]</span><br><span class="line">AudioFlinger::PlaybackThread::Track::Track(</span><br><span class="line">            PlaybackThread *thread,</span><br><span class="line">            <span class="keyword">const</span> sp&lt;Client&gt;&amp; client,</span><br><span class="line">            <span class="keyword">audio_stream_type_t</span> streamType,</span><br><span class="line">            <span class="keyword">uint32_t</span> sampleRate,</span><br><span class="line">            <span class="keyword">audio_format_t</span> format,</span><br><span class="line">            <span class="keyword">audio_channel_mask_t</span> channelMask,</span><br><span class="line">            <span class="keyword">size_t</span> frameCount,</span><br><span class="line">            <span class="keyword">void</span> *buffer,</span><br><span class="line">            <span class="keyword">const</span> sp&lt;IMemory&gt;&amp; sharedBuffer,</span><br><span class="line">            <span class="keyword">int</span> sessionId,</span><br><span class="line">            <span class="keyword">int</span> uid,</span><br><span class="line">            IAudioFlinger::<span class="keyword">track_flags_t</span> flags,</span><br><span class="line">            track_type type)</span><br><span class="line">    :   TrackBase(thread, client, sampleRate, format, channelMask, frameCount,</span><br><span class="line">                  (sharedBuffer != <span class="number">0</span>) ? sharedBuffer-&gt;pointer() : buffer,</span><br><span class="line">                  sessionId, uid, flags, <span class="literal">true</span> <span class="comment">/*isOut*/</span>,</span><br><span class="line">                  (type == TYPE_PATCH) ? ( buffer == <span class="literal">NULL</span> ? ALLOC_LOCAL : ALLOC_NONE) : ALLOC_CBLK,</span><br><span class="line">                  type),</span><br><span class="line">    mFillingUpStatus(FS_INVALID),</span><br><span class="line">    <span class="comment">// mRetryCount initialized later when needed</span></span><br><span class="line">    mSharedBuffer(sharedBuffer),</span><br><span class="line">    mStreamType(streamType),</span><br><span class="line">    mName(<span class="number">-1</span>),  <span class="comment">// see note below</span></span><br><span class="line">    mMainBuffer(thread-&gt;mixBuffer()),</span><br><span class="line">    mAuxBuffer(<span class="literal">NULL</span>),</span><br><span class="line">    mAuxEffectId(<span class="number">0</span>), mHasVolumeController(<span class="literal">false</span>),</span><br><span class="line">    mPresentationCompleteFrames(<span class="number">0</span>),</span><br><span class="line">    mFastIndex(<span class="number">-1</span>),</span><br><span class="line">    mCachedVolume(<span class="number">1.0</span>),</span><br><span class="line">    mIsInvalid(<span class="literal">false</span>),</span><br><span class="line">    mAudioTrackServerProxy(<span class="literal">NULL</span>),</span><br><span class="line">    mResumeToStopping(<span class="literal">false</span>),</span><br><span class="line">    mFlushHwPending(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// client == 0 implies sharedBuffer == 0</span></span><br><span class="line">    ALOG_ASSERT(!(client == <span class="number">0</span> &amp;&amp; sharedBuffer != <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    ALOGV_IF(sharedBuffer != <span class="number">0</span>, <span class="string">"sharedBuffer: %p, size: %d"</span>, sharedBuffer-&gt;pointer(),</span><br><span class="line">            sharedBuffer-&gt;size());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查 FIFO 控制块（audio_track_cblk_t）是否分配好了，上面代码并未分配 audio_track_cblk_t</span></span><br><span class="line">    <span class="comment">// 因此只可能是构造 TrackBase 时分配的，等下再看看 TrackBase 的构造函数</span></span><br><span class="line">    <span class="keyword">if</span> (mCblk == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sharedBuffer == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 数据传输模式为 MODE_STREAM 模式，创建一个 AudioTrackServerProxy 对象</span></span><br><span class="line">        <span class="comment">// PlaybackThread 将持续使用它从 FIFO 上取得可读数据的位置</span></span><br><span class="line">        mAudioTrackServerProxy = <span class="keyword">new</span> AudioTrackServerProxy(mCblk, mBuffer, frameCount,</span><br><span class="line">                mFrameSize, !isExternalTrack(), sampleRate);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 数据传输模式为 MODE_STATIC 模式，创建一个 StaticAudioTrackServerProxy 对象</span></span><br><span class="line">        mAudioTrackServerProxy = <span class="keyword">new</span> StaticAudioTrackServerProxy(mCblk, mBuffer, frameCount,</span><br><span class="line">                mFrameSize);</span><br><span class="line">    &#125;</span><br><span class="line">    mServerProxy = mAudioTrackServerProxy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为 Track 分配一个名称，AudioMixer 会根据 TrackName 找到对应的 Track</span></span><br><span class="line">    mName = thread-&gt;getTrackName_l(channelMask, format, sessionId);</span><br><span class="line">    <span class="keyword">if</span> (mName &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"no more track names available"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AudioFlinger::ThreadBase::TrackBase::TrackBase(</span><br><span class="line">            ThreadBase *thread,</span><br><span class="line">            <span class="keyword">const</span> sp&lt;Client&gt;&amp; client,</span><br><span class="line">            <span class="keyword">uint32_t</span> sampleRate,</span><br><span class="line">            <span class="keyword">audio_format_t</span> format,</span><br><span class="line">            <span class="keyword">audio_channel_mask_t</span> channelMask,</span><br><span class="line">            <span class="keyword">size_t</span> frameCount,</span><br><span class="line">            <span class="keyword">void</span> *buffer,</span><br><span class="line">            <span class="keyword">int</span> sessionId,</span><br><span class="line">            <span class="keyword">int</span> clientUid,</span><br><span class="line">            IAudioFlinger::<span class="keyword">track_flags_t</span> flags,</span><br><span class="line">            <span class="keyword">bool</span> isOut,</span><br><span class="line">            alloc_type alloc,</span><br><span class="line">            track_type type)</span><br><span class="line">    :   RefBase(),</span><br><span class="line">        mThread(thread),</span><br><span class="line">        mClient(client),</span><br><span class="line">        mCblk(<span class="literal">NULL</span>),</span><br><span class="line">        <span class="comment">// mBuffer</span></span><br><span class="line">        mState(IDLE),</span><br><span class="line">        mSampleRate(sampleRate),</span><br><span class="line">        mFormat(format),</span><br><span class="line">        mChannelMask(channelMask),</span><br><span class="line">        mChannelCount(isOut ?</span><br><span class="line">                audio_channel_count_from_out_mask(channelMask) :</span><br><span class="line">                audio_channel_count_from_in_mask(channelMask)),</span><br><span class="line">        mFrameSize(audio_is_linear_pcm(format) ?</span><br><span class="line">                mChannelCount * audio_bytes_per_sample(format) : <span class="keyword">sizeof</span>(<span class="keyword">int8_t</span>)),</span><br><span class="line">        mFrameCount(frameCount),</span><br><span class="line">        mSessionId(sessionId),</span><br><span class="line">        mFlags(flags),</span><br><span class="line">        mIsOut(isOut),</span><br><span class="line">        mServerProxy(<span class="literal">NULL</span>),</span><br><span class="line">        mId(android_atomic_inc(&amp;nextTrackId)),</span><br><span class="line">        mTerminated(<span class="literal">false</span>),</span><br><span class="line">        mType(type),</span><br><span class="line">        mThreadIoHandle(thread-&gt;id())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ALOGD("Creating track with %d buffers @ %d bytes", bufferCount, bufferSize);</span></span><br><span class="line">    <span class="keyword">size_t</span> size = <span class="keyword">sizeof</span>(<span class="keyword">audio_track_cblk_t</span>);</span><br><span class="line">    <span class="keyword">size_t</span> bufferSize = (buffer == <span class="literal">NULL</span> ? roundup(frameCount) : frameCount) * mFrameSize;</span><br><span class="line">    <span class="keyword">if</span> (buffer == <span class="literal">NULL</span> &amp;&amp; alloc == ALLOC_CBLK) &#123;</span><br><span class="line">        <span class="comment">// 这个 size 将是分配的匿名共享内存的大小</span></span><br><span class="line">        <span class="comment">// 等于控制块的大小（sizeof(audio_track_cblk_t)加上数据 FIFO的大小（bufferSize）</span></span><br><span class="line">        <span class="comment">// 待会看到这块内存的结构，就明白这样分配的意义了</span></span><br><span class="line">        size += bufferSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (client != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 分配一块匿名共享内存</span></span><br><span class="line">        mCblkMemory = client-&gt;heap()-&gt;allocate(size);</span><br><span class="line">        <span class="keyword">if</span> (mCblkMemory == <span class="number">0</span> ||</span><br><span class="line">                (mCblk = <span class="keyword">static_cast</span>&lt;<span class="keyword">audio_track_cblk_t</span> *&gt;(mCblkMemory-&gt;pointer())) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">"not enough memory for AudioTrack size=%u"</span>, size);</span><br><span class="line">            client-&gt;heap()-&gt;dump(<span class="string">"AudioTrack"</span>);</span><br><span class="line">            mCblkMemory.clear();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// this syntax avoids calling the audio_track_cblk_t constructor twice</span></span><br><span class="line">        mCblk = (<span class="keyword">audio_track_cblk_t</span> *) <span class="keyword">new</span> <span class="keyword">uint8_t</span>[size];</span><br><span class="line">        <span class="comment">// assume mCblk != NULL</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// construct the shared structure in-place.</span></span><br><span class="line">    <span class="keyword">if</span> (mCblk != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 这是 C++ 的 placement new（定位创建对象）语法：new(@BUFFER) @CLASS();</span></span><br><span class="line">        <span class="comment">// 可以在特定内存位置上构造一个对象</span></span><br><span class="line">        <span class="comment">// 这里，在匿名共享内存首地址上构造了一个 audio_track_cblk_t 对象</span></span><br><span class="line">        <span class="comment">// 这样 AudioTrack 与 AudioFlinger 都能访问这个 audio_track_cblk_t 对象了</span></span><br><span class="line">        <span class="keyword">new</span>(mCblk) <span class="keyword">audio_track_cblk_t</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如下分配数据 FIFO，将用于 AudioTrack 与 AudioFlinger 的数据交换</span></span><br><span class="line">        <span class="keyword">switch</span> (alloc) &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        <span class="keyword">case</span> ALLOC_CBLK:</span><br><span class="line">            <span class="comment">// clear all buffers</span></span><br><span class="line">            <span class="keyword">if</span> (buffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">// 数据传输模式为 MODE_STREAM/TRANSFER_SYNC 时，数据 FIFO 的分配</span></span><br><span class="line">                <span class="comment">// 数据 FIFO 的首地址紧靠控制块（audio_track_cblk_t）之后</span></span><br><span class="line">                <span class="comment">//   |                                                         |</span></span><br><span class="line">                <span class="comment">//   | -------------------&gt; mCblkMemory &lt;--------------------- |</span></span><br><span class="line">                <span class="comment">//   |                                                         |</span></span><br><span class="line">                <span class="comment">//   +--------------------+------------------------------------+</span></span><br><span class="line">                <span class="comment">//   | audio_track_cblk_t |             Buffer                 |</span></span><br><span class="line">                <span class="comment">//   +--------------------+------------------------------------+</span></span><br><span class="line">                <span class="comment">//   ^                    ^</span></span><br><span class="line">                <span class="comment">//   |                    |</span></span><br><span class="line">                <span class="comment">//   mCblk               mBuffer</span></span><br><span class="line">                mBuffer = (<span class="keyword">char</span>*)mCblk + <span class="keyword">sizeof</span>(<span class="keyword">audio_track_cblk_t</span>);</span><br><span class="line">                <span class="built_in">memset</span>(mBuffer, <span class="number">0</span>, bufferSize);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 数据传输模式为 MODE_STATIC/TRANSFER_SHARED 时，直接指向 sharedBuffer</span></span><br><span class="line">                <span class="comment">// sharedBuffer 是应用进程分配的匿名共享内存，应用进程已经一次性把数据</span></span><br><span class="line">                <span class="comment">// 写到 sharedBuffer 来了，AudioFlinger 可以直接从这里读取</span></span><br><span class="line">                <span class="comment">//   +--------------------+    +-----------------------------------+</span></span><br><span class="line">                <span class="comment">//   | audio_track_cblk_t |    |            sharedBuffer           |</span></span><br><span class="line">                <span class="comment">//   +--------------------+    +-----------------------------------+</span></span><br><span class="line">                <span class="comment">//   ^                         ^</span></span><br><span class="line">                <span class="comment">//   |                         |</span></span><br><span class="line">                <span class="comment">//   mCblk                    mBuffer</span></span><br><span class="line">                mBuffer = buffer;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-3-AudioTrack-数据写入"><a href="#3-3-AudioTrack-数据写入" class="headerlink" title="3.3. AudioTrack 数据写入"></a>3.3. AudioTrack 数据写入</h5><p>AudioTrack 实例构造后，应用程序接着可以写入音频数据了。如之前所描述：AudioTrack 与 AudioFlinger 是 生产者-消费者 的关系：</p><p>☯ AudioTrack：AudioTrack 在 FIFO 中找到一块可用空间，把用户传入的音频数据写入到这块可用空间上，然后更新写位置（对于 AudioFinger 来说，意味 FIFO 上有更多的可读数据了）；如果用户传入的数据量比可用空间要大，那么要把用户传入的数据拆分多次写入到 FIFO 中（AudioTrack 和 AudioFlinger 是不同的进程，AudioFlinger 同时也在不停地读取数据，所以 FIFO 可用空间是在不停变化的）<br>☯ AudioFlinger：AudioFlinger 在 FIFO 中找到一块可读数据块，把可读数据拷贝到目的缓冲区上，然后更新读位置（对于 AudioTrack 来说，意味着 FIFO 上有更多的可用空间了）；如果FIFO 上可读数据量比预期的要小，那么要进行多次的读取，才能积累到预期的数据量（AudioTrack 和 AudioFlinger 是不同的进程，AudioTrack 同时也在不停地写入数据，所以 FIFO 可读的数据量是在不停变化的）<br>上面的过程中，如果 AudioTrack 总能及时生产数据，并且 AudioFlinger 总能及时消耗掉这些数据，那么整个过程将是非常和谐的；但系统可能会发生异常，出现如下的状态：</p><p>☯ Block：AudioFlinger 长时间不读取 FIFO 上的可读数据，使得 AudioTrack 长时间获取不到可用空间，无法写入数据；这种情况的根本原因大多是底层驱动发生阻塞异常，导致 AudioFlinger 无法继续写数据到硬件设备中，AudioFlinger 本身并没有错<br>☯ Underrun：AudioTrack 写入数据的速度跟不上 AudioFlinger 读取数据的速度，使得 AudioFlinger 不能及时获取到预期的数据量，反映到现实的后果就是声音断续；这种情况的根本原因大多是应用程序不能及时写入数据或者缓冲区分配过小，AudioTrack 本身并没有错；AudioFlinger 针对这点做了容错处理：当发现 underrun 时，先陷入短时间的睡眠，不急着读取数据，让应用程序准备更多的数据（如果某一天做应用的哥们意识到自己的错误原来由底层的兄弟默默埋单了，会不会感动得哭了^_^）</p><h5 id="3-3-1-AudioTrack-写数据流程"><a href="#3-3-1-AudioTrack-写数据流程" class="headerlink" title="3.3. 1. AudioTrack 写数据流程"></a>3.3. 1. AudioTrack 写数据流程</h5><p>我们看一下 AudioTrack 写数据的代码，流程很简单：obtainBuffer() 在 FIFO 中找到一块可用区间，memcpy() 把用户传入的音频数据拷贝到这个可用区间上，releaseBuffer() 更新写位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmedia\AudioTrack.cpp]</span><br><span class="line">ssize_t AudioTrack::write(const void* buffer, size_t userSize, bool blocking)</span><br><span class="line">&#123;</span><br><span class="line">    if (mTransfer != TRANSFER_SYNC) &#123;</span><br><span class="line">        return INVALID_OPERATION;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (isDirect()) &#123;</span><br><span class="line">        AutoMutex lock(mLock);</span><br><span class="line">        int32_t flags = android_atomic_and(</span><br><span class="line">                            ~(CBLK_UNDERRUN | CBLK_LOOP_CYCLE | CBLK_LOOP_FINAL | CBLK_BUFFER_END),</span><br><span class="line">                            &amp;mCblk-&gt;mFlags);</span><br><span class="line">        if (flags &amp; CBLK_INVALID) &#123;</span><br><span class="line">            return DEAD_OBJECT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (ssize_t(userSize) &lt; 0 || (buffer == NULL &amp;&amp; userSize != 0)) &#123;</span><br><span class="line">        // Sanity-check: user is most-likely passing an error code, and it would</span><br><span class="line">        // make the return value ambiguous (actualSize vs error).</span><br><span class="line">        ALOGE(&quot;AudioTrack::write(buffer=%p, size=%zu (%zd)&quot;, buffer, userSize, userSize);</span><br><span class="line">        return BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size_t written = 0;</span><br><span class="line">    Buffer audioBuffer;</span><br><span class="line"></span><br><span class="line">    while (userSize &gt;= mFrameSize) &#123;</span><br><span class="line">        // 单帧数据量 frameSize = channelCount * bytesPerSample</span><br><span class="line">        //   对于双声道，16位采样的音频数据来说，frameSize = 2 * 2 = 4(bytes)</span><br><span class="line">        // 用户传入的数据帧数 frameCount = userSize / frameSize</span><br><span class="line">        audioBuffer.frameCount = userSize / mFrameSize;</span><br><span class="line"></span><br><span class="line">        // obtainBuffer() 从 FIFO 上得到一块可用区间</span><br><span class="line">        status_t err = obtainBuffer(&amp;audioBuffer,</span><br><span class="line">                blocking ? &amp;ClientProxy::kForever : &amp;ClientProxy::kNonBlocking);</span><br><span class="line">        if (err &lt; 0) &#123;</span><br><span class="line">            if (written &gt; 0) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (err == TIMED_OUT || err == -EINTR) &#123;</span><br><span class="line">                err = WOULD_BLOCK;</span><br><span class="line">            &#125;</span><br><span class="line">            return ssize_t(err);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // toWrite 是 FIFO 可用区间的大小，可能比 userSize（用户传入数据的大小）要小</span><br><span class="line">        //   因此用户传入的数据可能要拆分多次拷贝到 FIFO 上</span><br><span class="line">        // 注意：AudioTrack 和 AudioFlinger 是不同的进程，AudioFlinger 同时也在不停地</span><br><span class="line">        //   消耗数据，所以 FIFO 可用区间是在不停变化的</span><br><span class="line">        size_t toWrite = audioBuffer.size;</span><br><span class="line">        memcpy(audioBuffer.i8, buffer, toWrite); // 把用户数据拷贝到 FIFO 可用区间</span><br><span class="line">        buffer = ((const char *) buffer) + toWrite; // 未拷贝数据的位置</span><br><span class="line">        userSize -= toWrite; // 未拷贝数据的大小</span><br><span class="line">        written += toWrite; // 已拷贝数据的大小</span><br><span class="line"></span><br><span class="line">        // releaseBuffer() 更新 FIFO 写位置</span><br><span class="line">        // 对于 AudioFinger 来说，意味 FIFO 上有更多的可读数据</span><br><span class="line">        releaseBuffer(&amp;audioBuffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (written &gt; 0) &#123;</span><br><span class="line">        mFramesWritten += written / mFrameSize;</span><br><span class="line">    &#125;</span><br><span class="line">    return written;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-3-2-AudioFlinger-读数据流程"><a href="#3-3-2-AudioFlinger-读数据流程" class="headerlink" title="3.3. 2. AudioFlinger 读数据流程"></a>3.3. 2. AudioFlinger 读数据流程</h5><p>AudioFlinger 消费数据的流程稍微复杂一点，3.4. AudioFlinger 回放录制线程 小节中描述了 AudioFlinger::PlaybackThread::threadLoop() 工作流程，这里不累述了，我们把焦点放在“如何从 FIFO 读取数据”节点上。</p><p>我们以 DirectOutputThread/OffloadThread 为例说明（MixerThread 读数据也是类似的过程，只不过是在 AudioMixer 中进行的）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\AudioFlinger.cpp]</span><br><span class="line">void AudioFlinger::DirectOutputThread::threadLoop_mix()</span><br><span class="line">&#123;</span><br><span class="line">    // mFrameCount 是硬件设备（PCM 设备）处理单个数据块的帧数（周期大小）</span><br><span class="line">    //   上层必须积累了足够多（mFrameCount）的数据，才写入到 PCM 设备</span><br><span class="line">    //   所以 mFrameCount 也就是 AudioFlinger 预期的数据量</span><br><span class="line">    size_t frameCount = mFrameCount;</span><br><span class="line">    // mSinkBuffer 目的缓冲区，threadLoop_write() 会把 mSinkBuffer 上的数据写到 PCM 设备</span><br><span class="line">    int8_t *curBuf = (int8_t *)mSinkBuffer;</span><br><span class="line">    // output audio to hardware</span><br><span class="line">    // FIFO 上可读的数据量可能要比预期的要小，因此可能需要多次读取才能积累足够的数据量</span><br><span class="line">    // 注意：AudioTrack 和 AudioFlinger 是不同的进程，AudioTrack 同时也在不停地生产数据</span><br><span class="line">    //   所以 FIFO 可读的数据量是在不停变化的</span><br><span class="line">    while (frameCount) &#123;</span><br><span class="line">        AudioBufferProvider::Buffer buffer;</span><br><span class="line">        buffer.frameCount = frameCount;</span><br><span class="line">        // getNextBuffer() 从 FIFO 上获取可读数据块</span><br><span class="line">        status_t status = mActiveTrack-&gt;getNextBuffer(&amp;buffer);</span><br><span class="line">        if (status != NO_ERROR || buffer.raw == NULL) &#123;</span><br><span class="line">            memset(curBuf, 0, frameCount * mFrameSize);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        // memcpy() 把 FIFO 可读数据拷贝到 mSinkBuffer 目的缓冲区</span><br><span class="line">        memcpy(curBuf, buffer.raw, buffer.frameCount * mFrameSize);</span><br><span class="line">        frameCount -= buffer.frameCount;</span><br><span class="line">        curBuf += buffer.frameCount * mFrameSize;</span><br><span class="line">        // releaseBuffer() 更新 FIFO 读位置</span><br><span class="line">        // 对于 AudioTrack 来说，意味着 FIFO 上有更多的可用空间</span><br><span class="line">        mActiveTrack-&gt;releaseBuffer(&amp;buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    mCurrentWriteLength = curBuf - (int8_t *)mSinkBuffer;</span><br><span class="line">    mSleepTimeUs = 0;</span><br><span class="line">    mStandbyTimeNs = systemTime() + mStandbyDelayNs;</span><br><span class="line">    mActiveTrack.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-3-3-环形-FIFO-管理"><a href="#3-3-3-环形-FIFO-管理" class="headerlink" title="3.3. 3. 环形 FIFO 管理"></a>3.3. 3. 环形 FIFO 管理</h5><p>在上述过程中，不知大家有无意识到：整个过程中，最难的是如何协调生产者与消费者之间的步调。上文所说的 FIFO 是环形 FIFO，AudioTrack 写指针、AudioFlinger 读指针都是基于 FIFO 当前的读写位置来计算的。</p><p>☯AudioTrack 与 AudioFlinger 不在同一个进程上，怎么保证读写指针的线程安全<br>☯读写指针越过 FIFO 后，怎么处理<br>☯AudioTrack 写数据完成后，需要同步状态给 AudioFlinger，让 AudioFlinger 知道当前有可读数据了，而 AudioFlinger 读数据完成后，也需要同步状态给 AudioTrack，让 AudioTrack 知道当前有可用空间了；这里采取什么同步机制<br>我们回顾下创建 AudioTrack 对象时，FIFO 及其控制块的结构如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MODE_STREAM 模式下的匿名共享内存结构：</span><br><span class="line">  |                                                         |</span><br><span class="line">  | -------------------&gt; mCblkMemory &lt;--------------------- |</span><br><span class="line">  |                                                         |</span><br><span class="line">  +--------------------+------------------------------------+</span><br><span class="line">  | audio_track_cblk_t |               FIFO                 |</span><br><span class="line">  +--------------------+------------------------------------+</span><br><span class="line">  ^                    ^</span><br><span class="line">  |                    |</span><br><span class="line">mCblk               mBuffer</span><br><span class="line"></span><br><span class="line">mCblk = static_cast&lt;audio_track_cblk_t *&gt;(mCblkMemory-&gt;pointer());</span><br><span class="line">new(mCblk) audio_track_cblk_t();</span><br><span class="line">mBuffer = (char*)mCblk + sizeof(audio_track_cblk_t);</span><br></pre></td></tr></table></figure><p>☯MODE_STATIC 模式下的匿名共享内存结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  +--------------------+    +-----------------------------------+</span><br><span class="line">  | audio_track_cblk_t |    |         FIFO (sharedBuffer)       |</span><br><span class="line">  +--------------------+    +-----------------------------------+</span><br><span class="line">  ^                         ^</span><br><span class="line">  |                         |</span><br><span class="line">mCblk                    mBuffer</span><br><span class="line"></span><br><span class="line">mCblk = (audio_track_cblk_t *) new uint8_t[size];</span><br><span class="line">new(mCblk) audio_track_cblk_t();</span><br><span class="line">mBuffer = sharedBuffer-&gt;pointer()</span><br></pre></td></tr></table></figure><p>FIFO 管理相关的类图：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/315-Audio-system-FIFO.jpg" alt="Alt text"></p><p>☯AudioTrackClientProxy：MODE_STREAM 模式下，生产者 AudioTrack 使用它在 FIFO 中找到可用空间的位置<br>☯AudioTrackServerProxy：MODE_STREAM 模式下，消费者 AudioFlinger::PlaybackThread 使用它在 FIFO 中找到可读数据的位置<br>☯StaticAudioTrackClientProxy：MODE_STATIC 模式下，生产者 AudioTrack 使用它在 FIFO 中找到可用空间的位置<br>☯StaticAudioTrackServerProxy：MODE_STATIC 模式下，消费者 AudioFlinger::PlaybackThread 使用它在 FIFO 中找到可读数据的位置<br>☯AudioRecordClientProxy：消费者 AudioRecord 使用它在 FIFO 中找到可读数据的位置<br>☯AudioTrackServerProxy：生产者 AudioFlinger::RecordThread 使用它在 FIFO 中找到可用空间的位置<br>到这里，我决定结束本文了。环形 FIFO 管理是 Android 音频系统的精髓，一个小节并不足以描述其原理及实现细节；Android 环形 FIFO 的实现可说得上精妙绝伦，其他项目如果要用到环形 FIFO，不妨多借鉴它。</p><h4 id="四-、深入剖析MediaPlayer播放音频流程"><a href="#四-、深入剖析MediaPlayer播放音频流程" class="headerlink" title="(四)、深入剖析MediaPlayer播放音频流程"></a>(四)、深入剖析MediaPlayer播放音频流程</h4><p>时序图：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/316-Audio-system-mediaplayer-playback.png" alt="Alt text"></p><h4 id="（五）、参考资料-特别感谢各位前辈的分析和图示-："><a href="#（五）、参考资料-特别感谢各位前辈的分析和图示-：" class="headerlink" title="（五）、参考资料(特别感谢各位前辈的分析和图示)："></a>（五）、参考资料(特别感谢各位前辈的分析和图示)：</h4><p><a href="https://zhuanlan.zhihu.com/p/27480328" target="_blank" rel="noopener">Android音频模块启动流程分析</a><br><a href="https://zhuanlan.zhihu.com/jhuster" target="_blank" rel="noopener">Jhuster的专栏​ Android音频开发</a><br><a href="http://thinks.me/2016/09/13/audio_qcom_offload/" target="_blank" rel="noopener">高通audio offload学习 | Thinking</a><br><a href="https://blog.csdn.net/droidphone/article/category/1118446" target="_blank" rel="noopener">DroidPhone的专栏 - CSDN博客</a><br><a href="https://blog.csdn.net/orz415678659/article/details/8866071" target="_blank" rel="noopener">alsa音频架构1-CSDN博客</a><br><a href="https://blog.csdn.net/orz415678659/article/details/8982771" target="_blank" rel="noopener">alsa音频架构2-ASoc - CSDN博客</a><br><a href="https://blog.csdn.net/orz415678659/article/details/8995163" target="_blank" rel="noopener">alsa音频架构3-Pcm - CSDN博客</a><br><a href="https://blog.csdn.net/orz415678659/article/details/8999364" target="_blank" rel="noopener">alsa音频架构4-声卡控制 - CSDN博客</a><br><a href="https://blog.csdn.net/zyuanyun/article/details/59180272" target="_blank" rel="noopener">Linux ALSA 音频系统：逻辑设备篇 - CSDN博客</a><br><a href="https://blog.csdn.net/zyuanyun/article/details/59170418" target="_blank" rel="noopener">Linux ALSA 音频系统：物理链路篇 - CSDN博客</a><br><a href="https://blog.csdn.net/column/details/12812.html" target="_blank" rel="noopener">专栏：MultiMedia框架总结(基于6.0源码) - CSDN博客</a><br><a href="https://blog.csdn.net/zyuanyun/article/details/60890534" target="_blank" rel="noopener">Android 音频系统：从 AudioTrack 到 AudioFlinger - CSDN博客</a><br><a href="https://blog.csdn.net/azloong/article/category/778492" target="_blank" rel="noopener">AZURE - CSDN博客 - ALSA-Android Audio</a><br><a href="https://blog.csdn.net/azloong/article/category/777239" target="_blank" rel="noopener">AZURE - CSDN博客 - ANDROID音频系统</a><br><a href="https://winddoing.github.io/2017/07/10/audio_alsa/" target="_blank" rel="noopener">Audio驱动总结–ALSA | Winddoing’s Blog</a><br><a href="http://www.cnblogs.com/muhe221/articles/4461543.html" target="_blank" rel="noopener">audio HAL - 牧 天 - 博客园</a><br><a href="https://blog.csdn.net/xuesen_lin/article/category/1390680" target="_blank" rel="noopener">林学森的Android专栏 - CSDN博客</a><br><a href="https://blog.csdn.net/yangwen123/article/category/2589087" target="_blank" rel="noopener">深入剖析Android音频 - CSDN博客Yangwen123</a><br><a href="http://www.cnblogs.com/tocy/tag/%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6/" target="_blank" rel="noopener">播放框架 - 标签 - Tocy - 博客园</a><br><a href="https://blog.csdn.net/miaomiao12345678/article/details/57415505" target="_blank" rel="noopener">Android-7.0-Nuplayer概述 - CSDN博客</a><br><a href="https://blog.csdn.net/miaomiao12345678/article/details/56961370" target="_blank" rel="noopener">Android-7.0-Nuplayer-启动流程 - CSDN博客</a><br><a href="https://blog.csdn.net/harman_zjc/article/details/53386010" target="_blank" rel="noopener">Android Media Player 框架分析-Nuplayer（1） - CSDN博客</a><br><a href="https://blog.csdn.net/harman_zjc/article/details/53397945" target="_blank" rel="noopener">Android Media Player 框架分析-AHandler AMessage ALooper - CSDN博客</a><br><a href="https://blog.csdn.net/liu1314you/article/category/6344583" target="_blank" rel="noopener">Android N Audio播放 start真面目- (六篇) CSDN博客</a><br><a href="https://blog.csdn.net/nonmarking/article/details/78746671" target="_blank" rel="noopener">深入理解Android音视频同步机制（五篇）NuPlayer的avsync逻辑 - CSDN博客</a><br><a href="https://blog.csdn.net/u014310046/article/category/6571854" target="_blank" rel="noopener">wangyf的专栏 - CSDN博客-MT6737 Android N 平台 Audio系统学习</a><br><a href="https://blog.csdn.net/xiashaohua/article/details/53638780" target="_blank" rel="noopener">Android 7.0 Audio: Mediaplayer - CSDN博客</a><br><a href="https://blog.csdn.net/xiashaohua/article/category/6549668" target="_blank" rel="noopener">Android 7.0 Audio-相关类浅析- CSDN博客</a><br><a href="https://blog.csdn.net/liu1314you/article/details/59119144" target="_blank" rel="noopener">Android N Audio播放六：如何读取buffer - CSDN博客</a><br><a href="https://blog.csdn.net/jinzhuojun/article/details/78007568" target="_blank" rel="noopener">Fuchsia OS中的RPC机制-FIDL - CSDN博客</a><br><a href="http://www.cnblogs.com/linhaostudy/category/1145404.html" target="_blank" rel="noopener">高通Audio中ASOC的codec驱动 - yooooooo - 博客园</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;amp;&amp;amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内
      
    
    </summary>
    
      <category term="Android" scheme="http://zhoujinjian.cc/categories/Android/"/>
    
    
      <category term="Android" scheme="http://zhoujinjian.cc/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Audio System（2）：Linux ALSA音频系统分析</title>
    <link href="http://zhoujinjian.cc/2018/05/15/Audio%20System%EF%BC%882%EF%BC%89%EF%BC%9ALinux%20ALSA%E9%9F%B3%E9%A2%91%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/"/>
    <id>http://zhoujinjian.cc/2018/05/15/Audio System（2）：Linux ALSA音频系统分析/</id>
    <published>2018-05-14T16:00:00.000Z</published>
    <updated>2018-05-09T15:03:49.790Z</updated>
    
    <content type="html"><![CDATA[<hr><p>注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;&amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除，禁止转载（©Qualcomm Technologies, Inc. 版权所有），谢谢。</p><p><a href="https://github.com/izhoujinjian/zhoujinjian.cc/tree/master/audio.system" target="_blank" rel="noopener">【博客原图链接】</a></p><p><a href="https://blog.csdn.net/zyuanyun" target="_blank" rel="noopener">【特别感谢 - 雲和山的彼端 - 音频系统分析】</a></p><p>Google Pixel、Pixel XL 内核代码（Kernel-3.18）：<br> <a href="https://github.com/matthewdalex/marlin" target="_blank" rel="noopener">Kernel source for Pixel and Pixel XL - GitHub</a></p><p>AOSP 源码（Android 7.1.2）：<br> <a href="https://testerhome.com/topics/2229" target="_blank" rel="noopener"> Android 系统全套源代码分享 (更新到 8.1.0_r1)</a></p><hr><p>源码（主要源码路径）：</p><blockquote><p>User space audio code 源码：</p></blockquote><p>• <strong>/hardware/qcom/audio/hal/ – (Audio HAL 源码)</strong> </p><p>• <strong>/external/tinyalsa/ –  (tinymix, tinyplay, tinycap 源码)</strong></p><p>• <strong>/vendor/qcom/proprietary/mm-audio/ – (QTI OMX  audio encoder and decoders 源码，未公开)</strong></p><p>• <strong>/frameworks/av/media/audioserver/ – (Audioserver 源码)</strong></p><p>• <strong>/frameworks/av/media/libstagefright/ – (Google Stagefright 多媒体框架源码)</strong></p><p>• <strong>/frameworks/av/services/audioflinger/ – (Audioflinger 相关源码)</strong></p><p>• <strong>/external/bluetooth/bluedroid/ – (A2DP audio HAL 相关源码)</strong>/</p><p>• <strong>/hardware/libhardware/modules/usbaudio/ – (USB HAL 源码)</strong>/</p><p>• <strong>/vendor/qcom/proprietary/wfd/mm/source/framework/src/ – (Wi-Fi Display (WFD)、 WFDMMSourceAudioSource.cpp，未公开)</strong></p><p>• <strong>/system/core/include/system/ – (audio.h)</strong>/</p><blockquote><p>Kernel space audio code 源码：</p></blockquote><p>• <strong>/kernel/sound/soc/msm/ –  msm8996.c machine driver 源码 </strong></p><p>• <strong>/kernel/sound/soc/msm/qdsp6v2 –  platform drivers, front end (FE), and back-end (BE) DAI driver, Hexagon DSP drivers for AFE, ADM, and ASM, voice driver 相关源码</strong></p><p>• <strong>kernel/sound/soc/soc-<em>.c – All the SoC-</em>.c  ALSA SoCs framework 源码</strong></p><p>• <strong>kernel/drivers/slimbus/ –  SLIMbus driver 源码 </strong></p><p>• <strong>kernel/arch/arm/mach-msm/ – 包含比如 acpuclock-8996.c, board-8996-gpiomux.c, board-8996.c, and clock-8996.c related to the GPIO, clock, and board-specific information on the MSM8996 相关源码</strong></p><p>• <strong>/kernel/arch/arm/mach-msm/qdsp6v2/ – Contains the drivers for DSP-based encoders and decoders, code for the aDSP loader, APR driver, Ion memory driver, and other utility files</strong></p><p>• <strong>/kernel/arch/arm/boot/dts – Contains MSM8996-<em>.its and MSM8996-</em>.Dtsi files that contain MSM8996-specific information; audio-related customization is available in files such as MSM8996.dtsi, msm8996-mtp.dtsi, and msm8996-cdp.dtsi</strong></p><p>• <strong>/kernel/sound/soc/codecs/ – Contains the source code for the codec driver for WCD9335; codec driver-related source files are wcd9335.c, wcd9xxx-mbhc.c, wcd9xxx-resmgr.c, wcd9xxx-common.c, and so on.</strong></p><p>• <strong>/kernel/drivers/mfd/ – Contains the source code for the codec driver; wcd9xxx-core.c, wcd9xxx-slimslave.c, and wcd9xxx-irq.c are the codec driverrelated files</strong></p><h4 id="（一）-Overview"><a href="#（一）-Overview" class="headerlink" title="（一） Overview"></a>（一） Overview</h4><p>硬件平台及软件版本：<br>☁ Kernel - 3.18<br>☁ SoC - Qualcomm snapdragon<br>☁ CODEC - WCD9335<br>☁ Machine - msm8996<br>☁ Userspace - tinyalsa</p><p>Linux ALSA 音频系统架构大致如下：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/21-Audio-system-Android-Linux-ASoc-arc.png.png" alt="Alt text"></p><p>• Native ALSA Application：tinyplay/tinycap/tinymix，这些用户程序直接调用 alsa 用户库接口来实现放音、录音、控制<br>• ALSA Library API：alsa 用户库接口，常见有 tinyalsa、alsa-lib<br>• ALSA CORE：alsa 核心层，向上提供逻辑设备（PCM/CTL/MIDI/TIMER/…）系统调用，向下驱动硬件设备（Machine/I2S/DMA/CODEC）<br>• ASoC CORE：asoc 是建立在标准 alsa core 基础上，为了更好支持嵌入式系统和应用于移动设备的音频 codec 的一套软件体系<br>• Hardware Driver：音频硬件设备驱动，由三大部分组成，分别是 Machine、Platform、Codec</p><p>Platform：指某款 SoC 平台的音频模块，如 exynos、omap、qcom 等等。Platform 又可细分两部分：</p><p>  • cpu dai：在嵌入式系统里面通常指 SoC 的 I2S、PCM 总线控制器，负责把音频数据从 I2S tx FIFO 搬运到 CODEC（这是回放的情形，录制则方向相反）。cpu_dai 通过 <strong>snd_soc_register_dai()</strong> 来注册。注：DAI 是 Digital Audio Interface 的简称，分为 cpu_dai 和 codec_dai，这两者通过 I2S/PCM 总线连接；AIF 是 Audio Interface 的简称，嵌入式系统中一般是 I2S 和 PCM 接口。<br>  • pcm dma：负责把 dma buffer 中的音频数据搬运到 I2S tx FIFO。值得留意的是：某些情形下是不需要 dma 操作的，比如 Modem 和 CODEC 直连，因为 Modem 本身已经把数据送到 FIFO 了，这时只需启动 codec_dai 接收数据即可；该情形下，Machine 驱动 dai_link 中需要设定 .platform_name = “msm-pcm-xxx”。</p><p>Codec：对于回放来说，userspace 送过来的音频数据是经过采样量化的数字信号，在 codec 经过 DAC 转换成模拟信号然后输出到外放或耳机，这样我们就可以听到声音了。Codec 字面意思是编解码器，但芯片里面的功能部件很多，常见的有 AIF、DAC、ADC、Mixer、PGA、Line-in、Line-out，有些高端的 codec 芯片还有 EQ、DSP、SRC、DRC、AGC、Echo-Canceller、Noise-Suppression 等部件。</p><p>Machine：指某款机器，通过配置 dai_link 把 cpu_dai、codec_dai、modem_dai 各个音频接口给链结成一条条音频链路，然后注册 snd_soc_card。和上面两个不一样，Platform 和 CODEC 驱动一般是可以重用的，而 Machine 有它特定的硬件特性，几乎是不可重用的。所谓的硬件特性指：SoC Platform 与 Codec 的差异；DAIs 之间的链结方式；通过某个 GPIO 打开 Amplifier；通过某个 GPIO 检测耳机插拔；使用某个时钟如 MCLK/External-OSC 作为 I2S、CODEC 的时钟源等等。</p><p>从上面的描述来看，对于回放的情形，PCM 数据流向大致是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">        copy_from_user           DMA                 I2S           DAC</span><br><span class="line">              ^                   ^                   ^             ^</span><br><span class="line">+---------+   |    +----------+   |   +-----------+   |   +-----+   |   +------+</span><br><span class="line">|userspace+--------&gt;DMA Buffer+-------&gt;I2S TX FIFO+-------&gt;CODEC+-------&gt;SPK/HP|</span><br><span class="line">+---------+        +----------+       +-----------+       +-----+       +------+</span><br></pre></td></tr></table></figure><p>几个音频物理链路的概念：</p><p>dai_link：machine 驱动中定义的音频数据链路，它指定链路用到的 codec、codec_dai、cpu_dai、platform。比如对于 WCD9335 平台的 media 链路：.codec_dai_name = “snd-soc-dummy-dai”, .codec_name = “snd-soc-dummy”, .cpu_dai_name = “MultiMediaX”, .platform_name = “msm-pcm-dsp.0”，这四者就构成了一条音频数据链路用于多媒体声音的回放和录制。一个系统可能有多个音频数据链路，比如 media 和 voice，因此可以定义多个 dai_link 。<br>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/msm/msm8996.c]</span><br><span class="line"><span class="comment">/* Digital audio interface glue - connects codec &lt;---&gt; CPU */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_link</span> <span class="title">msm8996_common_dai_links</span>[] = &#123;</span></span><br><span class="line"><span class="comment">/* FrontEnd DAI Links */</span></span><br><span class="line">&#123;</span><br><span class="line">.name = <span class="string">"MSM8996 Media1"</span>,</span><br><span class="line">.stream_name = <span class="string">"MultiMedia1"</span>,</span><br><span class="line">.cpu_dai_name = <span class="string">"MultiMedia1"</span>,</span><br><span class="line">.platform_name = <span class="string">"msm-pcm-dsp.0"</span>,</span><br><span class="line">.dynamic = <span class="number">1</span>,</span><br><span class="line">.async_ops = ASYNC_DPCM_SND_SOC_PREPARE,</span><br><span class="line">.dpcm_playback = <span class="number">1</span>,</span><br><span class="line">.dpcm_capture = <span class="number">1</span>,</span><br><span class="line">.trigger = &#123;SND_SOC_DPCM_TRIGGER_POST,</span><br><span class="line">SND_SOC_DPCM_TRIGGER_POST&#125;,</span><br><span class="line">.codec_dai_name = <span class="string">"snd-soc-dummy-dai"</span>,</span><br><span class="line">.codec_name = <span class="string">"snd-soc-dummy"</span>,</span><br><span class="line">.ignore_suspend = <span class="number">1</span>,</span><br><span class="line"><span class="comment">/* this dainlink has playback support */</span></span><br><span class="line">.ignore_pmdown_time = <span class="number">1</span>,</span><br><span class="line">.be_id = MSM_FRONTEND_DAI_MULTIMEDIA1</span><br><span class="line">&#125;,</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/22-MSM8996-Linux-Android-Audio-ASoc-Architectre.png" alt="Alt text"></p><p>高通平台因DSP而存在特殊性，如上图，Frontend 链接 “Platform”，经由 “Platform”-&gt;Backend链接到Codec。<br>Front-end DAI：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/msm/msm-dai-fe.c]</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_driver</span> <span class="title">msm_fe_dais</span>[] = &#123;</span></span><br><span class="line">&#123;</span><br><span class="line">.playback = &#123;</span><br><span class="line">.stream_name = <span class="string">"MultiMedia1 Playback"</span>,</span><br><span class="line">.aif_name = <span class="string">"MM_DL1"</span>,</span><br><span class="line">.rates = (SNDRV_PCM_RATE_8000_192000|</span><br><span class="line">SNDRV_PCM_RATE_KNOT),</span><br><span class="line">.formats = (SNDRV_PCM_FMTBIT_S16_LE |</span><br><span class="line">SNDRV_PCM_FMTBIT_S24_LE |</span><br><span class="line">SNDRV_PCM_FMTBIT_S24_3LE),</span><br><span class="line">.channels_min = <span class="number">1</span>,</span><br><span class="line">.channels_max = <span class="number">8</span>,</span><br><span class="line">.rate_min =     <span class="number">8000</span>,</span><br><span class="line">.rate_max =<span class="number">192000</span>,</span><br><span class="line">&#125;,</span><br><span class="line">.capture = &#123;</span><br><span class="line">.stream_name = <span class="string">"MultiMedia1 Capture"</span>,</span><br><span class="line">.aif_name = <span class="string">"MM_UL1"</span>,</span><br><span class="line">.rates = (SNDRV_PCM_RATE_8000_192000|</span><br><span class="line">SNDRV_PCM_RATE_KNOT),</span><br><span class="line">.formats = (SNDRV_PCM_FMTBIT_S16_LE |</span><br><span class="line">    SNDRV_PCM_FMTBIT_S24_LE|</span><br><span class="line">    SNDRV_PCM_FMTBIT_S24_3LE),</span><br><span class="line">.channels_min = <span class="number">1</span>,</span><br><span class="line">.channels_max = <span class="number">4</span>,</span><br><span class="line">.rate_min =     <span class="number">8000</span>,</span><br><span class="line">.rate_max =<span class="number">48000</span>,</span><br><span class="line">&#125;,</span><br><span class="line">.ops = &amp;msm_fe_Multimedia_dai_ops,</span><br><span class="line">.name = <span class="string">"MultiMedia1"</span>,</span><br><span class="line">.probe = fe_dai_probe,</span><br><span class="line">&#125;,</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Back-end DAI：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;sound/soc/msm/msm8996.c]</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_link</span> <span class="title">msm8996_tasha_be_dai_links</span>[] = &#123;</span></span><br><span class="line"><span class="comment">/* Backend DAI Links */</span></span><br><span class="line">&#123;</span><br><span class="line">.name = LPASS_BE_SLIMBUS_0_RX,</span><br><span class="line">.stream_name = <span class="string">"Slimbus Playback"</span>,</span><br><span class="line">.cpu_dai_name = <span class="string">"msm-dai-q6-dev.16384"</span>,</span><br><span class="line">.platform_name = <span class="string">"msm-pcm-routing"</span>,</span><br><span class="line">.codec_name = <span class="string">"tasha_codec"</span>,</span><br><span class="line">.codec_dai_name = <span class="string">"tasha_mix_rx1"</span>,</span><br><span class="line">.no_pcm = <span class="number">1</span>,</span><br><span class="line">.dpcm_playback = <span class="number">1</span>,</span><br><span class="line">.be_id = MSM_BACKEND_DAI_SLIMBUS_0_RX,</span><br><span class="line">.init = &amp;msm_audrx_init,</span><br><span class="line">.be_hw_params_fixup = msm_slim_0_rx_be_hw_params_fixup,</span><br><span class="line"><span class="comment">/* this dainlink has playback support */</span></span><br><span class="line">.ignore_pmdown_time = <span class="number">1</span>,</span><br><span class="line">.ignore_suspend = <span class="number">1</span>,</span><br><span class="line">.ops = &amp;msm8996_be_ops,</span><br><span class="line">&#125;,</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> struct snd_soc_dai_link msm8996_tasha_fe_dai_links[] = &#123;</span><br><span class="line">&#123;</span><br><span class="line">.name = LPASS_BE_SLIMBUS_4_TX,</span><br><span class="line">.stream_name = <span class="string">"Slimbus4 Capture"</span>,</span><br><span class="line">.cpu_dai_name = <span class="string">"msm-dai-q6-dev.16393"</span>,</span><br><span class="line">.platform_name = <span class="string">"msm-pcm-hostless"</span>,</span><br><span class="line">.codec_name = <span class="string">"tasha_codec"</span>,</span><br><span class="line">.codec_dai_name = <span class="string">"tasha_vifeedback"</span>,</span><br><span class="line">.be_id = MSM_BACKEND_DAI_SLIMBUS_4_TX,</span><br><span class="line">.be_hw_params_fixup = msm_slim_4_tx_be_hw_params_fixup,</span><br><span class="line">.ops = &amp;msm8996_be_ops,</span><br><span class="line">.no_host_mode = SND_SOC_DAI_LINK_NO_HOST,</span><br><span class="line">.ignore_suspend = <span class="number">1</span>,</span><br><span class="line">&#125;,</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hw constraints：指平台本身的硬件限制，如所能支持的通道数/采样率/数据格式、DMA 支持的数据周期大小（period size）、周期次数（period count）等，通过 snd_pcm_hardware 结构体描述：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;sound/soc/msm/qdsp6v2/msm-pcm-q6-v2.c]</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_pcm_hardware</span> <span class="title">msm_pcm_hardware_capture</span> = &#123;</span></span><br><span class="line">.info =                 (SNDRV_PCM_INFO_MMAP |</span><br><span class="line">SNDRV_PCM_INFO_BLOCK_TRANSFER |</span><br><span class="line">SNDRV_PCM_INFO_MMAP_VALID |</span><br><span class="line">SNDRV_PCM_INFO_INTERLEAVED |</span><br><span class="line">SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME),</span><br><span class="line">.formats =              (SNDRV_PCM_FMTBIT_S16_LE |</span><br><span class="line">SNDRV_PCM_FMTBIT_S24_LE |</span><br><span class="line">SNDRV_PCM_FMTBIT_S24_3LE),</span><br><span class="line">.rates =                SNDRV_PCM_RATE_8000_48000,</span><br><span class="line">.rate_min =             <span class="number">8000</span>,</span><br><span class="line">.rate_max =             <span class="number">48000</span>,</span><br><span class="line">.channels_min =         <span class="number">1</span>,</span><br><span class="line">.channels_max =         <span class="number">4</span>,</span><br><span class="line">.buffer_bytes_max =     CAPTURE_MAX_NUM_PERIODS *</span><br><span class="line">CAPTURE_MAX_PERIOD_SIZE,</span><br><span class="line">.period_bytes_min =CAPTURE_MIN_PERIOD_SIZE,</span><br><span class="line">.period_bytes_max =     CAPTURE_MAX_PERIOD_SIZE,</span><br><span class="line">.periods_min =          CAPTURE_MIN_NUM_PERIODS,</span><br><span class="line">.periods_max =          CAPTURE_MAX_NUM_PERIODS,</span><br><span class="line">.fifo_size =            <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>hw params：用户层设置的硬件参数，如 channels、sample rate、pcm format、period size、period count；这些参数受 hw constraints 约束。</p><p>sw params：用户层设置的软件参数，如 start threshold、stop threshold、silence threshold。</p><h4 id="（二）ASoC-Core"><a href="#（二）ASoC-Core" class="headerlink" title="（二）ASoC Core"></a>（二）ASoC Core</h4><p>ASoC：ALSA System on Chip，是建立在标准 ALSA 驱动之上，为了更好支持嵌入式系统和应用于移动设备的音频 codec 的一套软件体系，它依赖于标准 ALSA 驱动框架。内核文档 Documentation/alsa/soc/overview.txt 中详细介绍了 ASoC 的设计初衷，这里不一一引用，简单陈述如下：</p><p>• 独立的 codec 驱动，标准的 ALSA 驱动框架里面 codec 驱动往往与 SoC/CPU 耦合过于紧密，不利于在多样化的平台/机器上移植复用<br>• 方便 codec 与 SoC 通过 PCM/I2S 总线建立链接<br>• 动态音频电源管理 DAPM，使得 codec 任何时候都工作在最低功耗状态，同时负责音频路由的创建<br>• POPs 和 click 音抑制弱化处理，在 ASoC 中通过正确的音频部件上下电次序来实现<br>• Machine 驱动的特定控制，比如耳机、麦克风的插拔检测，外放功放的开关<br>在概述中已经介绍了 ASoC 硬件设备驱动的三大构成：Codec、Platform 和 Machine，下面列举各驱动的功能构成：</p><p>ASoC Codec Driver：</p><p>• Codec DAI 和 PCM 的配置信息<br>• Codec 的控制接口，如 I2C/SPI<br>• Mixer 和其他音频控件<br>• Codec 的音频接口函数，见 snd_soc_dai_ops 结构体定义<br>• DAPM 描述信息<br>• DAPM 事件处理句柄<br>• DAC 数字静音控制</p><p>ASoC Platform Driver： 包括 dma 和 cpu_dai 两部分：</p><p>• dma 驱动实现音频 dma 操作，具体见 snd_pcm_ops 结构体定义<br>• cpu_dai 驱动实现音频数字接口控制器的描述和配置<br>• ASoC Machine Driver：</p><p>作为链结 Platform 和 Codec 的载体，它必须配置 dai_link 为音频数据链路指定 Platform 和 Codec<br>处理机器特有的音频控件和音频事件，例如回放时打开外放功放<br>硬件设备驱动相关结构体：</p><p>• snd_soc_codec_driver：音频编解码芯片描述及操作函数，如控件/微件/音频路由的描述信息、时钟配置、IO 控制等<br>• snd_soc_dai_driver：音频数据接口描述及操作函数，根据 codec 端和 soc 端，分为 codec_dai 和 cpu_dai<br>• snd_soc_platform_driver：音频 dma 设备描述及操作函数<br>• snd_soc_dai_link：音频链路描述及板级操作函数</p><h4 id="（三）Codec-Driver"><a href="#（三）Codec-Driver" class="headerlink" title="（三）Codec Driver"></a>（三）Codec Driver</h4><p>基本是以内核文档 Documentation/sound/alsa/soc/codec.txt 中的内容为脉络来分析的。Codec 的作用，之前已有描述，本章主要罗列下 Codec driver 中重要的数据结构及注册流程。<br>其中有着各种功能部件，包括但不限于 ：</p><blockquote><p>ADC    把麦克风拾取的模拟信号转换成数字信号<br>DAC    把音频接口过来的数字信号转换成模拟信号<br>MIXER    混音器，把多路输入信号混合成单路输出</p></blockquote><h5 id="3-1-Codec-DAI-and-PCM-configuration"><a href="#3-1-Codec-DAI-and-PCM-configuration" class="headerlink" title="3.1. Codec DAI and PCM configuration"></a>3.1. Codec DAI and PCM configuration</h5><p>codec_dai 和 pcm 配置信息通过结构体 snd_soc_dai_driver 描述，包括 dai 的能力描述和操作接口，snd_soc_dai_driver 最终会被注册到 soc-core 中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;include/sound/soc-dai.h]</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Digital Audio Interface Driver.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Describes the Digital Audio Interface in terms of its ALSA, DAI and AC97</span></span><br><span class="line"><span class="comment"> * operations and capabilities. Codec and platform drivers will register this</span></span><br><span class="line"><span class="comment"> * structure for every DAI they have.</span></span><br><span class="line"><span class="comment"> * This structure covers the clocking, formating and ALSA operations for each</span></span><br><span class="line"><span class="comment"> * interface.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_driver</span> &#123;</span></span><br><span class="line">    <span class="comment">/* DAI description */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">int</span> ac97_control;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* DAI driver callbacks */</span></span><br><span class="line">    <span class="keyword">int</span> (*probe)(struct snd_soc_dai *dai);</span><br><span class="line">    <span class="keyword">int</span> (*remove)(struct snd_soc_dai *dai);</span><br><span class="line">    <span class="keyword">int</span> (*suspend)(struct snd_soc_dai *dai);</span><br><span class="line">    <span class="keyword">int</span> (*resume)(struct snd_soc_dai *dai);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ops */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* DAI capabilities */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_pcm_stream</span> <span class="title">capture</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_pcm_stream</span> <span class="title">playback</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> symmetric_rates:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* probe ordering - for components with runtime dependencies */</span></span><br><span class="line">    <span class="keyword">int</span> probe_order;</span><br><span class="line">    <span class="keyword">int</span> remove_order;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>name：codec_dai 的名称标识，dai_link 通过配置 codec_dai_name 来找到对应的 codec_dai；<br>probe：codec_dai 的初始化函数，注册声卡时回调；<br>playback：回放能力描述，如回放设备所支持的声道数、采样率、音频格式；<br>capture：录制能力描述，如录制设备所支持声道数、采样率、音频格式；<br>ops：codec_dai 的操作函数集，这些函数集非常重要，用于 dai 的时钟配置、格式配置、硬件参数配置。</p><p>codec_dai：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;sound/soc/codecs/wcd9335.c]</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_driver</span> <span class="title">tasha_i2s_dai</span>[] = &#123;</span></span><br><span class="line">&#123;</span><br><span class="line">.name = <span class="string">"tasha_i2s_rx1"</span>,</span><br><span class="line">.id = AIF1_PB,</span><br><span class="line">.playback = &#123;</span><br><span class="line">.stream_name = <span class="string">"AIF1 Playback"</span>,</span><br><span class="line">.rates = WCD9335_RATES_MASK,</span><br><span class="line">.formats = TASHA_FORMATS_S16_S24_LE,</span><br><span class="line">.rate_max = <span class="number">192000</span>,</span><br><span class="line">.rate_min = <span class="number">8000</span>,</span><br><span class="line">.channels_min = <span class="number">1</span>,</span><br><span class="line">.channels_max = <span class="number">2</span>,</span><br><span class="line">&#125;,</span><br><span class="line">.ops = &amp;tasha_dai_ops,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">.name = <span class="string">"tasha_i2s_tx1"</span>,</span><br><span class="line">.id = AIF1_CAP,</span><br><span class="line">.capture = &#123;</span><br><span class="line">.stream_name = <span class="string">"AIF1 Capture"</span>,</span><br><span class="line">.rates = WCD9335_RATES_MASK,</span><br><span class="line">.formats = TASHA_FORMATS,</span><br><span class="line">.rate_max = <span class="number">192000</span>,</span><br><span class="line">.rate_min = <span class="number">8000</span>,</span><br><span class="line">.channels_min = <span class="number">1</span>,</span><br><span class="line">.channels_max = <span class="number">4</span>,</span><br><span class="line">&#125;,</span><br><span class="line">.ops = &amp;tasha_dai_ops,</span><br><span class="line">&#125;,</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="3-2-Codec-control-IO"><a href="#3-2-Codec-control-IO" class="headerlink" title="3.2. Codec control IO"></a>3.2. Codec control IO</h5><p>移动设备的音频 Codec，其控制接口一般是 I2C 或 SPI，控制接口用于读写 codec 的寄存器。在 snd_soc_codec_driver 结构体中，有如下字段描述 Codec 的控制接口：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;include/sound/soc.h]</span><br><span class="line"><span class="comment">/* codec driver */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_codec_driver</span> &#123;</span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">/* codec IO */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">regmap</span> *(*<span class="title">get_regmap</span>)(<span class="title">struct</span> <span class="title">device</span> *);</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*read)</span><span class="params">(struct snd_soc_codec *, <span class="keyword">unsigned</span> <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> (*write)(struct snd_soc_codec *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">int</span> (*display_register)(struct snd_soc_codec *, <span class="keyword">char</span> *,</span><br><span class="line"><span class="keyword">size_t</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">int</span> (*volatile_register)(struct snd_soc_codec *, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">int</span> (*readable_register)(struct snd_soc_codec *, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">int</span> (*writable_register)(struct snd_soc_codec *, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> reg_cache_size;</span><br><span class="line"><span class="keyword">short</span> reg_cache_step;</span><br><span class="line"><span class="keyword">short</span> reg_word_size;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">void</span> *reg_cache_default;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>• read：读寄存器；<br>• write：写寄存器；<br>• volatile_register：判断指定的寄存器是否是 volatile 属性；假如是，则读取寄存器时不是读 cache，而直接访问硬件；<br>• readable_register：判断指定的寄存器是否可读；<br>• reg_cache_default：寄存器的缺省值；<br>• reg_cache_size：缺省的寄存器值数组大小；<br>• reg_word_size：寄存器宽度。<br>在 Linux-3.4.5 中，很多 codec 的控制接口都改用 regmap 了。soc-core 中判断是否用的是 regmap，如果是，则调用 regmap 接口。</p><h5 id="3-3-Mixers-and-audio-controls"><a href="#3-3-Mixers-and-audio-controls" class="headerlink" title="3.3. Mixers and audio controls"></a>3.3. Mixers and audio controls</h5><p>音频控件多用于部件开关和音量的设定，音频控件可通过 soc.h 中的宏来定义，例如单一型控件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;include/sound/soc.h]</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOC_SINGLE(xname, reg, shift, max, invert) \</span></span><br><span class="line">&#123;   .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \</span><br><span class="line">    .info = snd_soc_info_volsw, .get = snd_soc_get_volsw,\</span><br><span class="line">    .put = snd_soc_put_volsw, \</span><br><span class="line">    .private_value =  SOC_SINGLE_VALUE(reg, shift, max, invert) &#125;</span><br></pre></td></tr></table></figure><p>这种控件只有一个设置量，一般用于部件开关。宏定义的参数说明：</p><p>• xname：控件的名称标识；<br>• reg：控件对应的寄存器地址；<br>• shift：控件控制位在寄存器中的偏移；<br>• max：控件设置值范围；<br>• invert：设定值是否取反。<br>其他类型控件类似，不一一介绍了。</p><p>上述只是宏定义，音频控件真正的结构是 snd_kcontrol_new：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/include/sound/control.h]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_kcontrol_new</span> &#123;</span></span><br><span class="line">    <span class="keyword">snd_ctl_elem_iface_t</span> iface; <span class="comment">/* interface identifier */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> device;        <span class="comment">/* device/client number */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> subdevice;     <span class="comment">/* subdevice (substream) number */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *name;  <span class="comment">/* ASCII name of item */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> index;     <span class="comment">/* index of item */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> access;        <span class="comment">/* access rights */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count;     <span class="comment">/* count of same elements */</span></span><br><span class="line">    <span class="keyword">snd_kcontrol_info_t</span> *info;</span><br><span class="line">    <span class="keyword">snd_kcontrol_get_t</span> *get;</span><br><span class="line">    <span class="keyword">snd_kcontrol_put_t</span> *put;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">snd_kcontrol_tlv_rw_t</span> *c;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> *p;</span><br><span class="line">    &#125; tlv;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> private_value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Codec 初始化时，通过 snd_soc_add_codec_controls() 把所有定义好的音频控件注册到 alsa-core ，上层可以通过 tinymix、alsa_amixer 等工具查看修改这些控件的设定。</p><h5 id="3-6-Codec-audio-operations"><a href="#3-6-Codec-audio-operations" class="headerlink" title="3.6. Codec audio operations"></a>3.6. Codec audio operations</h5><p>Codec 音频操作接口通过结构体 snd_soc_dai_ops 描述：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;include/sound/soc-dai.h]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_ops</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * DAI clocking configuration, all optional.</span></span><br><span class="line"><span class="comment"> * Called by soc_card drivers, normally in their hw_params.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> (*set_sysclk)(struct snd_soc_dai *dai,</span><br><span class="line"><span class="keyword">int</span> clk_id, <span class="keyword">unsigned</span> <span class="keyword">int</span> freq, <span class="keyword">int</span> dir);</span><br><span class="line"><span class="keyword">int</span> (*set_pll)(struct snd_soc_dai *dai, <span class="keyword">int</span> pll_id, <span class="keyword">int</span> source,</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> freq_in, <span class="keyword">unsigned</span> <span class="keyword">int</span> freq_out);</span><br><span class="line"><span class="keyword">int</span> (*set_clkdiv)(struct snd_soc_dai *dai, <span class="keyword">int</span> div_id, <span class="keyword">int</span> div);</span><br><span class="line"><span class="keyword">int</span> (*set_bclk_ratio)(struct snd_soc_dai *dai, <span class="keyword">unsigned</span> <span class="keyword">int</span> ratio);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * DAI format configuration</span></span><br><span class="line"><span class="comment"> * Called by soc_card drivers, normally in their hw_params.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> (*set_fmt)(struct snd_soc_dai *dai, <span class="keyword">unsigned</span> <span class="keyword">int</span> fmt);</span><br><span class="line"><span class="keyword">int</span> (*xlate_tdm_slot_mask)(<span class="keyword">unsigned</span> <span class="keyword">int</span> slots,</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> *tx_mask, <span class="keyword">unsigned</span> <span class="keyword">int</span> *rx_mask);</span><br><span class="line"><span class="keyword">int</span> (*set_tdm_slot)(struct snd_soc_dai *dai,</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> tx_mask, <span class="keyword">unsigned</span> <span class="keyword">int</span> rx_mask,</span><br><span class="line"><span class="keyword">int</span> slots, <span class="keyword">int</span> slot_width);</span><br><span class="line"><span class="keyword">int</span> (*set_channel_map)(struct snd_soc_dai *dai,</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> tx_num, <span class="keyword">unsigned</span> <span class="keyword">int</span> *tx_slot,</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> rx_num, <span class="keyword">unsigned</span> <span class="keyword">int</span> *rx_slot);</span><br><span class="line"><span class="keyword">int</span> (*set_tristate)(struct snd_soc_dai *dai, <span class="keyword">int</span> tristate);</span><br><span class="line"><span class="keyword">int</span> (*get_channel_map)(struct snd_soc_dai *dai,</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> *tx_num, <span class="keyword">unsigned</span> <span class="keyword">int</span> *tx_slot,</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> *rx_num, <span class="keyword">unsigned</span> <span class="keyword">int</span> *rx_slot);</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注释比较详细的了，Codec 音频操作接口分为 5 大部分：时钟配置、格式配置、数字静音、PCM 音频接口、FIFO 延迟。着重说下时钟配置及格式配置接口：</p><p>• set_sysclk：codec_dai 系统时钟设置，当上层打开 pcm 设备时，需要回调该接口设置 Codec 的系统时钟，Codec 才能正常工作；<br>• set_pll：Codec FLL 设置，Codec 一般接了一个 MCLK 输入时钟，回调该接口基于 MCLK 来产生 Codec FLL 时钟，接着 codec_dai 的 sysclk、bclk、lrclk 均可从 FLL 分频出来（假设 Codec 作为 master）；<br>• set_fmt：codec_dai 格式设置，具体见 soc-dai.h；<br>  • SND_SOC_DAIFMT_I2S：音频数据是 I2S 格式，常用于多媒体音频；<br>  • SND_SOC_DAIFMT_DSP_A：音频数据是 PCM 格式，常用于通话语音；<br>  • SND_SOC_DAIFMT_CBM_CFM：Codec 作为 master，BCLK 和 LRCLK 由 Codec 提供；<br>  • SND_SOC_DAIFMT_CBS_CFS：Codec 作为 slave，BCLK 和 LRCLK 由 SoC/CPU 提供；<br>• hw_params：codec_dai 硬件参数设置，根据上层设定的声道数、采样率、数据格式，来配置 codec_dai 相关寄存器。</p><p>WCD9335的snd_soc_dai_ops ：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/codecs/wcd9335.c]</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_ops</span> <span class="title">tasha_dai_ops</span> = &#123;</span></span><br><span class="line">.startup = tasha_startup,</span><br><span class="line">.shutdown = tasha_shutdown,</span><br><span class="line">.hw_params = tasha_hw_params,</span><br><span class="line">.prepare = tasha_prepare,</span><br><span class="line">.set_sysclk = tasha_set_dai_sysclk,</span><br><span class="line">.set_fmt = tasha_set_dai_fmt,</span><br><span class="line">.set_channel_map = tasha_set_channel_map,</span><br><span class="line">.get_channel_map = tasha_get_channel_map,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h5 id="3-6-Codec-register"><a href="#3-6-Codec-register" class="headerlink" title="3.6. Codec register"></a>3.6. Codec register</h5><p>当 platform_driver：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/codecs/wcd9335.c]</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">tasha_codec_driver</span> = &#123;</span></span><br><span class="line">.probe = tasha_probe,</span><br><span class="line">.remove = tasha_remove,</span><br><span class="line">.driver = &#123;</span><br><span class="line">.name = <span class="string">"tasha_codec"</span>,</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">#ifdef CONFIG_PM</span><br><span class="line">.pm = &amp;tasha_pm_ops,</span><br><span class="line">#endif</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>与.name = “tasha_codec”  的 platform_device（该 platform_device 在 drivers/mfd/wcd9xxx-core.c 中注册wcd9xxx_device_init-&gt;wcd9xxx_check_codec_type-&gt;tasha_devs）匹配后，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;drivers/mfd/wcd9xxx-core.c]</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mfd_cell</span> <span class="title">tasha_devs</span>[] = &#123;</span></span><br><span class="line">&#123;</span><br><span class="line">.name = <span class="string">"tasha_codec"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>立即回调 tasha_probe() 注册 Codec：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/codecs/wcd9335.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tasha_probe</span><span class="params">(struct platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasha_priv</span> *<span class="title">tasha</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clk</span> *<span class="title">wcd_ext_clk</span>, *<span class="title">wcd_native_clk</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">wcd9xxx_resmgr_v2</span> *<span class="title">resmgr</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">wcd9xxx_power_region</span> *<span class="title">cdc_pwr</span>;</span></span><br><span class="line">......</span><br><span class="line">tasha = devm_kzalloc(&amp;pdev-&gt;dev, <span class="keyword">sizeof</span>(struct tasha_priv),</span><br><span class="line">    GFP_KERNEL);</span><br><span class="line">......</span><br><span class="line">    tasha-&gt;resmgr = resmgr;</span><br><span class="line">tasha-&gt;swr_plat_data.handle = (<span class="keyword">void</span> *) tasha;</span><br><span class="line">tasha-&gt;swr_plat_data.read = tasha_swrm_read;</span><br><span class="line">tasha-&gt;swr_plat_data.write = tasha_swrm_write;</span><br><span class="line">tasha-&gt;swr_plat_data.bulk_write = tasha_swrm_bulk_write;</span><br><span class="line">tasha-&gt;swr_plat_data.clk = tasha_swrm_clock;</span><br><span class="line">tasha-&gt;swr_plat_data.handle_irq = tasha_swrm_handle_irq;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Register for Clock */</span></span><br><span class="line">wcd_ext_clk = clk_get(tasha-&gt;wcd9xxx-&gt;dev, <span class="string">"wcd_clk"</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(wcd_ext_clk)) &#123;</span><br><span class="line">dev_err(tasha-&gt;wcd9xxx-&gt;dev, <span class="string">"%s: clk get %s failed\n"</span>,</span><br><span class="line">__func__, <span class="string">"wcd_ext_clk"</span>);</span><br><span class="line"><span class="keyword">goto</span> err_clk;</span><br><span class="line">&#125;</span><br><span class="line">tasha-&gt;wcd_ext_clk = wcd_ext_clk;</span><br><span class="line">tasha-&gt;sido_voltage = SIDO_VOLTAGE_NOMINAL_MV;</span><br><span class="line">set_bit(AUDIO_NOMINAL, &amp;tasha-&gt;status_mask);</span><br><span class="line">tasha-&gt;sido_ccl_cnt = <span class="number">0</span>;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">if</span> (wcd9xxx_get_intf_type() == WCD9XXX_INTERFACE_TYPE_SLIMBUS)</span><br><span class="line">ret = snd_soc_register_codec(&amp;pdev-&gt;dev, &amp;soc_codec_dev_tasha,</span><br><span class="line">     tasha_dai, ARRAY_SIZE(tasha_dai));</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (wcd9xxx_get_intf_type() == WCD9XXX_INTERFACE_TYPE_I2C)</span><br><span class="line">ret = snd_soc_register_codec(&amp;pdev-&gt;dev, &amp;soc_codec_dev_tasha,</span><br><span class="line">     tasha_i2s_dai,</span><br><span class="line">     ARRAY_SIZE(tasha_i2s_dai));</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ret = -EINVAL;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>snd_soc_register_codec：将 codec_driver 和 codec_dai_driver 注册到 soc-core。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;]</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * snd_soc_register_codec - Register a codec with the ASoC core</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @codec: codec to register</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snd_soc_register_codec</span><span class="params">(struct device *dev,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">const</span> struct snd_soc_codec_driver *codec_drv,</span></span></span><br><span class="line"><span class="function"><span class="params">               struct snd_soc_dai_driver *dai_drv,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">int</span> num_dai)</span></span></span><br></pre></td></tr></table></figure><p>创建一个 snd_soc_codec 实例，包含 codec_drv（snd_soc_dai_driver）相关信息，封装给 soc-core 使用，相关代码段如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[sound/soc/soc-core.c: snd_soc_register_codec]</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_codec</span> *<span class="title">codec</span>;</span></span><br><span class="line"></span><br><span class="line">    dev_dbg(dev, <span class="string">"codec register %s\n"</span>, dev_name(dev));</span><br><span class="line"></span><br><span class="line">    codec = kzalloc(<span class="keyword">sizeof</span>(struct snd_soc_codec), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (codec == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create CODEC component name */</span></span><br><span class="line">    codec-&gt;name = fmt_single_name(dev, &amp;codec-&gt;id);</span><br><span class="line">    <span class="keyword">if</span> (codec-&gt;name == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        kfree(codec);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 Codec 的寄存器缓存配置及读写接口</span></span><br><span class="line">    codec-&gt;write = codec_drv-&gt;write;</span><br><span class="line">    codec-&gt;read = codec_drv-&gt;read;</span><br><span class="line">    codec-&gt;volatile_register = codec_drv-&gt;volatile_register;</span><br><span class="line">    codec-&gt;readable_register = codec_drv-&gt;readable_register;</span><br><span class="line">    codec-&gt;writable_register = codec_drv-&gt;writable_register;</span><br><span class="line">    codec-&gt;ignore_pmdown_time = codec_drv-&gt;ignore_pmdown_time;</span><br><span class="line">    codec-&gt;dapm.bias_level = SND_SOC_BIAS_OFF;</span><br><span class="line">    codec-&gt;dapm.dev = dev;</span><br><span class="line">    codec-&gt;dapm.codec = codec;</span><br><span class="line">    codec-&gt;dapm.seq_notifier = codec_drv-&gt;seq_notifier;</span><br><span class="line">    codec-&gt;dapm.stream_event = codec_drv-&gt;stream_event;</span><br><span class="line">    codec-&gt;dev = dev;</span><br><span class="line">    codec-&gt;driver = codec_drv;</span><br><span class="line">    codec-&gt;num_dai = num_dai;</span><br><span class="line">    mutex_init(&amp;codec-&gt;mutex);</span><br></pre></td></tr></table></figure><p>把以上 codec 实例插入到 codec_list链表中（声卡注册时会遍历该链表，找到 dai_link 声明的 codec 并绑定）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[sound/soc/soc-core.c: snd_soc_register_codec]</span><br><span class="line">list_add(&amp;codec-&gt;<span class="built_in">list</span>, &amp;codec_list);</span><br></pre></td></tr></table></figure><p>把 codec_drv 中的 snd_soc_dai_driver（tasha_dai 或者tasha_i2s_dai ）注册到 soc-core：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[sound/soc/soc-core.c: snd_soc_register_codec]</span><br><span class="line">snd_soc_register_dais(&amp;codec-&gt;component, dai_drv, num_dai, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>snd_soc_register_dais() 会把 dai 插入到 dai_list 链表中（声卡注册时会遍历该链表，找到 dai_link 声明的 codec_dai 并绑定）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[sound/soc/soc-core.c: snd_soc_register_codec]</span><br><span class="line">list_add(&amp;dai-&gt;<span class="built_in">list</span>, &amp;dai_list);</span><br></pre></td></tr></table></figure><p>最后顺便提下 codec 和 codec_dai 的区别：codec 指音频芯片共有的部分，包括 codec 初始化函数、控制接口、寄存器缓存、控件、dapm 部件、音频路由、偏置电压设置函数等描述信息；而 codec_dai 指 codec 上的音频接口驱动描述，包括时钟配置、格式配置、能力描述等等，各个接口的描述信息不一定都是一致的，所以每个音频接口都有着各自的驱动描述。</p><h4 id="（四）Platform-Driver"><a href="#（四）Platform-Driver" class="headerlink" title="（四）Platform Driver"></a>（四）Platform Driver</h4><p>概述中提到音频 Platform 驱动主要用于音频数据传输，这里又细分为两步：</p><p>启动 dma 设备，把音频数据从 dma buffer 搬运到 cpu_dai FIFO，这部分驱动用 snd_soc_platform_driver 描述，后面分析用 pcm_dma 指代它。<br>启动数字音频接口控制器（I2S/PCM/AC97），把音频数据从 cpu_dai FIFO 传送到 codec_dai（高通平台会将数据传送到ADSP）这部分驱动用 snd_soc_dai_driver 描述，后面分析用 cpu_dai 指代它。</p><blockquote><p>MSM8996 包含三个 Hexagon DSP ：application, modem, and sensor。<br>Application  DSP：不仅可以处理语音和音频，还可以处理计算机 视觉、视频、图像和Camera。<br> Sensor DSP：也叫做SLPI，所有的sensor都链接到SLPI上面，它管理所有的Sensor及相关算法。</p></blockquote><p>对于 cpu_dai 驱动，从上面的类图我们可知，主要工作有：</p><p>实现 dai 操作函数，见 snd_soc_dai_ops 定义，用于配置和操作音频数字接口控制器，如时钟配置 set_sysclk()、格式配置 set_fmt()、硬件参数配置 hw_params()、启动/停止数据传输 trigger() 等；<br>实现 probe 函数（初始化）、remove 函数（卸载）、suspend/resume 函数（电源管理）；<br>初始化 snd_soc_dai_driver 实例，包括回放和录制的能力描述、dai 操作函数集、probe/remove 回调、电源管理相关的 suspend/resume 回调；<br>通过 snd_soc_register_dai() 把初始化完成的 snd_soc_dai_driver 注册到 soc-core：首先创建一个 snd_soc_dai 实例，然后把该 snd_soc_dai 实例插入到 dai_list 链表（声卡注册时会遍历该链表，找到 dai_link 声明的 cpu_dai 并绑定）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">[sound/soc/soc-core.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">snd_soc_register_dais</span><span class="params">(struct snd_soc_component *component,</span></span></span><br><span class="line"><span class="function"><span class="params">struct snd_soc_dai_driver *dai_drv, <span class="keyword">size_t</span> count,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">bool</span> legacy_dai_naming)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> = <span class="title">component</span>-&gt;<span class="title">dev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai</span> *<span class="title">dai</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">dev_dbg(dev, <span class="string">"ASoC: dai register %s #%Zu\n"</span>, dev_name(dev), count);</span><br><span class="line"></span><br><span class="line">component-&gt;dai_drv = dai_drv;</span><br><span class="line">component-&gt;num_dai = count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line"></span><br><span class="line">dai = kzalloc(<span class="keyword">sizeof</span>(struct snd_soc_dai), GFP_KERNEL);</span><br><span class="line">......</span><br><span class="line"><span class="keyword">if</span> (count == <span class="number">1</span> &amp;&amp; legacy_dai_naming) &#123;</span><br><span class="line">dai-&gt;name = fmt_single_name(dev, &amp;dai-&gt;id);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dai-&gt;name = fmt_multiple_name(dev, &amp;dai_drv[i]);</span><br><span class="line"><span class="keyword">if</span> (dai_drv[i].id)</span><br><span class="line">dai-&gt;id = dai_drv[i].id;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">dai-&gt;id = i;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">dai-&gt;component = component;</span><br><span class="line">dai-&gt;dev = dev;</span><br><span class="line">dai-&gt;driver = &amp;dai_drv[i];</span><br><span class="line"><span class="keyword">if</span> (!dai-&gt;driver-&gt;ops)</span><br><span class="line">dai-&gt;driver-&gt;ops = &amp;null_dai_ops;</span><br><span class="line"></span><br><span class="line">list_add(&amp;dai-&gt;<span class="built_in">list</span>, &amp;component-&gt;dai_list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dai 操作函数的实现是 cpu_dai 驱动的主体，需要配置好相关寄存器让 I2S/PCM 总线控制器正常运转，snd_soc_dai_ops 字段的详细说明见 3.6. Codec audio operations 章节。</p><p>cpu_dai 驱动应该算是这个系列中最简单的一环，因此不多花费笔墨在这里了。倒是某些平台上，dma 设备信息（总线地址、通道号、传输单元大小）是在这里初始化的，这点要留意，这些 dma 设备信息在 pcm_dma 驱动中用到。</p><h5 id="4-1-pcm-operations"><a href="#4-1-pcm-operations" class="headerlink" title="4.1. pcm operations"></a>4.1. pcm operations</h5><p>操作函数的实现是本模块的主体，见 snd_pcm_ops 结构体描述：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;include/sound/pcm.h]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_pcm_ops</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> (*open)(struct snd_pcm_substream *substream);</span><br><span class="line"><span class="keyword">int</span> (*close)(struct snd_pcm_substream *substream);</span><br><span class="line"><span class="keyword">int</span> (*ioctl)(struct snd_pcm_substream * substream,</span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">void</span> *arg);</span><br><span class="line"><span class="keyword">int</span> (*compat_ioctl)(struct snd_pcm_substream *substream,</span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">void</span> *arg);</span><br><span class="line"><span class="keyword">int</span> (*hw_params)(struct snd_pcm_substream *substream,</span><br><span class="line"> struct snd_pcm_hw_params *params);</span><br><span class="line"><span class="keyword">int</span> (*hw_free)(struct snd_pcm_substream *substream);</span><br><span class="line"><span class="keyword">int</span> (*prepare)(struct snd_pcm_substream *substream);</span><br><span class="line"><span class="keyword">int</span> (*trigger)(struct snd_pcm_substream *substream, <span class="keyword">int</span> cmd);</span><br><span class="line"><span class="keyword">snd_pcm_uframes_t</span> (*pointer)(struct snd_pcm_substream *substream);</span><br><span class="line"><span class="keyword">int</span> (*delay_blk)(struct snd_pcm_substream *substream);</span><br><span class="line"><span class="keyword">int</span> (*wall_clock)(struct snd_pcm_substream *substream,</span><br><span class="line">  struct timespec *audio_ts);</span><br><span class="line"><span class="keyword">int</span> (*copy)(struct snd_pcm_substream *substream, <span class="keyword">int</span> channel,</span><br><span class="line">    <span class="keyword">snd_pcm_uframes_t</span> pos,</span><br><span class="line">    <span class="keyword">void</span> __user *buf, <span class="keyword">snd_pcm_uframes_t</span> count);</span><br><span class="line"><span class="keyword">int</span> (*silence)(struct snd_pcm_substream *substream, <span class="keyword">int</span> channel,</span><br><span class="line">       <span class="keyword">snd_pcm_uframes_t</span> pos, <span class="keyword">snd_pcm_uframes_t</span> count);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *(*<span class="title">page</span>)(<span class="title">struct</span> <span class="title">snd_pcm_substream</span> *<span class="title">substream</span>,</span></span><br><span class="line"><span class="class">     <span class="title">unsigned</span> <span class="title">long</span> <span class="title">offset</span>);</span></span><br><span class="line"><span class="keyword">int</span> (*mmap)(struct snd_pcm_substream *substream, struct vm_area_struct *vma);</span><br><span class="line"><span class="keyword">int</span> (*ack)(struct snd_pcm_substream *substream);</span><br><span class="line"><span class="keyword">int</span> (*restart)(struct snd_pcm_substream *substream);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="4-1-platform-driver-注册"><a href="#4-1-platform-driver-注册" class="headerlink" title="4.1. platform_driver 注册"></a>4.1. platform_driver 注册</h5><p>当 platform_driver：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;sound/soc/msm/qdsp6v2/msm-pcm-q6-v2.c]</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">msm_pcm_driver</span> = &#123;</span></span><br><span class="line">.driver = &#123;</span><br><span class="line">.name = <span class="string">"msm-pcm-dsp"</span>,</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.of_match_table = msm_pcm_dt_match,</span><br><span class="line">&#125;,</span><br><span class="line">.probe = msm_pcm_probe,</span><br><span class="line">.remove = msm_pcm_remove,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>与 .name = “msm-pcm-dsp” 的 platform_device 注册 匹配后，系统会回调 msm_pcm_probe() 注册 platform：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;sound/soc/msm/qdsp6v2/msm-pcm-q6-v2.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">msm_pcm_probe</span><span class="params">(struct platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> rc;</span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msm_plat_data</span> *<span class="title">pdata</span>;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *latency_level;</span><br><span class="line"></span><br><span class="line">rc = of_property_read_u32(pdev-&gt;dev.of_node,</span><br><span class="line"><span class="string">"qcom,msm-pcm-dsp-id"</span>, &amp;id);</span><br><span class="line">......</span><br><span class="line">pdata = kzalloc(<span class="keyword">sizeof</span>(struct msm_plat_data), GFP_KERNEL);</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (of_property_read_bool(pdev-&gt;dev.of_node,</span><br><span class="line"><span class="string">"qcom,msm-pcm-low-latency"</span>)) &#123;</span><br><span class="line">pdata-&gt;perf_mode = LOW_LATENCY_PCM_MODE;</span><br><span class="line">rc = of_property_read_string(pdev-&gt;dev.of_node,</span><br><span class="line"><span class="string">"qcom,latency-level"</span>, &amp;latency_level);</span><br><span class="line"><span class="keyword">if</span> (!rc) &#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strcmp</span>(latency_level, <span class="string">"ultra"</span>))</span><br><span class="line">pdata-&gt;perf_mode = ULTRA_LOW_LATENCY_PCM_MODE;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(latency_level, <span class="string">"ull-pp"</span>))</span><br><span class="line">pdata-&gt;perf_mode =</span><br><span class="line">ULL_POST_PROCESSING_PCM_MODE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">pdata-&gt;perf_mode = LEGACY_PCM_MODE;</span><br><span class="line"></span><br><span class="line">dev_set_drvdata(&amp;pdev-&gt;dev, pdata);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> snd_soc_register_platform(&amp;pdev-&gt;dev,</span><br><span class="line">   &amp;msm_soc_platform);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>snd_soc_register_platform：将 platform_drv 注册到 soc-core。<br>创建一个 snd_soc_platform 实例，包含 platform_drv（snd_soc_platform_driver）的相关信息，封装给 soc-core 使用；<br>把以上创建的 platform 实例插入到 platform_list 链表上（声卡注册时会遍历该链表，找到 dai_link 声明的 platform 并绑定）。<br>代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int snd_soc_register_platform(struct device *dev,</span><br><span class="line">const struct snd_soc_platform_driver *platform_drv)</span><br><span class="line">&#123;</span><br><span class="line">struct snd_soc_platform *platform;</span><br><span class="line">int ret;</span><br><span class="line"></span><br><span class="line">platform = kzalloc(sizeof(struct snd_soc_platform), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">ret = snd_soc_add_platform(dev, platform, platform_drv);</span><br><span class="line"></span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，完成了 Platform 驱动的实现。回放情形下，pcm_dma 设备负责把 dma buffer 中的数据搬运到 I2S tx FIFO，I2S 总线控制器负责把 I2S tx FIFO 中的数据传送DSP，DSP经处理后传送到到 Codec。</p><h4 id="（五）-Machine-Driver"><a href="#（五）-Machine-Driver" class="headerlink" title="（五）  Machine Driver"></a>（五）  Machine Driver</h4><p>章节 3. Codec 和 4. Platform 介绍了 Codec、Platform 驱动，但仅有 Codec、Platform 驱动是不能工作的，需要一个角色把 codec、codec_dai、cpu_dai、platform 给链结起来才能构成一个完整的音频链路，这个角色就由 machine_drv 承担了。</p><p>snd_soc_dai_link 结构体：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/include/sound/soc.h]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_link</span> &#123;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *name;<span class="comment">/* Codec name */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *stream_name;<span class="comment">/* Stream name */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *cpu_name;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">cpu_of_node</span>;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *cpu_dai_name;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *codec_name;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">codec_of_node</span>;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *codec_dai_name;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_link_component</span> *<span class="title">codecs</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> num_codecs;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *platform_name;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">platform_of_node</span>;</span></span><br><span class="line"><span class="keyword">int</span> be_id;<span class="comment">/* optional ID for machine driver BE identification */</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_pcm_stream</span> *<span class="title">params</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> dai_fmt;           <span class="comment">/* format to set on init */</span></span><br><span class="line"><span class="keyword">enum</span> snd_soc_dpcm_trigger trigger[<span class="number">2</span>]; <span class="comment">/* trigger type for DPCM */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> ignore_suspend:<span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> symmetric_rates:<span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> symmetric_channels:<span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> symmetric_samplebits:<span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> no_pcm:<span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> dynamic:<span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> no_host_mode:<span class="number">2</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> dpcm_capture:<span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> dpcm_playback:<span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> ignore_pmdown_time:<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> (*init)(struct snd_soc_pcm_runtime *rtd);</span><br><span class="line"><span class="keyword">int</span> (*be_hw_params_fixup)(struct snd_soc_pcm_runtime *rtd,</span><br><span class="line">struct snd_pcm_hw_params *params);</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_compr_ops</span> *<span class="title">compr_ops</span>;</span></span><br><span class="line"><span class="keyword">bool</span> playback_only;</span><br><span class="line"><span class="keyword">bool</span> capture_only;</span><br><span class="line"><span class="keyword">enum</span> snd_soc_async_ops async_ops;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点介绍如下几个字段：</p><p>• codec_name：音频链路需要绑定的 codec 名称，声卡注册时会遍历 codec_list，找到同名的 codec 并绑定；<br>• platform_name：音频链路需要绑定的 platform 名称，声卡注册时会遍历 platform_list，找到同名的 platform 并绑定；<br>• cpu_dai_name：音频链路需要绑定的 cpu_dai 名称，声卡注册时会遍历 dai_list，找到同名的 dai 并绑定；<br>• codec_dai_name：音频链路需要绑定的 codec_dai 名称，声卡注册时会遍历 dai_list，找到同名的 dai 并绑定；<br>ops：重点留意 hw_params() 回调，一般来说这个回调是要实现的，用于配置 codec、codec_dai、cpu_dai 的数据格式和系统时钟。在 3.6. Codec audio operations 小节中有描述。<br>/sound/soc/msm/msm8996.c 中的 dai_link 定义，两个音频链路分别用于 Media和 Voice：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/msm/msm8996.c]</span><br><span class="line"><span class="comment">/* Digital audio interface glue - connects codec &lt;---&gt; CPU */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_link</span> <span class="title">msm8996_common_dai_links</span>[] = &#123;</span></span><br><span class="line"><span class="comment">/* FrontEnd DAI Links */</span></span><br><span class="line">&#123;</span><br><span class="line">.name = <span class="string">"MSM8996 Media1"</span>,</span><br><span class="line">.stream_name = <span class="string">"MultiMedia1"</span>,</span><br><span class="line">.cpu_dai_name = <span class="string">"MultiMedia1"</span>,</span><br><span class="line">.platform_name = <span class="string">"msm-pcm-dsp.0"</span>,</span><br><span class="line">.dynamic = <span class="number">1</span>,</span><br><span class="line">.async_ops = ASYNC_DPCM_SND_SOC_PREPARE,</span><br><span class="line">.dpcm_playback = <span class="number">1</span>,</span><br><span class="line">.dpcm_capture = <span class="number">1</span>,</span><br><span class="line">.trigger = &#123;SND_SOC_DPCM_TRIGGER_POST,</span><br><span class="line">SND_SOC_DPCM_TRIGGER_POST&#125;,</span><br><span class="line">.codec_dai_name = <span class="string">"snd-soc-dummy-dai"</span>,</span><br><span class="line">.codec_name = <span class="string">"snd-soc-dummy"</span>,</span><br><span class="line">.ignore_suspend = <span class="number">1</span>,</span><br><span class="line"><span class="comment">/* this dainlink has playback support */</span></span><br><span class="line">.ignore_pmdown_time = <span class="number">1</span>,</span><br><span class="line">.be_id = MSM_FRONTEND_DAI_MULTIMEDIA1</span><br><span class="line">&#125;,</span><br><span class="line">......</span><br><span class="line">&#123;</span><br><span class="line">.name = <span class="string">"VoiceMMode1"</span>,</span><br><span class="line">.stream_name = <span class="string">"VoiceMMode1"</span>,</span><br><span class="line">.cpu_dai_name = <span class="string">"VoiceMMode1"</span>,</span><br><span class="line">.platform_name = <span class="string">"msm-pcm-voice"</span>,</span><br><span class="line">.dynamic = <span class="number">1</span>,</span><br><span class="line">.dpcm_playback = <span class="number">1</span>,</span><br><span class="line">.dpcm_capture = <span class="number">1</span>,</span><br><span class="line">.trigger = &#123;SND_SOC_DPCM_TRIGGER_POST,</span><br><span class="line">    SND_SOC_DPCM_TRIGGER_POST&#125;,</span><br><span class="line">.no_host_mode = SND_SOC_DAI_LINK_NO_HOST,</span><br><span class="line">.ignore_suspend = <span class="number">1</span>,</span><br><span class="line">.ignore_pmdown_time = <span class="number">1</span>,</span><br><span class="line">.codec_dai_name = <span class="string">"snd-soc-dummy-dai"</span>,</span><br><span class="line">.codec_name = <span class="string">"snd-soc-dummy"</span>,</span><br><span class="line">.be_id = MSM_FRONTEND_DAI_VOICEMMODE1,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了 dai_link，机器中一些特定的音频控件和音频事件也可以在 machine_drv 定义，如耳机插拔检测、外部功放打开关闭等。</p><p>我们再分析 machine_drv 初始化过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/msm/msm8996.c]</span><br><span class="line">static struct platform_driver msm8996_asoc_machine_driver = &#123;</span><br><span class="line">.driver = &#123;</span><br><span class="line">.name = DRV_NAME,</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.pm = &amp;snd_soc_pm_ops,</span><br><span class="line">.of_match_table = msm8996_asoc_machine_of_match,</span><br><span class="line">&#125;,</span><br><span class="line">.probe = msm8996_asoc_machine_probe,</span><br><span class="line">.remove = msm8996_asoc_machine_remove,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/msm/msm8996.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">msm8996_asoc_machine_probe</span><span class="params">(struct platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_card</span> *<span class="title">card</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msm8996_asoc_mach_data</span> *<span class="title">pdata</span>;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *mbhc_audio_jack_type = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">char</span> *mclk_freq_prop_name;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> *<span class="title">match</span>;</span></span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line">    ......</span><br><span class="line">pdata = devm_kzalloc(&amp;pdev-&gt;dev,</span><br><span class="line"><span class="keyword">sizeof</span>(struct msm8996_asoc_mach_data), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">card = populate_snd_card_dailinks(&amp;pdev-&gt;dev);</span><br><span class="line">......</span><br><span class="line">match = of_match_node(msm8996_asoc_machine_of_match,</span><br><span class="line">pdev-&gt;dev.of_node);</span><br><span class="line">ret = msm8996_populate_dai_link_component_of_node(card);</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">ret = snd_soc_register_card(card);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置dailinks后，继而调用 snd_soc_register_card() 注册声卡。由于该过程很冗长，这里不一一贴代码分析了，但整个流程是比较简单的，流程图如下：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/23-Audio-system-msm8996-probe-snd-card-register.png" alt="Alt text"></p><p>• 取出 platform_device 的私有数据，该私有数据就是 snd_soc_card ；<br>• snd_soc_register_card() 为每个 dai_link 分配一个 snd_soc_pcm_runtime 实例，别忘了之前提过 snd_soc_pcm_runtime 是 ASoC 的桥梁，保存着 codec、codec_dai、cpu_dai、platform 等硬件设备实例。<br>• 随后的工作都在 snd_soc_instantiate_card() 进行：<br>• 遍历 dai_list、codec_list、platform_list 链表，为每个音频链路找到对应的 cpu_dai、codec_dai、codec、platform；找到的 cpu_dai、codec_dai、codec、platform 保存到 snd_soc_pcm_runtime ，完成音频链路的设备绑定；<br>• 调用 snd_card_create() 创建声卡；<br>• soc_probe_dai_link() 依次回调 cpu_dai、codec、platform、codec_dai 的 probe() 函数，完成各音频设备的初始化，随后调用<br>• soc_new_pcm() 创建 pcm 逻辑设备（因为涉及到本系列的重点内容，后面具体分析这个函数）；<br>最后调用 snd_card_register() 注册声卡。</p><p>[-&gt;sound/soc/soc-core.c]</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/24-Audio-system-msm8996-probe-snd-card.png" alt="Alt text"></p><p>soc_new_pcm 源码分析：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-pcm.c]</span><br><span class="line"><span class="comment">/* create a new pcm */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">soc_new_pcm</span><span class="params">(struct snd_soc_pcm_runtime *rtd, <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_platform</span> *<span class="title">platform</span> = <span class="title">rtd</span>-&gt;<span class="title">platform</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai</span> *<span class="title">codec_dai</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai</span> *<span class="title">cpu_dai</span> = <span class="title">rtd</span>-&gt;<span class="title">cpu_dai</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_pcm</span> *<span class="title">pcm</span>;</span></span><br><span class="line"><span class="keyword">char</span> new_name[<span class="number">64</span>];</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>, playback = <span class="number">0</span>, capture = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rtd-&gt;dai_link-&gt;dynamic || rtd-&gt;dai_link-&gt;no_pcm) &#123;</span><br><span class="line">playback = rtd-&gt;dai_link-&gt;dpcm_playback;</span><br><span class="line">capture = rtd-&gt;dai_link-&gt;dpcm_capture;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; rtd-&gt;num_codecs; i++) &#123;</span><br><span class="line">codec_dai = rtd-&gt;codec_dais[i];</span><br><span class="line"><span class="keyword">if</span> (codec_dai-&gt;driver-&gt;playback.channels_min)</span><br><span class="line">playback = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (codec_dai-&gt;driver-&gt;capture.channels_min)</span><br><span class="line">capture = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">capture = capture &amp;&amp; cpu_dai-&gt;driver-&gt;capture.channels_min;</span><br><span class="line">playback = playback &amp;&amp; cpu_dai-&gt;driver-&gt;playback.channels_min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rtd-&gt;dai_link-&gt;playback_only) &#123;</span><br><span class="line">playback = <span class="number">1</span>;</span><br><span class="line">capture = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rtd-&gt;dai_link-&gt;capture_only) &#123;</span><br><span class="line">playback = <span class="number">0</span>;</span><br><span class="line">capture = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* create the PCM */</span></span><br><span class="line"><span class="keyword">if</span> (rtd-&gt;dai_link-&gt;no_pcm) &#123;</span><br><span class="line"><span class="built_in">snprintf</span>(new_name, <span class="keyword">sizeof</span>(new_name), <span class="string">"(%s)"</span>,</span><br><span class="line">rtd-&gt;dai_link-&gt;stream_name);</span><br><span class="line"></span><br><span class="line">ret = snd_pcm_new_internal(rtd-&gt;card-&gt;snd_card, new_name, num,</span><br><span class="line">playback, capture, &amp;pcm);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (rtd-&gt;dai_link-&gt;dynamic)</span><br><span class="line"><span class="built_in">snprintf</span>(new_name, <span class="keyword">sizeof</span>(new_name), <span class="string">"%s (*)"</span>,</span><br><span class="line">rtd-&gt;dai_link-&gt;stream_name);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">snprintf</span>(new_name, <span class="keyword">sizeof</span>(new_name), <span class="string">"%s %s-%d"</span>,</span><br><span class="line">rtd-&gt;dai_link-&gt;stream_name,</span><br><span class="line">(rtd-&gt;num_codecs &gt; <span class="number">1</span>) ?</span><br><span class="line"><span class="string">"multicodec"</span> : rtd-&gt;codec_dai-&gt;name, num);</span><br><span class="line"></span><br><span class="line">ret = snd_pcm_new(rtd-&gt;card-&gt;snd_card, new_name, num, playback,</span><br><span class="line">capture, &amp;pcm);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">dev_err(rtd-&gt;card-&gt;dev, <span class="string">"ASoC: can't create pcm for %s\n"</span>,</span><br><span class="line">rtd-&gt;dai_link-&gt;name);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">dev_dbg(rtd-&gt;card-&gt;dev, <span class="string">"ASoC: registered pcm #%d %s\n"</span>,num, new_name);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* DAPM dai link stream work */</span></span><br><span class="line">INIT_DELAYED_WORK(&amp;rtd-&gt;delayed_work, close_delayed_work);</span><br><span class="line"></span><br><span class="line">rtd-&gt;pcm = pcm;</span><br><span class="line">pcm-&gt;private_data = rtd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rtd-&gt;dai_link-&gt;no_pcm) &#123;</span><br><span class="line"><span class="keyword">if</span> (playback)</span><br><span class="line">pcm-&gt;streams[SNDRV_PCM_STREAM_PLAYBACK].substream-&gt;private_data = rtd;</span><br><span class="line"><span class="keyword">if</span> (capture)</span><br><span class="line">pcm-&gt;streams[SNDRV_PCM_STREAM_CAPTURE].substream-&gt;private_data = rtd;</span><br><span class="line"><span class="keyword">if</span> (platform-&gt;driver-&gt;pcm_new)</span><br><span class="line">rtd-&gt;platform-&gt;driver-&gt;pcm_new(rtd);</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* setup any hostless PCMs - i.e. no host IO is performed */</span></span><br><span class="line"><span class="keyword">if</span> (rtd-&gt;dai_link-&gt;no_host_mode) &#123;</span><br><span class="line"><span class="keyword">if</span> (pcm-&gt;streams[SNDRV_PCM_STREAM_PLAYBACK].substream) &#123;</span><br><span class="line">pcm-&gt;streams[SNDRV_PCM_STREAM_PLAYBACK].substream-&gt;hw_no_buffer = <span class="number">1</span>;</span><br><span class="line">snd_soc_set_runtime_hwparams(</span><br><span class="line">pcm-&gt;streams[SNDRV_PCM_STREAM_PLAYBACK].substream,</span><br><span class="line">&amp;no_host_hardware);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pcm-&gt;streams[SNDRV_PCM_STREAM_CAPTURE].substream) &#123;</span><br><span class="line">pcm-&gt;streams[SNDRV_PCM_STREAM_CAPTURE].substream-&gt;hw_no_buffer = <span class="number">1</span>;</span><br><span class="line">snd_soc_set_runtime_hwparams(</span><br><span class="line">pcm-&gt;streams[SNDRV_PCM_STREAM_CAPTURE].substream,</span><br><span class="line">&amp;no_host_hardware);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ASoC PCM operations */</span></span><br><span class="line"><span class="keyword">if</span> (rtd-&gt;dai_link-&gt;dynamic) &#123;</span><br><span class="line">rtd-&gt;ops.open= dpcm_fe_dai_open;</span><br><span class="line">rtd-&gt;ops.hw_params= dpcm_fe_dai_hw_params;</span><br><span class="line">rtd-&gt;ops.prepare= dpcm_fe_dai_prepare;</span><br><span class="line">rtd-&gt;ops.trigger= dpcm_fe_dai_trigger;</span><br><span class="line">rtd-&gt;ops.hw_free= dpcm_fe_dai_hw_free;</span><br><span class="line">rtd-&gt;ops.close= dpcm_fe_dai_close;</span><br><span class="line">rtd-&gt;ops.pointer= soc_pcm_pointer;</span><br><span class="line">rtd-&gt;ops.delay_blk= soc_pcm_delay_blk;</span><br><span class="line">rtd-&gt;ops.ioctl= soc_pcm_ioctl;</span><br><span class="line">rtd-&gt;ops.compat_ioctl   = soc_pcm_compat_ioctl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">rtd-&gt;ops.open= soc_pcm_open;</span><br><span class="line">rtd-&gt;ops.hw_params= soc_pcm_hw_params;</span><br><span class="line">rtd-&gt;ops.prepare= soc_pcm_prepare;</span><br><span class="line">rtd-&gt;ops.trigger= soc_pcm_trigger;</span><br><span class="line">rtd-&gt;ops.hw_free= soc_pcm_hw_free;</span><br><span class="line">rtd-&gt;ops.close= soc_pcm_close;</span><br><span class="line">rtd-&gt;ops.pointer= soc_pcm_pointer;</span><br><span class="line">rtd-&gt;ops.delay_blk= soc_pcm_delay_blk;</span><br><span class="line">rtd-&gt;ops.ioctl= soc_pcm_ioctl;</span><br><span class="line">rtd-&gt;ops.compat_ioctl   = soc_pcm_compat_ioctl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (platform-&gt;driver-&gt;ops) &#123;</span><br><span class="line">rtd-&gt;ops.ack= platform-&gt;driver-&gt;ops-&gt;ack;</span><br><span class="line">rtd-&gt;ops.copy= platform-&gt;driver-&gt;ops-&gt;copy;</span><br><span class="line">rtd-&gt;ops.silence= platform-&gt;driver-&gt;ops-&gt;silence;</span><br><span class="line">rtd-&gt;ops.page= platform-&gt;driver-&gt;ops-&gt;page;</span><br><span class="line">rtd-&gt;ops.mmap= platform-&gt;driver-&gt;ops-&gt;mmap;</span><br><span class="line">rtd-&gt;ops.restart= platform-&gt;driver-&gt;ops-&gt;restart;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (playback)</span><br><span class="line">snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &amp;rtd-&gt;ops);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (capture)</span><br><span class="line">snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &amp;rtd-&gt;ops);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (platform-&gt;driver-&gt;pcm_new) &#123;</span><br><span class="line">ret = platform-&gt;driver-&gt;pcm_new(rtd);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">dev_err(platform-&gt;dev,</span><br><span class="line"><span class="string">"ASoC: pcm constructor failed: %d\n"</span>,</span><br><span class="line">ret);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pcm-&gt;private_free = platform-&gt;driver-&gt;pcm_free;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见 soc_new_pcm() 最主要的工作是创建 pcm 逻辑设备，创建回放子流和录制子流实例，并初始化回放子流和录制子流的 pcm 操作函数（数据搬运时，需要调用这些函数来驱动 codec、codec_dai、cpu_dai、dma 设备工作）。</p><h4 id="（六）、声卡和-PCM-设备的建立过程"><a href="#（六）、声卡和-PCM-设备的建立过程" class="headerlink" title="（六）、声卡和 PCM 设备的建立过程"></a>（六）、声卡和 PCM 设备的建立过程</h4><p>前面几章分析了 Codec、Platform、Machine 驱动的组成部分及其注册过程，这三者都是物理设备相关的，大家应该对音频物理链路有了一定的认知。接着分析音频驱动的中间层，由于这些并不是真正的物理设备，故我们称之为逻辑设备。</p><p>PCM 逻辑设备，我们又习惯称之为 PCM 中间层或 pcm native，起着承上启下的作用：往上是与用户态接口的交互，实现音频数据在用户态和内核态之间的拷贝；往下是触发 codec、platform、machine 的操作函数，实现音频数据在 dma_buffer &lt;-&gt; cpu_dai &lt;-&gt; codec 之间的传输。后面章节将会详细分析这个过程，这里还是先从声卡的注册谈起。<br>声卡驱动中，一般挂载着多个逻辑设备，看看我们计算机的声卡驱动有几个逻辑设备：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">adb shell cat /proc/asound/devices </span><br><span class="line">  2: [ 0]   : control</span><br><span class="line">  3: [ 0- 0]: digital audio playback</span><br><span class="line">  4: [ 0- 0]: digital audio capture</span><br><span class="line">  5: [ 0- 1]: digital audio playback</span><br><span class="line">  6: [ 0- 1]: digital audio capture</span><br><span class="line"> ......</span><br><span class="line"> 27: [ 0-16]: digital audio playback</span><br><span class="line"> 28: [ 0-16]: digital audio capture</span><br><span class="line"> 29: [ 0-17]: digital audio playback</span><br><span class="line"> 30: [ 0-17]: digital audio capture</span><br><span class="line"> 33:        : timer</span><br></pre></td></tr></table></figure><blockquote><p>digital audio playback    用于回放的 PCM 设备<br>digital audio capture    用于录制的 PCM 设备<br>control    用于声卡控制的 CTL 设备，如通路控制、音量调整等<br>timer    定时器设备<br>手机系统中，通常我们更关心 PCM 和 CTL 这两种设备。</p></blockquote><p>设备节点如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">adb shell ls -l /dev/snd</span><br><span class="line">crw-rw---- 1 system audio 116,  51 1970-06-19 02:07 comprC0D24</span><br><span class="line">crw-rw---- 1 system audio 116,  52 1970-06-19 02:07 comprC0D27</span><br><span class="line">crw-rw---- 1 system audio 116,  53 1970-06-19 02:07 comprC0D28</span><br><span class="line">......</span><br><span class="line">crw-rw---- 1 system audio 116,   2 1970-06-19 02:07 controlC0</span><br><span class="line">crw-rw---- 1 system audio 116,  59 1970-06-19 02:07 hwC0D1000</span><br><span class="line">crw-rw---- 1 system audio 116,  66 1970-06-19 02:07 hwC0D11</span><br><span class="line">crw-rw---- 1 system audio 116,  67 1970-06-19 02:07 hwC0D12</span><br><span class="line">crw-rw---- 1 system audio 116,  76 1970-06-19 02:07 hwC0D13</span><br><span class="line">......</span><br><span class="line">crw-rw---- 1 system audio 116,  13 1970-06-19 02:07 pcmC0D6c</span><br><span class="line">crw-rw---- 1 system audio 116,  14 1970-06-19 02:07 pcmC0D7p</span><br><span class="line">crw-rw---- 1 system audio 116,  15 1970-06-19 02:07 pcmC0D8c</span><br><span class="line">crw-rw---- 1 system audio 116,  33 1970-06-19 02:07 timer</span><br></pre></td></tr></table></figure><p>可以看到这些设备节点的 Major=116，Minor 则与 /proc/asound/devices 所列的对应起来，都是字符设备。上层可以通过 open/close/read/write/ioctl 等系统调用来操作声卡设备，这和其他字符设备类似，但一般情况下我们会使用已封装好的用户接口库如 tinyalsa、alsa-lib。</p><h5 id="6-1-声卡结构概述"><a href="#6-1-声卡结构概述" class="headerlink" title="6.1. 声卡结构概述"></a>6.1. 声卡结构概述</h5><p>回顾下 ASoC 是如何注册声卡的，详细请参考章节 5. ASoC machine driver，这里仅简单陈述下：</p><p>• Machine 驱动初始化时，.name = “soc-audio” 的 platform_device 与 platform_driver 匹配成功，触发 soc_probe() 调用；<br>• 继而调用 snd_soc_register_card()：<br>  ﹋• 为每个音频物理链路找到对应的 codec、codec_dai、cpu_dai、platform 设备实例，完成 dai_link 的绑定；<br>  ﹋ • 调用 snd_card_create() 创建声卡；<br>  ﹋ • 依次回调 cpu_dai、codec、platform 的 probe() 函数，完成物理设备的初始化；<br>• 随后调用 soc_new_pcm()：<br>  ﹋ • 设置 pcm native 中要使用的 pcm 操作函数，这些函数用于驱动音频物理设备，包括 machine、codec_dai、cpu_dai、platform；<br>  ﹋ • 调用 snd_pcm_new() 创建 pcm 逻辑设备，回放子流和录制子流都在这里创建；<br>  ﹋ • 回调 platform 驱动的 pcm_new()，完成音频 dma 设备初始化和 dma buffer 内存分配；<br>• 最后调用 snd_card_register() 注册声卡。<br>关于音频物理设备部分（Codec/Platform/Machine）不再累述，下面详细分析声卡和 PCM 逻辑设备的注册过程。</p><p>上面提到声卡驱动上挂着多个逻辑子设备，有 pcm 音频数据流、control 混音器、midi 迷笛、timer 定时器等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">                  +-----------+</span><br><span class="line">                  | snd_card  |</span><br><span class="line">                  +-----------+</span><br><span class="line">                    |   |   |</span><br><span class="line">        +-----------+   |   +------------+</span><br><span class="line">        |               |                |</span><br><span class="line">+-----------+    +-----------+    +-----------+</span><br><span class="line"> |  snd_pcm  |    |snd_control|    | snd_timer |    ...</span><br><span class="line"> +-----------+    +-----------+    +-----------+</span><br></pre></td></tr></table></figure><p>这些与声音相关的逻辑设备都在结构体 snd_card 管理之下，可以说 snd_card 是 alsa 中最顶层的结构。我们再看看 alsa 声卡驱动的大致结构图（不是严格的 UML 类图，有结构体定义、模块关系、函数调用，方便标示结构模块的层次及关系）：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/25-Audio-system-snd-card-uml.png" alt="Alt text"></p><p>snd_cards：记录着所注册的声卡实例，每个声卡实例有着各自的逻辑设备，如 PCM 设备、CTL 设备、MIDI 设备等，并一一记录到 snd_card 的 devices 链表上<br>snd_minors：记录着所有逻辑设备的上下文信息，它是声卡逻辑设备与系统调用 API 之间的桥梁；每个 snd_minor 在逻辑设备注册时被填充，在逻辑设备使用时就可以从该结构体中得到相应的信息（主要是系统调用函数集 file_operations）</p><h5 id="6-2-声卡的创建snd-card-create"><a href="#6-2-声卡的创建snd-card-create" class="headerlink" title="6.2. 声卡的创建snd_card_create()"></a>6.2. 声卡的创建snd_card_create()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;sound/core/init.c]</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  snd_card_new - create and initialize a soundcard structure</span></span><br><span class="line"><span class="comment"> *  @parent: the parent device object</span></span><br><span class="line"><span class="comment"> *  @idx: card index (address) [0 ... (SNDRV_CARDS-1)]</span></span><br><span class="line"><span class="comment"> *  @xid: card identification (ASCII string)</span></span><br><span class="line"><span class="comment"> *  @module: top level module for locking</span></span><br><span class="line"><span class="comment"> *  @extra_size: allocate this extra size after the main soundcard structure</span></span><br><span class="line"><span class="comment"> *  @card_ret: the pointer to store the created card instance</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Creates and initializes a soundcard structure.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  The function allocates snd_card instance via kzalloc with the given</span></span><br><span class="line"><span class="comment"> *  space for the driver to use freely.  The allocated struct is stored</span></span><br><span class="line"><span class="comment"> *  in the given card_ret pointer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Return: Zero if successful or a negative error code.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snd_card_new</span><span class="params">(struct device *parent, <span class="keyword">int</span> idx, <span class="keyword">const</span> <span class="keyword">char</span> *xid,</span></span></span><br><span class="line"><span class="function"><span class="params">    struct <span class="keyword">module</span> *<span class="keyword">module</span>, <span class="keyword">int</span> extra_size,</span></span></span><br><span class="line"><span class="function"><span class="params">    struct snd_card **card_ret)</span></span></span><br></pre></td></tr></table></figure><p>注释非常详细，简单说下：<br>idx：声卡的编号，如为 -1，则由系统自动分配<br>xid：声卡标识符，如为 NULL，则以 snd_card 的 shortname 或 longname 代替<br>card_ret：返回所创建的声卡实例的指针<br>如下是Google Pixel手机的声卡信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">adb shell</span><br><span class="line">sailfish:/ $ cat /proc/asound/cards</span><br><span class="line"> 0 [msm8996tashamar]: msm8996-tasha-m - msm8996-tasha-marlin-snd-card</span><br><span class="line">                      msm8996-tasha-marlin-snd-card</span><br></pre></td></tr></table></figure></p><h5 id="6-3-逻辑设备的创建"><a href="#6-3-逻辑设备的创建" class="headerlink" title="6.3. 逻辑设备的创建"></a>6.3. 逻辑设备的创建</h5><p>当声卡实例建立后，接着可以创建声卡下面的各个逻辑设备了。每个逻辑设备创建时，都会调用 snd_device_new() 生成一个 snd_device 实例，并把该实例挂到声卡 snd_card 的 devices 链表上。alsa 驱动为各种逻辑设备提供了创建接口，如下：</p><blockquote><p>PCM    snd_pcm_new()<br>CONTROL    snd_ctl_create()<br>MIDI    snd_rawmidi_new()<br>TIMER    snd_timer_new()<br>SEQUENCER    snd_seq_device_new()<br>JACK    snd_jack_new()</p></blockquote><p>这些接口的一般过程如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snd_xxx_new</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这些接口供逻辑设备注册时回调</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_device_ops</span> <span class="title">ops</span> = &#123;</span></span><br><span class="line">        .dev_free = snd_xxx_dev_free,</span><br><span class="line">        .dev_register = snd_xxx_dev_register,</span><br><span class="line">        .dev_disconnect = snd_xxx_dev_disconnect,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逻辑设备实例初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新建一个设备实例 snd_device，挂到 snd_card 的 devices 链表上，把该逻辑设备纳入声卡的管理当中，SNDRV_DEV_xxx 是逻辑设备的类型</span></span><br><span class="line">    <span class="keyword">return</span> snd_device_new(card, SNDRV_DEV_xxx, card, &amp;ops);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 snd_device_ops 是声卡逻辑设备的注册函数集，dev_register() 回调尤其重要，它在声卡注册时被调用，用于建立系统的设备节点，/dev/snd/ 目录的设备节点都是在这里创建的，通过这些设备节点可系统调用 open/release/read/write/ioctl… 访问操作该逻辑设备。</p><p>例如 snd_ctl_dev_register()：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/core/control.c]</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">snd_ctl_f_ops</span> =</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">.owner =THIS_MODULE,</span><br><span class="line">.read =snd_ctl_read,</span><br><span class="line">.open =snd_ctl_open,</span><br><span class="line">.release =snd_ctl_release,</span><br><span class="line">.llseek =no_llseek,</span><br><span class="line">.poll =snd_ctl_poll,</span><br><span class="line">.unlocked_ioctl =snd_ctl_ioctl,</span><br><span class="line">.compat_ioctl =snd_ctl_ioctl_compat,</span><br><span class="line">.fasync =snd_ctl_fasync,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * registration of the control device</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">snd_ctl_dev_register</span><span class="params">(struct snd_device *device)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_card</span> *<span class="title">card</span> = <span class="title">device</span>-&gt;<span class="title">device_data</span>;</span></span><br><span class="line"><span class="keyword">int</span> err, cardnum;</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (snd_BUG_ON(!card))</span><br><span class="line"><span class="keyword">return</span> -ENXIO;</span><br><span class="line">cardnum = card-&gt;number;</span><br><span class="line"><span class="keyword">if</span> (snd_BUG_ON(cardnum &lt; <span class="number">0</span> || cardnum &gt;= SNDRV_CARDS))</span><br><span class="line"><span class="keyword">return</span> -ENXIO;</span><br><span class="line"><span class="built_in">sprintf</span>(name, <span class="string">"controlC%i"</span>, cardnum);</span><br><span class="line"><span class="keyword">if</span> ((err = snd_register_device(SNDRV_DEVICE_TYPE_CONTROL, card, <span class="number">-1</span>,</span><br><span class="line">       &amp;snd_ctl_f_ops, card, name)) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实是调用 snd_register_device_for_dev ()：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/core/sound.c]</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snd_register_device_for_dev</span><span class="params">(<span class="keyword">int</span> type, struct snd_card *card, <span class="keyword">int</span> dev,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> struct file_operations *f_ops,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">void</span> *private_data,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="keyword">char</span> *name, struct device *device)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> minor;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_minor</span> *<span class="title">preg</span>;</span></span><br><span class="line">preg = kmalloc(<span class="keyword">sizeof</span> *preg, GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">preg-&gt;type = type;</span><br><span class="line">preg-&gt;card = card ? card-&gt;number : <span class="number">-1</span>;</span><br><span class="line">preg-&gt;device = dev;</span><br><span class="line">preg-&gt;f_ops = f_ops;</span><br><span class="line">preg-&gt;private_data = private_data;</span><br><span class="line">preg-&gt;card_ptr = card;</span><br><span class="line">mutex_lock(&amp;sound_mutex);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SND_DYNAMIC_MINORS</span></span><br><span class="line">minor = snd_find_free_minor(type);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">minor = snd_kernel_minor(type, card, dev);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">......</span><br><span class="line">snd_minors[minor] = preg;</span><br><span class="line">preg-&gt;dev = device_create(sound_class, device, MKDEV(major, minor),</span><br><span class="line">  private_data, <span class="string">"%s"</span>, name);</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">mutex_unlock(&amp;sound_mutex);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分配并初始化一个 snd_minor 实例；<br>保存该 snd_minor 实例到 snd_minors 数组中；<br>调用 device_create() 生成设备文件节点。</p><p>上面过程是声卡注册时才被回调的。</p><h5 id="6-4-声卡的注册"><a href="#6-4-声卡的注册" class="headerlink" title="6.4. 声卡的注册"></a>6.4. 声卡的注册</h5><p>当声卡下的所有逻辑设备都已经准备就绪后，就可以调用 snd_card_register() 注册声卡了：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/26-Audio-system-snd-card-register.png.png" alt="Alt text"></p><p>• 创建声卡的 sysfs 设备；<br>• 调用 snd_device_register_all() 注册所有挂在该声卡下的逻辑设备；<br>• 建立 proc 信息文件和 sysfs 属性文件。</p><h4 id="（七）、DAPM分析"><a href="#（七）、DAPM分析" class="headerlink" title="（七）、DAPM分析"></a>（七）、DAPM分析</h4><h5 id="7-1、DAPM简介"><a href="#7-1、DAPM简介" class="headerlink" title="7.1、DAPM简介"></a>7.1、DAPM简介</h5><p> DAPM是Dynamic Audio Power Management的缩写，直译过来就是动态音频电源管理的意思，DAPM是为了使基于linux的移动设备上的音频子系统，在任何时候都工作在最小功耗状态下。DAPM对用户空间的应用程序来说是透明的，所有与电源相关的开关都在ASoc core中完成。用户空间的应用程序无需对代码做出修改，也无需重新编译，DAPM根据当前激活的音频流（playback/capture）和声卡中的mixer等的配置来决定那些音频控件的电源开关被打开或关闭。</p><p>DAPM是基于kcontrol改进过后的相应框架，增加了相应的电源管理机制，其电源管理机制其实就是按照相应的音频路径，完美的对各种部件的电源进行控制，而且按照某种顺序进行。</p><h5 id="7-1、kcontrol"><a href="#7-1、kcontrol" class="headerlink" title="7.1、kcontrol"></a>7.1、kcontrol</h5><p>通常，一个kcontrol代表着一个mixer（混音器），或者是一个mux（多路开关），又或者是一个音量控制器等等。 从上述文章中我们知道，定义一个kcontrol主要就是定义一个snd_kcontrol_new 结构，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/include/sound/control.h]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_kcontrol_new</span> &#123;</span></span><br><span class="line"><span class="keyword">snd_ctl_elem_iface_t</span> iface;<span class="comment">/* interface identifier */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> device;<span class="comment">/* device/client number */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> subdevice;<span class="comment">/* subdevice (substream) number */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *name;<span class="comment">/* ASCII name of item */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> index;<span class="comment">/* index of item */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> access;<span class="comment">/* access rights */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> count;<span class="comment">/* count of same elements */</span></span><br><span class="line"><span class="keyword">snd_kcontrol_info_t</span> *info;</span><br><span class="line"><span class="keyword">snd_kcontrol_get_t</span> *get;</span><br><span class="line"><span class="keyword">snd_kcontrol_put_t</span> *put;</span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line"><span class="keyword">snd_kcontrol_tlv_rw_t</span> *c;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> *p;</span><br><span class="line">&#125; tlv;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> private_value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于每个控件，我们需要定义一个和他对应的snd_kcontrol_new结构，这些snd_kcontrol_new结构会在声卡的初始化阶段，通过snd_soc_dapm_new_controls()函数注册到系统中，用户空间就可以通过tinymix查看和设定这些控件的状态。<br>编译/external/tinyalsa/得到tinymix, tinyplay, tinycap，Push到手机执行tinymix可得到如下类似信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">990BOOL1QUAT_MI2S_RX Audio Mixer MultiMedia10    Off</span><br><span class="line">991BOOL1QUAT_MI2S_RX Audio Mixer MultiMedia11    Off</span><br><span class="line">992BOOL1QUAT_MI2S_RX Audio Mixer MultiMedia12    Off</span><br><span class="line">993BOOL1QUAT_MI2S_RX Audio Mixer MultiMedia13    Off</span><br><span class="line">994BOOL1QUAT_MI2S_RX Audio Mixer MultiMedia14    Off</span><br><span class="line">995BOOL1QUAT_MI2S_RX Audio Mixer MultiMedia15    Off</span><br><span class="line">996BOOL1QUAT_MI2S_RX Audio Mixer MultiMedia16    Off</span><br><span class="line">997BOOL1MI2S_RX Audio Mixer MultiMedia1          Off</span><br><span class="line">998BOOL1MI2S_RX Audio Mixer MultiMedia2          Off</span><br><span class="line">999BOOL1MI2S_RX Audio Mixer MultiMedia3          Off</span><br><span class="line">1000BOOL1MI2S_RX Audio Mixer MultiMedia4          Off</span><br><span class="line">1001BOOL1MI2S_RX Audio Mixer MultiMedia5          Off</span><br><span class="line">1002BOOL1MI2S_RX Audio Mixer MultiMedia6          Off</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>snd_kcontrol_new结构中，几个主要的字段是get，put，private_value，get回调函数用于获取该控件当前的状态值，而put回调函数则用于设置控件的状态值，而private_value字段则根据不同的控件类型有不同的意义，比如对于普通的控件，private_value字段可以用来定义该控件所对应的寄存器的地址以及对应的控制位在寄存器中的位置信息。值得庆幸的是，ASoc系统已经为我们准备了大量的宏定义，用于定义常用的控件，这些宏定义位于include/sound/soc.h中。下面我们分别讨论一下如何用这些预设的宏定义来定义一些常用的控件。</p><h5 id="7-1-1、简单型的控件"><a href="#7-1-1、简单型的控件" class="headerlink" title="7.1.1、简单型的控件"></a>7.1.1、简单型的控件</h5><p>SOC_SINGLE    SOC_SINGLE应该算是最简单的控件了，这种控件只有一个控制量，比如一个开关，或者是一个数值变量（比如Codec中某个频率，FIFO大小等等）。我们看看这个宏是如何定义的：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/include/sound/soc.h]</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOC_SINGLE(xname, reg, shift, max, invert) \</span></span><br><span class="line">&#123;.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \</span><br><span class="line">.info = snd_soc_info_volsw, .get = snd_soc_get_volsw,\</span><br><span class="line">.put = snd_soc_put_volsw, \</span><br><span class="line">.private_value = SOC_SINGLE_VALUE(reg, shift, max, invert, <span class="number">0</span>) &#125;</span><br></pre></td></tr></table></figure></p><p>宏定义的参数分别是：xname（该控件的名字），reg（该控件对应的寄存器的地址），shift（控制位在寄存器中的位移），max（控件可设置的最大值），invert（设定值是否逻辑取反）。这里又使用了一个宏来定义private_value字段：SOC_SINGLE_VALUE，我们看看它的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/include/sound/soc.h]</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOC_DOUBLE_VALUE(xreg, shift_left, shift_right, xmax, xinvert, xautodisable) \</span></span><br><span class="line">((<span class="keyword">unsigned</span> <span class="keyword">long</span>)&amp;(struct soc_mixer_control) \</span><br><span class="line">&#123;.reg = xreg, .rreg = xreg, .shift = shift_left, \</span><br><span class="line">.rshift = shift_right, .max = xmax, .platform_max = xmax, \</span><br><span class="line">.invert = xinvert, .autodisable = xautodisable&#125;)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOC_SINGLE_VALUE(xreg, xshift, xmax, xinvert, xautodisable) \</span></span><br><span class="line">SOC_DOUBLE_VALUE(xreg, xshift, xshift, xmax, xinvert, xautodisable)</span><br></pre></td></tr></table></figure><p>这里实际上是定义了一个soc_mixer_control结构，然后把该结构的地址赋值给了private_value字段，soc_mixer_control结构是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/include/sound/soc.h]</span><br><span class="line"><span class="comment">/* mixer control */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">soc_mixer_control</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> min, max, platform_max;</span><br><span class="line"><span class="keyword">int</span> reg, rreg;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> shift, rshift;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> sign_bit;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> invert:<span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> autodisable:<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看来soc_mixer_control是控件特征的真正描述者，它确定了该控件对应寄存器的地址，位移值，最大值和是否逻辑取反等特性，控件的put回调函数和get回调函数需要借助该结构来访问实际的寄存器。<br><strong>SOC_SINGLE_TLV</strong>    <strong>SOC_SINGLE_TLV</strong>是SOC_SINGLE的一种扩展，主要用于定义那些有增益控制的控件，例如音量控制器，EQ均衡器等等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/include/sound/soc.h]</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOC_SINGLE_TLV(xname, reg, shift, max, invert, tlv_array) \</span></span><br><span class="line">&#123;.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \</span><br><span class="line">.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ |\</span><br><span class="line"> SNDRV_CTL_ELEM_ACCESS_READWRITE,\</span><br><span class="line">.tlv.p = (tlv_array), \</span><br><span class="line">.info = snd_soc_info_volsw, .get = snd_soc_get_volsw,\</span><br><span class="line">.put = snd_soc_put_volsw, \</span><br><span class="line">.private_value = SOC_SINGLE_VALUE(reg, shift, max, invert, <span class="number">0</span>) &#125;</span><br></pre></td></tr></table></figure><p>从他的定义可以看出，用于设定寄存器信息的private_value字段的定义和SOC_SINGLE是一样的，甚至put、get回调函数也是使用同一套，唯一不同的是增加了一个tlv_array参数，并把它赋值给了tlv.p字段。用户空间可以通过对声卡的control设备发起以下两种ioctl来访问tlv字段所指向的数组：<br>  •  SNDRV_CTL_IOCTL_TLV_READ<br>  •  SNDRV_CTL_IOCTL_TLV_WRITE<br>  •  SNDRV_CTL_IOCTL_TLV_COMMAND</p><p>SOC_DOUBLE    与SOC_SINGLE相对应，区别是SOC_SINGLE只控制一个变量，而SOC_DOUBLE则可以同时在一个寄存器中控制两个相似的变量，最常用的就是用于一些立体声的控件，我们需要同时对左右声道进行控制，因为多了一个声道，参数也就相应地多了一个shift位移值</p><p>SOC_DOUBLE_R    与SOC_DOUBLE类似，对于左右声道的控制寄存器不一样的情况，使用SOC_DOUBLE_R来定义，参数中需要指定两个寄存器地址。<br>SOC_DOUBLE_TLV    与SOC_SINGLE_TLV对应的立体声版本，通常用于立体声音量控件的定义。</p><p>SOC_DOUBLE_R_TLV    左右声道有独立寄存器控制的SOC_DOUBLE_TLV版本</p><h5 id="7-1-2、Mixer控件"><a href="#7-1-2、Mixer控件" class="headerlink" title="7.1.2、Mixer控件"></a>7.1.2、Mixer控件</h5><p>Mixer控件用于音频通道的路由控制，由多个输入和一个输出组成，多个输入可以自由地混合在一起，形成混合后的输出：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/27-Audio-system-mixer-1525417497024.png" alt="Alt text"></p><p>对于Mixer控件，我们可以认为是多个简单控件的组合，通常，我们会为mixer的每个输入端都单独定义一个简单控件来控制该路输入的开启和关闭，反应在代码上，就是定义一个soc_kcontrol_new数组：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/codecs/wcd9335.c]</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_kcontrol_new</span> <span class="title">aif4_vi_mixer</span>[] = &#123;</span></span><br><span class="line">SOC_SINGLE_EXT(<span class="string">"SPKR_VI_1"</span>, SND_SOC_NOPM, TASHA_TX14, <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">tasha_vi_feed_mixer_get, tasha_vi_feed_mixer_put),</span><br><span class="line">SOC_SINGLE_EXT(<span class="string">"SPKR_VI_2"</span>, SND_SOC_NOPM, TASHA_TX15, <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">tasha_vi_feed_mixer_get, tasha_vi_feed_mixer_put),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="7-1-3、Mux控件"><a href="#7-1-3、Mux控件" class="headerlink" title="7.1.3、Mux控件"></a>7.1.3、Mux控件</h5><p>mux控件与mixer控件类似，也是多个输入端和一个输出端的组合控件，与mixer控件不同的是，mux控件的多个输入端同时只能有一个被选中。因此，mux控件所对应的寄存器，通常可以设定一段连续的数值，每个不同的数值对应不同的输入端被打开，与上述的mixer控件不同，ASoc用soc_enum结构来描述mux控件的寄存器信息：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/include/sound/soc.h]</span><br><span class="line"><span class="comment">/* enumerated kcontrol */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">soc_enum</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> reg;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> shift_l;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> shift_r;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> items;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> mask;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> *texts;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> *values;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>两个寄存器地址和位移字段：reg，reg2，shift_l，shift_r，用于描述左右声道的控制寄存器信息。字符串数组指针用于描述每个输入端对应的名字，value字段则指向一个数组，该数组定义了寄存器可以选择的值，每个值对应一个输入端，如果value是一组连续的值，通常我们可以忽略values参数。</p><h5 id="7-2、widget、path、route"><a href="#7-2、widget、path、route" class="headerlink" title="7.2、widget、path、route"></a>7.2、widget、path、route</h5><p>前面一节中，我们介绍了音频驱动中对基本控制单元的封装：kcontrol。利用kcontrol，我们可以完成对音频系统中的mixer，mux，音量控制，音效控制，以及各种开关量的控制，通过对各种kcontrol的控制，使得音频硬件能够按照我们预想的结果进行工作。同时我们可以看到，kcontrol还是有以下几点不足：<br>只能描述自身，无法描述各个kcontrol之间的连接关系；<br>没有相应的电源管理机制；<br>没有相应的时间处理机制来响应播放、停止、上电、下电等音频事件；<br>为了防止pop-pop声，需要用户程序关注各个kcontrol上电和下电的顺序；<br>当一个音频路径不再有效时，不能自动关闭该路径上的所有的kcontrol；<br>为此，DAPM框架正是为了要解决以上这些问题而诞生的，DAPM目前已经是ASoc中的重要组成部分，让我们先从DAPM的数据结构开始，了解它的设计思想和工作原理。</p><h5 id="7-2-1、DAPM的基本单元：widget"><a href="#7-2-1、DAPM的基本单元：widget" class="headerlink" title="7.2.1、DAPM的基本单元：widget"></a>7.2.1、DAPM的基本单元：widget</h5><p>文章的开头，我们说明了一下目前kcontrol的一些不足，而DAPM框架为了解决这些问题，引入了widget这一概念，所谓widget，其实可以理解为是kcontrol的进一步升级和封装，她同样是指音频系统中的某个部件，比如mixer，mux，输入输出引脚，电源供应器等等，甚至，我们可以定义虚拟的widget，例如playback stream widget。widget把kcontrol和动态电源管理进行了有机的结合，同时还具备音频路径的连结功能，一个widget可以与它相邻的widget有某种动态的连结关系。在DAPM框架中，widget用结构体snd_soc_dapm_widget来描述：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/include/sound/soc-dapm.h]</span><br><span class="line"><span class="comment">/* dapm widget */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_widget</span> &#123;</span></span><br><span class="line"><span class="keyword">enum</span> snd_soc_dapm_type id;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *name;<span class="comment">/* widget name */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *sname;<span class="comment">/* stream name */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_codec</span> *<span class="title">codec</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_context</span> *<span class="title">dapm</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *priv;<span class="comment">/* widget specific data */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">regulator</span> *<span class="title">regulator</span>;</span><span class="comment">/* attached regulator */</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_pcm_stream</span> *<span class="title">params</span>;</span> <span class="comment">/* params for dai links */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* dapm control */</span></span><br><span class="line"><span class="keyword">int</span> reg;<span class="comment">/* negative reg = no direct dapm */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> shift;<span class="comment">/* bits to shift */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> mask;<span class="comment">/* non-shifted mask */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> on_val;<span class="comment">/* on state value */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> off_val;<span class="comment">/* off state value */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> power:<span class="number">1</span>;<span class="comment">/* block power status */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> active:<span class="number">1</span>;<span class="comment">/* active stream on DAC, ADC's */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> connected:<span class="number">1</span>;<span class="comment">/* connected codec pin */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="keyword">new</span>:<span class="number">1</span>;<span class="comment">/* cnew complete */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> ext:<span class="number">1</span>;<span class="comment">/* has external widgets */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> force:<span class="number">1</span>;<span class="comment">/* force state */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> ignore_suspend:<span class="number">1</span>;         <span class="comment">/* kept enabled over suspend */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> new_power:<span class="number">1</span>;<span class="comment">/* power from this run */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> power_checked:<span class="number">1</span>;<span class="comment">/* power checked this run */</span></span><br><span class="line"><span class="keyword">int</span> subseq;<span class="comment">/* sort within widget type */</span></span><br><span class="line">......</span><br><span class="line"><span class="comment">/* widget input and outputs */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">sources</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">sinks</span>;</span></span><br><span class="line">......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>snd_soc_dapm_widget结构比较大，为了简洁一些，这里我没有列出该结构体的完整字段，不过不用担心，下面我会说明每个字段的意义：<br>id    该widget的类型值，比如snd_soc_dapm_output，snd_soc_dapm_mixer等等。</p><p>*name    该widget的名字</p><p>*sname    代表该widget所在stream的名字，比如对于snd_soc_dapm_dai_in类型的widget，会使用该字段。</p><p><em>codec </em>platform    指向该widget所属的codec和platform。</p><p>list    所有注册到系统中的widget都会通过该list，链接到代表声卡的snd_soc_card结构的widgets链表头字段中。</p><p>*dapm    snd_soc_dapm_context结构指针，ASoc把系统划分为多个dapm域，每个widget属于某个dapm域，同一个域代表着同样的偏置电压供电策略，比如，同一个codec中的widget通常位于同一个dapm域，而平台上的widget可能又会位于另外一个platform域中。</p><p>*priv    有些widget可能需要一些专有的数据，可以使用该字段来保存，像snd_soc_dapm_dai_in类型的widget，会使用该字段来记住与之相关联的snd_soc_dai结构指针。</p><p>*regulator    对于snd_soc_dapm_regulator_supply类型的widget，该字段指向与之相关的regulator结构指针。</p><p>*params    目前对于snd_soc_dapm_dai_link类型的widget，指向该dai的配置信息的snd_soc_pcm_stream结构。</p><p>reg shift mask     这3个字段用来控制该widget的电源状态，分别对应控制信息所在的寄存器地址，位移值和屏蔽值。</p><p>value  on_val  off_val    电源状态的当前只，开启时和关闭时所对应的值。</p><p>power invert    用于指示该widget当前是否处于上电状态，invert则用于表明power字段是否需要逻辑反转。</p><p>active connected    分别表示该widget是否处于激活状态和连接状态，当和相邻的widget有连接关系时，connected位会被置1，否则置0。</p><p>new   我们定义好的widget（snd_soc_dapm_widget结构），在注册到声卡中时需要进行实例化，该字段用来表示该widget是否已经被实例化。</p><p>ext    表示该widget当前是否有外部连接，比如连接mic，耳机，喇叭等等。</p><p>force    该位被设置后，将会不管widget当前的状态，强制更新至新的电源状态。</p><p>ignore_suspend new_power power_checked    这些电源管理相关的字段。</p><p>subseq    该widget目前在上电或下电队列中的排序编号，为了防止在上下电的过程中出现pop-pop声，DAPM会给每个widget分配合理的上下电顺序。</p><p>*power_check    用于检查该widget是否应该上电或下电的回调函数指针。<br>event_flags    该字段是一个位或字段，每个位代表该widget会关注某个DAPM事件通知。只有被关注的通知事件会被发送到widget的事件处理回调函数中。</p><p>*event    DAPM事件处理回调函数指针。</p><p>num_kcontrols <em>kcontrol_news *</em>kcontrols    这3个字段用来描述与该widget所包含的kcontrol控件，例如一个mixer控件或者是一个mux控件。</p><p>sources sinks    两个链表字段，两个widget如果有连接关系，会通过一个snd_soc_dapm_path结构进行连接，sources链表用于链接所有的输入path，sinks链表用于链接所有的输出path。</p><p>power_list    每次更新整个dapm的电源状态时，会根据一定的算法扫描所有的widget，然后把需要变更电源状态的widget利用该字段链接到一个上电或下电的链表中，扫描完毕后，dapm系统会遍历这两个链表执行相应的上电或下电操作。</p><p>dirty    链表字段，widget的状态变更后，dapm系统会利用该字段，把该widget加入到一个dirty链表中，稍后会对dirty链表进行扫描，以执行整个路径的更新。</p><p>inputs    该widget的所有有效路径中，连接到输入端的路径数量。</p><p>outputs    该widget的所有有效路径中，连接到输出端的路径数量。</p><p>*clk    对于snd_soc_dapm_clock_supply类型的widget，指向相关联的clk结构指针。</p><p>以上我们对snd_soc_dapm_widget结构的各个字段所代表的意义一一做出了说明，这里只是让大家现有个概念</p><h5 id="7-2-2、widget的种类"><a href="#7-2-2、widget的种类" class="headerlink" title="7.2.2、widget的种类"></a>7.2.2、widget的种类</h5><p>在DAPM框架中，把各种不同的widget划分为不同的种类，snd_soc_dapm_widget结构中的id字段用来表示该widget的种类，可选的种类都定义在一个枚举中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/include/sound/soc-dapm.h]</span><br><span class="line"><span class="comment">/* dapm widget types */</span></span><br><span class="line"><span class="keyword">enum</span> snd_soc_dapm_type &#123;</span><br><span class="line">snd_soc_dapm_input = <span class="number">0</span>,<span class="comment">/* input pin */</span></span><br><span class="line">snd_soc_dapm_output,<span class="comment">/* output pin */</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>下面我们逐个解释一下这些widget的种类：<br>snd_soc_dapm_input     该widget对应一个输入引脚。<br>snd_soc_dapm_output    该widget对应一个输出引脚。<br>snd_soc_dapm_mux    该widget对应一个mux控件。<br>snd_soc_dapm_virt_mux    该widget对应一个虚拟的mux控件。<br>snd_soc_dapm_value_mux    该widget对应一个value类型的mux控件。<br>snd_soc_dapm_mixer    该widget对应一个mixer控件。<br>snd_soc_dapm_mixer_named_ctl    该widget对应一个mixer控件，但是对应的kcontrol的名字不会加入widget的名字作为前缀。<br>snd_soc_dapm_pga    该widget对应一个pga控件（可编程增益控件）。<br>snd_soc_dapm_out_drv    该widget对应一个输出驱动控件<br>snd_soc_dapm_adc    该widget对应一个ADC<br>snd_soc_dapm_dac    该widget对应一个DAC<br>snd_soc_dapm_micbias    该widget对应一个麦克风偏置电压控件<br>snd_soc_dapm_mic    该widget对应一个麦克风。<br>snd_soc_dapm_hp    该widget对应一个耳机。<br>snd_soc_dapm_spk    该widget对应一个扬声器。<br>snd_soc_dapm_line     该widget对应一个线路输入。<br>snd_soc_dapm_switch       该widget对应一个模拟开关。<br>snd_soc_dapm_vmid      该widget对应一个codec的vmid偏置电压。<br>snd_soc_dapm_pre      machine级别的专用widget，会先于其它widget执行检查操作。<br>snd_soc_dapm_post    machine级别的专用widget，会后于其它widget执行检查操作。<br>snd_soc_dapm_supply           对应一个电源或是时钟源。<br>snd_soc_dapm_regulator_supply  对应一个外部regulator稳压器。<br>snd_soc_dapm_clock_supply      对应一个外部时钟源。<br>snd_soc_dapm_aif_in            对应一个数字音频输入接口，比如I2S接口的输入端。<br>snd_soc_dapm_aif_out          对应一个数字音频输出接口，比如I2S接口的输出端。<br>snd_soc_dapm_siggen            对应一个信号发生器。<br>snd_soc_dapm_dai_in           对应一个platform或codec域的输入DAI结构。<br>snd_soc_dapm_dai_out        对应一个platform或codec域的输出DAI结构。<br>snd_soc_dapm_dai_link         用于链接一对输入/输出DAI结构。</p><h5 id="7-2-3、widget之间的连接器：path"><a href="#7-2-3、widget之间的连接器：path" class="headerlink" title="7.2.3、widget之间的连接器：path"></a>7.2.3、widget之间的连接器：path</h5><p>之前已经提到，一个widget是有输入和输出的，而且widget之间是可以动态地进行连接的，那它们是用什么来连接两个widget的呢？DAPM为我们提出了path这一概念，path相当于电路中的一根跳线，它把一个widget的输出端和另一个widget的输入端连接在一起，path用snd_soc_dapm_path结构来描述：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/include/sound/soc-dapm.h]</span><br><span class="line"><span class="comment">/* dapm audio path between two widgets */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_path</span> &#123;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* source (input) and sink (output) widgets */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_widget</span> *<span class="title">source</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_widget</span> *<span class="title">sink</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* status */</span></span><br><span class="line">u32 connect:<span class="number">1</span>;<span class="comment">/* source and sink widgets are connected */</span></span><br><span class="line">u32 walked:<span class="number">1</span>;<span class="comment">/* path has been walked */</span></span><br><span class="line">u32 walking:<span class="number">1</span>;  <span class="comment">/* path is in the process of being walked */</span></span><br><span class="line">u32 weak:<span class="number">1</span>;<span class="comment">/* path ignored for power management */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> (*connected)(struct snd_soc_dapm_widget *source,</span><br><span class="line"> struct snd_soc_dapm_widget *sink);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list_source</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list_sink</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list_kcontrol</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当widget之间发生连接关系时，snd_soc_dapm_path作为连接者，它的source字段会指向该连接的起始端widget，而它的sink字段会指向该连接的到达端widget，还记得前面snd_soc_dapm_widget结构中的两个链表头字段：sources和sinks么？widget的输入端和输出端可能连接着多个path，所有输入端的snd_soc_dapm_path结构通过list_sink字段挂在widget的souces链表中，同样，所有输出端的snd_soc_dapm_path结构通过list_source字段挂在widget的sinks链表中。这里可能大家会被搞得晕呼呼的，一会source，一会sink，不要紧，只要记住，连接的路径是这样的：起始端widget的输出–&gt;path的输入–&gt;path的输出–&gt;到达端widget输入。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/28-Audio-system-snd_soc_dapm_path.png" alt="Alt text"><br>另外，snd_soc_dapm_path结构的list字段用于把所有的path注册到声卡中，其实就是挂在snd_soc_card结构的paths链表头字段中。如果你要自己定义方法来检查path的当前连接状态，你可以提供自己的connected回调函数指针。</p><p>connect，walked，walking，weak是几个辅助字段，用于帮助所有path的遍历。</p><h5 id="7-2-4、widget的连接关系：route"><a href="#7-2-4、widget的连接关系：route" class="headerlink" title="7.2.4、widget的连接关系：route"></a>7.2.4、widget的连接关系：route</h5><p>通过上一节的内容，我们知道，一个路径的连接至少包含以下几个元素：起始端widget，跳线path，到达端widget，在DAPM中，用snd_soc_dapm_route结构来描述这样一个连接关系：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/include/sound/soc-dapm.h]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_route</span> &#123;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *sink;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *control;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *source;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Note: currently only supported for links where source is a supply */</span></span><br><span class="line"><span class="keyword">int</span> (*connected)(struct snd_soc_dapm_widget *source,</span><br><span class="line"> struct snd_soc_dapm_widget *sink);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>sink指向到达端widget的名字字符串，source指向起始端widget的名字字符串，control指向负责控制该连接所对应的kcontrol名字字符串，connected回调则定义了上一节所提到的自定义连接检查回调函数。该结构的意义很明显就是：source通过一个kcontrol，和sink连接在一起，现在是否处于连接状态，请调用connected回调函数检查。<br>这里直接使用名字字符串来描述连接关系，所有定义好的route，最后都要注册到dapm系统中，dapm会根据这些名字找出相应的widget，并动态地生成所需要的snd_soc_dapm_path结构，正确地处理各个链表和指针的关系，实现两个widget之间的连接</p><h5 id="7-3、建立widget之间的连接关系"><a href="#7-3、建立widget之间的连接关系" class="headerlink" title="7.3、建立widget之间的连接关系"></a>7.3、建立widget之间的连接关系</h5><p>前面我们主要着重于codec、platform、machine驱动程序中如何使用和建立dapm所需要的widget，route，这些是音频驱动开发人员必须要了解的内容，经过前几章的介绍，我们应该知道如何在alsa音频驱动的3大部分（codec、platform、machine）中，按照所使用的音频硬件结构，定义出相应的widget，kcontrol，以及必要的音频路径，而在本节中，我们将会深入dapm的核心部分，看看各个widget之间是如何建立连接关系，形成一条完整的音频路径。</p><p>前面我们已经简单地介绍过，驱动程序需要使用以下api函数创建widget：</p><p>• snd_soc_dapm_new_controls()<br>实际上，这个函数只是创建widget的第一步，它为每个widget分配内存，初始化必要的字段，然后把这些widget挂在代表声卡的snd_soc_card的widgets链表字段中。要使widget之间具备连接能力，我们还需要第二个函数：<br>• snd_soc_dapm_new_widgets()<br>这个函数会根据widget的信息，创建widget所需要的dapm kcontrol，这些dapm kcontol的状态变化，代表着音频路径的变化，从而影响着各个widget的电源状态。看到函数的名称可能会迷惑一下，实际上，snd_soc_dapm_new_controls的作用更多地是创建widget，而snd_soc_dapm_new_widget的作用则更多地是创建widget所包含的kcontrol，所以在我看来，这两个函数名称应该换过来叫更好！下面我们分别介绍一下这两个函数是如何工作的。</p><h5 id="7-3-1、创建widget"><a href="#7-3-1、创建widget" class="headerlink" title="7.3.1、创建widget"></a>7.3.1、创建widget</h5><p>snd_soc_dapm_new_controls()函数完成widget的创建工作，并把这些创建好的widget注册在声卡的widgets链表中，我们看看他的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c]</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snd_soc_dapm_new_controls</span><span class="params">(struct snd_soc_dapm_context *dapm,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> struct snd_soc_dapm_widget *widget,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_widget</span> *<span class="title">w</span>;</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">mutex_lock_nested(&amp;dapm-&gt;card-&gt;dapm_mutex, SND_SOC_DAPM_CLASS_INIT);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">w = snd_soc_dapm_new_control(dapm, widget);</span><br><span class="line"><span class="keyword">if</span> (!w) &#123;</span><br><span class="line">dev_err(dapm-&gt;dev,</span><br><span class="line"><span class="string">"ASoC: Failed to create DAPM control %s\n"</span>,</span><br><span class="line">widget-&gt;name);</span><br><span class="line">ret = -ENOMEM;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">widget++;</span><br><span class="line">&#125;</span><br><span class="line">mutex_unlock(&amp;dapm-&gt;card-&gt;dapm_mutex);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数只是简单的一个循环，为传入的widget模板数组依次调用snd_soc_dapm_new_control函数，实际的工作由snd_soc_dapm_new_control完成，继续进入该函数，看看它做了那些工作。<br>我们之前已经说过，驱动中定义的snd_soc_dapm_widget数组，只是作为一个模板，所以，snd_soc_dapm_new_control所做的第一件事，就是为该widget重新分配内存，并把模板的内容拷贝过来：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c]</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_widget</span> *</span></span><br><span class="line"><span class="class"><span class="title">snd_soc_dapm_new_control</span>(<span class="title">struct</span> <span class="title">snd_soc_dapm_context</span> *<span class="title">dapm</span>,</span></span><br><span class="line"><span class="class"> <span class="title">const</span> <span class="title">struct</span> <span class="title">snd_soc_dapm_widget</span> *<span class="title">widget</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_widget</span> *<span class="title">w</span>;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *prefix;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((w = dapm_cnew_widget(widget)) == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//由dapm_cnew_widget完成内存申请和拷贝模板的动作。接下来，根据widget的类型做不同的处理：</span></span><br><span class="line"><span class="keyword">switch</span> (w-&gt;id) &#123;</span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_regulator_supply:</span><br><span class="line">......</span><br><span class="line">    &#125;</span><br><span class="line">prefix = soc_dapm_prefix(dapm);</span><br><span class="line"><span class="comment">//对于snd_soc_dapm_regulator_supply类型的widget，根据widget的名称获取对应的regulator结构，对于snd_soc_dapm_clock_supply类型的widget，根据widget的名称，获取对应的clock结构。接下来，根据需要，在widget的名称前加入必要的前缀：</span></span><br><span class="line"><span class="keyword">if</span> (prefix) &#123;</span><br><span class="line">w-&gt;name = kasprintf(GFP_KERNEL, <span class="string">"%s %s"</span>, prefix, widget-&gt;name);</span><br><span class="line"><span class="keyword">if</span> (widget-&gt;sname)</span><br><span class="line">w-&gt;sname = kasprintf(GFP_KERNEL, <span class="string">"%s %s"</span>, prefix,</span><br><span class="line">     widget-&gt;sname);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">w-&gt;name = kasprintf(GFP_KERNEL, <span class="string">"%s"</span>, widget-&gt;name);</span><br><span class="line"><span class="keyword">if</span> (widget-&gt;sname)</span><br><span class="line">w-&gt;sname = kasprintf(GFP_KERNEL, <span class="string">"%s"</span>, widget-&gt;sname);</span><br><span class="line">&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/29-Audio-system-widget-1525420992983.png" alt="Alt text"><br>当音频路径发生变化时，power_check回调会被调用，用于检查该widget的电源状态是否需要更新。power_check设置完成后，需要设置widget所属的codec、platform和dapm context，几个用于音频路径的链表也需要初始化，然后，把该widget加入到声卡的widgets链表中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c：snd_soc_dapm_new_control()</span><br><span class="line">w-&gt;dapm = dapm;  </span><br><span class="line">w-&gt;codec = dapm-&gt;codec;  </span><br><span class="line">w-&gt;platform = dapm-&gt;platform;  </span><br><span class="line">INIT_LIST_HEAD(&amp;w-&gt;sources);  </span><br><span class="line">INIT_LIST_HEAD(&amp;w-&gt;sinks);  </span><br><span class="line">INIT_LIST_HEAD(&amp;w-&gt;<span class="built_in">list</span>);  </span><br><span class="line">INIT_LIST_HEAD(&amp;w-&gt;dirty);  </span><br><span class="line">list_add(&amp;w-&gt;<span class="built_in">list</span>, &amp;dapm-&gt;card-&gt;widgets);</span><br></pre></td></tr></table></figure><p>几个链表的作用如下：<br>sources    用于链接所有连接到该widget输入端的snd_soc_path结构<br>sinks    用于链接所有连接到该widget输出端的snd_soc_path结构<br>list    用于链接到声卡的widgets链表<br>dirty    用于链接到声卡的dapm_dirty链表<br>最后，把widget设置为connect状态：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c：snd_soc_dapm_new_control()</span><br><span class="line"><span class="comment">/* machine layer set ups unconnected pins and insertions */</span>  </span><br><span class="line">w-&gt;connected = <span class="number">1</span>;  </span><br><span class="line"><span class="keyword">return</span> w;</span><br></pre></td></tr></table></figure><p>connected字段代表着引脚的连接状态，目前，只有以下这些widget使用connected字段：<br>snd_soc_dapm_output<br>snd_soc_dapm_input<br>snd_soc_dapm_hp<br>snd_soc_dapm_spk<br>snd_soc_dapm_line<br>snd_soc_dapm_vmid<br>snd_soc_dapm_mic<br>snd_soc_dapm_siggen<br>驱动程序可以使用以下这些api来设置引脚的连接状态：<br>snd_soc_dapm_enable_pin<br>snd_soc_dapm_force_enable_pin<br>snd_soc_dapm_disable_pin<br>snd_soc_dapm_nc_pin<br>到此，widget已经被正确地创建并初始化，而且被挂在声卡的widgets链表中，以后我们就可以通过声卡的widgets链表来遍历所有的widget，再次强调一下snd_soc_dapm_new_controls函数所完成的主要功能：<br>为widget分配内存，并拷贝参数中传入的在驱动中定义好的模板<br>设置power_check回调函数<br>把widget挂在声卡的widgets链表中</p><h5 id="7-3-2、为widget建立dapm-kcontrol"><a href="#7-3-2、为widget建立dapm-kcontrol" class="headerlink" title="7.3.2、为widget建立dapm kcontrol"></a>7.3.2、为widget建立dapm kcontrol</h5><p>定义一个widget，我们需要指定两个很重要的内容：一个是用于控制widget的电源状态的reg/shift等寄存器信息，另一个是用于控制音频路径切换的dapm kcontrol信息，这些dapm kcontrol有它们自己的reg/shift寄存器信息用于切换widget的路径连接方式。前一节的内容中，我们只是创建了widget的实例，并把它们注册到声卡的widgts链表中，但是到目前为止，包含在widget中的dapm kcontrol并没有建立起来，dapm框架在声卡的初始化阶段，等所有的widget（包括machine、platform、codec）都创建好之后，通过snd_soc_dapm_new_widgets函数，创建widget内包含的dapm kcontrol，并初始化widget的初始电源状态和音频路径的初始连接状态。我们看看声卡的初始化函数，都有那些初始化与dapm有关：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">snd_soc_instantiate_card</span><span class="params">(struct snd_soc_card *card)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">        ......  </span><br><span class="line">        <span class="comment">/* card bind complete so register a sound card */</span>  </span><br><span class="line">        ret = snd_card_create(SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1,  </span><br><span class="line">                        card-&gt;owner, <span class="number">0</span>, &amp;card-&gt;snd_card);  </span><br><span class="line">        ......  </span><br><span class="line">   </span><br><span class="line">        card-&gt;dapm.bias_level = SND_SOC_BIAS_OFF;  </span><br><span class="line">        card-&gt;dapm.dev = card-&gt;dev;  </span><br><span class="line">        card-&gt;dapm.card = card;  </span><br><span class="line">        list_add(&amp;card-&gt;dapm.<span class="built_in">list</span>, &amp;card-&gt;dapm_list);  </span><br><span class="line">        ......  </span><br><span class="line">        <span class="keyword">if</span> (card-&gt;dapm_widgets)    <span class="comment">/* 创建machine级别的widget  */</span>  </span><br><span class="line">                snd_soc_dapm_new_controls(&amp;card-&gt;dapm, card-&gt;dapm_widgets,  </span><br><span class="line">                                          card-&gt;num_dapm_widgets);  </span><br><span class="line">        ......  </span><br><span class="line">        snd_soc_dapm_link_dai_widgets(card);  <span class="comment">/*  连接dai widget  */</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (card-&gt;controls)    <span class="comment">/*  建立machine级别的普通kcontrol控件  */</span>  </span><br><span class="line">                snd_soc_add_card_controls(card, card-&gt;controls, card-&gt;num_controls);  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (card-&gt;dapm_routes)    <span class="comment">/*  注册machine级别的路径连接信息  */</span>  </span><br><span class="line">                snd_soc_dapm_add_routes(&amp;card-&gt;dapm, card-&gt;dapm_routes,  </span><br><span class="line">                                        card-&gt;num_dapm_routes);  </span><br><span class="line">        ......  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (card-&gt;fully_routed)    <span class="comment">/*  如果该标志被置位，自动把codec中没有路径连接信息的引脚设置为无用widget  */</span>  </span><br><span class="line">                list_for_each_entry(codec, &amp;card-&gt;codec_dev_list, card_list)  </span><br><span class="line">                        snd_soc_dapm_auto_nc_codec_pins(codec);  </span><br><span class="line">  </span><br><span class="line">        snd_soc_dapm_new_widgets(card);    <span class="comment">/*初始化widget包含的dapm kcontrol、电源状态和连接状态*/</span>  </span><br><span class="line">  </span><br><span class="line">        ret = snd_card_register(card-&gt;snd_card);  </span><br><span class="line">        ......  </span><br><span class="line">        card-&gt;instantiated = <span class="number">1</span>;  </span><br><span class="line">        snd_soc_dapm_sync(&amp;card-&gt;dapm);  </span><br><span class="line">        ......  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如我添加的注释中所示，在完成machine级别的widget和route处理之后，调用的snd_soc_dapm_new_widgets函数，来为所有已经注册的widget初始化他们所包含的dapm kcontrol，并初始化widget的电源状态和路径连接状态。下面我们看看snd_soc_dapm_new_widgets函数的工作过程。</p><h5 id="7-3-2-1、snd-soc-dapm-new-widgets函数"><a href="#7-3-2-1、snd-soc-dapm-new-widgets函数" class="headerlink" title="7.3.2.1、snd_soc_dapm_new_widgets函数"></a>7.3.2.1、snd_soc_dapm_new_widgets函数</h5><p>该函数通过声卡的widgets链表，遍历所有已经注册了的widget，其中的new字段用于判断该widget是否已经执行过snd_soc_dapm_new_widgets函数，如果num_kcontrols字段有数值，表明该widget包含有若干个dapm kcontrol，那么就需要为这些kcontrol分配一个指针数组，并把数组的首地址赋值给widget的kcontrols字段，该数组存放着指向这些kcontrol的指针，当然现在这些都是空指针，因为实际的kcontrol现在还没有被创建：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c]</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snd_soc_dapm_new_widgets</span><span class="params">(struct snd_soc_card *card)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">        ......  </span><br><span class="line">        list_for_each_entry(w, &amp;card-&gt;widgets, <span class="built_in">list</span>)  </span><br><span class="line">        &#123;                 </span><br><span class="line">                <span class="keyword">if</span> (w-&gt;<span class="keyword">new</span>) <span class="keyword">continue</span>;  </span><br><span class="line">                                  </span><br><span class="line">                <span class="keyword">if</span> (w-&gt;num_kcontrols) &#123;  </span><br><span class="line">                        w-&gt;kcontrols = kzalloc(w-&gt;num_kcontrols *  </span><br><span class="line">                                                <span class="keyword">sizeof</span>(struct snd_kcontrol *),  </span><br><span class="line">                                                GFP_KERNEL);  </span><br><span class="line">                        ......  </span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure><p>接着，对几种能影响音频路径的widget，创建并初始化它们所包含的dapm kcontrol：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c:snd_soc_dapm_new_widgets()]</span><br><span class="line"><span class="keyword">switch</span>(w-&gt;id) &#123;  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_switch:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_mixer:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_mixer_named_ctl:  </span><br><span class="line">        dapm_new_mixer(w);  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_mux:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_virt_mux:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_value_mux:  </span><br><span class="line">        dapm_new_mux(w);  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_pga:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_out_drv:  </span><br><span class="line">        dapm_new_pga(w);  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line"><span class="keyword">default</span>:  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要用到的创建函数分别是：<br>dapm_new_mixer()    对于mixer类型，用该函数创建dapm kcontrol；<br>dapm_new_mux()   对于mux类型，用该函数创建dapm kcontrol；<br>dapm_new_pga()   对于pga类型，用该函数创建dapm kcontrol；<br>然后，根据widget寄存器的当前值，初始化widget的电源状态，并设置到power字段中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c:snd_soc_dapm_new_widgets()]</span><br><span class="line"><span class="comment">/* Read the initial power state from the device */</span>  </span><br><span class="line"><span class="keyword">if</span> (w-&gt;reg &gt;= <span class="number">0</span>) &#123;  </span><br><span class="line">        val = soc_widget_read(w, w-&gt;reg) &gt;&gt; w-&gt;shift;  </span><br><span class="line">        val &amp;= w-&gt;mask;  </span><br><span class="line">        <span class="keyword">if</span> (val == w-&gt;on_val)  </span><br><span class="line">                w-&gt;power = <span class="number">1</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，设置new字段，表明该widget已经初始化完成，我们还要吧该widget加入到声卡的dapm_dirty链表中，表明该widget的状态发生了变化，稍后在合适的时刻，dapm框架会扫描dapm_dirty链表，统一处理所有已经变化的widget。为什么要统一处理？因为dapm要控制各种widget的上下电顺序，同时也是为了减少寄存器的读写次数（多个widget可能使用同一个寄存器）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c:snd_soc_dapm_new_widgets()]</span><br><span class="line">w-&gt;<span class="keyword">new</span> = <span class="number">1</span>;  </span><br><span class="line">  </span><br><span class="line">dapm_mark_dirty(w, <span class="string">"new widget"</span>);  </span><br><span class="line">dapm_debugfs_add_widget(w);</span><br></pre></td></tr></table></figure><p>最后，通过dapm_power_widgets函数，统一处理所有位于dapm_dirty链表上的widget的状态改变：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c:snd_soc_dapm_new_widgets()]</span><br><span class="line">dapm_power_widgets(card, SND_SOC_DAPM_STREAM_NOP);  </span><br><span class="line">......  </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h5 id="7-3-2-2、dapm-mixer-kcontrol"><a href="#7-3-2-2、dapm-mixer-kcontrol" class="headerlink" title="7.3.2.2、dapm mixer kcontrol"></a>7.3.2.2、dapm mixer kcontrol</h5><p>上一节中，我们提到，对于mixer类型的dapm kcontrol，我们会使用dapm_new_mixer来完成具体的创建工作，先看代码后分析：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dapm_new_mixer</span><span class="params">(struct snd_soc_dapm_widget *w)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> i, ret;  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_path</span> *<span class="title">path</span>;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">/* add kcontrol */</span>  </span><br><span class="line">（<span class="number">1</span>）        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; w-&gt;num_kcontrols; i++) &#123;                                  </span><br><span class="line">                <span class="comment">/* match name */</span>  </span><br><span class="line">（<span class="number">2</span>）                list_for_each_entry(path, &amp;w-&gt;sources, list_sink) &#123;               </span><br><span class="line">                        <span class="comment">/* mixer/mux paths name must match control name */</span>  </span><br><span class="line">（<span class="number">3</span>）                        <span class="keyword">if</span> (path-&gt;name != (<span class="keyword">char</span> *)w-&gt;kcontrol_news[i].name)       </span><br><span class="line">                                <span class="keyword">continue</span>;  </span><br><span class="line">  </span><br><span class="line">（<span class="number">4</span>）                        <span class="keyword">if</span> (w-&gt;kcontrols[i]) &#123;                                   </span><br><span class="line">                                dapm_kcontrol_add_path(w-&gt;kcontrols[i], path);  </span><br><span class="line">                                <span class="keyword">continue</span>;  </span><br><span class="line">                        &#125;  </span><br><span class="line">  </span><br><span class="line">（<span class="number">5</span>）                        ret = dapm_create_or_share_mixmux_kcontrol(w, i);        </span><br><span class="line">                        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)  </span><br><span class="line">                                <span class="keyword">return</span> ret;  </span><br><span class="line">  </span><br><span class="line">（<span class="number">6</span>）                        dapm_kcontrol_add_path(w-&gt;kcontrols[i], path);           </span><br><span class="line">                &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（1）  因为一个mixer是由多个kcontrol组成的，每个kcontrol控制着mixer的一个输入端的开启和关闭，所以，该函数会根据kcontrol的数量做循环，逐个建立对应的kcontrol。<br>（2）（3）  之前多次提到，widget之间使用snd_soc_path进行连接，widget的sources链表保存着所有和输入端连接的snd_soc_path结构，所以我们可以用kcontrol模板中指定的名字来匹配对应的snd_soc_path结构。<br>（4）  因为一个输入脚可能会连接多个输入源，所以可能在上一个输入源的path关联时已经创建了这个kcontrol，所以这里判断kcontrols指针数组中对应索引中的指针值，如果已经赋值，说明kcontrol已经在之前创建好了，所以我们只要简单地把连接该输入端的path加入到kcontrol的path_list链表中，并且增加一个虚拟的影子widget，该影子widget连接和输入端对应的源widget，因为使用了kcontrol本身的reg/shift等寄存器信息，所以实际上控制的是该kcontrol的开和关，这个影子widget只有在kcontrol的autodisable字段被设置的情况下才会被创建，该特性使得source的关闭时，与之连接的mixer的输入端也可以自动关闭，这个特性通过dapm_kcontrol_add_path来实现这一点：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dapm_kcontrol_add_path</span><span class="params">(<span class="keyword">const</span> struct snd_kcontrol *kcontrol,  </span></span></span><br><span class="line"><span class="function"><span class="params">        struct snd_soc_dapm_path *path)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dapm_kcontrol_data</span> *<span class="title">data</span> = <span class="title">snd_kcontrol_chip</span>(<span class="title">kcontrol</span>);</span>  </span><br><span class="line">        <span class="comment">/*  把kcontrol连接的path加入到paths链表中  */</span>  </span><br><span class="line">        <span class="comment">/*  paths链表所在的dapm_kcontrol_data结构会保存在kcontrol的private_data字段中  */</span>  </span><br><span class="line">        list_add_tail(&amp;path-&gt;list_kcontrol, &amp;data-&gt;paths);  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (data-&gt;widget) &#123;  </span><br><span class="line">                snd_soc_dapm_add_path(data-&gt;widget-&gt;dapm, data-&gt;widget,  </span><br><span class="line">                    path-&gt;source, <span class="literal">NULL</span>, <span class="literal">NULL</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（5）  如果kcontrol之前没有被创建，则通过dapm_create_or_share_mixmux_kcontrol创建这个输入端的kcontrol，同理，kcontrol对应的影子widget也会通过dapm_kcontrol_add_path判断是否需要创建。</p><h5 id="7-3-2-3、dapm-mux-kcontrol"><a href="#7-3-2-3、dapm-mux-kcontrol" class="headerlink" title="7.3.2.3、dapm mux kcontrol"></a>7.3.2.3、dapm mux kcontrol</h5><p>因为一个widget最多只会包含一个mux类型的damp kcontrol，所以他的创建方法稍有不同，dapm框架使用dapm_new_mux函数来创建mux类型的dapm kcontrol：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dapm_new_mux</span><span class="params">(struct snd_soc_dapm_widget *w)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;         </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_context</span> *<span class="title">dapm</span> = <span class="title">w</span>-&gt;<span class="title">dapm</span>;</span>  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_path</span> *<span class="title">path</span>;</span>  </span><br><span class="line">        <span class="keyword">int</span> ret;  </span><br><span class="line">          </span><br><span class="line">(<span class="number">1</span>)     <span class="keyword">if</span> (w-&gt;num_kcontrols != <span class="number">1</span>) &#123;  </span><br><span class="line">                dev_err(dapm-&gt;dev,  </span><br><span class="line">                        <span class="string">"ASoC: mux %s has incorrect number of controls\n"</span>,  </span><br><span class="line">                        w-&gt;name);  </span><br><span class="line">                <span class="keyword">return</span> -EINVAL;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (list_empty(&amp;w-&gt;sources)) &#123;  </span><br><span class="line">                dev_err(dapm-&gt;dev, <span class="string">"ASoC: mux %s has no paths\n"</span>, w-&gt;name);  </span><br><span class="line">                <span class="keyword">return</span> -EINVAL;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">(<span class="number">2</span>)     ret = dapm_create_or_share_mixmux_kcontrol(w, <span class="number">0</span>);  </span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)  </span><br><span class="line">                <span class="keyword">return</span> ret;  </span><br><span class="line">(<span class="number">3</span>)       list_for_each_entry(path, &amp;w-&gt;sources, list_sink)  </span><br><span class="line">                dapm_kcontrol_add_path(w-&gt;kcontrols[<span class="number">0</span>], path);  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（1）  对于mux类型的widget，因为只会有一个kcontrol，所以在这里做一下判断。<br>（2）  同样地，和mixer类型一样，也使用dapm_create_or_share_mixmux_kcontrol来创建这个kcontrol。<br>（3）  对每个输入端所连接的path都加入dapm_kcontrol_data结构的paths链表中，并且创建一个影子widget，用于支持autodisable特性。</p><h5 id="7-3-2-4、dapm-pga-kcontrol"><a href="#7-3-2-4、dapm-pga-kcontrol" class="headerlink" title="7.3.2.4、dapm pga kcontrol"></a>7.3.2.4、dapm pga kcontrol</h5><p>目前对于pga类型的widget，kcontrol的创建函数是个空函数，所以我们不用太关注它：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dapm_new_pga</span><span class="params">(struct snd_soc_dapm_widget *w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (w-&gt;num_kcontrols)</span><br><span class="line">dev_err(w-&gt;dapm-&gt;dev,</span><br><span class="line"><span class="string">"ASoC: PGA controls not supported: '%s'\n"</span>, w-&gt;name);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dapm_create_or_share_mixmux_kcontrol函数<br>上面所说的mixer类型和mux类型的widget，在创建他们所包含的dapm kcontrol时，最后其实都是使用了dapm_create_or_share_mixmux_kcontrol函数来完成创建工作的，所以在这里我们有必要分析一下这个函数的工作原理。这个函数中有很大一部分代码实在处理kcontrol的名字是否要加入codec的前缀，我们会忽略这部分的代码，感兴趣的读者可以自己查看内核的代码，路径在：sound/soc/soc-dapm.c中，简化后的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dapm_create_or_share_mixmux_kcontrol</span><span class="params">(struct snd_soc_dapm_widget *w,  </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> kci)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">          ......  </span><br><span class="line">(<span class="number">1</span>)       shared = dapm_is_shared_kcontrol(dapm, w, &amp;w-&gt;kcontrol_news[kci],  </span><br><span class="line">                                         &amp;kcontrol);  </span><br><span class="line">     </span><br><span class="line">(<span class="number">2</span>)       <span class="keyword">if</span> (!kcontrol) &#123;  </span><br><span class="line">(<span class="number">3</span>)            kcontrol = snd_soc_cnew(&amp;w-&gt;kcontrol_news[kci], <span class="literal">NULL</span>, name,prefix）;  </span><br><span class="line">               ......  </span><br><span class="line">               kcontrol-&gt;private_free = dapm_kcontrol_free;  </span><br><span class="line">(<span class="number">4</span>)            ret = dapm_kcontrol_data_alloc(w, kcontrol);  </span><br><span class="line">                ......  </span><br><span class="line">(<span class="number">5</span>)            ret = snd_ctl_add(card, kcontrol);  </span><br><span class="line">                ......  </span><br><span class="line">        &#125;  </span><br><span class="line">(<span class="number">6</span>)     ret = dapm_kcontrol_add_widget(kcontrol, w);  </span><br><span class="line">        ......  </span><br><span class="line">(<span class="number">7</span>)     w-&gt;kcontrols[kci] = kcontrol;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（1）  为了节省内存，通过kcontrol名字的匹配查找，如果这个kcontrol已经在其他widget中已经创建好了，那我们不再创建，dapm_is_shared_kcontrol的参数kcontrol会返回已经创建好的kcontrol的指针。<br>（2）  如果kcontrol指针被赋值，说明在（1）中查找到了其他widget中同名的kcontrol，我们不用再次创建，只要共享该kcontrol即可。<br>（3）  标准的kcontrol创建函数，<br>（4）  如果widget支持autodisable特性，创建与该kcontrol所对应的影子widget，该影子widget的类型是：snd_soc_dapm_kcontrol。<br>（5）  标准的kcontrol创建函数，<br>（6）  把所有共享该kcontrol的影子widget（snd_soc_dapm_kcontrol），加入到kcontrol的private_data字段所指向的dapm_kcontrol_data结构中。<br>（7）  把创建好的kcontrol指针赋值到widget的kcontrols数组中。<br>需要注意的是，如果kcontol支持autodisable特性，一旦kcontrol由于source的关闭而被自动关闭，则用户空间只能操作该kcontrol的cache值，只有该kcontrol再次打开时，该cache值才会被真正地更新到寄存器中。<br>现在。我们总结一下，创建一个widget所包含的kcontrol所做的工作：<br>• 循环每一个输入端，为每个输入端依次执行下面的一系列操作<br>• 为每个输入端创建一个kcontrol，能共享的则直接使用创建好的kcontrol<br>• kcontrol的private_data字段保存着这些共享widget的信息<br>• 如果支持autodisable特性，每个输入端还要额外地创建一个虚拟的snd_soc_dapm_kcontrol类型的影子widget，该影子widget也记录在private_data字段中<br>• 创建好的kcontrol会依次存放在widget的kcontrols数组中，供路径的控制和匹配之用。</p><h5 id="7-3-2-5、为widget建立连接关系"><a href="#7-3-2-5、为widget建立连接关系" class="headerlink" title="7.3.2.5、为widget建立连接关系"></a>7.3.2.5、为widget建立连接关系</h5><p>如果widget之间没有连接关系，dapm就无法实现动态的电源管理工作，正是widget之间有了连结关系，这些连接关系形成了一条所谓的完成的音频路径，dapm可以顺着这条路径，统一控制路径上所有widget的电源状态，前面我们已经知道，widget之间是使用snd_soc_path结构进行连接的，驱动要做的是定义一个snd_soc_route结构数组，该数组的每个条目描述了目的widget的和源widget的名称，以及控制这个连接的kcontrol的名称，最终，驱动程序使用api函数snd_soc_dapm_add_routes来注册这些连接信息，接下来我们就是要分析该函数的具体实现方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c]</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snd_soc_dapm_add_routes</span><span class="params">(struct snd_soc_dapm_context *dapm,  </span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">const</span> struct snd_soc_dapm_route *route, <span class="keyword">int</span> num)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> i, r, ret = <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">        mutex_lock_nested(&amp;dapm-&gt;card-&gt;dapm_mutex, SND_SOC_DAPM_CLASS_INIT);  </span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++) &#123;  </span><br><span class="line">                r = snd_soc_dapm_add_route(dapm, route);  </span><br><span class="line">                ......  </span><br><span class="line">                route++;  </span><br><span class="line">        &#125;  </span><br><span class="line">        mutex_unlock(&amp;dapm-&gt;card-&gt;dapm_mutex);  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> ret;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数只是一个循环，依次对参数传入的数组调用snd_soc_dapm_add_route，主要的工作由snd_soc_dapm_add_route完成。我们进入snd_soc_dapm_add_route函数看看：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">snd_soc_dapm_add_route</span><span class="params">(struct snd_soc_dapm_context *dapm,  </span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">const</span> struct snd_soc_dapm_route *route)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_widget</span> *<span class="title">wsource</span> = <span class="title">NULL</span>, *<span class="title">wsink</span> = <span class="title">NULL</span>, *<span class="title">w</span>;</span>  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_widget</span> *<span class="title">wtsource</span> = <span class="title">NULL</span>, *<span class="title">wtsink</span> = <span class="title">NULL</span>;</span>  </span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *sink;  </span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *source;  </span><br><span class="line">        ......  </span><br><span class="line">        list_for_each_entry(w, &amp;dapm-&gt;card-&gt;widgets, <span class="built_in">list</span>) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (!wsink &amp;&amp; !(<span class="built_in">strcmp</span>(w-&gt;name, sink))) &#123;  </span><br><span class="line">                        wtsink = w;  </span><br><span class="line">                        <span class="keyword">if</span> (w-&gt;dapm == dapm)  </span><br><span class="line">                                wsink = w;  </span><br><span class="line">                        <span class="keyword">continue</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">if</span> (!wsource &amp;&amp; !(<span class="built_in">strcmp</span>(w-&gt;name, source))) &#123;  </span><br><span class="line">                        wtsource = w;  </span><br><span class="line">                        <span class="keyword">if</span> (w-&gt;dapm == dapm)  </span><br><span class="line">                                wsource = w;  </span><br><span class="line">                &#125;  </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>上面的代码我再次省略了关于名称前缀的处理部分。我们可以看到，用widget的名字来比较，遍历声卡的widgets链表，找出源widget和目的widget的指针，这段代码虽然正确，但我总感觉少了一个判断退出循环的条件，如果链表的开头就找到了两个widget，还是要遍历整个链表才结束循环，好浪费时间。<br>下面，如果在本dapm context中没有找到，则使用别的dapm context中找到的widget：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c:snd_soc_dapm_add_route()]</span><br><span class="line"><span class="keyword">if</span> (!wsink)  </span><br><span class="line">        wsink = wtsink;  </span><br><span class="line"><span class="keyword">if</span> (!wsource)  </span><br><span class="line">        wsource = wtsource;</span><br></pre></td></tr></table></figure><p>最后，使用来增加一条连接信息：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c:snd_soc_dapm_add_route()]</span><br><span class="line">        ret = snd_soc_dapm_add_path(dapm, wsource, wsink, route-&gt;control,  </span><br><span class="line">                route-&gt;connected);  </span><br><span class="line">        ......  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>snd_soc_dapm_add_path函数是整个调用链条中的关键，我们来分析一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">snd_soc_dapm_add_path</span><span class="params">(struct snd_soc_dapm_context *dapm,  </span></span></span><br><span class="line"><span class="function"><span class="params">        struct snd_soc_dapm_widget *wsource, struct snd_soc_dapm_widget *wsink,  </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">char</span> *control,  </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> (*connected)</span><span class="params">(struct snd_soc_dapm_widget *source,  </span></span></span><br><span class="line">                         struct snd_soc_dapm_widget *sink))  </span><br><span class="line">&#123;  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_path</span> *<span class="title">path</span>;</span>  </span><br><span class="line">        <span class="keyword">int</span> ret;  </span><br><span class="line">  </span><br><span class="line">        path = kzalloc(<span class="keyword">sizeof</span>(struct snd_soc_dapm_path), GFP_KERNEL);  </span><br><span class="line">        <span class="keyword">if</span> (!path)  </span><br><span class="line">                <span class="keyword">return</span> -ENOMEM;  </span><br><span class="line">  </span><br><span class="line">        path-&gt;source = wsource;  </span><br><span class="line">        path-&gt;sink = wsink;  </span><br><span class="line">        path-&gt;connected = connected;  </span><br><span class="line">        INIT_LIST_HEAD(&amp;path-&gt;<span class="built_in">list</span>);  </span><br><span class="line">        INIT_LIST_HEAD(&amp;path-&gt;list_kcontrol);  </span><br><span class="line">        INIT_LIST_HEAD(&amp;path-&gt;list_source);  </span><br><span class="line">        INIT_LIST_HEAD(&amp;path-&gt;list_sink);</span><br></pre></td></tr></table></figure><p>函数的一开始，首先为这个连接分配了一个snd_soc_path结构，path的source和sink字段分别指向源widget和目的widget，connected字段保存connected回调函数，初始化几个snd_soc_path结构中的几个链表。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c:snd_soc_dapm_add_path()]</span><br><span class="line"><span class="comment">/* check for external widgets */</span>  </span><br><span class="line">        <span class="keyword">if</span> (wsink-&gt;id == snd_soc_dapm_input) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (wsource-&gt;id == snd_soc_dapm_micbias ||  </span><br><span class="line">                        wsource-&gt;id == snd_soc_dapm_mic ||  </span><br><span class="line">                        wsource-&gt;id == snd_soc_dapm_line ||  </span><br><span class="line">                        wsource-&gt;id == snd_soc_dapm_output)  </span><br><span class="line">                        wsink-&gt;ext = <span class="number">1</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (wsource-&gt;id == snd_soc_dapm_output) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (wsink-&gt;id == snd_soc_dapm_spk ||  </span><br><span class="line">                        wsink-&gt;id == snd_soc_dapm_hp ||  </span><br><span class="line">                        wsink-&gt;id == snd_soc_dapm_line ||  </span><br><span class="line">                        wsink-&gt;id == snd_soc_dapm_input)  </span><br><span class="line">                        wsource-&gt;ext = <span class="number">1</span>;  </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>这段代码用于判断是否有外部连接关系，如果有，置位widget的ext字段。判断方法从代码中可以方便地看出：<br>目的widget是一个输入脚，如果源widget是mic、line、micbias或output，则认为目的widget具有外部连接关系。<br>源widget是一个输出脚，如果目的widget是spk、hp、line或input，则认为源widget具有外部连接关系。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c:snd_soc_dapm_add_path()]</span><br><span class="line">dapm_mark_dirty(wsource, <span class="string">"Route added"</span>);  </span><br><span class="line">dapm_mark_dirty(wsink, <span class="string">"Route added"</span>);  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/* connect static paths */</span>  </span><br><span class="line"><span class="keyword">if</span> (control == <span class="literal">NULL</span>) &#123;  </span><br><span class="line">        list_add(&amp;path-&gt;<span class="built_in">list</span>, &amp;dapm-&gt;card-&gt;paths);  </span><br><span class="line">        list_add(&amp;path-&gt;list_sink, &amp;wsink-&gt;sources);  </span><br><span class="line">        list_add(&amp;path-&gt;list_source, &amp;wsource-&gt;sinks);  </span><br><span class="line">        path-&gt;connect = <span class="number">1</span>;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为增加了连结关系，所以把源widget和目的widget加入到dapm_dirty链表中。如果没有kcontrol来控制该连接关系，则这是一个静态连接，直接用path把它们连接在一起。在接着往下看：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c:snd_soc_dapm_add_path()]</span><br><span class="line"><span class="comment">/* connect dynamic paths */</span>  </span><br><span class="line"><span class="keyword">switch</span> (wsink-&gt;id) &#123;  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_adc:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_dac:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_pga:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_out_drv:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_input:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_output:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_siggen:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_micbias:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_vmid:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_pre:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_post:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_supply:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_regulator_supply:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_clock_supply:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_aif_in:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_aif_out:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_dai_in:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_dai_out:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_dai_link:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_kcontrol:  </span><br><span class="line">        list_add(&amp;path-&gt;<span class="built_in">list</span>, &amp;dapm-&gt;card-&gt;paths);  </span><br><span class="line">        list_add(&amp;path-&gt;list_sink, &amp;wsink-&gt;sources);  </span><br><span class="line">        list_add(&amp;path-&gt;list_source, &amp;wsource-&gt;sinks);  </span><br><span class="line">        path-&gt;connect = <span class="number">1</span>;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>按照目的widget来判断，如果属于以上这些类型，直接把它们连接在一起即可，这段感觉有点多余，因为通常以上这些类型的widget本来也没有kcontrol，直接用上一段代码就可以了，也许是dapm的作者们想着以后可能会有所扩展吧。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c:snd_soc_dapm_add_path()]</span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_mux:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_virt_mux:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_value_mux:  </span><br><span class="line">        ret = dapm_connect_mux(dapm, wsource, wsink, path, control,  </span><br><span class="line">                &amp;wsink-&gt;kcontrol_news[<span class="number">0</span>]);  </span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span>)  </span><br><span class="line">                <span class="keyword">goto</span> err;  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_switch:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_mixer:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_mixer_named_ctl:  </span><br><span class="line">        ret = dapm_connect_mixer(dapm, wsource, wsink, path, control);  </span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span>)  </span><br><span class="line">                <span class="keyword">goto</span> err;  </span><br><span class="line">        <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>目的widget如果是mixer和mux类型，分别用dapm_connect_mixer和dapm_connect_mux函数完成连接工作，这两个函数我们后面再讲。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c:snd_soc_dapm_add_path()]</span><br><span class="line">        <span class="keyword">case</span> snd_soc_dapm_hp:  </span><br><span class="line">        <span class="keyword">case</span> snd_soc_dapm_mic:  </span><br><span class="line">        <span class="keyword">case</span> snd_soc_dapm_line:  </span><br><span class="line">        <span class="keyword">case</span> snd_soc_dapm_spk:  </span><br><span class="line">                list_add(&amp;path-&gt;<span class="built_in">list</span>, &amp;dapm-&gt;card-&gt;paths);  </span><br><span class="line">                list_add(&amp;path-&gt;list_sink, &amp;wsink-&gt;sources);  </span><br><span class="line">                list_add(&amp;path-&gt;list_source, &amp;wsource-&gt;sinks);  </span><br><span class="line">                path-&gt;connect = <span class="number">0</span>;  </span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">err:  </span><br><span class="line">        kfree(path);  </span><br><span class="line">        <span class="keyword">return</span> ret;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hp、mic、line和spk这几种widget属于外部器件，也只是简单地连接在一起，不过connect字段默认为是未连接状态。<br>现在，我们回过头来看看目的widget是mixer和mux这两种类型时的连接方式：<br>dapm_connect_mixer  用该函数连接一个目的widget为mixer类型的所有输入端：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dapm_connect_mixer</span><span class="params">(struct snd_soc_dapm_context *dapm,  </span></span></span><br><span class="line"><span class="function"><span class="params">        struct snd_soc_dapm_widget *src, struct snd_soc_dapm_widget *dest,  </span></span></span><br><span class="line"><span class="function"><span class="params">        struct snd_soc_dapm_path *path, <span class="keyword">const</span> <span class="keyword">char</span> *control_name)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> i;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">/* search for mixer kcontrol */</span>  </span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; dest-&gt;num_kcontrols; i++) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(control_name, dest-&gt;kcontrol_news[i].name)) &#123;  </span><br><span class="line">                        list_add(&amp;path-&gt;<span class="built_in">list</span>, &amp;dapm-&gt;card-&gt;paths);  </span><br><span class="line">                        list_add(&amp;path-&gt;list_sink, &amp;dest-&gt;sources);  </span><br><span class="line">                        list_add(&amp;path-&gt;list_source, &amp;src-&gt;sinks);  </span><br><span class="line">                        path-&gt;name = dest-&gt;kcontrol_news[i].name;  </span><br><span class="line">                        dapm_set_path_status(dest, path, i);  </span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> -ENODEV;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用需要用来连接的kcontrol的名字，和目的widget中的kcontrol模板数组中的名字相比较，找出该kcontrol在widget中的编号，path的名字设置为该kcontrol的名字，然后用dapm_set_path_status函数来初始化该输入端的连接状态。连接两个widget的链表操作和其他widget是一样的。</p><p>dapm_connect_mux 用该函数连接一个目的widget是mux类型的所有输入端：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dapm_connect_mux</span><span class="params">(struct snd_soc_dapm_context *dapm,  </span></span></span><br><span class="line"><span class="function"><span class="params">        struct snd_soc_dapm_widget *src, struct snd_soc_dapm_widget *dest,  </span></span></span><br><span class="line"><span class="function"><span class="params">        struct snd_soc_dapm_path *path, <span class="keyword">const</span> <span class="keyword">char</span> *control_name,  </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> struct snd_kcontrol_new *kcontrol)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">soc_enum</span> *<span class="title">e</span> = (<span class="title">struct</span> <span class="title">soc_enum</span> *)<span class="title">kcontrol</span>-&gt;<span class="title">private_value</span>;</span>  </span><br><span class="line">        <span class="keyword">int</span> i;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; e-&gt;max; i++) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (!(<span class="built_in">strcmp</span>(control_name, e-&gt;texts[i]))) &#123;  </span><br><span class="line">                        list_add(&amp;path-&gt;<span class="built_in">list</span>, &amp;dapm-&gt;card-&gt;paths);  </span><br><span class="line">                        list_add(&amp;path-&gt;list_sink, &amp;dest-&gt;sources);  </span><br><span class="line">                        list_add(&amp;path-&gt;list_source, &amp;src-&gt;sinks);  </span><br><span class="line">                        path-&gt;name = (<span class="keyword">char</span>*)e-&gt;texts[i];  </span><br><span class="line">                        dapm_set_path_status(dest, path, <span class="number">0</span>);  </span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> -ENODEV;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和mixer类型一样用名字进行匹配，只不过mux类型的kcontrol只需一个，所以要通过private_value字段所指向的soc_enum结构找出匹配的输入脚编号，最后也是通过dapm_set_path_status函数来初始化该输入端的连接状态，因为只有一个kcontrol，所以第三个参数是0。连接两个widget的链表操作和其他widget也是一样的。<br>dapm_set_path_status    该函数根据传入widget中的kcontrol编号，读取实际寄存器的值，根据寄存器的值来初始化这个path是否处于连接状态，详细的代码这里就不贴了。<br>当widget之间通过path进行连接之后，他们之间的关系就如下图所示：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/210-Audio-system-snd_soc_dapm_path.png" alt="Alt text"></p><p>到这里为止，我们为声卡创建并初始化好了所需的widget，各个widget也通过path连接在了一起，接下来，dapm等待用户的指令，一旦某个dapm kcontrol被用户空间改变，利用这些连接关系，dapm会重新创建音频路径，脱离音频路径的widget会被下电，加入音频路径的widget会被上电，所有的上下电动作都会自动完成，用户空间的应用程序无需关注这些变化，它只管按需要改变某个dapm kcontrol即可。</p><h4 id="（八）、tinyplay-playback、capture"><a href="#（八）、tinyplay-playback、capture" class="headerlink" title="（八）、tinyplay playback、capture"></a>（八）、tinyplay playback、capture</h4><h5 id="8-1、tinyplay-playback"><a href="#8-1、tinyplay-playback" class="headerlink" title="8.1、tinyplay playback"></a>8.1、tinyplay playback</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/211-tiny-capture.png" alt="Alt text"></p><p>有时序图可知：主要涉及pcm_open()、pcm_write()、pcm_prepare()、pcm_start()。</p><h5 id="8-1-1、使用耳机播放"><a href="#8-1-1、使用耳机播放" class="headerlink" title="8.1.1、使用耳机播放"></a>8.1.1、使用耳机播放</h5><ol><li>启动音频播放</li><li>启用 Rx codec 路径<br>tinymix ‘RX1 MIX1 INP1’ ‘RX1’<br>tinymix ‘RX2 MIX1 INP1’ ‘RX2’<br>tinymix ‘RDAC2 MUX’ ‘RX2’<br>tinymix ‘HPHL’ ‘Switch’<br>tinymix ‘HPHR’ ‘Switch’<br>tinymix ‘MI2S_RX Channels’ ‘Two</li><li>启用用于通过 MI2S 接口进行播放的 DSP AFE<br>tinymix ‘PRI_MI2S_RX Audio Mixer MultiMedia1’ 1</li><li>播放 PCM 音频<br>tinyplay <filename.wav> </filename.wav></li><li>停止音频播放</li><li>禁用接收 Rx codec 路径<br>tinymix ‘RX1 MIX1 INP1’ ‘ZERO’<br>tinymix ‘RX2 MIX1 INP1’ ‘ZERO’<br>tinymix ‘RDAC2 MUX’ ‘ZERO’<br>tinymix ‘HPHL’ ‘ZERO’<br>tinymix ‘HPHR’ ‘ZERO’<br>tinymix ‘MI2S_RX Channels’ ‘One’</li><li>禁用用于通过 I2S 接口进行音频播放的 DSP AFE<br>tinymix ‘PRI_MI2S_RX Audio Mixer MultiMedia1’ 0</li></ol><h5 id="8-2、tinyplay-capture"><a href="#8-2、tinyplay-capture" class="headerlink" title="8.2、tinyplay capture"></a>8.2、tinyplay capture</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/212-tiny-playback.png" alt="Alt text"></p><p>有时序图可知：主要涉及pcm_open()、pcm_read()、pcm_start()。</p><h5 id="8-2-1、使用音频录制"><a href="#8-2-1、使用音频录制" class="headerlink" title="8.2.1、使用音频录制"></a>8.2.1、使用音频录制</h5><ol><li>输入以下命令：<br>//Enable DSP AFE for Audio Recording over I2S<br>tinymix ‘MultiMedia1 Mixer TERT_MI2S_TX’ 1<br>//Enable Codec TX Path<br>tinymix ‘DEC1 MUX’ ‘ADC2’<br>tinymix ‘ADC2 MUX’ ‘INP2’</li><li>启动录音功能：<br>tinycap /data/rec.wav</li><li>禁用 HeadsetX 设备 (AMIC2)：<br>tinymix ‘MultiMedia1 Mixer TERT_MI2S_TX’ 0<br>tinymix ‘DEC1 MUX’ ‘ZERO’<br>tinymix ‘ADC2 MUX’ ‘ZERO’</li></ol><h4 id="（九）、参考资料-特别感谢各位前辈的分析和图示-："><a href="#（九）、参考资料-特别感谢各位前辈的分析和图示-：" class="headerlink" title="（九）、参考资料(特别感谢各位前辈的分析和图示)："></a>（九）、参考资料(特别感谢各位前辈的分析和图示)：</h4><p><a href="https://zhuanlan.zhihu.com/p/27480328" target="_blank" rel="noopener">Android音频模块启动流程分析</a><br><a href="https://zhuanlan.zhihu.com/jhuster" target="_blank" rel="noopener">Jhuster的专栏​ Android音频开发</a><br><a href="http://thinks.me/2016/09/13/audio_qcom_offload/" target="_blank" rel="noopener">高通audio offload学习 | Thinking</a><br><a href="https://blog.csdn.net/droidphone/article/category/1118446" target="_blank" rel="noopener">DroidPhone的专栏 - CSDN博客</a><br><a href="https://blog.csdn.net/orz415678659/article/details/8866071" target="_blank" rel="noopener">alsa音频架构1-CSDN博客</a><br><a href="https://blog.csdn.net/orz415678659/article/details/8982771" target="_blank" rel="noopener">alsa音频架构2-ASoc - CSDN博客</a><br><a href="https://blog.csdn.net/orz415678659/article/details/8995163" target="_blank" rel="noopener">alsa音频架构3-Pcm - CSDN博客</a><br><a href="https://blog.csdn.net/orz415678659/article/details/8999364" target="_blank" rel="noopener">alsa音频架构4-声卡控制 - CSDN博客</a><br><a href="https://blog.csdn.net/zyuanyun/article/details/59180272" target="_blank" rel="noopener">Linux ALSA 音频系统：逻辑设备篇 - CSDN博客</a><br><a href="https://blog.csdn.net/zyuanyun/article/details/59170418" target="_blank" rel="noopener">Linux ALSA 音频系统：物理链路篇 - CSDN博客</a><br><a href="https://blog.csdn.net/column/details/12812.html" target="_blank" rel="noopener">专栏：MultiMedia框架总结(基于6.0源码) - CSDN博客</a><br><a href="https://blog.csdn.net/zyuanyun/article/details/60890534" target="_blank" rel="noopener">Android 音频系统：从 AudioTrack 到 AudioFlinger - CSDN博客</a><br><a href="https://blog.csdn.net/azloong/article/category/778492" target="_blank" rel="noopener">AZURE - CSDN博客 - ALSA-Android Audio</a><br><a href="https://blog.csdn.net/azloong/article/category/777239" target="_blank" rel="noopener">AZURE - CSDN博客 - ANDROID音频系统</a><br><a href="https://winddoing.github.io/2017/07/10/audio_alsa/" target="_blank" rel="noopener">Audio驱动总结–ALSA | Winddoing’s Blog</a><br><a href="http://www.cnblogs.com/muhe221/articles/4461543.html" target="_blank" rel="noopener">audio HAL - 牧 天 - 博客园</a><br><a href="https://blog.csdn.net/xuesen_lin/article/category/1390680" target="_blank" rel="noopener">林学森的Android专栏 - CSDN博客</a><br><a href="https://blog.csdn.net/yangwen123/article/category/2589087" target="_blank" rel="noopener">深入剖析Android音频 - CSDN博客Yangwen123</a><br><a href="http://www.cnblogs.com/tocy/tag/%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6/" target="_blank" rel="noopener">播放框架 - 标签 - Tocy - 博客园</a><br><a href="https://blog.csdn.net/miaomiao12345678/article/details/57415505" target="_blank" rel="noopener">Android-7.0-Nuplayer概述 - CSDN博客</a><br><a href="https://blog.csdn.net/miaomiao12345678/article/details/56961370" target="_blank" rel="noopener">Android-7.0-Nuplayer-启动流程 - CSDN博客</a><br><a href="https://blog.csdn.net/harman_zjc/article/details/53386010" target="_blank" rel="noopener">Android Media Player 框架分析-Nuplayer（1） - CSDN博客</a><br><a href="https://blog.csdn.net/harman_zjc/article/details/53397945" target="_blank" rel="noopener">Android Media Player 框架分析-AHandler AMessage ALooper - CSDN博客</a><br><a href="https://blog.csdn.net/liu1314you/article/category/6344583" target="_blank" rel="noopener">Android N Audio播放 start真面目- (六篇) CSDN博客</a><br><a href="https://blog.csdn.net/nonmarking/article/details/78746671" target="_blank" rel="noopener">深入理解Android音视频同步机制（五篇）NuPlayer的avsync逻辑 - CSDN博客</a><br><a href="https://blog.csdn.net/u014310046/article/category/6571854" target="_blank" rel="noopener">wangyf的专栏 - CSDN博客-MT6737 Android N 平台 Audio系统学习</a><br><a href="https://blog.csdn.net/xiashaohua/article/details/53638780" target="_blank" rel="noopener">Android 7.0 Audio: Mediaplayer - CSDN博客</a><br><a href="https://blog.csdn.net/xiashaohua/article/category/6549668" target="_blank" rel="noopener">Android 7.0 Audio-相关类浅析- CSDN博客</a><br><a href="https://blog.csdn.net/liu1314you/article/details/59119144" target="_blank" rel="noopener">Android N Audio播放六：如何读取buffer - CSDN博客</a><br><a href="https://blog.csdn.net/jinzhuojun/article/details/78007568" target="_blank" rel="noopener">Fuchsia OS中的RPC机制-FIDL - CSDN博客</a><br><a href="http://www.cnblogs.com/linhaostudy/category/1145404.html" target="_blank" rel="noopener">高通Audio中ASOC的codec驱动 - yooooooo - 博客园</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;amp;&amp;amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内
      
    
    </summary>
    
      <category term="Android" scheme="http://zhoujinjian.cc/categories/Android/"/>
    
    
      <category term="Android" scheme="http://zhoujinjian.cc/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Audio System（1）：Linux &amp;&amp; Android Audio 系统框架分析</title>
    <link href="http://zhoujinjian.cc/2018/05/01/Audio%20System%EF%BC%881%EF%BC%89%EF%BC%9ALinux%20&amp;&amp;%20Android%20Audio%20%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/"/>
    <id>http://zhoujinjian.cc/2018/05/01/Audio System（1）：Linux &amp;&amp; Android Audio 系统框架分析/</id>
    <published>2018-04-30T16:00:00.000Z</published>
    <updated>2018-05-09T15:03:51.779Z</updated>
    
    <content type="html"><![CDATA[<hr><p>注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;&amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除，禁止转载（©Qualcomm Technologies, Inc. 版权所有），谢谢。</p><p><a href="https://github.com/izhoujinjian/zhoujinjian.cc/tree/master/audio.system" target="_blank" rel="noopener">【博客原图链接】</a></p><p>Google Pixel、Pixel XL 内核代码（Kernel-3.18）：<br> <a href="https://github.com/matthewdalex/marlin" target="_blank" rel="noopener">Kernel source for Pixel and Pixel XL - GitHub</a></p><p>AOSP 源码（Android 7.1.2）：<br> <a href="https://testerhome.com/topics/2229" target="_blank" rel="noopener"> Android 系统全套源代码分享 (更新到 8.1.0_r1)</a></p><hr><h4 id="（一）、音频基础知识"><a href="#（一）、音频基础知识" class="headerlink" title="（一）、音频基础知识"></a>（一）、音频基础知识</h4><p>理解音频的一些基础知识，对于我们分析整个音频系统是大有裨益的。它可以让我们从实现的层面去思考，音频系统的目的是什么，然后才是怎么样去完成这个目的</p><p>#####（1）声音有哪些重要属性呢？</p><h5 id="1-1、响度-Loudness"><a href="#1-1、响度-Loudness" class="headerlink" title="1.1、响度(Loudness)"></a>1.1、响度(Loudness)</h5><p>响度就是人类可以感知到的各种声音的大小，也就是音量。响度与声波的振幅有直接关系。</p><h5 id="1-2、音调-Pitch"><a href="#1-2、音调-Pitch" class="headerlink" title="1.2、音调(Pitch)"></a>1.2、音调(Pitch)</h5><p>音调与声音的频率有关系，当声音的频率越大时，人耳所感知到的音调就越高，否则就越低。</p><h5 id="1-3、音色-Quality"><a href="#1-3、音色-Quality" class="headerlink" title="1.3、音色(Quality)"></a>1.3、音色(Quality)</h5><p>同一种乐器，使用不同的材质来制作，所表现出来的音色效果是不一样的，这是由物体本身的结构特性所决定的。</p><p>如何将各种媒体源数字化呢？<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/11-Audio-system-1024px-A-D-A_Flow.svg.png" alt="Alt text"></p><p>将声波波形信号通过ADC转换成计算机支持的二进制的过程叫做音频采样(Audio Sampling)。采样(Sampling)的核心是把连续的模拟信号转换成离散的数字信号。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/12-Audio-system-sampling.png" alt="Alt text"></p><h5 id="1-4、样本-Sample"><a href="#1-4、样本-Sample" class="headerlink" title="1.4、样本(Sample)"></a>1.4、样本(Sample)</h5><p>这是我们进行采样的初始资料，比如一段连续的声音波形。</p><h5 id="1-5、采样器-Sampler"><a href="#1-5、采样器-Sampler" class="headerlink" title="1.5、采样器(Sampler)"></a>1.5、采样器(Sampler)</h5><p>采样器是将样本转换成终态信号的关键。它可以是一个子系统，也可以指一个操作过程，甚至是一个算法，取决于不同的信号处理场景。理想的采样器要求尽可能不产生信号失真。</p><h5 id="1-6、量化-Quantization"><a href="#1-6、量化-Quantization" class="headerlink" title="1.6、量化(Quantization)"></a>1.6、量化(Quantization)</h5><p>采样后的值还需要通过量化，也就是将连续值近似为某个范围内有限多个离散值的处理过程。因为原始数据是模拟的连续信号，而数字信号则是离散的，它的表达范围是有限的，所以量化是必不可少的一个步骤。</p><h5 id="1-7、编码-Coding"><a href="#1-7、编码-Coding" class="headerlink" title="1.7、编码(Coding)"></a>1.7、编码(Coding)</h5><p>计算机的世界里，所有数值都是用二进制表示的，因而我们还需要把量化值进行二进制编码。这一步通常与量化同时进行。</p><h5 id="1-8、采样率（samplerate）"><a href="#1-8、采样率（samplerate）" class="headerlink" title="1.8、采样率（samplerate）"></a>1.8、采样率（samplerate）</h5><p>采样就是把模拟信号数字化的过程，不仅仅是音频需要采样，所有的模拟信号都需要通过采样转换为可以用0101来表示的数字信号，示意图如下所示：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/13-Audio-system-sampling-rate.png.png" alt="Alt text"></p><p>蓝色代表模拟音频信号，红色的点代表采样得到的量化数值。</p><p>采样频率越高，红色的间隔就越密集，记录这一段音频信号所用的数据量就越大，同时音频质量也就越高。</p><p>根据奈奎斯特理论，采样频率只要不低于音频信号最高频率的两倍，就可以无损失地还原原始的声音。</p><p>通常人耳能听到频率范围大约在20Hz～20kHz之间的声音，为了保证声音不失真，采样频率应在40kHz以上。常用的音频采样频率有：8kHz、11.025kHz、22.05kHz、16kHz、37.8kHz、44.1kHz、48kHz、96kHz、192kHz等。</p><h5 id="1-9、量化精度（位宽）"><a href="#1-9、量化精度（位宽）" class="headerlink" title="1.9、量化精度（位宽）"></a>1.9、量化精度（位宽）</h5><p>上图（1.8）中，每一个红色的采样点，都需要用一个数值来表示大小，这个数值的数据类型大小可以是：4bit、8bit、16bit、32bit等等，位数越多，表示得就越精细，声音质量自然就越好，当然，数据量也会成倍增大。</p><p>常见的位宽是：8bit 或者 16bit</p><h5 id="1-10、-声道数（channels）"><a href="#1-10、-声道数（channels）" class="headerlink" title="1.10、 声道数（channels）"></a>1.10、 声道数（channels）</h5><p>由于音频的采集和播放是可以叠加的，因此，可以同时从多个音频源采集声音，并分别输出到不同的扬声器，故声道数一般表示声音录制时的音源数量或回放时相应的扬声器数量。</p><p>单声道（Mono）和双声道（Stereo）比较常见，顾名思义，前者的声道数为1，后者为2</p><h5 id="1-11、音频帧（frame）"><a href="#1-11、音频帧（frame）" class="headerlink" title="1.11、音频帧（frame）"></a>1.11、音频帧（frame）</h5><p>这个概念在应用开发中非常重要，网上很多文章都没有专门介绍这个概念。</p><p>音频跟视频很不一样，视频每一帧就是一张图像，而从上面的正玄波可以看出，音频数据是流式的，本身没有明确的一帧帧的概念，在实际的应用中，为了音频算法处理/传输的方便，一般约定俗成取2.5ms~60ms为单位的数据量为一帧音频。</p><p>这个时间被称之为“采样时间”，其长度没有特别的标准，它是根据编解码器和具体应用的需求来决定的，我们可以计算一下一帧音频帧的大小：</p><p>假设某音频信号是采样率为8kHz、双通道、位宽为16bit，20ms一帧，则一帧音频数据的大小为：</p><p>int size = 8000 x 2 x 16bit x 0.02s = 5120 bit = 640 byte</p><h5 id="1-12、常见的音频编码方式有哪些？"><a href="#1-12、常见的音频编码方式有哪些？" class="headerlink" title="1.12、常见的音频编码方式有哪些？"></a>1.12、常见的音频编码方式有哪些？</h5><p>上面提到过，模拟的音频信号转换为数字信号需要经过采样和量化，量化的过程被称之为编码，根据不同的量化策略，产生了许多不同的编码方式，常见的编码方式有：PCM 和 ADPCM，这些数据代表着无损的原始数字音频信号，添加一些文件头信息，就可以存储为WAV文件了，它是一种由微软和IBM联合开发的用于音频数字存储的标准，可以很容易地被解析和播放。</p><p>我们在音频开发过程中，会经常涉及到WAV文件的读写，以验证采集、传输、接收的音频数据的正确性。</p><h5 id="1-13、常见的音频压缩格式有哪些？"><a href="#1-13、常见的音频压缩格式有哪些？" class="headerlink" title="1.13、常见的音频压缩格式有哪些？"></a>1.13、常见的音频压缩格式有哪些？</h5><p>首先简单介绍一下音频数据压缩的最基本的原理：因为有冗余信息，所以可以压缩。</p><p>（1） 频谱掩蔽效应： 人耳所能察觉的声音信号的频率范围为20Hz～20KHz，在这个频率范围以外的音频信号属于冗余信号。</p><p>（2） 时域掩蔽效应： 当强音信号和弱音信号同时出现时，弱信号会听不到，因此，弱音信号也属于冗余信号。</p><p>下面简单列出常见的音频压缩格式：</p><p>MP3，AAC，OGG，WMA，Opus，FLAC，APE，M4A，AMR，等等</p><h5 id="1-14、奈奎斯特采样理论"><a href="#1-14、奈奎斯特采样理论" class="headerlink" title="1.14、奈奎斯特采样理论"></a>1.14、奈奎斯特采样理论</h5><p>“当对被采样的模拟信号进行还原时，其最高频率只有采样频率的一半”。<br>换句话说，如果我们要完整重构原始的模拟信号，则采样频率就必须是它的两倍以上。比如人的声音范围是2~ 20kHZ,那么选择的采样频率就应该在40kHZ左右，数值太小则声音将产生失真现象，而数值太大也无法明显提升人耳所能感知的音质。</p><h5 id="1-15、总结（音频处理和播放过程）："><a href="#1-15、总结（音频处理和播放过程）：" class="headerlink" title="1.15、总结（音频处理和播放过程）："></a>1.15、总结（音频处理和播放过程）：</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/14-Audio-system-how-audio-works.png" alt="Alt text"></p><h4 id="（二）、Audio-系统框架"><a href="#（二）、Audio-系统框架" class="headerlink" title="（二）、Audio 系统框架"></a>（二）、Audio 系统框架</h4><h5 id="总体Audio框架图"><a href="#总体Audio框架图" class="headerlink" title="总体Audio框架图"></a>总体Audio框架图</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/15-Audio-system-Android-Linux-arc.png" alt="Alt text"></p><h5 id="2-1、APP"><a href="#2-1、APP" class="headerlink" title="2.1、APP"></a>2.1、APP</h5><p>音乐播放器软件等等。</p><h5 id="2-2、Framework"><a href="#2-2、Framework" class="headerlink" title="2.2、Framework"></a>2.2、Framework</h5><p>Android也提供了另两个相似功能的类，即AudioTrack和AudioRecorder，MediaPlayerService内部的实现就是通过它们来完成的,只不过MediaPlayer/MediaRecorder提供了更强大的控制功能，相比前者也更易于使用。除此以外，Android系统还为我们控制音频系统提供了AudioManager、AudioService及AudioSystem类。这些都是framework为便利上层应用开发所设计的。</p><h5 id="2-3、Libraries"><a href="#2-3、Libraries" class="headerlink" title="2.3、Libraries"></a>2.3、Libraries</h5><p>framework只是向应用程序提供访问Android库的桥梁，具体功能实现放在库中完成。比如上面的AudioTrack、AudioRecorder、MediaPlayer和MediaRecorder等等在库中都能找到相对应的类。</p><p>1、frameworks/av/media/libmedia【libmedia.so】<br>2、frameworks/av/services/audioflinger【libaudioflinger.so】<br>3、frameworks/av/media/libmediaplayerservice【libmediaplayerservice.so】</p><h5 id="2-4、HAL"><a href="#2-4、HAL" class="headerlink" title="2.4、HAL"></a>2.4、HAL</h5><p>从设计上来看，硬件抽象层是AudioFlinger直接访问的对象。这说明了两个问题，一方面AudioFlinger并不直接调用底层的驱动程序;另一方面，AudioFlinger上层模块只需要与它进行交互就可以实现音频相关的功能了。因而我们可以认为AudioFlinger是Android音频系统中真正的“隔离板”，无论下面如何变化，上层的实现都可以保持兼容。</p><p>音频方面的硬件抽象层主要分为两部分，即AudioFlinger和AudioPolicyService。实际上后者并不是一个真实的设备，只是采用虚拟设备的方式来让厂商可以方便地定制出自己的策略。抽象层的任务是将AudioFlinger/AudioPolicyService真正地与硬件设备关联起来，但又必须提供灵活的结构来应对变化——特别是对于Android这个更新相当频繁的系统。比如以前Android系统中的Audio系统依赖于ALSA-lib，但后期就变为了tinyalsa，这样的转变不应该对上层造成破坏。因而Audio HAL提供了统一的接口来定义它与AudioFlinger/AudioPolicyService之间的通信方式，这就是audio_hw_device、audio_stream_in及audio_stream_out等等存在的目的，这些Struct数据类型内部大多只是函数指针的定义，是一些“壳”。当AudioFlinger/AudioPolicyService初始化时，它们会去寻找系统中最匹配的实现(这些实现驻留在以audio.primary.<em>,audio.a2dp.</em>为名的各种库中)来填充这些“壳”。根据产品的不同，音频设备存在很大差异，在Android的音频架构中，这些问题都是由HAL层的audio.primary等等库来解决的，而不需要大规模地修改上层实现。换句话说，厂商在定制时的重点就是如何提供这部分库的高效实现了。</p><h5 id="2-5、Tinyalsa"><a href="#2-5、Tinyalsa" class="headerlink" title="2.5、Tinyalsa"></a>2.5、Tinyalsa</h5><p>源码在external/tinyalsa目录下<br>Tinyalsa：tinyplay/tinycap/tinymix，这些用户程序直接调用 alsa 用户库接口来实现放音、录音、控制</p><h5 id="2-6、Kernel部分"><a href="#2-6、Kernel部分" class="headerlink" title="2.6、Kernel部分"></a>2.6、Kernel部分</h5><h5 id="2-6-1、ALSA-和-ASoC"><a href="#2-6-1、ALSA-和-ASoC" class="headerlink" title="2.6.1、ALSA 和 ASoC"></a>2.6.1、ALSA 和 ASoC</h5><p>Native ALSA Application：tinyplay/tinycap/tinymix，这些用户程序直接调用 alsa 用户库接口来实现放音、录音、控制<br>ALSA Library API：alsa 用户库接口，常见有 tinyalsa、alsa-lib<br>ALSA CORE：alsa 核心层，向上提供逻辑设备（PCM/CTL/MIDI/TIMER/…）系统调用，向下驱动硬件设备（Machine/I2S/DMA/CODEC）<br>ASoC CORE：asoc 是建立在标准 alsa core 基础上，为了更好支持嵌入式系统和应用于移动设备的音频 codec 的一套软件体系<br>Hardware Driver：音频硬件设备驱动，由三大部分组成，分别是 Machine、Platform、Codec</p><h5 id="2-6-2、ASoC"><a href="#2-6-2、ASoC" class="headerlink" title="2.6.2、ASoC"></a>2.6.2、ASoC</h5><p>ASoC被分为Machine、Platform和Codec三大部分。其中的Machine驱动负责Platform和Codec之间的耦合和设备或板子特定的代码。Platform驱动的主要作用是完成音频数据的管理，最终通过CPU的数字音频接口（DAI）把音频数据传送给Codec进行处理，最终由Codec输出驱动耳机或者是喇叭的音信信号。</p><h5 id="2-6-2-1、Machine"><a href="#2-6-2-1、Machine" class="headerlink" title="2.6.2.1、Machine"></a>2.6.2.1、<strong>Machine</strong></h5><p>用于描述设备组件信息和特定的控制如耳机/外放等。</p><blockquote><p>是指某一款机器，可以是某款设备，某款开发板，又或者是某款智能手机，由此可以看出Machine几乎是不可重用的，每个Machine上的硬件实现可能都不一样，CPU不一样，Codec不一样，音频的输入、输出设备也不一样，Machine为CPU、Codec、输入输出设备提供了一个载体。</p></blockquote><p>这一部分将平台驱动和Codec驱动绑定在一起，描述了板级的硬件特征。主要负责Platform和Codec之间的耦合以及部分和设备或板子特定的代码。Machine驱动负责处理机器特有的一些控件和音频事件（例如，当播放音频时，需要先行打开一个放大器）；单独的Platform和Codec驱动是不能工作的，它必须由Machine驱动把它们结合在一起才能完成整个设备的音频处理工作。ASoC的一切都从Machine驱动开始，包括声卡的注册，绑定Platform和Codec驱动等等</p><h5 id="2-6-2-2、Platform"><a href="#2-6-2-2、Platform" class="headerlink" title="2.6.2.2、Platform"></a>2.6.2.2、<strong>Platform</strong></h5><p>用于实现平台相关的DMA驱动和音频接口等。</p><blockquote><p>一般是指某一个SoC平台，比如pxaxxx,s3cxxxx,omapxxx等等，与音频相关的通常包含该SoC中的时钟、DMA、I2S、PCM等等，只要指定了SoC，那么我们可以认为它会有一个对应的Platform，它只与SoC相关，与Machine无关，这样我们就可以把Platform抽象出来，使得同一款SoC不用做任何的改动，就可以用在不同的Machine中。实际上，把Platform认为是某个SoC更好理解。</p></blockquote><p>这一部分只关心CPU本身，不关心Codec。主要处理两个问题：DMA引擎和SoC集成的PCM、I2S或AC ‘97数字接口控制。主要作用是完成音频数据的管理，最终通过CPU的数字音频接口（DAI）把音频数据传送给Codec进行处理，最终由Codec输出驱动耳机或者是喇叭的音信信号。在具体实现上，ASoC有把Platform驱动分为两个部分：snd_soc_platform_driver和snd_soc_dai_driver。其中，platform_driver负责管理音频数据，把音频数据通过dma或其他操作传送至cpu dai中，dai_driver则主要完成cpu一侧的dai的参数配置，同时也会通过一定的途径把必要的dma等参数与snd_soc_platform_driver进行交互。</p><h5 id="2-6-2-3、Codec"><a href="#2-6-2-3、Codec" class="headerlink" title="2.6.2.3、Codec"></a>2.6.2.3、<strong>Codec</strong></h5><p>用于实现平台无关的功能，如寄存器读写接口，音频接口，各widgets的控制接口和DAPM的实现等</p><blockquote><p>字面上的意思就是编解码器，Codec里面包含了I2S接口、D/A、A/D、Mixer、PA（功放），通常包含多种输入（Mic、Line-in、I2S、PCM）和多个输出（耳机、喇叭、听筒，Line-out），Codec和Platform一样，是可重用的部件，同一个Codec可以被不同的Machine使用。嵌入式Codec通常通过I2C对内部的寄存器进行控制。</p></blockquote><p>这一部分只关心Codec本身，与CPU平台相关的特性不由此部分操作。在移动设备中，Codec的作用可以归结为4种，分别是：</p><p>1、对PCM等信号进行D/A转换，把数字的音频信号转换为模拟信号。<br>2、对Mic、Linein或者其他输入源的模拟信号进行A/D转换，把模拟的声音信号转变CPU能够处理的数字信号。<br>3、对音频通路进行控制，比如播放音乐，收听调频收音机，又或者接听电话时，音频信号在codec内的流通路线是不一样的。<br>4、对音频信号做出相应的处理，例如音量控制，功率放大，EQ控制等等。</p><p>ASoC对Codec的这些功能都定义好了一些列相应的接口，以方便地对Codec进行控制。ASoC对Codec驱动的一个基本要求是：驱动程序的代码必须要做到平台无关性，以方便同一个Codec的代码不经修改即可用在不同的平台上。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/16-Audio-system-asoc-pcm-control.png" alt="Alt text"></p><p>ASoC对于Alsa来说，就是分别注册PCM/CONTROL类型的snd_device设备，并实现相应的操作方法集。图中DAI是数字音频接口，用于配置音频数据格式等。</p><p>☁ Codec驱动向ASoC注册snd_soc_codec和snd_soc_dai设备。<br>☁ Platform驱动向ASoC注册snd_soc_platform和snd_soc_dai设备。<br>☁ Machine驱动通过snd_soc_dai_link绑定codec/dai/platform。</p><p>Widget是各个组件内部的小单元。处在活动通路上电，不在活动通路下电。ASoC的DAPM正是通过控制这些Widget的上下电达到动态电源管理的效果。</p><p>☁ path描述与其它widget的连接关系。<br>☁ event用于通知该widget的上下电状态。<br>☁ power指示当前的上电状态。<br>☁ control实现空间用户接口用于控制widget的音量/通路切换等。</p><p>对驱动开者来说，就可以很好的解耦了：</p><p>☁ codec驱动的开发者，实现codec的IO读写方法，描述DAI支持的数据格式/操作方法和Widget的连接关系就可以了;<br>☁ soc芯片的驱动开发者，Platform实现snd_pcm的操作方法集和DAI的配置如操作 DMA，I2S/AC97/PCM的设定等;<br>☁ 板级的开发者，描述Machine上codec与platform之间的总线连接， earphone/Speaker的布线情况就可以了。</p><h5 id="2-6-3、DAPM"><a href="#2-6-3、DAPM" class="headerlink" title="2.6.3、DAPM"></a>2.6.3、<strong>DAPM</strong></h5><p> DAPM是Dynamic Audio Power Management的缩写，直译过来就是动态音频电源管理的意思，DAPM是为了使基于linux的移动设备上的音频子系统，在任何时候都工作在最小功耗状态下。DAPM对用户空间的应用程序来说是透明的，所有与电源相关的开关都在ASoc core中完成。用户空间的应用程序无需对代码做出修改，也无需重新编译，DAPM根据当前激活的音频流（playback/capture）和声卡中的mixer等的配置来决定那些音频控件的电源开关被打开或关闭。</p><h5 id="2-6-4、DPCM"><a href="#2-6-4、DPCM" class="headerlink" title="2.6.4、DPCM"></a>2.6.4、<strong>DPCM</strong></h5><p><a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/plain/Documentation/sound/soc/dpcm.rst?h=v4.16-rc5" target="_blank" rel="noopener">Dynamic PCM</a></p><h5 id="2-7、Audio-devices"><a href="#2-7、Audio-devices" class="headerlink" title="2.7、Audio devices"></a>2.7、Audio devices</h5><p>具体的Audio硬件设备。</p><h4 id="（三）、Qualcomm平台-Audio系统框架"><a href="#（三）、Qualcomm平台-Audio系统框架" class="headerlink" title="（三）、Qualcomm平台 - Audio系统框架"></a>（三）、Qualcomm平台 - Audio系统框架</h4><p>由于接下来的一系列Android &amp;&amp; kernel 源码分析都是基于Qualcomm 平台的，十分有必要介绍Qualcomm 平台的Audio 系统框架。硬件平台及软件版本：<br>☁ Kernel - 3.18<br>☁ SoC - Qualcomm snapdragon<br>☁ CODEC - WCD9335<br>☁ Machine - msm8996<br>☁ Userspace - tinyalsa</p><h5 id="3-1、Qualcomm-Audio系统总体框架图"><a href="#3-1、Qualcomm-Audio系统总体框架图" class="headerlink" title="3.1、Qualcomm Audio系统总体框架图"></a>3.1、Qualcomm Audio系统总体框架图</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/17-MSM8996-Linux-Android-Audio-Software-Overview-Architecture.png" alt="Alt text"></p><h5 id="3-2、ASoC-driver"><a href="#3-2、ASoC-driver" class="headerlink" title="3.2、ASoC driver"></a>3.2、ASoC driver</h5><p>ALSA 片上系统 (ASoC) 驱动程序将音频系统分为四个组成部分Machine driver、Platform driver、CPU driver、Codec driver。</p><h5 id="3-2-1、Machine-driver"><a href="#3-2-1、Machine-driver" class="headerlink" title="3.2.1、Machine driver"></a>3.2.1、Machine driver</h5><p>将平台、CPU 和编解码驱动程序整合在一起<br>kernel/sound/soc/msm/<chipset>.c<br>定义Frontend (FE) and Backend (BE), Digital Audio Interface (DAI) links</chipset></p><h5 id="3-2-2、Platform-driver"><a href="#3-2-2、Platform-driver" class="headerlink" title="3.2.2、Platform driver"></a>3.2.2、Platform driver</h5><p>包含用于流数据传输与路由的平台特定的控件（control）， 细分为 FE 和 BE 平台驱动程序<br><strong>FE</strong><br> Audio – 实例化 PCM 播放和录制会话；借助 ASM 接口，将 PCM 数据从用户空间传输到 DSP 进行播放<br>以及从 DSP 传输到用户空间进行录制 – 在 kernel/sound/soc/msm-pcm-q6-v2.c 中实现<br> Voice – 初始化/取消初始化语音呼叫设置 – 在 kernel/sound/soc/msm-pcm-voice-v2.c 中实现<br> VoIP – 初始化/取消初始化 MVS 接口以传输自/至 DSP 的 PCM 数据 – 在kernel/sound/soc/msm-pcmvoip-v2.c<br>中实现<br> Compressed offload – 支持将压缩数据发送到 DSP 进行压缩分流播放 – 在 kernel/sound/soc/msm-compress-q6-<br>v2.c 中实现<br><strong>BE</strong><br> 路由 – 执行音频路由任务 – 在 /kernel/sound/soc/msm-pcm-routing-v2.c 中实现</p><h5 id="3-2-3、CPU-driver"><a href="#3-2-3、CPU-driver" class="headerlink" title="3.2.3、CPU driver"></a>3.2.3、CPU driver</h5><p><strong>FE</strong><br> 向 ASoC 框架提供关于 FE PCM 设备的信息<br> ASoC 框架与平台驱动程序提供的路由表共同将 PCM 播放/捕获从 FE 传递至 BE<br> 没有针对播放和录制的内置逻辑<br> 定义 FE CPU DAI – 在 kernel/sound/soc/msm/msm-dai-fe.c 中实现<br><strong>BE</strong><br> 要在初始化 PCM 播放/捕获时激活所需音频硬件端口，则配置 DSP AFE 模块<br> 定义 BE CPU DAI – 在 kernel/sound/soc/msm/qdsp6v2/msm-dai-q6-v2.c 中实现</p><h5 id="3-2-4、Codec-driver"><a href="#3-2-4、Codec-driver" class="headerlink" title="3.2.4、Codec driver"></a>3.2.4、Codec driver</h5><p>与平台无关，其中包含音频控制、音频接口功能、编解码器 DAPM 定义以及编解<br>码器输入输出功能<br> 此外，实现 MBHC 状态机，用于检测有线耳机插入/拔出、附件类型、连接器类型<br>和多按钮检测</p><h5 id="3-3、DSP-driver"><a href="#3-3、DSP-driver" class="headerlink" title="3.3、DSP driver"></a>3.3、DSP driver</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/18-MSM8996-Linux-Android-Audio-ADSP-Architecture.png" alt="Alt text"></p><p><strong>ASM（Audio Stream Manager）</strong><br> 用于与 DSP ASM 模块通信的接口<br> 提供将 PCM 数据路由至 DSP 的机制，支持按数据流进行后期处理/预处理<br><strong>ADM（Audio Device Manager）</strong><br> 允许在 DSP 中使用 ADM 服务<br> 配置 COPP 和路由矩阵<br> 与音频校准数据库 (ACDB) 进行通信，使用正确的校准数据配置 COPP<br> 将 ASM 会话 ID 路由至 ADM 会话<br><strong>AFE（Audio Front-End）</strong><br> 允许在 DSP 中使用 AFE 服务<br> 激活/禁用音频硬件端口<br> 子系统管理器 – 发生 MDSP 复位事件时，通知音频和语音驱动程序关闭待处理<br>会话、执行清理操作并等待一个指示 MDSP 已启动的事件<br><strong>APR（Asynchronous Packet Router）</strong><br> 为处理器间通信提供异步框架<br> 用于与 Hexagon 和调制解调器处理器进行通信<br> Image loader PIL  – 载入 MDSP 图像</p><h5 id="3-4、User-Space"><a href="#3-4、User-Space" class="headerlink" title="3.4、User Space"></a>3.4、User Space</h5><p> Audio Hardware Abstraction Layer (AHAL) – 通过 tinyALSA 将 AudioFlinger<br> 调用映射至ASoC 驱动程序的硬件抽象层。<br> ACDB loader – 检索特定设备的校准信息，并写入 PMEM。ACDB 驱动程<br>序在启动过程中分配该 PMEM。在设备切换时，此校准将被发送到 DSP。<br> tinyALSA – 连接至内核 ASoC 驱动程序的接口，供音频 HAL 使用。提供用<br>于音频流和设备管理的基本 PCM 和混音控件 API。<br> Audio route – 此模块会从一个 .xml 文件读取 ALSA 混音控件，并根据音频<br>HAL 所选的设备设置混音控件。<br> Concurrency Manager - 在MSM8x10中，视频解码和编码在DSP中完成; 因此，有<br>对可支持的并发性有一些限制。MSM8x10中引入的并发管理器管理并发性<br>可以支持涉及语音和音频的不同用例</p><p>Multimedia framework – Stagefright<br> 支持标准音频格式的播放/录制<br> 与解码器/编码器库以及 OpenMAX IL 组件通信，以便进行解码和编码</p><p>Audio service<br> 由系统服务器启动并由服务管理器管理的运行时服务之一<br> 意图注册；当从各种应用程序（HDMI、蓝牙等）接收到这些意图时，通知音频<br>系统</p><p>AudioFlinger<br> 通过 libaudio 接口、蓝牙 A2DP 接口管理所有音频输出/输入设备<br> 将多个音频流处理为单一的 PCM 音频；混合后的输出被传送到输出设备<br> 播放音乐流时的音量</p><p>Audio Policy Manager (APM)<br> 定义多个音频用例之间的并发规则<br> 用例示例 – 电话通话、音乐播放、系统声音和通知<br> 定义播放的音频（例如：语音、播放、铃声）以及播放的设备（蓝牙、扬声器<br>和耳机）<br>APM 用途：<br> 管理各种输入输出设备接口<br> 管理各种输入输出设备，例如：麦克风、扬声器、耳机、听筒、A2DP、蓝牙 SCO<br> 基于音频流、模式和方法选择和定义适当的路由策略<br> 管理每个音频流的音量/静音设置（在它们激活或禁用时）</p><h4 id="（四）、参考资料-特别感谢各位前辈的分析和图示-："><a href="#（四）、参考资料-特别感谢各位前辈的分析和图示-：" class="headerlink" title="（四）、参考资料(特别感谢各位前辈的分析和图示)："></a>（四）、参考资料(特别感谢各位前辈的分析和图示)：</h4><p><a href="https://zhuanlan.zhihu.com/p/27480328" target="_blank" rel="noopener">Android音频模块启动流程分析</a><br><a href="https://zhuanlan.zhihu.com/jhuster" target="_blank" rel="noopener">Jhuster的专栏​ Android音频开发</a><br><a href="http://thinks.me/2016/09/13/audio_qcom_offload/" target="_blank" rel="noopener">高通audio offload学习 | Thinking</a><br><a href="https://blog.csdn.net/droidphone/article/category/1118446" target="_blank" rel="noopener">DroidPhone的专栏 - CSDN博客</a><br><a href="https://blog.csdn.net/orz415678659/article/details/8866071" target="_blank" rel="noopener">alsa音频架构1-CSDN博客</a><br><a href="https://blog.csdn.net/orz415678659/article/details/8982771" target="_blank" rel="noopener">alsa音频架构2-ASoc - CSDN博客</a><br><a href="https://blog.csdn.net/orz415678659/article/details/8995163" target="_blank" rel="noopener">alsa音频架构3-Pcm - CSDN博客</a><br><a href="https://blog.csdn.net/orz415678659/article/details/8999364" target="_blank" rel="noopener">alsa音频架构4-声卡控制 - CSDN博客</a><br><a href="https://blog.csdn.net/zyuanyun/article/details/59180272" target="_blank" rel="noopener">Linux ALSA 音频系统：逻辑设备篇 - CSDN博客</a><br><a href="https://blog.csdn.net/zyuanyun/article/details/59170418" target="_blank" rel="noopener">Linux ALSA 音频系统：物理链路篇 - CSDN博客</a><br><a href="https://blog.csdn.net/column/details/12812.html" target="_blank" rel="noopener">专栏：MultiMedia框架总结(基于6.0源码) - CSDN博客</a><br><a href="https://blog.csdn.net/zyuanyun/article/details/60890534" target="_blank" rel="noopener">Android 音频系统：从 AudioTrack 到 AudioFlinger - CSDN博客</a><br><a href="https://blog.csdn.net/azloong/article/category/778492" target="_blank" rel="noopener">AZURE - CSDN博客 - ALSA-Android Audio</a><br><a href="https://blog.csdn.net/azloong/article/category/777239" target="_blank" rel="noopener">AZURE - CSDN博客 - ANDROID音频系统</a><br><a href="https://winddoing.github.io/2017/07/10/audio_alsa/" target="_blank" rel="noopener">Audio驱动总结–ALSA | Winddoing’s Blog</a><br><a href="http://www.cnblogs.com/muhe221/articles/4461543.html" target="_blank" rel="noopener">audio HAL - 牧 天 - 博客园</a><br><a href="https://blog.csdn.net/xuesen_lin/article/category/1390680" target="_blank" rel="noopener">林学森的Android专栏 - CSDN博客</a><br><a href="https://blog.csdn.net/yangwen123/article/category/2589087" target="_blank" rel="noopener">深入剖析Android音频 - CSDN博客Yangwen123</a><br><a href="http://www.cnblogs.com/tocy/tag/%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6/" target="_blank" rel="noopener">播放框架 - 标签 - Tocy - 博客园</a><br><a href="https://blog.csdn.net/miaomiao12345678/article/details/57415505" target="_blank" rel="noopener">Android-7.0-Nuplayer概述 - CSDN博客</a><br><a href="https://blog.csdn.net/miaomiao12345678/article/details/56961370" target="_blank" rel="noopener">Android-7.0-Nuplayer-启动流程 - CSDN博客</a><br><a href="https://blog.csdn.net/harman_zjc/article/details/53386010" target="_blank" rel="noopener">Android Media Player 框架分析-Nuplayer（1） - CSDN博客</a><br><a href="https://blog.csdn.net/harman_zjc/article/details/53397945" target="_blank" rel="noopener">Android Media Player 框架分析-AHandler AMessage ALooper - CSDN博客</a><br><a href="https://blog.csdn.net/liu1314you/article/category/6344583" target="_blank" rel="noopener">Android N Audio播放 start真面目- (六篇) CSDN博客</a><br><a href="https://blog.csdn.net/nonmarking/article/details/78746671" target="_blank" rel="noopener">深入理解Android音视频同步机制（五篇）NuPlayer的avsync逻辑 - CSDN博客</a><br><a href="https://blog.csdn.net/u014310046/article/category/6571854" target="_blank" rel="noopener">wangyf的专栏 - CSDN博客-MT6737 Android N 平台 Audio系统学习</a><br><a href="https://blog.csdn.net/xiashaohua/article/details/53638780" target="_blank" rel="noopener">Android 7.0 Audio: Mediaplayer - CSDN博客</a><br><a href="https://blog.csdn.net/xiashaohua/article/category/6549668" target="_blank" rel="noopener">Android 7.0 Audio-相关类浅析- CSDN博客</a><br><a href="https://blog.csdn.net/liu1314you/article/details/59119144" target="_blank" rel="noopener">Android N Audio播放六：如何读取buffer - CSDN博客</a><br><a href="https://blog.csdn.net/jinzhuojun/article/details/78007568" target="_blank" rel="noopener">Fuchsia OS中的RPC机制-FIDL - CSDN博客</a><br><a href="http://www.cnblogs.com/linhaostudy/category/1145404.html" target="_blank" rel="noopener">高通Audio中ASOC的codec驱动 - yooooooo - 博客园</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;amp;&amp;amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内
      
    
    </summary>
    
      <category term="Android" scheme="http://zhoujinjian.cc/categories/Android/"/>
    
    
      <category term="Android" scheme="http://zhoujinjian.cc/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Google Pixel Oreo 8.1 OPM2.171019.029 Root 亲测成功 [i.wonder~]</title>
    <link href="http://zhoujinjian.cc/2018/04/20/Google%20Pixel%20Oreo%208.1%20OPM2.171019.029%20Root%20%E4%BA%B2%E6%B5%8B%E6%88%90%E5%8A%9F/"/>
    <id>http://zhoujinjian.cc/2018/04/20/Google Pixel Oreo 8.1 OPM2.171019.029 Root 亲测成功/</id>
    <published>2018-04-19T16:00:00.000Z</published>
    <updated>2018-04-21T06:06:04.591Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.androidinfotech.com/2018/04/root-google-pixel-oreo-8-1-opm2-171019-029.html" target="_blank" rel="noopener">Root教程原文 Root Google Pixel Oreo 8.1 OPM2.171019.029 Install TWRP</a></p><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p>✢ 电池电量高于80％。<br>✢ 数据会完全丢失不可恢复，请提前备份您的数据。<br>✢ 解锁你的Bootloader。<br>✢ 仅限Google Pixel Oreo 8.1。<br>✢ 仅限奥利奥版本。<br>✢ 笔者手机如图：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/others/google-pixel.jpg" alt="enter image description here"></p><h4 id="一、解锁Bootloader"><a href="#一、解锁Bootloader" class="headerlink" title="一、解锁Bootloader"></a>一、解锁Bootloader</h4><p>在Google Pixel Oreo 8.1 OPM2.171019.029中解锁引导加载程序bootloader</p><h5 id="1-1、OEM解锁"><a href="#1-1、OEM解锁" class="headerlink" title="1.1、OEM解锁"></a>1.1、OEM解锁</h5><p><a href="https://www.androidinfotech.com/2018/04/root-google-pixel-oreo-8-1-opm2-171019-029.html" target="_blank" rel="noopener">解锁BootLoader教程 Unlocking Bootloader in Google Pixel and Pixel XL</a><br>✢ <a href="https://bitbucket.org/Serverbee/downloadbee/downloads/adb-setup-1.4.3.exe" target="_blank" rel="noopener">下载</a>（Windows）/<a href="https://bitbucket.org/Serverbee/downloadbee/downloads/adb-mac.zip" target="_blank" rel="noopener">下载</a>（Mac）相应的ADB、Fastboot、驱动程序并将其安装到您的系统中。<br>✢ 进入 设置-&gt;关于手机 连续点击5次版本号，直到提示”你已处于开发者模式，无需进行此操作”<br>✢ 点击返回进入 “开发者模式” 打开 “OEM解锁” 和 “USB调试”<br>✢ 连接手机，若弹出提示框请选择是/允许，命令行执行：adb devices，成功会有以下类似提示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List of devices attached</span><br><span class="line">* daemon not running; starting now at tcp:5037</span><br><span class="line">* daemon started successfully</span><br><span class="line">FA7240301112    device</span><br></pre></td></tr></table></figure><p>✢ 命令行执行：adb reboot bootloader<br>✢ 执行：fastboot oem unlock<br>✢ 您需要通过增大音量按钮来确认手机中的操作。您将成功解除成功消息。当您收到此消息时，请按音量键并导航开始，然后按电源按钮。手机将重新启动。启动第一次启动需要一些时间。<br>✢ 解锁成功在开机界面会有一个打开的小锁图标</p><h5 id="1-2、将系统升级到Oreo-8-1-OPM2-171019-029稳定版"><a href="#1-2、将系统升级到Oreo-8-1-OPM2-171019-029稳定版" class="headerlink" title="1.2、将系统升级到Oreo 8.1 OPM2.171019.029稳定版"></a>1.2、将系统升级到Oreo 8.1 OPM2.171019.029稳定版</h5><p>Root Google Pixel Oreo 8.1 OPM2.171019.029稳定的版本于2018年4月发布。<br>1、<a href="https://developers.google.cn/android/images#sailfish" target="_blank" rel="noopener">Sailfish-OPM2.171019.029下载地址</a><br>2、解压运行update-all.bat（Windows）/ update-all.bat（Mac）</p><h5 id="1-3、Root-Pixel-Oreo-8-1-OPM2-171019-029有四个步骤"><a href="#1-3、Root-Pixel-Oreo-8-1-OPM2-171019-029有四个步骤" class="headerlink" title="1.3、Root Pixel Oreo 8.1 OPM2.171019.029有四个步骤"></a>1.3、Root Pixel Oreo 8.1 OPM2.171019.029有四个步骤</h5><p>✢ Install TWRP Recovery Officially in Google Pixel Oreo 8.1 OPM2.171019.029<br>✢ Install Root Files in Google Pixel Oreo 8.1 OPM2.171019.029 Using TWRP Recovery 3.2.0<br>✢ Install SuperSu in Google Pixel Oreo 8.1 OPM2.171019.029 Using TWRP Recovery 3.2.0<br>✢ Install SuperSu in Google Pixel Oreo 8.1 OPM2.171019.029 Using TWRP Recovery 3.2.0</p><h4 id="二、Install-TWRP-Recovery-Officially-in-Google-Pixel-Oreo-8-1-OPM2-171019-029"><a href="#二、Install-TWRP-Recovery-Officially-in-Google-Pixel-Oreo-8-1-OPM2-171019-029" class="headerlink" title="二、Install TWRP Recovery Officially in Google Pixel Oreo 8.1 OPM2.171019.029"></a>二、Install TWRP Recovery Officially in Google Pixel Oreo 8.1 OPM2.171019.029</h4><p><strong>步骤：</strong><br>1、确保 系统OEM解锁成功、手机版本为Oreo 8.1 OPM2.171019.029，然后执行接下来的操作<br>2、<a href="https://www.firmwares.androidinfotech.com/google-pixel-official-twrp-3-2-0-0-sailfish-img/" target="_blank" rel="noopener">下载 twrp-3.2.1-2-sailfish.img</a> Google Pixel Oreo 8.1 OPM2.171019.029的TWRP恢复镜像<br>3、通过USB连接您的手机，执行：adb reboot bootloader进入BootLoader模式（或者关机状态 Power键+音量下键进入）<br>4、确保您的手机已被系统检测到，执行：fastboot devices 会看到设备号<br>5、fastboot boot twrp-3.2.1-2-sailfish.img<br>6、重启进入下一步操作</p><h4 id="三、Install-Root-Files-in-Google-Pixel-Oreo-8-1-OPM2-171019-029-Using-TWRP-Recovery-3-2-0"><a href="#三、Install-Root-Files-in-Google-Pixel-Oreo-8-1-OPM2-171019-029-Using-TWRP-Recovery-3-2-0" class="headerlink" title="三、Install Root Files in Google Pixel Oreo 8.1 OPM2.171019.029 Using TWRP Recovery 3.2.0"></a>三、Install Root Files in Google Pixel Oreo 8.1 OPM2.171019.029 Using TWRP Recovery 3.2.0</h4><p><strong>步骤：</strong><br>1、<a href="https://www.firmwares.androidinfotech.com/twrp-pixel-installer-sailfish-3-1-1-0-zip/" target="_blank" rel="noopener">下载 twrp-pixel-installer-sailfish-3.1.1-0.zip</a>，将手机USB使用方式切换为传输文件模式，并将其复制到手机存储根目录<br>2、关掉你的手机<br>3、Power键+音量下键进入BootLoader模式模式 ，然后音量键选择 recovery mode，按power键进入Recovery模式<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/others/twrp-3-0.jpg" alt="enter image description here"><br>4、Select Wipe-&gt;Advance Wipe-&gt;Select  Data<br>5、返回到TWRP主界面：select Install<br>6、Select twrp-pixel-installer-sailfish-3.1.1-0.zip<br>安装后重新启动您的手机。</p><h4 id="四、Install-SuperSu-in-Google-Pixel-Oreo-8-1-OPM2-171019-029-Using-TWRP-Recovery-3-2-0"><a href="#四、Install-SuperSu-in-Google-Pixel-Oreo-8-1-OPM2-171019-029-Using-TWRP-Recovery-3-2-0" class="headerlink" title="四、Install SuperSu in Google Pixel Oreo 8.1 OPM2.171019.029 Using TWRP Recovery 3.2.0"></a>四、Install SuperSu in Google Pixel Oreo 8.1 OPM2.171019.029 Using TWRP Recovery 3.2.0</h4><p><strong>步骤：</strong><br>1、<a href="https://www.firmwares.androidinfotech.com/sr5-supersu-v2-82-sr5-20171001224502-zip/" target="_blank" rel="noopener">下载 SR5-SuperSU-v2.82-SR5-20171001224502.zip</a> 将手机USB使用方式切换为传输文件模式，并将其复制到手机存储根目录<br>2、关掉你的手机<br>3、Power键+音量下键进入BootLoader模式模式 ，然后音量键选择 recovery mode，按power键进入Recovery模式<br>4、Select Wipe-&gt;Advance Wipe-&gt;Select  Data<br>5、返回到TWRP主界面：select Install<br>6、Select SR5-SuperSU-v2.82-SR5-20171001224502.zip<br>安装后重新启动您的手机。</p><h4 id="五、Install-Magisk-in-Google-Pixel-Oreo-8-1-OPM2-171019-029-Using-TWRP-Recovery-3-2-0"><a href="#五、Install-Magisk-in-Google-Pixel-Oreo-8-1-OPM2-171019-029-Using-TWRP-Recovery-3-2-0" class="headerlink" title="五、Install Magisk in Google Pixel Oreo 8.1 OPM2.171019.029 Using TWRP Recovery 3.2.0"></a>五、Install Magisk in Google Pixel Oreo 8.1 OPM2.171019.029 Using TWRP Recovery 3.2.0</h4><p><strong>步骤：</strong><br>1、<a href="https://www.androidinfotech.com/2017/07/magisk-versions-download.html" target="_blank" rel="noopener">下载 Magisk-v16.1(1610).zip</a> 将手机USB使用方式切换为传输文件模式，并将其复制到手机存储根目录<br>2、关掉你的手机<br>3、Power键+音量下键进入BootLoader模式模式 ，然后音量键选择 recovery mode，按power键进入Recovery模式<br>4、Select Wipe-&gt;Advance Wipe-&gt;Select  Data<br>5、返回到TWRP主界面：select Install<br>6、Select Magisk-v16.1(1610).zip<br>安装后重新启动您的手机。</p><h4 id="六、出现的问题"><a href="#六、出现的问题" class="headerlink" title="六、出现的问题"></a>六、出现的问题</h4><p>（一）问题：adb 出现 device offline，更新adb版本到1.0.39<br>（二）问题：笔者Pixel手机执行上述步骤后，无法开机，执行以下步骤就可以开机了：<br>1、关掉你的手机<br>2、Power键+音量下键进入BootLoader模式模式，然后音量键选择 recovery mode，按power键进入Recovery模式<br>3、Select Wipe-&gt;Advance Wipe-&gt;Select  Data<br>4、滑动清除Data</p><p>Root成功，(o゜▽゜)o☆[BINGO!]</p><h4 id="七、参考资料-特别感谢各位前辈的辛苦奉献-："><a href="#七、参考资料-特别感谢各位前辈的辛苦奉献-：" class="headerlink" title="七、参考资料(特别感谢各位前辈的辛苦奉献)："></a>七、参考资料(特别感谢各位前辈的辛苦奉献)：</h4><p><a href="https://www.androidinfotech.com/2018/04/root-google-pixel-oreo-8-1-opm2-171019-029.html" target="_blank" rel="noopener">解锁BootLoader教程 Unlocking Bootloader in Google Pixel and Pixel XL</a><br><a href="https://www.androidinfotech.com/2018/04/root-google-pixel-oreo-8-1-opm2-171019-029.html" target="_blank" rel="noopener">Root教程原文 Root Google Pixel Oreo 8.1 OPM2.171019.029 Install TWRP</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.androidinfotech.com/2018/04/root-google-pixel-oreo-8-1-opm2-171019-029.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Root教程原文
      
    
    </summary>
    
      <category term="Android" scheme="http://zhoujinjian.cc/categories/Android/"/>
    
    
      <category term="Android" scheme="http://zhoujinjian.cc/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>个人网站(分享一个有趣的的Loading gif) [i.wonder~]</title>
    <link href="http://zhoujinjian.cc/2018/04/03/%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99(%E5%88%86%E4%BA%AB%E4%B8%80%E4%B8%AA%E6%9C%89%E8%B6%A3%E7%9A%84%E7%9A%84Loading%20gif)/"/>
    <id>http://zhoujinjian.cc/2018/04/03/个人网站(分享一个有趣的的Loading gif)/</id>
    <published>2018-04-02T16:00:00.000Z</published>
    <updated>2018-04-19T14:30:15.322Z</updated>
    
    <content type="html"><![CDATA[<h4 id="（一）、-Loading-gif："><a href="#（一）、-Loading-gif：" class="headerlink" title="（一）、 Loading gif："></a>（一）、 Loading gif：</h4><p>茶不思饭不想、不眠不夜折腾近两周，总算把个人网站搭建好了(๑乛◡乛๑)。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/personal.website/01-zhoujinjian.home.loading.gif" alt="Markdown"></p><h4 id="（二）、个人网站（zhoujinjian-cc）"><a href="#（二）、个人网站（zhoujinjian-cc）" class="headerlink" title="（二）、个人网站（zhoujinjian.cc）"></a>（二）、个人网站（zhoujinjian.cc）</h4><p>闷骚的主题，我想基本也不会有人来浏览我的个人网站，闷骚就闷骚点吧(๑乛◡乛๑)：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/personal.website/02-zhoujinjian.home.png" alt="Markdown"><br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/personal.website/03-zhoujinjian.home-2.png" alt="Markdown"><br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/personal.website/04-zhoujinjian.home-404.png" alt="Markdown"></p><h4 id="（三）、总结"><a href="#（三）、总结" class="headerlink" title="（三）、总结"></a>（三）、总结</h4><p>个人网站先暂时告一段落了，接下来还是继续老本行分析Android 源代码，之前分析虽已大致打通 App层 -&gt; Framework层 -&gt; Native层 -&gt; Kernel层，冒似有一定经验了然并卵，路漫漫其修远兮，生命不息，学无止境（其实嘛就是 -&gt; 人丑就要多读书๑乛◡乛๑）。好想读读书去看看外面的世界啊。</p><p>where you want to go-&gt;(Castelluccio di Norcia卡斯特鲁奇奥公园,意大利):</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/personal.website/05-zhoujinjian.home-norcaia.png" alt="Markdown"></p><p>Or-&gt;(Lofoten, Reinebringen(雷訥),挪威):</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/personal.website/06-zhoujinjian.home-lofoten.png" alt="Markdown"></p><p>PS：哇哦，好美，算了我就想想<strong>（ಡωಡ）</strong>。</p><h4 id="（四）、参考资料-特别感谢各位前辈的辛苦奉献-："><a href="#（四）、参考资料-特别感谢各位前辈的辛苦奉献-：" class="headerlink" title="（四）、参考资料(特别感谢各位前辈的辛苦奉献)："></a>（四）、参考资料(特别感谢各位前辈的辛苦奉献)：</h4><p><a href="https://bing.ioliu.cn/v1?p=1&amp;d=0&amp;w=1280&amp;h=768" target="_blank" rel="noopener">Bing 壁纸 API</a><br><a href="https://api.lylares.com/bing/image/?w=1920&amp;h=1080" target="_blank" rel="noopener">Api-bing-wallpaper</a><br><a href="https://github.com/Mrminfive/hexo-theme-skapp" target="_blank" rel="noopener">Mrminfive - Hexo-theme-skapp</a><br><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener">Molunerfinn - Hexo-theme-melody</a><br><a href="https://github.com/stkevintan/canoe-blog" target="_blank" rel="noopener">Stkevintan - canoe-blog</a><br><a href="https://www.designernews.co/404" target="_blank" rel="noopener">(404) The page you were looking for doesn’t exist</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;（一）、-Loading-gif：&quot;&gt;&lt;a href=&quot;#（一）、-Loading-gif：&quot; class=&quot;headerlink&quot; title=&quot;（一）、 Loading gif：&quot;&gt;&lt;/a&gt;（一）、 Loading gif：&lt;/h4&gt;&lt;p&gt;茶不思饭不想、不眠不
      
    
    </summary>
    
      <category term="Hexo" scheme="http://zhoujinjian.cc/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://zhoujinjian.cc/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核（Kernel-3.18） - Linux Input 子系统分析 [i.wonder~]</title>
    <link href="http://zhoujinjian.cc/2018/04/01/Linux%E5%86%85%E6%A0%B8%EF%BC%88Kernel-3-18%EF%BC%89-Input-%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90-i-wonder/"/>
    <id>http://zhoujinjian.cc/2018/04/01/Linux内核（Kernel-3-18）-Input-子系统分析-i-wonder/</id>
    <published>2018-03-31T16:00:00.000Z</published>
    <updated>2018-04-19T14:30:10.486Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/izhoujinjian/zhoujinjian.cc/tree/master/linux.input" target="_blank" rel="noopener">【博客原图链接】</a></p><p>源码（部分）：</p><p><strong>kernel/msm-3.18/include/linux</strong></p><ul><li>Input.h</li><li>evdev.h</li></ul><p><strong>kernel/msm-3.18/drivers/input</strong></p><ul><li>Input.c</li><li>evdev.c</li><li>gpio_keys.c</li></ul><p><strong>kernel/msm-3.18/drivers/input/touchscreen/synaptics_dsx_htc_2.6</strong></p><ul><li>Makefile</li><li>Kconfig</li><li>synaptics_dsx_core.c</li></ul><p><a href="https://github.com/izhoujinjian/zhoujinjian.cc/tree/master/linux.input" target="_blank" rel="noopener">【博客原图链接】</a></p><p>Google Pixel、Pixel XL 内核代码（Kernel-3.18）：</p><p><a href="https://android.googlesource.com/kernel/msm/+/android-msm-marlin-3.18-nougat-mr2-pixel" target="_blank" rel="noopener">Kernel source for Pixel and Pixel XL - Google</a> <a href="https://github.com/matthewdalex/marlin" target="_blank" rel="noopener">Kernel source for Pixel and Pixel XL - GitHub</a></p><hr><h2 id="（一）、Linux-Input-子系统框架"><a href="#（一）、Linux-Input-子系统框架" class="headerlink" title="（一）、Linux Input 子系统框架"></a>（一）、Linux Input 子系统框架</h2><p>输入(Input)子系统是分层架构的，总共分为5 层，从上到下分别是：用户空间层（User Space）事件处理层(Event Handler)、输入子系统核心层(Input Core)、硬件驱动层(Input Driver) 、硬件设备层（Hardware）。</p><p>驱动根据CORE提供的接口，向上报告发生的按键动作。然后CORE根据驱动的类型，分派这个报告给对应的事件处理层进行处理。事件处理层把数据变化反应到设备模型的文件中（事件缓冲区）。并通知在这些设备模型文件上等待的进程。</p><p>input子系统框架： </p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/linux.input/01-Linux-kernel-input-subsystem-framework.png" alt="Markdown"></p><p>(1) “硬件驱动层”负责操作具体的硬件设备，这层的代码是针对具体的驱动程序的，比如你的设备是触摸输入设备，还是鼠标输入设备，还是键盘输入设备，这些不同的设备，自然有不同的硬件操作，驱动工程师往往只需要完成这层的代码编写。</p><p>(2) “输入子系统核心层”是链接其他两层之间的纽带与桥梁，向下提供硬件驱动层的接口，向上提供事件处理层的接口。</p><p>(3) “事件处理层” 负责与用户程序打交道，将硬件驱动层传来的事件报告给用户程序。</p><p>各层之间通信的基本单位就是事件，任何一个输入设备的动作都可以抽象成一种事件，如键盘的按下，触摸屏的按下，鼠标的移动等。事件有三种属性：类型（type），编码(code)，值(value)， Input 子系统支持的所有事件都定义在 input.h中，包括所有支持的类型，所属类型支持的编码等。事件传送的方向是 硬件驱动层–&gt;子系统核心–&gt;事件处理层–&gt;用户空间。</p><h2 id="（二）、Input-主要通用数据结构"><a href="#（二）、Input-主要通用数据结构" class="headerlink" title="（二）、Input 主要通用数据结构"></a>（二）、Input 主要通用数据结构</h2><h2 id="2-1、input-dev"><a href="#2-1、input-dev" class="headerlink" title="2.1、input_dev"></a>2.1、input_dev</h2><p>输入设备 input_dev，这是input设备基本的设备结构，每个input驱动程序中都必须分配初始化这样一个结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;input.h]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;    <span class="comment">//输入设备的名称  </span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *phys;    <span class="comment">//输入设备节点名称  </span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *uniq;    <span class="comment">//指定唯一的ID号，就像MAC地址一样</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_id</span> <span class="title">id</span>;</span>    <span class="comment">//输入设备标识ID，用于和事件处理层进行匹配</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> propbit[BITS_TO_LONGS(INPUT_PROP_CNT)];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> evbit[BITS_TO_LONGS(EV_CNT)];    <span class="comment">//位图，记录设备支持的事件类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> keybit[BITS_TO_LONGS(KEY_CNT)];    <span class="comment">//位图，记录设备支持的按键类型      </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> relbit[BITS_TO_LONGS(REL_CNT)];    <span class="comment">//位图，记录设备支持的相对坐标  </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> absbit[BITS_TO_LONGS(ABS_CNT)];    <span class="comment">//位图，记录设备支持的绝对坐标</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> mscbit[BITS_TO_LONGS(MSC_CNT)];    <span class="comment">//位图，记录设备支持的其他功能</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ledbit[BITS_TO_LONGS(LED_CNT)];    <span class="comment">//位图，记录设备支持的指示灯</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sndbit[BITS_TO_LONGS(SND_CNT)];   <span class="comment">//位图，记录设备支持的声音或警报</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ffbit[BITS_TO_LONGS(FF_CNT)];     <span class="comment">//位图，记录设备支持的作用力功能  </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> swbit[BITS_TO_LONGS(SW_CNT)];     <span class="comment">//位图，记录设备支持的开关功能</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> hint_events_per_packet;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> keycodemax;      <span class="comment">//设备支持的最大按键值个数  </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> keycodesize;    <span class="comment">//每个按键的字节大小</span></span><br><span class="line">    <span class="keyword">void</span> *keycode;      <span class="comment">//指向按键池，即指向按键值数组首地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*setkeycode)(struct input_dev *dev,</span><br><span class="line">              <span class="keyword">const</span> struct input_keymap_entry *ke,</span><br><span class="line">              <span class="keyword">unsigned</span> <span class="keyword">int</span> *old_keycode);    <span class="comment">//修改按键值</span></span><br><span class="line">    <span class="keyword">int</span> (*getkeycode)(struct input_dev *dev,</span><br><span class="line">              struct input_keymap_entry *ke);   <span class="comment">//获取按键值</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ff_device</span> *<span class="title">ff</span>;</span>     <span class="comment">//用于强制更新输入设备的部分内容  </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> repeat_key;    <span class="comment">//重复按键的键值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">timer</span>;</span>   <span class="comment">//设置当有连击时的延时定时器  </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rep[REP_CNT];</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_mt</span> *<span class="title">mt</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_absinfo</span> *<span class="title">absinfo</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> key[BITS_TO_LONGS(KEY_CNT)];    <span class="comment">//位图，按键的状态  </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> led[BITS_TO_LONGS(LED_CNT)];    <span class="comment">//位图，led的状态  </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> snd[BITS_TO_LONGS(SND_CNT)];    <span class="comment">//位图，声音的状态  </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sw[BITS_TO_LONGS(SW_CNT)];   <span class="comment">//位图，开关的状态  </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*open)(struct input_dev *dev);</span><br><span class="line">    <span class="keyword">void</span> (*close)(struct input_dev *dev);</span><br><span class="line">    <span class="keyword">int</span> (*flush)(struct input_dev *dev, struct file *file);</span><br><span class="line">    <span class="keyword">int</span> (*event)(struct input_dev *dev, <span class="keyword">unsigned</span> <span class="keyword">int</span> type, <span class="keyword">unsigned</span> <span class="keyword">int</span> code, <span class="keyword">int</span> value);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_handle</span> __<span class="title">rcu</span> *<span class="title">grab</span>;</span> <span class="comment">//类似私有指针，可以直接访问到事件处理接口event  </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">spinlock_t</span> event_lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> users;</span><br><span class="line">    <span class="keyword">bool</span> going_away;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">h_list</span>;</span> <span class="comment">//该链表头用于链接此设备所关联的input_handle   </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">node</span>;</span> <span class="comment">//用于将此设备链接到input_dev_list(链接了所有注册到内核的事件处理器)  </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> num_vals;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> max_vals;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_value</span> *<span class="title">vals</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> devres_managed;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-1、input-handler"><a href="#2-1、input-handler" class="headerlink" title="2.1、input_handler"></a>2.1、input_handler</h2><p>input_handler 这是事件处理器的数据结构，代表一个事件处理器</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;input.h]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *<span class="keyword">private</span>;</span><br><span class="line">    <span class="comment">/* 当事件处理器接收到来自Input设备传来的事件时调用的处理函数,</span></span><br><span class="line"><span class="comment">        event、events用于处理事件 */</span>  </span><br><span class="line">    <span class="keyword">void</span> (*event)(struct input_handle *handle, <span class="keyword">unsigned</span> <span class="keyword">int</span> type, <span class="keyword">unsigned</span> <span class="keyword">int</span> code, <span class="keyword">int</span> value);</span><br><span class="line">    <span class="keyword">void</span> (*events)(struct input_handle *handle,</span><br><span class="line">               <span class="keyword">const</span> struct input_value *vals, <span class="keyword">unsigned</span> <span class="keyword">int</span> count);</span><br><span class="line">    <span class="keyword">bool</span> (*filter)(struct input_handle *handle, <span class="keyword">unsigned</span> <span class="keyword">int</span> type, <span class="keyword">unsigned</span> <span class="keyword">int</span> code, <span class="keyword">int</span> value);</span><br><span class="line">    <span class="comment">/* 比较 device's id with handler's id_table ，匹配device and handler*/</span></span><br><span class="line">    <span class="keyword">bool</span> (*match)(struct input_handler *handler, struct input_dev *dev);</span><br><span class="line">    <span class="comment">/* connect用于建立intput_handler和input_dev的联系,</span></span><br><span class="line"><span class="comment">       当一个Input设备注册到内核的时候被调用,将输入设备与事件处理器联结起来 */</span></span><br><span class="line">    <span class="keyword">int</span> (*connect)(struct input_handler *handler, struct input_dev *dev, <span class="keyword">const</span> struct input_device_id *id);</span><br><span class="line">    <span class="comment">/* disconnect用于解除handler和device的联系 */</span></span><br><span class="line">    <span class="keyword">void</span> (*disconnect)(struct input_handle *handle);</span><br><span class="line">    <span class="keyword">void</span> (*start)(struct input_handle *handle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> legacy_minors;</span><br><span class="line">    <span class="keyword">int</span> minor;    <span class="comment">//次设备号</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;    <span class="comment">//次设备号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_device_id</span> *<span class="title">id_table</span>;</span>    <span class="comment">//用于和device匹配 ,这个是事件处理器所支持的input设备</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个链表用来链接他所支持的input_handle结构,input_dev与input_handler配对之后就会生成一个input_handle结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">h_list</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//链接到input_handler_list，这个链表链接了所有注册到内核的事件处理器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">node</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-3、input-handle"><a href="#2-3、input-handle" class="headerlink" title="2.3、input_handle"></a>2.3、input_handle</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;input.h]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_handle</span> &#123;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    每个配对的事件处理器都会分配一个对应的设备结构，如evdev事件处理器的evdev结构，</span></span><br><span class="line"><span class="comment">    注意这个结构与设备驱动层的input_dev不同，初始化handle时，保存到这里。   </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *<span class="keyword">private</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    打开标志，每个input_handle 打开后才能操作，</span></span><br><span class="line"><span class="comment">    这个一般通过事件处理器的open方法间接设置  </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> open;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="comment">/* 指向Input_dev结构实体 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">dev</span>;</span></span><br><span class="line">    <span class="comment">/* 指向Input_Hander结构实体 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> *<span class="title">handler</span>;</span></span><br><span class="line">    <span class="comment">/* input_handle通过d_node连接到了input_dev上的h_list链表上 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">d_node</span>;</span></span><br><span class="line">    <span class="comment">/* input_handle通过h_node连接到了input_handler的h_list链表上 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">h_node</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-4、三个数据结构之间的关系"><a href="#2-4、三个数据结构之间的关系" class="headerlink" title="2.4、三个数据结构之间的关系"></a>2.4、三个数据结构之间的关系</h2><blockquote><p>input_dev: 是硬件驱动层，代表一个input设备。 input_handler: 是事件处理层，代表一个事件处理器。 input_handle: 属于核心层，代表一个配对的input_dev与input_handler</p></blockquote><p>input_dev 通过全局的input_dev_list链接在一起。设备注册的时候实现这个操作。注：（稍后详细分析）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;input.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">LIST_HEAD</span><span class="params">(input_dev_list)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">LIST_HEAD</span><span class="params">(input_handler_list)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">input_register_device</span><span class="params">(struct input_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_devres</span> *<span class="title">devres</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> *<span class="title">handler</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> packet_size;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *path;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line">    list_add_tail(&amp;dev-&gt;node, &amp;input_dev_list);</span><br><span class="line"></span><br><span class="line">    list_for_each_entry(handler, &amp;input_handler_list, node)</span><br><span class="line">        input_attach_handler(dev, handler);</span><br><span class="line"></span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>input_handler 通过全局的input_handler_list链接在一起。事件处理器注册的时候实现这个操作（事件处理器一般内核自带，一般不需要我们来写）注：（稍后详细分析）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;input.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">LIST_HEAD</span><span class="params">(input_dev_list)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">LIST_HEAD</span><span class="params">(input_handler_list)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">input_register_handler</span><span class="params">(struct input_handler *handler)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">dev</span>;</span></span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">    ......</span><br><span class="line">    list_add_tail(&amp;handler-&gt;node, &amp;input_handler_list);</span><br><span class="line"></span><br><span class="line">    list_for_each_entry(dev, &amp;input_dev_list, node)</span><br><span class="line">        input_attach_handler(dev, handler);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>input_hande 没有一个全局的链表，它注册的时候将自己分别挂在了input_dev 和 input_handler 的h_list上了。通过input_dev 和input_handler就可以找到input_handle在设备注册和事件处理器，注册的时候都要进行配对工作<strong>(input_match_device)</strong>，配对后就会实现链接<strong>(handler-&gt;connect)</strong>通过input_handle也可以找到input_dev和input_handler。注：（稍后详细分析）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;input.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">input_attach_handler</span><span class="params">(struct input_dev *dev, struct input_handler *handler)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_device_id</span> *<span class="title">id</span>;</span></span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    id = input_match_device(handler, dev);</span><br><span class="line">    ......</span><br><span class="line">    error = handler-&gt;connect(handler, dev, id);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，input_device和input_handler中都有一个h_list,而input_handle拥有指向input_dev和input_handler的指针，也就是说input_handle是用来关联input_dev和input_handler的。 那么为什么一个input_device和input_handler中拥有的是h_list而不是一个handle呢？因为一个device可能对应多个handler,而一个handler也不能只处理一个device,比如说一个鼠标，它可以对应even handler，也可以对应mouse handler,因此当其注册时与系统中的handler进行匹配，就有可能产生两个实例，一个是evdev,另一个是mousedev,而任何一个实例中都只有一个handle。至于以何种方式来传递事件，就由用户程序打开哪个实例来决定。后面一个情况很容易理解，一个事件驱动不能只为一个甚至一种设备服务，系统中可能有多种设备都能使用这类handler,比如event handler就可以匹配所有的设备。在input子系统中，有8种事件驱动，每种事件驱动最多可以对应32个设备，因此dev实例总数最多可以达到256个。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/linux.input/02-Linux-kernel-input-dev-handler.png" alt="Markdown"></p><h2 id="（三）、Input-核心层（Input-c）"><a href="#（三）、Input-核心层（Input-c）" class="headerlink" title="（三）、Input 核心层（Input.c）"></a>（三）、Input 核心层（Input.c）</h2><p>这一节主要介绍核心层的初始化，input_device、input_handle、input_handler之间的关系(稍后回头看更佳)。 总体概览图：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/linux.input/03-Linux-kernel-input-core-h_list.png" alt="Markdown"></p><h2 id="3-1、输入核心层：初始化"><a href="#3-1、输入核心层：初始化" class="headerlink" title="3.1、输入核心层：初始化"></a>3.1、输入核心层：初始化</h2><p>首先从驱动”入口函数”开始查看</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;input.c]</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">input_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="comment">//注册input类，可在/sys/class下看到对应节点文件</span></span><br><span class="line">    err = class_register(&amp;input_class);</span><br><span class="line">    ......</span><br><span class="line">    err = input_proc_init();<span class="comment">/*创建/proc中的项，查看/proc/bus/input  */</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/*注册设备/dev/input，主设备号为INPUT_MAJOR，就是13，后面注册的输入设备都使用该主设备号*/</span></span><br><span class="line">    err = register_chrdev_region(MKDEV(INPUT_MAJOR, <span class="number">0</span>),</span><br><span class="line">                     INPUT_MAX_CHAR_DEVICES, <span class="string">"input"</span>);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在入口函数里面创建了一个input_class类，其实就在/sys/class下创建了一个目录input.当然对于一个新设备，可以注册进一个class也可以不注册进去，如果存在对应class的话注册进去更好，另外在/proc创建了入口项,这样就可以/proc目录看到input的信息，然后就注册设备，可以看出输入子系统的主设备号是13，在这里并没有生成设备文件。只是在/dev/目录下创建了input目录，以后所有注册进系统的输入设备文件都放在这个目录下。</p><p>相应的对应关系可以使用adb 命令进入文件系统之后，cat /proc/bus/input/devices ，查看各个设备对应的event多少，比如Google Pixel 手机：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">I: Bus=<span class="number">0000</span> Vendor=<span class="number">0000</span> Product=<span class="number">0003</span> Version=<span class="number">2066</span></span><br><span class="line">N: Name=<span class="string">"synaptics_dsxv26"</span></span><br><span class="line">P: Phys=synaptics_dsx/touch_input</span><br><span class="line">S: Sysfs=/devices/soc/<span class="number">7577000.</span>i2c/i2c<span class="number">-3</span>/<span class="number">3</span><span class="number">-0020</span>/input/input3</span><br><span class="line">U: Uniq=</span><br><span class="line">H: Handlers=mdss_fb kgsl event3</span><br><span class="line">B: PROP=<span class="number">2</span></span><br><span class="line">B: EV=b</span><br><span class="line">B: KEY=<span class="number">8000</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">B: ABS=<span class="number">663800000000000</span></span><br></pre></td></tr></table></figure><p>event3 就是事件序号， 我们在调试的时候直接 adb shell getevent /dev/input/event3，来实时捕捉 event3 中储存的数据。</p><p>那么接下来看看怎么注册input设备的.我们需要在设备驱动层中完成输入设备的注册，通过调用input_register_device()函数来完成，该函数的一个重要任务就是完成设备与事件驱动的匹配</p><h2 id="3-2、输入核心层：注册设备input-dev"><a href="#3-2、输入核心层：注册设备input-dev" class="headerlink" title="3.2、输入核心层：注册设备input_dev"></a>3.2、输入核心层：注册设备input_dev</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;input.c]</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">input_register_device</span><span class="params">(struct input_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_devres</span> *<span class="title">devres</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> *<span class="title">handler</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> packet_size;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *path;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;devres_managed) &#123;</span><br><span class="line">        devres = devres_alloc(devm_input_device_unregister,</span><br><span class="line">                      <span class="keyword">sizeof</span>(struct input_devres), GFP_KERNEL);</span><br><span class="line">        ......</span><br><span class="line">        devres-&gt;input = dev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//EN_SYN这个是设备都要支持的事件类型，所以要设置   </span></span><br><span class="line">    <span class="comment">/* Every input device generates EV_SYN/SYN_REPORT events. */</span></span><br><span class="line">    __set_bit(EV_SYN, dev-&gt;evbit);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* KEY_RESERVED is not supposed to be transmitted to userspace. */</span></span><br><span class="line">    __clear_bit(KEY_RESERVED, dev-&gt;keybit);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure that bitmasks not mentioned in dev-&gt;evbit are clean. */</span></span><br><span class="line">    input_cleanse_bitmasks(dev);</span><br><span class="line"></span><br><span class="line">    packet_size = input_estimate_events_per_packet(dev);</span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;hint_events_per_packet &lt; packet_size)</span><br><span class="line">        dev-&gt;hint_events_per_packet = packet_size;</span><br><span class="line"></span><br><span class="line">    dev-&gt;max_vals = dev-&gt;hint_events_per_packet + <span class="number">2</span>;</span><br><span class="line">    dev-&gt;vals = kcalloc(dev-&gt;max_vals, <span class="keyword">sizeof</span>(*dev-&gt;vals), GFP_KERNEL);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If delay and period are pre-set by the driver, then autorepeating</span></span><br><span class="line"><span class="comment">     * is handled by the driver itself and we don't do it in input.c.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">// 这个定时器是为了重复按键而设置的</span></span><br><span class="line">    <span class="keyword">if</span> (!dev-&gt;rep[REP_DELAY] &amp;&amp; !dev-&gt;rep[REP_PERIOD]) &#123;</span><br><span class="line">        dev-&gt;timer.data = (<span class="keyword">long</span>) dev;</span><br><span class="line">        dev-&gt;timer.function = input_repeat_key;</span><br><span class="line">        dev-&gt;rep[REP_DELAY] = <span class="number">250</span>;</span><br><span class="line">        dev-&gt;rep[REP_PERIOD] = <span class="number">33</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 如果设备驱动没有设置自己的获取键值的函数，系统默认 */</span>  </span><br><span class="line">    <span class="keyword">if</span> (!dev-&gt;getkeycode)</span><br><span class="line">        dev-&gt;getkeycode = input_default_getkeycode;</span><br><span class="line">    <span class="comment">/* 如果设备驱动没有指定按键重置函数，系统默认 */</span>  </span><br><span class="line">    <span class="keyword">if</span> (!dev-&gt;setkeycode)</span><br><span class="line">        dev-&gt;setkeycode = input_default_setkeycode;</span><br><span class="line"></span><br><span class="line">    error = device_add(&amp;dev-&gt;dev);</span><br><span class="line">    ......</span><br><span class="line">    path = kobject_get_path(&amp;dev-&gt;dev.kobj, GFP_KERNEL);</span><br><span class="line">    pr_info(<span class="string">"%s as %s\n"</span>,</span><br><span class="line">        dev-&gt;name ? dev-&gt;name : <span class="string">"Unspecified device"</span>,</span><br><span class="line">        path ? path : <span class="string">"N/A"</span>);</span><br><span class="line">    kfree(path);</span><br><span class="line"></span><br><span class="line">    error = mutex_lock_interruptible(&amp;input_mutex);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 将新分配的input设备连接到input_dev_list链表上  </span></span><br><span class="line">    list_add_tail(&amp;dev-&gt;node, &amp;input_dev_list);</span><br><span class="line">    <span class="comment">/* 核心重点，input设备在增加到input_dev_list链表上之后，会查找</span></span><br><span class="line"><span class="comment">     * input_handler_list事件处理链表上的handler进行匹配，这里的匹配</span></span><br><span class="line"><span class="comment">     * 方式与设备模型的device和driver匹配过程很相似，所有的input</span></span><br><span class="line"><span class="comment">     * 都挂在input_dev_list上，所有类型的事件都挂在input_handler_list</span></span><br><span class="line"><span class="comment">     * 上，进行“匹配相亲”，list_for_each_entry就是个for循环，跳出条件遍历了一遍，又回到链表头 */</span>  </span><br><span class="line">    list_for_each_entry(handler, &amp;input_handler_list, node)</span><br><span class="line">        input_attach_handler(dev, handler);</span><br><span class="line"></span><br><span class="line">    input_wakeup_procfs_readers();</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;input_mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;devres_managed) &#123;</span><br><span class="line">        dev_dbg(dev-&gt;dev.parent, <span class="string">"%s: registering %s with devres.\n"</span>,</span><br><span class="line">            __func__, dev_name(&amp;dev-&gt;dev));</span><br><span class="line">        devres_add(dev-&gt;dev.parent, devres);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码主要的功能有以下几个功能，也是设备驱动注册为输入设备委托内核做的事情：</p><p>1、进一步初始化输入设备，例如连击事件 2、注册输入设备到input类中，把输入设备挂到输入设备链表input_dev_list中 3、查找并匹配输入设备对应的事件处理层，通过input_handler_list链表</p><p>我们需要再分析下这个匹配的过程，input_attach_handler()匹配过程如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;input.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">input_attach_handler</span><span class="params">(struct input_dev *dev, struct input_handler *handler)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_device_id</span> *<span class="title">id</span>;</span></span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">    <span class="comment">/* input_dev 和 input_handler 进行匹配,返回匹配的id，类型是struct input_device_id  */</span>  </span><br><span class="line">    id = input_match_device(handler, dev);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/* 匹配成功，调用handler里面的connect函数,这个函数在事件处理器中定义，主要生成一个input_handle结构，并初始化，还生成一个事件处理器相关的设备结构 */</span>  </span><br><span class="line">    error = handler-&gt;connect(handler, dev, id);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先来看下input_match_device（）函数，看一下这个匹配的条件是什么，如何匹配的过程是怎样的，匹配的结果会是什么</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;input.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> struct input_device_id *<span class="title">input_match_device</span><span class="params">(struct input_handler *handler,</span></span></span><br><span class="line"><span class="function"><span class="params">                            struct input_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_device_id</span> *<span class="title">id</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (id = handler-&gt;id_table; id-&gt;flags || id-&gt;driver_info; id++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_BUS)</span><br><span class="line">            <span class="keyword">if</span> (id-&gt;bustype != dev-&gt;id.bustype) <span class="comment">//匹配总线id</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_VENDOR)</span><br><span class="line">            <span class="keyword">if</span> (id-&gt;vendor != dev-&gt;id.vendor)  <span class="comment">//匹配生产商id</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_PRODUCT)</span><br><span class="line">            <span class="keyword">if</span> (id-&gt;product != dev-&gt;id.product)  <span class="comment">//匹配产品id  </span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_VERSION)</span><br><span class="line">            <span class="keyword">if</span> (id-&gt;version != dev-&gt;id.version) <span class="comment">//匹配版本  </span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//匹配id的evbit和input_dev中evbit的各个位，如果不匹配则continue，数组中下一个设备  </span></span><br><span class="line">        <span class="keyword">if</span> (!bitmap_subset(id-&gt;evbit, dev-&gt;evbit, EV_MAX))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (!bitmap_subset(id-&gt;swbit, dev-&gt;swbit, SW_MAX))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!handler-&gt;match || handler-&gt;match(handler, dev))</span><br><span class="line">            <span class="keyword">return</span> id;<span class="comment">//匹配成功,返回id</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>input_match_device() 到最合适的事件处理层驱动时，便执行handler-&gt;connect() 函数进行连接了，看下面这部分代码（以evdev类型驱动为例，在input/evdev.c中）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;evdev.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">evdev_connect</span><span class="params">(struct input_handler *handler, struct input_dev *dev,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">const</span> struct input_device_id *id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evdev</span> *<span class="title">evdev</span>;</span></span><br><span class="line">    <span class="keyword">int</span> minor;</span><br><span class="line">    <span class="keyword">int</span> dev_no;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">    <span class="comment">/* EVDEV_MINORS为32，代表共能容纳32个evdev事件层设备，下面代码在找到空的地方，用于保存evdev事件层的数据，即上面定义的evdev */</span></span><br><span class="line">    minor = input_get_new_minor(EVDEV_MINOR_BASE, EVDEV_MINORS, <span class="literal">true</span>);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/* 开始给evdev事件层驱动分配空间了 */</span></span><br><span class="line">    evdev = kzalloc(<span class="keyword">sizeof</span>(struct evdev), GFP_KERNEL);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/* 初始化client_list列表和evdev_wait队列，后面介绍 */</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;evdev-&gt;client_list);</span><br><span class="line">    spin_lock_init(&amp;evdev-&gt;client_lock);</span><br><span class="line">    mutex_init(&amp;evdev-&gt;mutex);</span><br><span class="line">    init_waitqueue_head(&amp;evdev-&gt;wait);</span><br><span class="line">    evdev-&gt;exist = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">/* 初始化evdev结构体，其中handle为输入设备和事件处理的关联接口 */</span></span><br><span class="line">    dev_no = minor;</span><br><span class="line">    <span class="comment">/* Normalize device number if it falls into legacy range */</span></span><br><span class="line">    <span class="keyword">if</span> (dev_no &lt; EVDEV_MINOR_BASE + EVDEV_MINORS)</span><br><span class="line">        dev_no -= EVDEV_MINOR_BASE;</span><br><span class="line">    dev_set_name(&amp;evdev-&gt;dev, <span class="string">"event%d"</span>, dev_no);</span><br><span class="line">    <span class="comment">/*这里就将handle的dev指针指向了input_dev*/</span></span><br><span class="line">    evdev-&gt;handle.dev = input_get_device(dev);</span><br><span class="line">    evdev-&gt;handle.name = dev_name(&amp;evdev-&gt;dev);</span><br><span class="line">    evdev-&gt;handle.handler = handler;<span class="comment">/*这里将handle的handler指向了当前的input_handler.注意本函数evdev_connect,可能是在在输入设备注册的时候</span></span><br><span class="line"><span class="comment">38     在input_register_device函数中调用input_attach_handler的时候调用;也可能是在输入设备的处理方法input_handler时在input_register_handler</span></span><br><span class="line"><span class="comment">39     函数中也会用到input_attach_handler函数,就会调用本函数.这里就很明显了,本函数就将input_handler和input_dev都放在input_handle中统一管理*/</span></span><br><span class="line">    evdev-&gt;handle.<span class="keyword">private</span> = evdev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*初始化evdev中的内嵌device*/</span></span><br><span class="line">    evdev-&gt;dev.devt = MKDEV(INPUT_MAJOR, minor);</span><br><span class="line">    evdev-&gt;dev.class = &amp;input_class;</span><br><span class="line">    evdev-&gt;dev.parent = &amp;dev-&gt;dev;</span><br><span class="line">    evdev-&gt;dev.release = evdev_free;</span><br><span class="line">    device_initialize(&amp;evdev-&gt;dev);</span><br><span class="line">   <span class="comment">/* input_dev设备驱动层和input_handler事件处理层的关联，由input_handle完成(不要和handler搞混淆了，这不是一个概念～) */</span>  </span><br><span class="line">    error = input_register_handle(&amp;evdev-&gt;handle);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    cdev_init(&amp;evdev-&gt;cdev, &amp;evdev_fops);</span><br><span class="line">    evdev-&gt;cdev.kobj.parent = &amp;evdev-&gt;dev.kobj;</span><br><span class="line">    error = cdev_add(&amp;evdev-&gt;cdev, evdev-&gt;dev.devt, <span class="number">1</span>);</span><br><span class="line">    ......</span><br><span class="line">    error = device_add(&amp;evdev-&gt;dev);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3、输入核心层：注册input-handler"><a href="#3-3、输入核心层：注册input-handler" class="headerlink" title="3.3、输入核心层：注册input_handler"></a>3.3、输入核心层：注册input_handler</h2><p>为了逻辑更清新，我们稍后再来看input_register_handle() 程，先来了解input_handler的注册过程。 要了解input_handler的注册过程，又需要先了解evdev初始化过程（以evdev为例）： /kernel/drivers/input下众多事件处理器handler其中的一个，可以看下源码/kernel/drivers/input/evdev.c中的模块init</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;edev.c]</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">evdev_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> input_register_handler(&amp;evdev_handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个初始化就是往input核心中注册一个input_handler类型的evdev_handler，调用的是input.c提供的接口，input_handler结构前面有介绍，看下evdev_handler的赋值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;edev.c]</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> <span class="title">evdev_handler</span> = &#123;</span></span><br><span class="line">    .event        = evdev_event,</span><br><span class="line">    .events        = evdev_events,</span><br><span class="line">    .connect    = evdev_connect,</span><br><span class="line">    .disconnect    = evdev_disconnect,</span><br><span class="line">    .legacy_minors    = <span class="literal">true</span>,</span><br><span class="line">    .minor        = EVDEV_MINOR_BASE,</span><br><span class="line">    .name        = <span class="string">"evdev"</span>,</span><br><span class="line">    .id_table    = evdev_ids,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以注意的是evdev是匹配所有设备的，因为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;edev.c]</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_device_id</span> <span class="title">evdev_ids</span>[] = &#123;</span></span><br><span class="line">    &#123; .driver_info = <span class="number">1</span> &#125;,    <span class="comment">/* Matches all devices */</span></span><br><span class="line">    &#123; &#125;,            <span class="comment">/* Terminating zero entry */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;input.c]</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">input_register_handler</span><span class="params">(struct input_handler *handler)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">dev</span>;</span></span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    error = mutex_lock_interruptible(&amp;input_mutex);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    INIT_LIST_HEAD(&amp;handler-&gt;h_list);</span><br><span class="line">    <span class="comment">//添加进input_handler_list全局链表</span></span><br><span class="line">    list_add_tail(&amp;handler-&gt;node, &amp;input_handler_list);</span><br><span class="line">    <span class="comment">//同样遍历input_dev这个链表，依次调用下面的input_attach_handler去匹配input_dev,这个跟input_dev注册的时候的情形类似  </span></span><br><span class="line">    list_for_each_entry(dev, &amp;input_dev_list, node)</span><br><span class="line">        input_attach_handler(dev, handler);</span><br><span class="line"></span><br><span class="line">    input_wakeup_procfs_readers();</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;input_mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4、输入核心层：注册input-handle（不要和handler搞混淆了哦，这不是一个概念～）"><a href="#3-4、输入核心层：注册input-handle（不要和handler搞混淆了哦，这不是一个概念～）" class="headerlink" title="3.4、输入核心层：注册input_handle（不要和handler搞混淆了哦，这不是一个概念～）"></a>3.4、输入核心层：注册input_handle（不要和handler搞混淆了哦，这不是一个概念～）</h2><p>input_handle关联匹配input_dev和input_handler 继续分析input_dev和input_handler 是如何关联上的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;input.c]</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">input_register_handle</span><span class="params">(struct input_handle *handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> *<span class="title">handler</span> = <span class="title">handle</span>-&gt;<span class="title">handler</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">dev</span> = <span class="title">handle</span>-&gt;<span class="title">dev</span>;</span></span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    error = mutex_lock_interruptible(&amp;dev-&gt;mutex);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将d_node链接到输入设备的h_list，h_node链接到事件层的h_list链表上</span></span><br><span class="line"><span class="comment">    * 因此，在handle中是输入设备和事件层的关联结构体，通过输入设备可以</span></span><br><span class="line"><span class="comment">    * 找到对应的事件处理层接口，通过事件处理层也可找到匹配的输入设备</span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//把这个handle的d_node 加到对应input_dev的h_list链表里面  </span></span><br><span class="line">    <span class="keyword">if</span> (handler-&gt;filter)</span><br><span class="line">        list_add_rcu(&amp;handle-&gt;d_node, &amp;dev-&gt;h_list);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        list_add_tail_rcu(&amp;handle-&gt;d_node, &amp;dev-&gt;h_list);</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;dev-&gt;mutex);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//把这个handle的h_node 加到对应input_handler的h_list链表里面</span></span><br><span class="line">    list_add_tail_rcu(&amp;handle-&gt;h_node, &amp;handler-&gt;h_list);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (handler-&gt;start)</span><br><span class="line">        handler-&gt;start(handle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个注册是把handle 本身的链表加入到它自己的input_dev 以及 input_handler的h_list链表中，这样以后就可以通过h_list遍历到这个handle，这样就实现了三者的绑定联系。</p><p>以上是输入设备驱动注册的全过程，纵观整个过程，输入设备驱动最终的目的就是能够与事件处理层的事件驱动相互匹配，但是在drivers/input目录下有evdev.c事件驱动、mousedev.c事件驱动、joydev.c事件驱动等等，我们的输入设备产生的事件应该最终上报给谁，然后让事件被谁去处理呢？知道了这么个原因再看上面代码就会明白，其实evdev.c、mousedev.c等根据硬件输入设备的处理方式的不同抽象出了不同的事件处理接口帮助上层去调用，而我们写的设备驱动程序只不过是完成了硬件寄存器中数据的读写，但提交给用户的事件必须是经过事件处理层的封装和同步才能够完成的，事件处理层提供给用户一个统一的界面来操作。 整个关联注册的过程：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/linux.input/04-Linux-kernel-input-reg-device.png" alt="Markdown"></p><h2 id="（四）、Input-事件处理层-Event-handler-（以evdev事件处理器为例）"><a href="#（四）、Input-事件处理层-Event-handler-（以evdev事件处理器为例）" class="headerlink" title="（四）、Input 事件处理层 Event handler （以evdev事件处理器为例）"></a>（四）、Input 事件处理层 Event handler （以evdev事件处理器为例）</h2><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/linux.input/05-Linux-kernel-input-event-hardware.png" alt="Markdown"></p><h2 id="4-1、主要数据结构"><a href="#4-1、主要数据结构" class="headerlink" title="4.1、主要数据结构"></a>4.1、主要数据结构</h2><p><strong>（1） evdev设备结构</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[evdev.h]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evdev</span> &#123;</span>   </span><br><span class="line">    <span class="keyword">int</span> exist;   </span><br><span class="line">    <span class="keyword">int</span> open;                     <span class="comment">//打开标志   </span></span><br><span class="line">    <span class="keyword">int</span> minor;                    <span class="comment">//次设备号   </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_handle</span> <span class="title">handle</span>;</span>   <span class="comment">//关联的input_handle   </span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> wait;       <span class="comment">//等待队列，当进程读取设备，而没有事件产生的时候，进程就会睡在其上面   </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evdev_client</span> *<span class="title">grab</span>;</span>    <span class="comment">//强制绑定的evdev_client结构，这个结构后面再分析   </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">client_list</span>;</span> <span class="comment">//evdev_client 链表，这说明一个evdev设备可以处理多个evdev_client，可以有多个进程访问evdev设备   </span></span><br><span class="line">    <span class="keyword">spinlock_t</span> client_lock;       <span class="comment">/* protects client_list */</span>   </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span>   </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span>            <span class="comment">//device结构，说明这是一个设备结构   </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>evdev结构体在配对成功的时候生成，由handler-&gt;connect生成，对应设备文件为/class/input/event(n)，如触摸屏驱动的event3，这个设备是用户空间要访问的设备，可以理解它是一个虚拟设备，因为没有对应的硬件，但是通过handle-&gt;dev 就可以找到input_dev结构，而它对应着触摸屏，设备文件为/class/input/input3。这个设备结构生成之后保存在evdev_table中，索引值是minor。 <strong>（2）evdev用户端结构</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[evdev.h]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evdev_client</span> &#123;</span>  </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> head;  <span class="comment">//buffer数组的索引头  </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> tail;   <span class="comment">//buffer数组的索引尾  </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> packet_head; <span class="comment">/* [future] position of the first element of next packet */</span>  </span><br><span class="line">    <span class="keyword">spinlock_t</span> buffer_lock; <span class="comment">/* protects access to buffer, head and tail */</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">wake_lock</span> <span class="title">wake_lock</span>;</span>  </span><br><span class="line">    <span class="keyword">bool</span> use_wake_lock;  </span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">28</span>];  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync</span>;</span>    <span class="comment">//异步通知函数  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evdev</span> *<span class="title">evdev</span>;</span>  <span class="comment">//包含一个evdev变量  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span>  <span class="comment">//链表  </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> bufsize;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> <span class="title">buffer</span>[];</span>   <span class="comment">//input_event数据结构的数组，input_event代表一个事件，基本成员：类型（type），编码（code），值（value）  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个结构在进程打开event3设备的时候调用evdev的open方法，在open中创建这个结构，并初始化。在关闭设备文件的时候释放这个结构。 <strong>（3）input_event结构</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[input.h]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">time</span>;</span>    <span class="comment">//事件发生的时间   </span></span><br><span class="line">    __u16 type;             <span class="comment">//事件类型   </span></span><br><span class="line">    __u16 code;             <span class="comment">//子事件   </span></span><br><span class="line">    __s32 value;            <span class="comment">//事件的value  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-2、事件处理层evdev"><a href="#4-2、事件处理层evdev" class="headerlink" title="4.2、事件处理层evdev"></a>4.2、事件处理层evdev</h2><p>事件处理层与用户程序和输入子系统核心打交道，是他们两层的桥梁。一般内核有好几个事件处理器，像evdev mousedev jotdev。evdev事件处理器可以处理所有的事件，触摸屏驱动就是用的这个，所以下面分析这个事件处理器的实现。它也是作为模块注册到内核中的,前面已经分析过它的模块初始化函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;evdev.c]</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">evdev_fops</span> = &#123;</span></span><br><span class="line">    .owner        = THIS_MODULE,</span><br><span class="line">    .read        = evdev_read,</span><br><span class="line">    .write        = evdev_write,</span><br><span class="line">    .poll        = evdev_poll,</span><br><span class="line">    .open        = evdev_open,</span><br><span class="line">    .release    = evdev_release,</span><br><span class="line">    .unlocked_ioctl    = evdev_ioctl,</span><br><span class="line">#ifdef CONFIG_COMPAT</span><br><span class="line">    .compat_ioctl    = evdev_ioctl_compat,</span><br><span class="line">#endif</span><br><span class="line">    .fasync        = evdev_fasync,</span><br><span class="line">    .flush        = evdev_flush,</span><br><span class="line">    .llseek        = no_llseek,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果匹配上了就会创建一个evdev，它里边封装了一个handle，会把input_dev和input_handler关联到一起。关系如下：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/linux.input/06-Linux-kernel-input-evdev-connect.png" alt="Markdown"></p><h2 id="4-3、evdev设备结点的open-操作"><a href="#4-3、evdev设备结点的open-操作" class="headerlink" title="4.3、evdev设备结点的open()操作"></a>4.3、evdev设备结点的open()操作</h2><p>我们知道.对主设备号为INPUT_MAJOR的设备节点进行操作，会将操作集转换成handler的操作集。在evdev中，这个操作集就是evdev_fops。对应的open函数如下示：</p><p>首先来看打开event(x)设备文件，evdev_open函数.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;evdev.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">evdev_open</span><span class="params">(struct inode *inode, struct file *file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evdev</span> *<span class="title">evdev</span> = <span class="title">container_of</span>(<span class="title">inode</span>-&gt;<span class="title">i_cdev</span>, <span class="title">struct</span> <span class="title">evdev</span>, <span class="title">cdev</span>);</span></span><br><span class="line">    <span class="comment">//evdev_client的buffer大小  </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> bufsize = evdev_compute_buffer_size(evdev-&gt;handle.dev);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size = <span class="keyword">sizeof</span>(struct evdev_client) +</span><br><span class="line">                    bufsize * <span class="keyword">sizeof</span>(struct input_event);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evdev_client</span> *<span class="title">client</span>;</span></span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">    <span class="comment">//打开的时候创建一个evdev_client</span></span><br><span class="line">    client = kzalloc(size, GFP_KERNEL | __GFP_NOWARN);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    client-&gt;bufsize = bufsize;</span><br><span class="line">    spin_lock_init(&amp;client-&gt;buffer_lock);</span><br><span class="line">    <span class="built_in">snprintf</span>(client-&gt;name, <span class="keyword">sizeof</span>(client-&gt;name), <span class="string">"%s-%d"</span>,</span><br><span class="line">            dev_name(&amp;evdev-&gt;dev), task_tgid_vnr(current));</span><br><span class="line">    client-&gt;evdev = evdev;</span><br><span class="line">    evdev_attach_client(evdev, client);</span><br><span class="line">    <span class="comment">//调用打开真正的底层设备函数  </span></span><br><span class="line">    error = evdev_open_device(evdev);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    file-&gt;private_data = client;</span><br><span class="line">    nonseekable_open(inode, file);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">evdev_open_device</span><span class="params">(struct evdev *evdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">    retval = mutex_lock_interruptible(&amp;evdev-&gt;mutex);</span><br><span class="line">    <span class="keyword">if</span> (retval)<span class="comment">/*如果设备不存在，返回错误*/</span>  </span><br><span class="line">        <span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!evdev-&gt;exist)</span><br><span class="line">        retval = -ENODEV;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!evdev-&gt;open++) &#123;<span class="comment">//递增打开计数  </span></span><br><span class="line">        retval = input_open_device(&amp;evdev-&gt;handle);<span class="comment">//如果是被第一次打开，则调用input_open_device</span></span><br><span class="line">        <span class="keyword">if</span> (retval)</span><br><span class="line">            evdev-&gt;open--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;evdev-&gt;mutex);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">input_open_device</span><span class="params">(struct input_handle *handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">dev</span> = <span class="title">handle</span>-&gt;<span class="title">dev</span>;</span><span class="comment">//根据input_handle找到对应的input_dev设备  </span></span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">    retval = mutex_lock_interruptible(&amp;dev-&gt;mutex);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    handle-&gt;open++;<span class="comment">//递增handle的打开计数  </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dev-&gt;users++ &amp;&amp; dev-&gt;open)</span><br><span class="line">        retval = dev-&gt;open(dev);<span class="comment">//如果是第一次打开.则调用input device的open()函数  </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (retval) &#123;</span><br><span class="line">        dev-&gt;users--;</span><br><span class="line">        <span class="keyword">if</span> (!--handle-&gt;open) &#123;</span><br><span class="line">            synchronize_rcu();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> out:</span><br><span class="line">    mutex_unlock(&amp;dev-&gt;mutex);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-4、用户进程读取event的底层实现"><a href="#4-4、用户进程读取event的底层实现" class="headerlink" title="4.4、用户进程读取event的底层实现"></a>4.4、用户进程读取event的底层实现</h2><p>至于具体的如何初始化input_dev，这个是具体的输入设备去实现的，稍后具体实例再分析，现在来看看，对于一个event(x)设备文件的，应用程序来读，最终会导致”handler”里面的的”读函数”被调用。</p><p>evdev_fops 结 构 体 是 一 个 file_operations 的 类 型 。 当 用 户 层 调 用 类 似 代 码open(“/dev/input/event3” , O_RDONLY) 函 数 打 开 设 备 结 点 时 , 会 调 用 evdev_fops 中 的evdev_read()函数,该函数的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;evdev.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">evdev_read</span><span class="params">(struct file *file, <span class="keyword">char</span> __user *buffer,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *ppos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evdev_client</span> *<span class="title">client</span> = <span class="title">file</span>-&gt;<span class="title">private_data</span>;</span><span class="comment">//就是刚才在open函数中保存的evdev_client  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evdev</span> *<span class="title">evdev</span> = <span class="title">client</span>-&gt;<span class="title">evdev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> <span class="title">event</span>;</span></span><br><span class="line">    <span class="keyword">size_t</span> read = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//如果获得了数据则取出来，调用evdev_fetch_next_event  </span></span><br><span class="line">        <span class="keyword">while</span> (read + input_event_size() &lt;= count &amp;&amp;</span><br><span class="line">               evdev_fetch_next_event(client, &amp;event)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//input_event_to_user调用copy_to_user传入用户程序中，这样读取完成  </span></span><br><span class="line">            <span class="keyword">if</span> (input_event_to_user(buffer + read, &amp;event))</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">            read += input_event_size();</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">/*如果是可阻塞状态的话,则等待在wait队列上.直到有数据要被处理,当前进程才被唤醒.这很好理解,既然是</span></span><br><span class="line"><span class="comment">         输入设备,读的话比如读按键,那么必须要有硬件设备有按键按下才会返回按键值,这里还是处于事件处理层,应用程序在这里休眠,那么谁来唤醒?</span></span><br><span class="line"><span class="comment">         当然是有按键按下才去唤醒,因此这个工作就交给了设备驱动层,那么找到这个唤醒呢,直接去找不好找,那么可以直接搜索evdev-&gt;wait,搜索结果</span></span><br><span class="line"><span class="comment">         可知evdev-&gt;wait在evdev_event()函数中被唤醒*/</span></span><br><span class="line">        <span class="keyword">if</span> (!(file-&gt;f_flags &amp; O_NONBLOCK)) &#123;</span><br><span class="line">            error = wait_event_interruptible(evdev-&gt;wait,</span><br><span class="line">                    client-&gt;packet_head != client-&gt;tail ||</span><br><span class="line">                    !evdev-&gt;exist || client-&gt;revoked);</span><br><span class="line">            <span class="keyword">if</span> (error)</span><br><span class="line">                <span class="keyword">return</span> error;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> read;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">evdev_fetch_next_event</span><span class="params">(struct evdev_client *client,</span></span></span><br><span class="line"><span class="function"><span class="params">                  struct input_event *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> have_event;</span><br><span class="line"></span><br><span class="line">    spin_lock_irq(&amp;client-&gt;buffer_lock);</span><br><span class="line">    <span class="comment">/*先判断一下是否有数据*/</span>   </span><br><span class="line">    have_event = client-&gt;packet_head != client-&gt;tail;</span><br><span class="line">    <span class="comment">/*如果有就从环形缓冲区的取出来，记得是从head存储，tail取出*/</span></span><br><span class="line">    <span class="keyword">if</span> (have_event) &#123;</span><br><span class="line">        *event = client-&gt;buffer[client-&gt;tail++];</span><br><span class="line">        client-&gt;tail &amp;= client-&gt;bufsize - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (client-&gt;use_wake_lock &amp;&amp;</span><br><span class="line">            client-&gt;packet_head == client-&gt;tail)</span><br><span class="line">            wake_unlock(&amp;client-&gt;wake_lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    spin_unlock_irq(&amp;client-&gt;buffer_lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> have_event;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">input_event_to_user</span><span class="params">(<span class="keyword">char</span> __user *buffer,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> struct input_event *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*如果设置了标志INPUT_COMPAT_TEST就将事件event包装成结构体compat_event*/</span></span><br><span class="line">    <span class="keyword">if</span> (INPUT_COMPAT_TEST &amp;&amp; !COMPAT_USE_64BIT_TIME) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">input_event_compat</span> <span class="title">compat_event</span>;</span></span><br><span class="line"></span><br><span class="line">        compat_event.time.tv_sec = event-&gt;time.tv_sec;</span><br><span class="line">        compat_event.time.tv_usec = event-&gt;time.tv_usec;</span><br><span class="line">        compat_event.type = event-&gt;type;</span><br><span class="line">        compat_event.code = event-&gt;code;</span><br><span class="line">        compat_event.value = event-&gt;value;</span><br><span class="line">         <span class="comment">/*将包装成的compat_event拷贝到用户空间*/</span>  </span><br><span class="line">        <span class="keyword">if</span> (copy_to_user(buffer, &amp;compat_event,</span><br><span class="line">                 <span class="keyword">sizeof</span>(struct input_event_compat)))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">/*否则，将event拷贝到用户空间*/</span>   </span><br><span class="line">        <span class="keyword">if</span> (copy_to_user(buffer, event, <span class="keyword">sizeof</span>(struct input_event)))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是可阻塞状态的话，则等待在wait队列上。直到有数据要被处理，当前进程才被唤醒。这很好理解，既然是输入设备，读的话比如读按键，那么必须要有硬件设备有按键按下才会返回按键值，这里还是处于事件处理层，应用程序在这里休眠，那么谁来唤醒?</p><p>当然是有按键按下才去唤醒，因此这个工作就交给了设备驱动层。那么找到这个唤醒呢，直接去找不好找。那么可以直接搜索evdev-&gt;wait，搜索结果可知evdev-&gt;wait在evdev_event()函数中被唤醒</p><p>注释中说的很清楚，evdev_event()会唤醒此处的读按键进程。那么evdev_event()又是被谁调用?显然是设备驱动层，现在看一个设备层例子，内核中有个按键的例子，gpiokey.c，这只是个例子不针对任何设备，在gpio_keys.c终端处理函数里面</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;gpio_keys.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> irqreturn_t <span class="title">gpio_keys_irq_isr</span><span class="params">(<span class="keyword">int</span> irq, <span class="keyword">void</span> *dev_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (!bdata-&gt;key_pressed) &#123;</span><br><span class="line">        ......</span><br><span class="line">        input_event(input, EV_KEY, button-&gt;code, <span class="number">1</span>);</span><br><span class="line">        input_sync(input);</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此可以看出 在设备的中断服务程序里面，确定事件是什么，然后调用相应的input_handler的event处理函数 实际上这就是我们的核心 input_event()是用来上报事件的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;input.c]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input_event</span><span class="params">(struct input_dev *dev,</span></span></span><br><span class="line"><span class="function"><span class="params">         <span class="keyword">unsigned</span> <span class="keyword">int</span> type, <span class="keyword">unsigned</span> <span class="keyword">int</span> code, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_event_supported(type, dev-&gt;evbit, EV_MAX)) &#123;</span><br><span class="line"></span><br><span class="line">        spin_lock_irqsave(&amp;dev-&gt;event_lock, flags);</span><br><span class="line">        input_handle_event(dev, type, code, value);</span><br><span class="line">        spin_unlock_irqrestore(&amp;dev-&gt;event_lock, flags);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">input_handle_event</span><span class="params">(struct input_dev *dev,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">unsigned</span> <span class="keyword">int</span> type, <span class="keyword">unsigned</span> <span class="keyword">int</span> code, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (disposition &amp; INPUT_FLUSH) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dev-&gt;num_vals &gt;= <span class="number">2</span>)</span><br><span class="line">            input_pass_values(dev, dev-&gt;vals, dev-&gt;num_vals);</span><br><span class="line">        dev-&gt;num_vals = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dev-&gt;num_vals &gt;= dev-&gt;max_vals - <span class="number">2</span>) &#123;</span><br><span class="line">        dev-&gt;vals[dev-&gt;num_vals++] = input_value_sync;</span><br><span class="line">        input_pass_values(dev, dev-&gt;vals, dev-&gt;num_vals);</span><br><span class="line">        dev-&gt;num_vals = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">input_pass_values</span><span class="params">(struct input_dev *dev,</span></span></span><br><span class="line"><span class="function"><span class="params">                  struct input_value *vals, <span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_handle</span> *<span class="title">handle</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_value</span> *<span class="title">v</span>;</span></span><br><span class="line">    ......</span><br><span class="line">    handle = rcu_dereference(dev-&gt;grab);</span><br><span class="line">    <span class="keyword">if</span> (handle) &#123;</span><br><span class="line">        count = input_to_handler(handle, vals, count);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        list_for_each_entry_rcu(handle, &amp;dev-&gt;h_list, d_node)</span><br><span class="line">            <span class="keyword">if</span> (handle-&gt;open)</span><br><span class="line">                count = input_to_handler(handle, vals, count);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">input_to_handler</span><span class="params">(struct input_handle *handle,</span></span></span><br><span class="line"><span class="function"><span class="params">            struct input_value *vals, <span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> *<span class="title">handler</span> = <span class="title">handle</span>-&gt;<span class="title">handler</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_value</span> *<span class="title">end</span> = <span class="title">vals</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_value</span> *<span class="title">v</span>;</span></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (handler-&gt;events)</span><br><span class="line">        handler-&gt;events(handle, vals, count);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (handler-&gt;event)</span><br><span class="line">        <span class="keyword">for</span> (v = vals; v != end; v++)</span><br><span class="line">            handler-&gt;event(handle, v-&gt;type, v-&gt;code, v-&gt;value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到最终调用handler-&gt;event()来处理，此处handler即对应evdev。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;input.c]</span><br><span class="line">handler-&gt;event(handle, v-&gt;type, v-&gt;code, v-&gt;value)</span><br></pre></td></tr></table></figure><p>所以会调用evdev_event()函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;evdev.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">evdev_pass_values</span><span class="params">(struct evdev_client *client,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> struct input_value *vals, <span class="keyword">unsigned</span> <span class="keyword">int</span> count,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">ktime_t</span> mono, <span class="keyword">ktime_t</span> real)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evdev</span> *<span class="title">evdev</span> = <span class="title">client</span>-&gt;<span class="title">evdev</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_value</span> *<span class="title">v</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> <span class="title">event</span>;</span></span><br><span class="line">    <span class="keyword">bool</span> wakeup = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (client-&gt;revoked)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    event.time = ktime_to_timeval(client-&gt;clkid == CLOCK_MONOTONIC ?</span><br><span class="line">                      mono : real);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Interrupts are disabled, just acquire the lock. */</span></span><br><span class="line">    spin_lock(&amp;client-&gt;buffer_lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (v = vals; v != vals + count; v++) &#123;</span><br><span class="line">        event.type = v-&gt;type;</span><br><span class="line">        event.code = v-&gt;code;</span><br><span class="line">        event.value = v-&gt;value;</span><br><span class="line">        __pass_event(client, &amp;event);</span><br><span class="line">        <span class="keyword">if</span> (v-&gt;type == EV_SYN &amp;&amp; v-&gt;code == SYN_REPORT)</span><br><span class="line">            wakeup = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    spin_unlock(&amp;client-&gt;buffer_lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (wakeup)</span><br><span class="line">        wake_up_interruptible(&amp;evdev-&gt;wait);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">evdev_events</span><span class="params">(struct input_handle *handle,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">const</span> struct input_value *vals, <span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evdev</span> *<span class="title">evdev</span> = <span class="title">handle</span>-&gt;<span class="title">private</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evdev_client</span> *<span class="title">client</span>;</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (client)</span><br><span class="line">        evdev_pass_values(client, vals, count, time_mono, time_real);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        list_for_each_entry_rcu(client, &amp;evdev-&gt;client_list, node)</span><br><span class="line">            evdev_pass_values(client, vals, count,</span><br><span class="line">                      time_mono, time_real);</span><br><span class="line"></span><br><span class="line">    rcu_read_unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">evdev_event</span><span class="params">(struct input_handle *handle,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">unsigned</span> <span class="keyword">int</span> type, <span class="keyword">unsigned</span> <span class="keyword">int</span> code, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_value</span> <span class="title">vals</span>[] = &#123;</span> &#123; type, code, value &#125; &#125;;</span><br><span class="line">    evdev_events(handle, vals, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终唤醒evdev_read()将数据拷贝到用户空间。</p><h2 id="（五）、Input-事件上报过程"><a href="#（五）、Input-事件上报过程" class="headerlink" title="（五）、Input 事件上报过程"></a>（五）、Input 事件上报过程</h2><h2 id="5-1、Input-事件产生"><a href="#5-1、Input-事件产生" class="headerlink" title="5.1、Input 事件产生"></a>5.1、Input 事件产生</h2><p>当按下触摸屏时，进入触摸屏按下中断，开始ad转换，ad转换完成进入ad完成中断，在这个终端中将事件发送出去，会调用以下函数上报事件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> input_report_key(input_dev,</span><br><span class="line">         BTN_TOUCH, 1);</span><br><span class="line"></span><br><span class="line"> input_report_abs(input_dev,</span><br><span class="line">         ABS_POSITION_X, x);</span><br><span class="line"></span><br><span class="line"> input_report_abs(input_dev,</span><br><span class="line">         ABS_POSITION_Y, y);</span><br><span class="line"></span><br><span class="line">input_sync(input_dev);</span><br></pre></td></tr></table></figure><p>这两个函数调用了 input_event(dev, EV_ABS, code, value) 所有的事件报告函数都调用这个函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;input.h]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">input_report_key</span><span class="params">(struct input_dev *dev, <span class="keyword">unsigned</span> <span class="keyword">int</span> code, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    input_event(dev, EV_KEY, code, !!value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">input_report_abs</span><span class="params">(struct input_dev *dev, <span class="keyword">unsigned</span> <span class="keyword">int</span> code, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    input_event(dev, EV_ABS, code, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">input_sync</span><span class="params">(struct input_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    input_event(dev, EV_SYN, SYN_REPORT, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-2、Input-事件报告"><a href="#5-2、Input-事件报告" class="headerlink" title="5.2、Input 事件报告"></a>5.2、Input 事件报告</h2><p>input_event 函数前面已经分析过，这里不再分析。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;input.c:input_pass_values]</span><br><span class="line"><span class="keyword">for</span> (v = vals; v != end; v++)</span><br><span class="line">    handler-&gt;event(handle, v-&gt;type, v-&gt;code, v-&gt;value);</span><br></pre></td></tr></table></figure><p>最终会调用handler-&gt;event(handle, v-&gt;type, v-&gt;code, v-&gt;value) 来将数据 传递给用户空间等待读取数据的进程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy_to_user(buffer, event, <span class="keyword">sizeof</span>(struct input_event))</span><br></pre></td></tr></table></figure><h2 id="（六）、Android-Input子系统"><a href="#（六）、Android-Input子系统" class="headerlink" title="（六）、Android Input子系统"></a>（六）、Android Input子系统</h2><p>输入子系统的系统架构如下图所示：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/linux.input/07-Linux-kernel-android-input-system.png" alt="Markdown"></p><p>详细分析请参考：Android 7.1.2 (Android N) Android 输入子系统-Input System 分析</p><h2 id="（七）、Input-设备驱动层实例（Synaptics）"><a href="#（七）、Input-设备驱动层实例（Synaptics）" class="headerlink" title="（七）、Input 设备驱动层实例（Synaptics）"></a>（七）、Input 设备驱动层实例（Synaptics）</h2><p>触摸屏也是用上面这一套框架来操作的。右边需要一个”evdev.c”文件。左边要分配一个”input_dev”结构。接着就看上图的硬件设备左边的过程：分配一个”input_dev”结构体 –&gt; 设置这个”input_dev”结构体 –&gt; 注册这个”input_dev”结构体 –&gt; 硬件相关的操作。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/linux.input/08-Linux-kernel-input-drivers-fw.png" alt="Markdown"></p><p>编写Input驱动一般框架:</p><p>Google Pixel、Pixel XL 触控驱动模块型号为Synaptics（ClearPad S3708），源码：<a href="https://github.com/matthewdalex/marlin/tree/2f567606935d601f1391ad9575b103f35737a438/drivers/input/touchscreen/synaptics_dsx_htc_2.6" target="_blank" rel="noopener">Synaptics 触摸屏驱动源码</a></p><p>Makefile：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;drivers/input/touchscreen/synaptics_dsx_htc_2<span class="number">.6</span>/Makefile]</span><br><span class="line">#</span><br><span class="line"># Makefile <span class="keyword">for</span> the Synaptics DSX touchscreen driver.</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line"># Each configuration option enables a <span class="built_in">list</span> of files.</span><br><span class="line"></span><br><span class="line">obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_I2C_HTC_v26) += synaptics_dsx_i2c.o</span><br><span class="line">obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_SPI_HTC_v26) += synaptics_dsx_spi.o</span><br><span class="line">obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_CORE_HTC_v26) += synaptics_dsx_core.o</span><br><span class="line">obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_RMI_DEV_HTC_v26) += synaptics_dsx_rmi_dev.o</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>抓取kernel log：可知input 驱动名为synaptics_dsxv26，全局搜索可知synaptics_rmi4_f12_init在[-&gt;synaptics_dsx_core.c]中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[    <span class="number">1.362728</span>] c3      <span class="number">1</span> [TP]:synaptics_rmi4_f12_init: Function <span class="number">12</span> max x = <span class="number">1079</span> max y = <span class="number">1919</span> Rx: <span class="number">16</span> Tx: <span class="number">28</span></span><br><span class="line">[    <span class="number">1.363344</span>] c3      <span class="number">1</span> [TP]synaptics_rmi4_f12_init:Wakeup Gesture range (<span class="number">0</span>,<span class="number">0</span>) -&gt; (<span class="number">1079</span>,<span class="number">1919</span>)</span><br><span class="line">[    <span class="number">1.363623</span>] c3      <span class="number">1</span> [TP]:synaptics_rmi4_f12_init report data init done</span><br><span class="line">[    <span class="number">1.371945</span>] c3      <span class="number">1</span> [TP]:synaptics_rmi4_query_device: chip_id:<span class="number">3708</span>, firmware_id:<span class="number">2433782</span></span><br><span class="line">[    <span class="number">1.372865</span>] c3      <span class="number">1</span> [TP]:synaptics_rmi4_query_device: config_version: <span class="number">5331763200190000000000000000000000000000000000000000000000000000</span></span><br><span class="line">[    <span class="number">1.373249</span>] c3      <span class="number">1</span> input: synaptics_dsxv26 as /devices/soc/<span class="number">7577000.</span>i2c/i2c<span class="number">-3</span>/<span class="number">3</span><span class="number">-0020</span>/input/input3</span><br></pre></td></tr></table></figure><p>查看input设备：adb shell cat /proc/bus/input/devices</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">I: Bus=0000 Vendor=0000 Product=0003 Version=2066</span><br><span class="line">N: Name=&quot;synaptics_dsxv26&quot;</span><br><span class="line">P: Phys=synaptics_dsx/touch_input</span><br><span class="line">S: Sysfs=/devices/soc/7577000.i2c/i2c-3/3-0020/input/input3</span><br><span class="line">U: Uniq=</span><br><span class="line">H: Handlers=mdss_fb kgsl event3</span><br><span class="line">B: PROP=2</span><br><span class="line">B: EV=b</span><br><span class="line">B: KEY=8000 0 0</span><br><span class="line">B: ABS=663800000000000</span><br><span class="line"></span><br><span class="line">对应：/dev/input/event3</span><br></pre></td></tr></table></figure><h2 id="7-1、分配Input-dev结构体"><a href="#7-1、分配Input-dev结构体" class="headerlink" title="7.1、分配Input_dev结构体"></a>7.1、分配Input_dev结构体</h2><h2 id="7-1-1、synaptics-rmi4-f12-init"><a href="#7-1-1、synaptics-rmi4-f12-init" class="headerlink" title="7.1.1、synaptics_rmi4_f12_init()"></a>7.1.1、synaptics_rmi4_f12_init()</h2><p>首先看一下初始化过程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;synaptics_dsx_core.c]</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">synaptics_rmi4_driver</span> = &#123;</span></span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = PLATFORM_DRIVER_NAME,</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">#ifdef CONFIG_PM</span><br><span class="line">        .pm = &amp;synaptics_rmi4_dev_pm_ops,</span><br><span class="line">#endif</span><br><span class="line">    &#125;,</span><br><span class="line">    .probe = synaptics_rmi4_probe,</span><br><span class="line">    .remove = synaptics_rmi4_remove,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">synaptics_rmi4_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">    retval = synaptics_rmi4_bus_init();</span><br><span class="line">    <span class="keyword">if</span> (retval)</span><br><span class="line">        <span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> platform_driver_register(&amp;synaptics_rmi4_driver);</span><br><span class="line">&#125;</span><br><span class="line">module_init(synaptics_rmi4_init);</span><br></pre></td></tr></table></figure><p>首先注册平台驱动，当驱动和设备匹配成功，继续看一下synaptics_rmi4_probe()函数</p><h2 id="7-1-2、synaptics-rmi4-probe"><a href="#7-1-2、synaptics-rmi4-probe" class="headerlink" title="7.1.2、synaptics_rmi4_probe()"></a>7.1.2、synaptics_rmi4_probe()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;synaptics_dsx_core.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">synaptics_rmi4_probe</span><span class="params">(struct platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retval, len;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> attr_count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">synaptics_rmi4_data</span> *<span class="title">rmi4_data</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">synaptics_dsx_hw_interface</span> *<span class="title">hw_if</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">synaptics_dsx_board_data</span> *<span class="title">bdata</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">temp</span>;</span></span><br><span class="line">    <span class="comment">//初始化platform_data、board_data、rmi4_data</span></span><br><span class="line">    hw_if = pdev-&gt;dev.platform_data;</span><br><span class="line">    bdata = hw_if-&gt;board_data;</span><br><span class="line">    rmi4_data = kzalloc(<span class="keyword">sizeof</span>(*rmi4_data), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">    rmi4_data-&gt;pdev = pdev;</span><br><span class="line">    rmi4_data-&gt;current_page = MASK_8BIT;</span><br><span class="line">    rmi4_data-&gt;hw_if = hw_if;</span><br><span class="line">    rmi4_data-&gt;touch_stopped = <span class="literal">false</span>;</span><br><span class="line">    rmi4_data-&gt;sensor_sleep = <span class="literal">false</span>;</span><br><span class="line">    rmi4_data-&gt;irq_enabled = <span class="literal">false</span>;</span><br><span class="line">    rmi4_data-&gt;fw_updating = <span class="literal">false</span>;</span><br><span class="line">    rmi4_data-&gt;fingers_on_2d = <span class="literal">false</span>;</span><br><span class="line">    rmi4_data-&gt;update_coords = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    rmi4_data-&gt;write_buf = devm_kzalloc(&amp;pdev-&gt;dev, I2C_WRITE_BUF_MAX_LEN,</span><br><span class="line">                    GFP_KERNEL);</span><br><span class="line">    rmi4_data-&gt;write_buf_len = I2C_WRITE_BUF_MAX_LEN;</span><br><span class="line"></span><br><span class="line">    rmi4_data-&gt;irq_enable = synaptics_rmi4_irq_enable;</span><br><span class="line">    rmi4_data-&gt;reset_device = synaptics_rmi4_reset_device;</span><br><span class="line"></span><br><span class="line">    mutex_init(&amp;(rmi4_data-&gt;rmi4_io_ctrl_mutex));</span><br><span class="line">    mutex_init(&amp;(rmi4_data-&gt;rmi4_reset_mutex));</span><br><span class="line"></span><br><span class="line">    retval = synaptics_dsx_regulator_configure(rmi4_data);</span><br><span class="line">    retval = synaptics_dsx_regulator_enable(rmi4_data, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    platform_set_drvdata(pdev, rmi4_data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bdata-&gt;gpio_config) &#123;</span><br><span class="line">        retval = synaptics_rmi4_set_gpio(rmi4_data);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        retval = synaptics_dsx_pinctrl_init(rmi4_data);</span><br><span class="line">        <span class="keyword">if</span> (!retval &amp;&amp; rmi4_data-&gt;ts_pinctrl) &#123;</span><br><span class="line">            retval = pinctrl_select_state(rmi4_data-&gt;ts_pinctrl,</span><br><span class="line">                    rmi4_data-&gt;pinctrl_state_active);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        retval = synaptics_dsx_gpio_configure(rmi4_data, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bdata-&gt;fw_name) &#123;</span><br><span class="line">        len = <span class="built_in">strlen</span>(bdata-&gt;fw_name);</span><br><span class="line"></span><br><span class="line">        strlcpy(rmi4_data-&gt;fw_name, bdata-&gt;fw_name, len + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分配Input_dev结构体，设置，注册</span></span><br><span class="line">    retval = synaptics_rmi4_set_input_dev(rmi4_data);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    rmi4_data-&gt;irq = gpio_to_irq(bdata-&gt;irq_gpio);</span><br><span class="line">    <span class="comment">//请求中断，并设置中断处理函数synaptics_rmi4_irq</span></span><br><span class="line">    retval = synaptics_rmi4_irq_enable(rmi4_data, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!exp_data.initialized) &#123;</span><br><span class="line">        mutex_init(&amp;exp_data.mutex);</span><br><span class="line">        INIT_LIST_HEAD(&amp;exp_data.<span class="built_in">list</span>);</span><br><span class="line">        exp_data.initialized = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    exp_data.workqueue = create_singlethread_workqueue(<span class="string">"dsx_exp_workqueue"</span>);</span><br><span class="line">    INIT_DELAYED_WORK(&amp;exp_data.work, synaptics_rmi4_exp_fn_work);</span><br><span class="line">    exp_data.rmi4_data = rmi4_data;</span><br><span class="line">    exp_data.queue_work = <span class="literal">true</span>;</span><br><span class="line">    queue_delayed_work(exp_data.workqueue,</span><br><span class="line">            &amp;exp_data.work,</span><br><span class="line">            msecs_to_jiffies(EXP_FN_WORK_DELAY_MS));</span><br><span class="line"></span><br><span class="line">    rmi4_data-&gt;dir = debugfs_create_dir(DEBUGFS_DIR_NAME, <span class="literal">NULL</span>);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (attr_count = <span class="number">0</span>; attr_count &lt; ARRAY_SIZE(attrs); attr_count++) &#123;</span><br><span class="line">        retval = sysfs_create_file(&amp;rmi4_data-&gt;input_dev-&gt;dev.kobj,</span><br><span class="line">                &amp;attrs[attr_count].attr);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    synaptics_secure_touch_init(rmi4_data);</span><br><span class="line">    synaptics_secure_touch_stop(rmi4_data, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">    .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-1-3、分配Input-dev结构体"><a href="#7-1-3、分配Input-dev结构体" class="headerlink" title="7.1.3、分配Input_dev结构体"></a>7.1.3、分配Input_dev结构体</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;synaptics_dsx_core.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">synaptics_rmi4_set_input_dev</span><span class="params">(struct synaptics_rmi4_data *rmi4_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">synaptics_dsx_board_data</span> *<span class="title">bdata</span> =</span></span><br><span class="line"><span class="class">                <span class="title">rmi4_data</span>-&gt;<span class="title">hw_if</span>-&gt;<span class="title">board_data</span>;</span></span><br><span class="line"></span><br><span class="line">    rmi4_data-&gt;input_dev = input_allocate_device();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-2、设置支持事件类型-set-bit-EV-SYN-evbit-、set-bit-EV-KEY-evbit-、set-bit-EV-ABS-evbit-……"><a href="#7-2、设置支持事件类型-set-bit-EV-SYN-evbit-、set-bit-EV-KEY-evbit-、set-bit-EV-ABS-evbit-……" class="headerlink" title="7.2、设置支持事件类型 set_bit(EV_SYN, evbit)、set_bit(EV_KEY, evbit)、set_bit(EV_ABS,evbit) ……"></a>7.2、设置支持事件类型 set_bit(EV_SYN, evbit)、set_bit(EV_KEY, evbit)、set_bit(EV_ABS,evbit) ……</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;synaptics_dsx_core.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">synaptics_rmi4_set_input_dev</span><span class="params">(struct synaptics_rmi4_data *rmi4_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">synaptics_dsx_board_data</span> *<span class="title">bdata</span> =</span></span><br><span class="line"><span class="class">                <span class="title">rmi4_data</span>-&gt;<span class="title">hw_if</span>-&gt;<span class="title">board_data</span>;</span></span><br><span class="line"></span><br><span class="line">    rmi4_data-&gt;input_dev = input_allocate_device();</span><br><span class="line">    ......</span><br><span class="line">    retval = synaptics_rmi4_query_device(rmi4_data);</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">//#define PLATFORM_DRIVER_NAME "synaptics_dsxv26"(synaptics_dsx_v2_6.h)</span></span><br><span class="line"></span><br><span class="line">    rmi4_data-&gt;input_dev-&gt;name = PLATFORM_DRIVER_NAME;</span><br><span class="line">    rmi4_data-&gt;input_dev-&gt;phys = INPUT_PHYS_NAME;</span><br><span class="line">    rmi4_data-&gt;input_dev-&gt;id.product = SYNAPTICS_DSX_DRIVER_PRODUCT;</span><br><span class="line">    rmi4_data-&gt;input_dev-&gt;id.version = SYNAPTICS_DSX_DRIVER_VERSION;</span><br><span class="line">    rmi4_data-&gt;input_dev-&gt;dev.parent = rmi4_data-&gt;pdev-&gt;dev.parent;</span><br><span class="line">    input_set_drvdata(rmi4_data-&gt;input_dev, rmi4_data);</span><br><span class="line"></span><br><span class="line">    set_bit(EV_SYN, rmi4_data-&gt;input_dev-&gt;evbit);</span><br><span class="line">    set_bit(EV_KEY, rmi4_data-&gt;input_dev-&gt;evbit);</span><br><span class="line">    set_bit(EV_ABS, rmi4_data-&gt;input_dev-&gt;evbit);</span><br><span class="line">    set_bit(BTN_TOUCH, rmi4_data-&gt;input_dev-&gt;keybit);</span><br><span class="line">    set_bit(BTN_TOOL_FINGER, rmi4_data-&gt;input_dev-&gt;keybit);</span><br><span class="line"></span><br><span class="line">    synaptics_rmi4_set_params(rmi4_data);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-3、注册设备input-register-device"><a href="#7-3、注册设备input-register-device" class="headerlink" title="7.3、注册设备input_register_device()"></a>7.3、注册设备input_register_device()</h2><p>此处即与前面kernel log呼应：注册名为 synaptics_dsxv26 的输入设备</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;synaptics_dsx_core.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">synaptics_rmi4_set_input_dev</span><span class="params">(struct synaptics_rmi4_data *rmi4_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">synaptics_dsx_board_data</span> *<span class="title">bdata</span> =</span></span><br><span class="line"><span class="class">                <span class="title">rmi4_data</span>-&gt;<span class="title">hw_if</span>-&gt;<span class="title">board_data</span>;</span></span><br><span class="line"></span><br><span class="line">    rmi4_data-&gt;input_dev = input_allocate_device();</span><br><span class="line">    ......</span><br><span class="line">    retval = synaptics_rmi4_query_device(rmi4_data);</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">//#define PLATFORM_DRIVER_NAME "synaptics_dsxv26"(synaptics_dsx_v2_6.h)</span></span><br><span class="line"></span><br><span class="line">    rmi4_data-&gt;input_dev-&gt;name = PLATFORM_DRIVER_NAME;</span><br><span class="line">    rmi4_data-&gt;input_dev-&gt;phys = INPUT_PHYS_NAME;</span><br><span class="line">    rmi4_data-&gt;input_dev-&gt;id.product = SYNAPTICS_DSX_DRIVER_PRODUCT;</span><br><span class="line">    rmi4_data-&gt;input_dev-&gt;id.version = SYNAPTICS_DSX_DRIVER_VERSION;</span><br><span class="line">    rmi4_data-&gt;input_dev-&gt;dev.parent = rmi4_data-&gt;pdev-&gt;dev.parent;</span><br><span class="line">    input_set_drvdata(rmi4_data-&gt;input_dev, rmi4_data);</span><br><span class="line"></span><br><span class="line">    set_bit(EV_SYN, rmi4_data-&gt;input_dev-&gt;evbit);</span><br><span class="line">    set_bit(EV_KEY, rmi4_data-&gt;input_dev-&gt;evbit);</span><br><span class="line">    set_bit(EV_ABS, rmi4_data-&gt;input_dev-&gt;evbit);</span><br><span class="line">    set_bit(BTN_TOUCH, rmi4_data-&gt;input_dev-&gt;keybit);</span><br><span class="line">    set_bit(BTN_TOOL_FINGER, rmi4_data-&gt;input_dev-&gt;keybit);</span><br><span class="line"></span><br><span class="line">    synaptics_rmi4_set_params(rmi4_data);</span><br><span class="line">    ......</span><br><span class="line">    retval = input_register_device(rmi4_data-&gt;input_dev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-4、硬件相关操作"><a href="#7-4、硬件相关操作" class="headerlink" title="7.4、硬件相关操作"></a>7.4、硬件相关操作</h2><p>当触摸屏按下，会产生中断，进而调用中断处理函数synaptics_rmi4_irq():</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;synaptics_dsx_core.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> irqreturn_t <span class="title">synaptics_rmi4_irq</span><span class="params">(<span class="keyword">int</span> irq, <span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">synaptics_rmi4_data</span> *<span class="title">rmi4_data</span> = <span class="title">data</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">synaptics_dsx_board_data</span> *<span class="title">bdata</span> =</span></span><br><span class="line"><span class="class">            <span class="title">rmi4_data</span>-&gt;<span class="title">hw_if</span>-&gt;<span class="title">board_data</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IRQ_HANDLED == synaptics_filter_interrupt(data))</span><br><span class="line">        <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (gpio_get_value(bdata-&gt;irq_gpio) != bdata-&gt;irq_on_state)</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line"></span><br><span class="line">    synaptics_rmi4_sensor_report(rmi4_data, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>:</span><br><span class="line">    <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进一步调用synaptics_rmi4_sensor_report(rmi4_data, true)处理数据：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;synaptics_dsx_core.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">synaptics_rmi4_sensor_report</span><span class="params">(struct synaptics_rmi4_data *rmi4_data,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">bool</span> report)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> data[MAX_INTR_REGISTERS + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *intr = &amp;data[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">bool</span> was_in_bl_mode;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">synaptics_rmi4_f01_device_status</span> <span class="title">status</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">synaptics_rmi4_fn</span> *<span class="title">fhandler</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">synaptics_rmi4_exp_fhandler</span> *<span class="title">exp_fhandler</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">synaptics_rmi4_device_info</span> *<span class="title">rmi</span>;</span></span><br><span class="line"></span><br><span class="line">    rmi = &amp;(rmi4_data-&gt;rmi4_mod_info);</span><br><span class="line"></span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">    retval = synaptics_rmi4_reg_read(rmi4_data,</span><br><span class="line">            rmi4_data-&gt;f01_data_base_addr,</span><br><span class="line">            data,</span><br><span class="line">            rmi4_data-&gt;num_of_intr_regs + <span class="number">1</span>);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//读取寄存器数据</span></span><br><span class="line">    status.data[<span class="number">0</span>] = data[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (status.status_code == STATUS_CRC_IN_PROGRESS) &#123;</span><br><span class="line">        retval = synaptics_rmi4_check_status(rmi4_data,</span><br><span class="line">                &amp;was_in_bl_mode);</span><br><span class="line">        ....</span><br><span class="line">        retval = synaptics_rmi4_reg_read(rmi4_data,</span><br><span class="line">                rmi4_data-&gt;f01_data_base_addr,</span><br><span class="line">                status.data,</span><br><span class="line">                <span class="keyword">sizeof</span>(status.data));</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (status.unconfigured &amp;&amp; !status.flash_prog) &#123;</span><br><span class="line">        pr_notice(<span class="string">"%s: spontaneous reset detected\n"</span>, __func__);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//synaptics_rmi4_report_touch()上报数据</span></span><br><span class="line">    <span class="keyword">if</span> (!list_empty(&amp;rmi-&gt;support_fn_list)) &#123;</span><br><span class="line">        list_for_each_entry(fhandler, &amp;rmi-&gt;support_fn_list, link) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fhandler-&gt;num_of_data_sources) &#123;</span><br><span class="line">                <span class="keyword">if</span> (fhandler-&gt;intr_mask &amp;</span><br><span class="line">                        intr[fhandler-&gt;intr_reg_num]) &#123;</span><br><span class="line">                    synaptics_rmi4_report_touch(rmi4_data,</span><br><span class="line">                            fhandler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;exp_data.mutex);</span><br><span class="line">    <span class="keyword">if</span> (!list_empty(&amp;exp_data.<span class="built_in">list</span>)) &#123;</span><br><span class="line">        list_for_each_entry(exp_fhandler, &amp;exp_data.<span class="built_in">list</span>, link) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!exp_fhandler-&gt;insert &amp;&amp;</span><br><span class="line">                    !exp_fhandler-&gt;remove &amp;&amp;</span><br><span class="line">                    (exp_fhandler-&gt;exp_fn-&gt;attn != <span class="literal">NULL</span>))</span><br><span class="line">                exp_fhandler-&gt;exp_fn-&gt;attn(rmi4_data, intr[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mutex_unlock(&amp;exp_data.mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-4-1、Input数据上报："><a href="#7-4-1、Input数据上报：" class="headerlink" title="7.4.1、Input数据上报："></a>7.4.1、Input数据上报：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;synaptics_dsx_core.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">synaptics_rmi4_report_touch</span><span class="params">(struct synaptics_rmi4_data *rmi4_data,</span></span></span><br><span class="line"><span class="function"><span class="params">        struct synaptics_rmi4_fn *fhandler)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">switch</span> (fhandler-&gt;fn_number) &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">case</span> SYNAPTICS_RMI4_F12:</span><br><span class="line">        touch_count_2d = synaptics_rmi4_f12_abs_report(rmi4_data,</span><br><span class="line">                fhandler);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (touch_count_2d)</span><br><span class="line">            rmi4_data-&gt;fingers_on_2d = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            rmi4_data-&gt;fingers_on_2d = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">synaptics_rmi4_f12_abs_report</span><span class="params">(struct synaptics_rmi4_data *rmi4_data,</span></span></span><br><span class="line"><span class="function"><span class="params">        struct synaptics_rmi4_fn *fhandler)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> touch_count = <span class="number">0</span>; <span class="comment">/* number of touch points */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> index;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> finger;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> fingers_to_process;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> finger_status;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> size_of_2d_data;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> gesture_type;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> data_addr;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">int</span> wx;</span><br><span class="line">    <span class="keyword">int</span> wy;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">synaptics_rmi4_f12_extra_data</span> *<span class="title">extra_data</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">synaptics_rmi4_f12_finger_data</span> *<span class="title">data</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">synaptics_rmi4_f12_finger_data</span> *<span class="title">finger_data</span>;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> finger_presence;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> stylus_presence;</span><br><span class="line"></span><br><span class="line">    fingers_to_process = fhandler-&gt;num_of_data_points;</span><br><span class="line">    data_addr = fhandler-&gt;full_addr.data_base;</span><br><span class="line">    extra_data = (struct synaptics_rmi4_f12_extra_data *)fhandler-&gt;extra;</span><br><span class="line">    size_of_2d_data = <span class="keyword">sizeof</span>(struct synaptics_rmi4_f12_finger_data);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    retval = synaptics_rmi4_reg_read(rmi4_data,</span><br><span class="line">            data_addr + extra_data-&gt;data1_offset,</span><br><span class="line">            (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)fhandler-&gt;data,</span><br><span class="line">            fingers_to_process * size_of_2d_data);</span><br><span class="line">    <span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    data = (struct synaptics_rmi4_f12_finger_data *)fhandler-&gt;data;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;(rmi4_data-&gt;rmi4_report_mutex));</span><br><span class="line">    <span class="comment">//根据触摸点数量循环上报input数据</span></span><br><span class="line">    <span class="keyword">for</span> (finger = <span class="number">0</span>; finger &lt; fingers_to_process; finger++) &#123;</span><br><span class="line">        finger_data = data + finger;</span><br><span class="line">        finger_status = finger_data-&gt;object_type_and_status;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        x = (finger_data-&gt;x_msb &lt;&lt; <span class="number">8</span>) | (finger_data-&gt;x_lsb);</span><br><span class="line">        y = (finger_data-&gt;y_msb &lt;&lt; <span class="number">8</span>) | (finger_data-&gt;y_lsb);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rmi4_data-&gt;hw_if-&gt;board_data-&gt;swap_axes) &#123;</span><br><span class="line">            temp = x;</span><br><span class="line">            x = y;</span><br><span class="line">            y = temp;</span><br><span class="line">            temp = wx;</span><br><span class="line">            wx = wy;</span><br><span class="line">            wy = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rmi4_data-&gt;hw_if-&gt;board_data-&gt;x_flip)</span><br><span class="line">            x = rmi4_data-&gt;sensor_max_x - x;</span><br><span class="line">        <span class="keyword">if</span> (rmi4_data-&gt;hw_if-&gt;board_data-&gt;y_flip)</span><br><span class="line">            y = rmi4_data-&gt;sensor_max_y - y;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (finger_status) &#123;</span><br><span class="line">        <span class="keyword">case</span> F12_FINGER_STATUS:</span><br><span class="line">        <span class="keyword">case</span> F12_GLOVED_FINGER_STATUS:</span><br><span class="line"></span><br><span class="line">            input_report_key(rmi4_data-&gt;input_dev,</span><br><span class="line">                    BTN_TOUCH, <span class="number">1</span>);</span><br><span class="line">            input_report_key(rmi4_data-&gt;input_dev,</span><br><span class="line">                    BTN_TOOL_FINGER, <span class="number">1</span>);</span><br><span class="line">            input_report_abs(rmi4_data-&gt;input_dev,</span><br><span class="line">                    ABS_MT_POSITION_X, x);</span><br><span class="line">            input_report_abs(rmi4_data-&gt;input_dev,</span><br><span class="line">                    ABS_MT_POSITION_Y, y);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    input_sync(rmi4_data-&gt;input_dev);</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;(rmi4_data-&gt;rmi4_report_mutex));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> touch_count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用input_report_key()、input_report_abs()、input_sync() 上报、同步数据。</p><h2 id="（八）、参考文档-特别感谢各位前辈的分析和图示-："><a href="#（八）、参考文档-特别感谢各位前辈的分析和图示-：" class="headerlink" title="（八）、参考文档(特别感谢各位前辈的分析和图示)："></a>（八）、参考文档(特别感谢各位前辈的分析和图示)：</h2><p><a href="https://blog.csdn.net/column/details/input.html" target="_blank" rel="noopener">Linux/Android—-Input系统</a><br><a href="https://blog.csdn.net/tiantangniaochao/article/details/50497353" target="_blank" rel="noopener">Android Input子系统浅谈</a><br><a href="http://huaqianlee.github.io/2017/11/23/Android/Android-Linux-input-system-analysis/" target="_blank" rel="noopener">Android(Linux) 输入子系统解析</a><br><a href="http://www.cnblogs.com/jason-lu/p/3156411.html" target="_blank" rel="noopener">input子系统分析之三:驱动模块</a><br><a href="https://blog.csdn.net/fanwenjieok/article/details/38503027" target="_blank" rel="noopener">Linux驱动框架之—-Input子系统</a><br><a href="https://www.zybuluo.com/zifehng/note/718523" target="_blank" rel="noopener">input子系统事件处理层(evdev)的环形缓冲区</a><br><a href="https://blog.csdn.net/ielife/article/details/7814108" target="_blank" rel="noopener">linux input输入子系统分析《四》：input子系统整体流程全面分析</a><br><a href="https://blog.csdn.net/yueqian_scut/article/details/48792939" target="_blank" rel="noopener">Linux input子系统分析之二：深入剖析input_handler、input_core、input_device</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/izhoujinjian/zhoujinjian.cc/tree/master/linux.input&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;【博客原图链接】&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;源码（部分
      
    
    </summary>
    
      <category term="Android" scheme="http://zhoujinjian.cc/categories/Android/"/>
    
    
      <category term="Android" scheme="http://zhoujinjian.cc/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android 7.1.2 (Android N) Android WindowManagerService 窗口管理服务 分析 [i.wonder~]</title>
    <link href="http://zhoujinjian.cc/2018/03/01/Android-7-1-2-Android-N-Android-WindowManagerService-%E7%AA%97%E5%8F%A3%E7%AE%A1%E7%90%86%E6%9C%8D%E5%8A%A1%E5%88%86%E6%9E%90-i-wonder/"/>
    <id>http://zhoujinjian.cc/2018/03/01/Android-7-1-2-Android-N-Android-WindowManagerService-窗口管理服务分析-i-wonder/</id>
    <published>2018-02-28T16:00:00.000Z</published>
    <updated>2018-04-19T14:30:05.646Z</updated>
    
    <content type="html"><![CDATA[<p>窗口管理系统WMS是Android中的主要子系统之一，它涉及到App中组件的管理，系统和应用窗口的管理和绘制等工作。由于其涉及模块众多，且与用户体验密切相关，所以它也是Android当中最为复杂的子系统之一。一个App从启动到主窗口显示出来，需要App，ActivityManagerService（AMS），WindowManagerService（WMS），SurfaceFlinger（SF）等几个模块相互合作。App负责业务逻辑，绘制自己的视图；AMS管理组件、进程信息和Activity的堆栈及状态等等；WMS管理Activity对应的窗口及子窗口，还有系统窗口等；SF用于管理图形缓冲区，将App绘制的东西合成渲染在屏幕上。</p><a id="more"></a><h2 id="【博客原图链接】"><a href="#【博客原图链接】" class="headerlink" title="【博客原图链接】"></a><a href="https://github.com/izhoujinjian/zhoujinjian.cc/tree/master/android.wms" target="_blank" rel="noopener">【博客原图链接】</a></h2><h2 id="源码（部分）："><a href="#源码（部分）：" class="headerlink" title="源码（部分）："></a>源码（部分）：</h2><p><strong>/frameworks/base/services/core/java/com/android/server/am/</strong></p><ul><li>ActivityStack.java</li><li>ActivityManagerService.java</li><li>ActivityStackSupervisor.java</li><li>ActivityStarter.java</li><li>ActivityRecord.java</li></ul><p><strong>/frameworks/base/core/java/android/view/</strong></p><ul><li>WindowManagerImpl.java</li><li>ViewManager.java</li><li>WindowManagerGlobal.java</li><li>ViewRootImpl.java</li><li>Choreographer.java</li><li>IWindowSession.aidl</li><li>DisplayEventReceiver.java</li><li>SurfaceControl.java</li><li>Surface.java</li><li>SurfaceSession.java</li></ul><p><strong>/frameworks/base/services/core/java/com/android/server/wm/</strong></p><ul><li>WindowManagerService.java</li><li>AppWindowAnimator.java</li><li>AppTransition.java</li><li>AppWindowToken.java</li><li>Session.java</li><li>WindowState.java</li><li>WindowAnimator.java</li><li>WindowStateAnimator.java</li><li>WindowSurfacePlacer.java</li><li>WindowSurfaceController.java</li></ul><h2 id="【博客原图链接】-1"><a href="#【博客原图链接】-1" class="headerlink" title="【博客原图链接】"></a><a href="https://github.com/izhoujinjian/zhoujinjian.cc/tree/master/android.wms" target="_blank" rel="noopener">【博客原图链接】</a></h2><p>我们先看一下窗口启动、退出过程动态图，之后再详细分析：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.wms/01-Android-WMS-ezgif.com-gif-maker-WindowManagerService-resize.gif" alt="Markdown"></p><h2 id="（一）、Window-组织方式"><a href="#（一）、Window-组织方式" class="headerlink" title="（一）、Window 组织方式"></a>（一）、Window 组织方式</h2><p>ActivityManagerService（AMS），WindowManagerService（WMS），SurfaceFlinger（SF）等几个模块相互合作。App负责业务逻辑，绘制自己的视图；AMS管理组件、进程信息和Activity的堆栈及状态等等；WMS管理Activity对应的窗口及子窗口，还有系统窗口等；SF用于管理图形缓冲区，将App绘制的东西合成渲染在屏幕上。 窗口管理系统主要框架：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.wms/02-Android-WMS-AMS-SurfaceFlinger-Conn.png" alt="Markdown"></p><blockquote><p>主要对象功能介绍：</p><p>WindowManagerService负责完成窗口的管理工作</p><p>WindowState和应用端窗口一一对应，应用调用WMS添加窗口时，最终会在WindowManagerService.addWindow()创建一个WindowState与之一一对应</p><p>WindowToken是一个句柄，保存了所有具有同一个token的WindowState。应用请求WindowManagerService添加窗口的时候，提供了一个token，该token标识了被添加窗口的归属，WindowManagerService为该token生成一个WindowToken对象，所有token相同的WindowState被关联到同一个WindowToken，如输入法添加窗口时，会传递一个IBinder mCurToken，墙纸服务添加窗口时，会传递一个WallpaperConnection::final Binder mToken。</p><p>AppWindowToken继承于WindowToken，专门用于标识一个Activity。AppWindowToken里的token实际上就是指向了一个Activity。ActivityManagerService通知应用启动的时候，在服务端生成一个token用于标识该Activity，并且把该token传递到应用客户端，客户端的Activity在申请添加窗口时，以该token作为标识传递到WindowManagerService。同一个Activity中的主窗口、对话框窗口、菜单窗口都关联到同一个AppWindowToken。</p><p>Session表示一个客户端和服务端的交互会话。一般来说不同的应用通过不同的会话来和WindowManagerService交互，但是处于同一个进程的不同应用通过同一个Session来交互。</p></blockquote><h3 id="1-1、Android-Token介绍"><a href="#1-1、Android-Token介绍" class="headerlink" title="1.1、Android Token介绍"></a>1.1、Android Token介绍</h3><p>Token是ActivityRecord的内部静态类，我们先来看下Token的继承关系，Token extends IApplicationToken.Stub，从IApplicationToken.Stub类进行继承，根据Binder的机制可以知道Token是一个匿名Binder实体类，这个匿名Binder实体会传递给其他进程，其他进程会拿到Token的代理端。 我们知道匿名Binder有两个比较重要的用途，一个是拿到Binder代理端后可跨Binder调用实体端的函数接口，另一个作用便是在多个进程中标识同一个对象。往往这两个作用是同时存在的，比如我们这里研究的Token就同时存在这两个作用，但最重要的便是后者，Token标识了一个ActivityRecord对象，即间接标识了一个Activity。</p><p>Token梳理： 分析源码，我们发现，大多数 token 的对象，都表示一个 IBinder 对象。提到 IBinder，大家一点也不陌生，就是 Android 的 IPC 通信机制。在创建窗口过程中，涉及到的 IPC 通信，无非包含两方面，一个是 WmS 用来跟应用所在的进程进行通信的 ViewRootImpl.W 类的对象，另一个是指向一个 ActivityRecord 的对象，自然应该是WMS用来跟 AMS进行通信的了。我们梳理了一下，token 以下几处的定义，分别来讲讲这里的 token 代表什么。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.wms/03-Android-WMS-Token-Detail.png" alt="Markdown"></p><p>分析一下 View 的 AttachInfo 的赋值。ViewRootImpl 在构建方法里，会初始化一个 AttachInfo 实例，把它的 Session，以及 W类对象赋值给 AttachInfo。分析可以看到，AttachInfo 中的 mWindowToken，与mWindow 都是指向 ViewRootImpl 中的 mWindow(W类实例)。当一个 View attach 到窗口后，ViewRootImpl会执行performTraversals，如果发现是首次调用会，会把自己的 mAttachInfo 传递给根 View（通过dispatchAttachedToWindow），告诉 View 树现在已经 attch to Window 了，马上可以显示了。根 View（一般是 ViewGroup）会把这个信息，遍历地传递给 View 树中的每一个子 View，这样每个 View 的 mAttachInfo 都被赋值为 ViewRootImp 的 mAttachInfo了。</p><h3 id="1-1-1、Token对象的创建"><a href="#1-1-1、Token对象的创建" class="headerlink" title="1.1.1、Token对象的创建"></a>1.1.1、Token对象的创建</h3><p>下面这个图是Token的传递，首先会传递到WMS中，接着会传递到应用进程ActivityThread中，下面来具体分析这个传递流程。 总体流程图：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.wms/04-Android-WMS-Token.png" alt="Markdown"></p><p>我们之前分析：【Android 7.1.2 (Android N) Activity启动流程分析】 在启动Activity过程中会调用ActivityStarter.startActivityLocked()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ActivityStarter.java]</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivityLocked</span><span class="params">(IApplicationThread caller, Intent intent, Intent ephemeralIntent,</span></span></span><br><span class="line"><span class="function"><span class="params">        String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">        IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode, <span class="keyword">int</span> callingPid, <span class="keyword">int</span> callingUid,</span></span></span><br><span class="line"><span class="function"><span class="params">        String callingPackage, <span class="keyword">int</span> realCallingPid, <span class="keyword">int</span> realCallingUid, <span class="keyword">int</span> startFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">        ActivityOptions options, <span class="keyword">boolean</span> ignoreTargetSecurity, <span class="keyword">boolean</span> componentSpecified,</span></span></span><br><span class="line"><span class="function"><span class="params">        ActivityRecord[] outActivity, ActivityStackSupervisor.ActivityContainer container,</span></span></span><br><span class="line"><span class="function"><span class="params">        TaskRecord inTask)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    ActivityRecord sourceRecord = <span class="keyword">null</span>;</span><br><span class="line">    ActivityRecord resultRecord = <span class="keyword">null</span>;</span><br><span class="line">    ......</span><br><span class="line">    ActivityRecord r = <span class="keyword">new</span> ActivityRecord(mService, callerApp, callingUid, callingPackage,</span><br><span class="line">            intent, resolvedType, aInfo, mService.mConfiguration, resultRecord, resultWho,</span><br><span class="line">            requestCode, componentSpecified, voiceSession != <span class="keyword">null</span>, mSupervisor, container,</span><br><span class="line">            options, sourceRecord);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        err = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor, startFlags,</span><br><span class="line">                <span class="keyword">true</span>, options, inTask);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在startActivityLocked()中创建了一个ActivityRecord对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ActivityRecord.java]</span><br><span class="line"><span class="keyword">final</span> IApplicationToken.Stub appToken; <span class="comment">// window manager token</span></span><br><span class="line"></span><br><span class="line">ActivityRecord(ActivityManagerService _service, ProcessRecord _caller,</span><br><span class="line">        <span class="keyword">int</span> _launchedFromUid, String _launchedFromPackage, Intent _intent, String _resolvedType,</span><br><span class="line">        ActivityInfo aInfo, Configuration _configuration,</span><br><span class="line">        ActivityRecord _resultTo, String _resultWho, <span class="keyword">int</span> _reqCode,</span><br><span class="line">        <span class="keyword">boolean</span> _componentSpecified, <span class="keyword">boolean</span> _rootVoiceInteraction,</span><br><span class="line">        ActivityStackSupervisor supervisor,</span><br><span class="line">        ActivityContainer container, ActivityOptions options, ActivityRecord sourceRecord) &#123;</span><br><span class="line">    service = _service;</span><br><span class="line">    appToken = <span class="keyword">new</span> Token(<span class="keyword">this</span>, service);</span><br><span class="line">    ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在ActivityRecord的构造函数中创建，标识着当前这个ActivityRecord，即间接代表着一个Activity。</p><h3 id="1-1-2、AMS调用WMS的addAPPToken-接口"><a href="#1-1-2、AMS调用WMS的addAPPToken-接口" class="headerlink" title="1.1.2、AMS调用WMS的addAPPToken()接口"></a>1.1.2、AMS调用WMS的addAPPToken()接口</h3><p>在启动一个Activity时，会调用startActivityLocked()来在WMS中添加一个AppWindowToken对象 startActivityLocked()创建ActivityRecord对象后会继续调用startActivityUnchecked()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ActivityStarter.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">startActivityUnchecked</span><span class="params">(<span class="keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord,</span></span></span><br><span class="line"><span class="function"><span class="params">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> startFlags, <span class="keyword">boolean</span> doResume, ActivityOptions options, TaskRecord inTask)</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        mTargetStack.startActivityLocked(mStartActivity, newTask, mKeepCurTransition, mOptions);</span><br><span class="line">        ......</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ActivityStack.java]</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startActivityLocked</span><span class="params">(ActivityRecord r, <span class="keyword">boolean</span> newTask, <span class="keyword">boolean</span> keepCurTransition,</span></span></span><br><span class="line"><span class="function"><span class="params">            ActivityOptions options)</span> </span>&#123;</span><br><span class="line">            ......</span><br><span class="line">            addConfigOverride(r, task);</span><br><span class="line">            ......</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addConfigOverride</span><span class="params">(ActivityRecord r, TaskRecord task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Rect bounds = task.updateOverrideConfigurationFromLaunchBounds();</span><br><span class="line">        <span class="comment">// 跳转到WMS</span></span><br><span class="line">        mWindowManager.addAppToken(task.mActivities.indexOf(r), r.appToken,</span><br><span class="line">                r.task.taskId, mStackId, r.info.screenOrientation, r.fullscreen,</span><br><span class="line">                (r.info.flags &amp; FLAG_SHOW_FOR_ALL_USERS) != <span class="number">0</span>, r.userId, r.info.configChanges,</span><br><span class="line">                task.voiceSession != <span class="keyword">null</span>, r.mLaunchTaskBehind, bounds, task.mOverrideConfig,</span><br><span class="line">                task.mResizeMode, r.isAlwaysFocusable(), task.isHomeTask(),</span><br><span class="line">                r.appInfo.targetSdkVersion, r.mRotationAnimationHint);</span><br><span class="line">        r.taskConfigOverride = task.mOverrideConfig;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们继续看下WindowManager.addAppToken()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowManagerService.java]</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAppToken</span><span class="params">(<span class="keyword">int</span> addPos, IApplicationToken token, <span class="keyword">int</span> taskId, <span class="keyword">int</span> stackId,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> requestedOrientation, <span class="keyword">boolean</span> fullscreen, <span class="keyword">boolean</span> showForAllUsers, <span class="keyword">int</span> userId,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> configChanges, <span class="keyword">boolean</span> voiceInteraction, <span class="keyword">boolean</span> launchTaskBehind,</span></span></span><br><span class="line"><span class="function"><span class="params">            Rect taskBounds, Configuration config, <span class="keyword">int</span> taskResizeMode, <span class="keyword">boolean</span> alwaysFocusable,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> homeTask, <span class="keyword">int</span> targetSdkVersion, <span class="keyword">int</span> rotationAnimationHint)</span> </span>&#123;</span><br><span class="line">      ......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span>(mWindowMap) &#123;</span><br><span class="line">            AppWindowToken atoken = findAppWindowToken(token.asBinder());</span><br><span class="line">            <span class="keyword">if</span> (atoken != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Slog.w(TAG_WM, <span class="string">"Attempted to add existing app token: "</span> + token);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//根据ActivityRecord中IApplicationToken.Stub的代理，创建AppWindowToken</span></span><br><span class="line">            atoken = <span class="keyword">new</span> AppWindowToken(<span class="keyword">this</span>, token, voiceInteraction);</span><br><span class="line">            atoken.inputDispatchingTimeoutNanos = inputDispatchingTimeoutNanos;</span><br><span class="line">            atoken.appFullscreen = fullscreen;</span><br><span class="line">            atoken.showForAllUsers = showForAllUsers;</span><br><span class="line">            atoken.targetSdk = targetSdkVersion;</span><br><span class="line">            atoken.requestedOrientation = requestedOrientation;</span><br><span class="line">            atoken.layoutConfigChanges = (configChanges &amp;</span><br><span class="line">                    (ActivityInfo.CONFIG_SCREEN_SIZE | ActivityInfo.CONFIG_ORIENTATION)) != <span class="number">0</span>;</span><br><span class="line">            atoken.mLaunchTaskBehind = launchTaskBehind;</span><br><span class="line">            atoken.mAlwaysFocusable = alwaysFocusable;</span><br><span class="line">            atoken.mRotationAnimationHint = rotationAnimationHint;</span><br><span class="line"></span><br><span class="line">            Task task = mTaskIdToTask.get(taskId);</span><br><span class="line">            <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">                task = createTaskLocked(taskId, stackId, userId, atoken, taskBounds, config);</span><br><span class="line">            &#125;</span><br><span class="line">            task.addAppToken(addPos, atoken, taskResizeMode, homeTask);</span><br><span class="line">            <span class="comment">//将atoken放入到mTokenMap中，等应用程序addWindow时，进行身份验证</span></span><br><span class="line">            <span class="comment">//其中token.asBinder()是IApplicationToken.Stub的代理，atoken就是根据代理，得到对应AppWindowToken</span></span><br><span class="line">            mTokenMap.put(token.asBinder(), atoken);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Application tokens start out hidden.</span></span><br><span class="line">            atoken.hidden = <span class="keyword">true</span>;</span><br><span class="line">            atoken.hiddenRequested = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="1-1-3、AMS跨Binder调用应用进程的scheduleLaunchActivity-将Token传递给上层应用进程"><a href="#1-1-3、AMS跨Binder调用应用进程的scheduleLaunchActivity-将Token传递给上层应用进程" class="headerlink" title="1.1.3、AMS跨Binder调用应用进程的scheduleLaunchActivity()将Token传递给上层应用进程"></a>1.1.3、AMS跨Binder调用应用进程的scheduleLaunchActivity()将Token传递给上层应用进程</h3><p>当框架通过ApplicationThread的代理回调到ActivityThread的时候，将对应的步骤一种生成的token代理传入。 ActivityStackSupervisor.realStartActivityLocked()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    [-&gt;ActivityStackSupervisor.java]</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">realStartActivityLocked</span><span class="params">(ActivityRecord r, ProcessRecord app,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> andResume, <span class="keyword">boolean</span> checkConfig)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line"></span><br><span class="line">      ......</span><br><span class="line">        app.thread.scheduleLaunchActivity(<span class="keyword">new</span> Intent(r.intent), r.appToken,</span><br><span class="line">                System.identityHashCode(r), r.info, <span class="keyword">new</span> Configuration(mService.mConfiguration),</span><br><span class="line">                <span class="keyword">new</span> Configuration(task.mOverrideConfig), r.compat, r.launchedFromPackage,</span><br><span class="line">                task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results,</span><br><span class="line">                newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo);</span><br><span class="line"></span><br><span class="line">       ......</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里通过调用IApplicationThread的方法实现的，这里调用的是scheduleLaunchActivity()方法，所以真正执行的是ActivityThread中的scheduleLaunchActivity()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[-&gt; ActivityThread.java :ApplicationThread]</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleLaunchActivity</span><span class="params">(Intent intent, IBinder token, <span class="keyword">int</span> ident,</span></span></span><br><span class="line"><span class="function"><span class="params">                ActivityInfo info, Configuration curConfig, Configuration overrideConfig,</span></span></span><br><span class="line"><span class="function"><span class="params">                CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">int</span> procState, Bundle state, PersistableBundle persistentState,</span></span></span><br><span class="line"><span class="function"><span class="params">                List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">boolean</span> notResumed, <span class="keyword">boolean</span> isForward, ProfilerInfo profilerInfo)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            updateProcessState(procState, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">            ActivityClientRecord r = <span class="keyword">new</span> ActivityClientRecord();</span><br><span class="line">            <span class="comment">//传递给了ActivityThread的token，这个token就是IApplicationToken.Stub的代理</span></span><br><span class="line">            r.token = token;</span><br><span class="line">            ......</span><br><span class="line">            updatePendingConfiguration(curConfig);</span><br><span class="line"></span><br><span class="line">            sendMessage(H.LAUNCH_ACTIVITY, r);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="1-1-4、Activity窗口添加过程"><a href="#1-1-4、Activity窗口添加过程" class="headerlink" title="1.1.4、Activity窗口添加过程"></a>1.1.4、Activity窗口添加过程</h3><p>详细过程请查看：【Android 7.1.2 (Android N) Activity-Window加载显示流程分析】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ActivityThread.java]</span><br><span class="line"> <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">handleResumeActivity</span><span class="params">(IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> clearHide, <span class="keyword">boolean</span> isForward, <span class="keyword">boolean</span> reallyResume, <span class="keyword">int</span> seq, String reason)</span> </span>&#123;</span><br><span class="line">    ActivityClientRecord r = mActivities.get(token);</span><br><span class="line">    ......</span><br><span class="line">    r = performResumeActivity(token, clearHide, reason);</span><br><span class="line">    ......</span><br><span class="line">        <span class="keyword">if</span> (r.window == <span class="keyword">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">            <span class="comment">//获得为当前Activity创建的窗口PhoneWindow对象</span></span><br><span class="line">            r.window = r.activity.getWindow();</span><br><span class="line">            <span class="comment">//获取为窗口创建的视图DecorView对象</span></span><br><span class="line">            View decor = r.window.getDecorView();</span><br><span class="line">            decor.setVisibility(View.INVISIBLE);</span><br><span class="line">            <span class="comment">//在attach函数中就为当前Activity创建了WindowManager对象  </span></span><br><span class="line">            ViewManager wm = a.getWindowManager();</span><br><span class="line">            <span class="comment">//得到该视图对象的布局参数  </span></span><br><span class="line">            WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">            <span class="comment">//将视图对象保存到Activity的成员变量mDecor中  </span></span><br><span class="line">            a.mDecor = decor;</span><br><span class="line">            l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line">            l.softInputMode |= forwardBit;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">if</span> (a.mVisibleFromClient &amp;&amp; !a.mWindowAdded) &#123;</span><br><span class="line">                a.mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//将创建的视图对象DecorView添加到Activity的窗口管理器中  </span></span><br><span class="line">                wm.addView(decor, l);</span><br><span class="line">            &#125;</span><br><span class="line">        ......</span><br><span class="line">            <span class="keyword">if</span> (r.activity.mVisibleFromClient) &#123;</span><br><span class="line">                r.activity.makeVisible();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进而层层调用到：ViewRootImpl.setView()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ViewRootImpl.java]</span><br><span class="line">WindowManager.LayoutParams l = r.window.getAttributes();</span><br></pre></td></tr></table></figure><p>ViewRootImpl.setView()函数中添加Activity窗口时在参数mWindowAttributes中携带Token代理对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ViewManager.java]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addWindow</span><span class="params">(Session session, IWindow client, <span class="keyword">int</span> seq,  </span></span></span><br><span class="line"><span class="function"><span class="params">        WindowManager.LayoutParams attrs, <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> displayId,  </span></span></span><br><span class="line"><span class="function"><span class="params">        Rect outContentInsets, Rect outStableInsets, InputChannel outInputChannel)</span> </span>&#123;  </span><br><span class="line">        ......  </span><br><span class="line">        <span class="keyword">boolean</span> addToken = <span class="keyword">false</span>;  </span><br><span class="line">        <span class="comment">//attrs这个是应用程序ActivityClientRecord中传递过来的参数，其中的attrs.token就是步骤三种的r.token</span></span><br><span class="line">        WindowToken token = mTokenMap.get(attrs.token);  </span><br><span class="line">        ......  </span><br><span class="line">        win = <span class="keyword">new</span> WindowState(<span class="keyword">this</span>, session, client, token,  </span><br><span class="line">                attachedWindow, appOp[<span class="number">0</span>], seq, attrs, viewVisibility, displayContent);  </span><br><span class="line"></span><br><span class="line">        mWindowMap.put(client.asBinder(), win);  </span><br><span class="line">        ......  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据Binder机制可以知道从上层应用传递过来的Token代理对象会转换成SystemServer进程中的Token本地对象，后者与第2步中从Token对象是同一个对象，所以上面调用mTokenMap.get(attrs.token)时便能返回正确返回一个WindowToken（这个WindowToken其实是一个APPWindowToken），这样添加的窗口也就跟Activity关联上了。</p><h3 id="1-2、WMS组织方式"><a href="#1-2、WMS组织方式" class="headerlink" title="1.2、WMS组织方式"></a>1.2、WMS组织方式</h3><p>Activity管理服务ActivityManagerService中每一个ActivityRecord对象在Window管理服务WindowManagerService中都对应有一个AppWindowToken对象。</p><p>此外，在输入法管理服务InputMethodManagerService中，每一个输入法窗口都对应有一个Binder对象，这个Binder对象在Window管理服务WindowManagerService又对应有一个WindowToken对象。</p><p>与输入法窗口类似，在壁纸管理服务WallpaperManagerService中，每一个壁纸窗口都对应有一个Binder对象，这个Binder对象在Window管理服务WindowManagerService也对应有一个WindowToken对象。</p><p>在Window管理服务WindowManagerService中，无论是AppWindowToken对象，还是WindowToken对象，它们都是用来描述一组有着相同令牌的窗口的，每一个窗口都是通过一个WindowState对象来描述的。例如，一个Activity组件窗口可能有一个启动窗口（Starting Window），还有若干个子窗口，那么这些窗口就会组成一组，并且都是以Activity组件在Window管理服务WindowManagerService中所对应的AppWindowToken对象为令牌的。从抽象的角度来看，就是在Window管理服务WindowManagerService中，每一个令牌（AppWindowToken或者WindowToken）都是用来描述一组窗口（WindowState）的，并且每一个窗口的子窗口也是与它同属于一个组，即都有着相同的令牌。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.wms/05-Android-WMS-AppWindowToken.png" alt="Markdown"><br>其中，Activity Stack是在ActivityManagerService服务中创建的，Token List和Window Stack是在WindowManagerService中创建的，而Binder for IM和Binder for WP分别是在InputMethodManagerService服务和WallpaperManagerService服务中创建的，用来描述一个输入法窗口和一个壁纸窗口。</p><h3 id="1-3、WMS窗口类型"><a href="#1-3、WMS窗口类型" class="headerlink" title="1.3、WMS窗口类型"></a>1.3、WMS窗口类型</h3><p>添加一个窗口是通过 WindowManagerGlobal.addView()来完成的，分析 addView 方法的参数，有三个参数是必不可少的，view，params，以及 display。而 display 一般直接取 WindowMnagerImpl 中的 mDisplay，表示要输出的显示设备。view 自然表示要显示的 View，而 params 是 WindowManager.LayoutParams，用来描述这个 view 的些窗口属性，其中一个重要的参数 type，用来描述窗口的类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowManagerGlobal]</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,</span></span></span><br><span class="line"><span class="function"><span class="params">            Display display, Window parentWindow)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"view must not be null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (display == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"display must not be null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!(params <span class="keyword">instanceof</span> WindowManager.LayoutParams)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Params must be WindowManager.LayoutParams"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ```</span><br></pre></td></tr></table></figure><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">打开WindowManager类，看到静态内部类。</span><br><span class="line"></span><br><span class="line">``` java</span><br><span class="line">[-&gt;WindowManager]</span><br><span class="line">public static class LayoutParams extends ViewGroup.LayoutParams implements Parcelable &#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在LayoutParams中，有2个比较重要的参数: flags,type。 我们简要的分析一下flags,该参数表示Window的属性，它有很多选项，通过这些选项可以控制Window的显示特性，这里主要介绍几个比较常用的选项。</p><p>FLAG_NOT_FOCUSABLE 表示Window不需要获取焦点，也不需要接收各种输入事件，此标记会同时启用FLAG_NOT_TOUCH_MODAL，最终事件会直接传递给下层具有焦点的Window。</p><p>FLAG_NOT_TOUCH_MODAL 系统会将当前Window区域以外的单击事件传递给底层的Window，当前Window区域以内的单击事件则自己处理，这个标记很重要，一般来说都需要开启此标记，否则其他Window将无法接收到单击事件。</p><p>FLAG_SHOW_WHEN_LOCKED 开启此模式可以让Window显示在锁屏的界面上。</p><blockquote><p>Type参数表示Window的类型，Window有三种类型，分别是应用Window、子Window、系统Window。应用类Window对应着一个Activity。子Window不能单独存在，它需要附属在特定的父Window之中，比如常见的PopupWindow就是一个子Window。有些系统Window是需要声明权限才能创建的Window，比如Toast和系统状态栏这些都是系统Window。</p></blockquote><h3 id="1-3-1、应用窗口"><a href="#1-3-1、应用窗口" class="headerlink" title="1.3.1、应用窗口"></a>1.3.1、应用窗口</h3><p>Activity 对应的窗口类型是应用窗口， 所有 Activity 默认的窗口类型是 TYPE_BASE_APPLICATION。 WindowManager 的 LayoutParams 的默认类型是 TYPE_APPLICATION。 Dialog 并没有设置type，所以也是默认的窗口类型即 TYPE_APPLICATION。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowManager.LayoutParams]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LayoutParams</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);</span><br><span class="line">    type = TYPE_APPLICATION;</span><br><span class="line">    format = PixelFormat.OPAQUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">type层级</th><th style="text-align:left">类型</th></tr></thead><tbody><tr><td style="text-align:left">FIRST_APPLICATION_WINDOW=1</td><td style="text-align:left">开始应用程序窗口，第一个普通应用窗口</td></tr><tr><td style="text-align:left">TYPE_BASE_APPLICATION=1</td><td style="text-align:left">所有程序窗口的base窗口，其他应用程序窗口都显示在它上面</td></tr><tr><td style="text-align:left">TYPE_APPLICATION=2</td><td style="text-align:left">普通应用程序窗口，token必须设置为Activity的token来指定窗口属于谁</td></tr><tr><td style="text-align:left">TYPE_APPLICATION_STARTING=3</td><td style="text-align:left">应用程序启动时先显示此窗口，当真正的窗口配置完成后，关闭此窗口</td></tr><tr><td style="text-align:left">LAST_APPLICATION_WINDOW=99</td><td style="text-align:left">最后一个应用窗口</td></tr></tbody></table><h3 id="1-3-2、子窗口"><a href="#1-3-2、子窗口" class="headerlink" title="1.3.2、子窗口"></a>1.3.2、子窗口</h3><p>子窗口不能单独存在，它需要附属在特定的父Window之中，例如开篇第一张图，绿色框框即为popupWindow，它就是子窗口，类型一般为TYPE_APPLICATION_PANEL。之所以称为子窗口，即它的父窗口显示时，子窗口才显示。父窗口不显示，它也不显示。追随父窗口。</p><table><thead><tr><th style="text-align:left">type层级</th><th style="text-align:left">类型</th></tr></thead><tbody><tr><td style="text-align:left">FIRST_SUB_WINDOW=1000</td><td style="text-align:left">第一个子窗口</td></tr><tr><td style="text-align:left">TYPE_APPLICATION_PANEL=1000</td><td style="text-align:left">应用窗口的子窗口,popupWindow的默认类型</td></tr><tr><td style="text-align:left">TYPE_APPLICATION_MEDIA=1001</td><td style="text-align:left">媒体窗口</td></tr><tr><td style="text-align:left">TYPE_APPLICATION_SUB_PANEL=1002</td><td style="text-align:left">TYPE_APPLICATION_PANE的子窗口</td></tr><tr><td style="text-align:left">TYPE_APPLICATION_ATTACHED_DIALOG=1003</td><td style="text-align:left">对话框，类似于面板窗口(OptionMenu,ContextMenu)</td></tr><tr><td style="text-align:left">TYPE_APPLICATION_MEDIA_OVERLAY=1004</td><td style="text-align:left">媒体信息，显示在媒体层和程序窗口之间，需要实现半透明效果</td></tr><tr><td style="text-align:left">LAST_SUB_WINDOW=1999</td><td style="text-align:left">最后一个子窗口</td></tr></tbody></table><h3 id="1-3-3、系统窗口"><a href="#1-3-3、系统窗口" class="headerlink" title="1.3.3、系统窗口"></a>1.3.3、系统窗口</h3><p>系统窗口跟应用窗口不同，不需要对应 Activity。跟子窗口不同，不需要有父窗口。一般来讲，系统窗口应该由系统来创建的，例如发生异常，ANR时的提示框，又如系统状态栏，屏保等。但是，Framework 还是定义了一些，可以被应用所创建的系统窗口，如 TYPE _TOAST，TYPE <em>INPUT</em> METHOD，TYPE _WALLPAPTER 等等。</p><table><thead><tr><th style="text-align:left">type层级</th><th style="text-align:left">类型</th></tr></thead><tbody><tr><td style="text-align:left">FIRST_SYSTEM_WINDOW=2000</td><td style="text-align:left">第一个系统窗口</td></tr><tr><td style="text-align:left">TYPE_STATUS_BAR=2000</td><td style="text-align:left">状态栏，只能有一个状态栏，位于屏幕顶端</td></tr><tr><td style="text-align:left">TYPE_SEARCH_BAR =2001</td><td style="text-align:left">搜索栏</td></tr><tr><td style="text-align:left">TYPE_PHONE=2002</td><td style="text-align:left">电话窗口，它用于电话交互</td></tr><tr><td style="text-align:left">TYPE_SYSTEM_ALERT=2003</td><td style="text-align:left">系统警告，出现在应用程序窗口之上</td></tr><tr><td style="text-align:left">TYPE_KEYGUARD=2004</td><td style="text-align:left">锁屏窗口</td></tr><tr><td style="text-align:left">TYPE_TOAST=2005</td><td style="text-align:left">信息窗口，用于显示Toast</td></tr><tr><td style="text-align:left">TYPE_SYSTEM_OVERLAY=2006</td><td style="text-align:left">系统顶层窗口，显示在其他内容之上，此窗口不能获得输入焦点，否则影响锁屏</td></tr><tr><td style="text-align:left">TYPE_PRIORITY_PHONE=2007</td><td style="text-align:left">当锁屏时显示的来电显示窗口</td></tr><tr><td style="text-align:left">TYPE_SYSTEM_DIALOG=2008</td><td style="text-align:left">系统对话框</td></tr><tr><td style="text-align:left">TYPE_KEYGUARD_DIALOG=2009</td><td style="text-align:left">锁屏时显示的对话框</td></tr><tr><td style="text-align:left">TYPE_SYSTEM_ERROR=2010</td><td style="text-align:left">系统内部错误提示</td></tr><tr><td style="text-align:left">TYPE_INPUT_METHOD=2011</td><td style="text-align:left">输入法窗口，显示于普通应用/子窗口之上</td></tr><tr><td style="text-align:left">TYPE_INPUT_METHOD_DIALOG=2012</td><td style="text-align:left">输入法中备选框对应的窗口</td></tr><tr><td style="text-align:left">TYPE_WALLPAPER=2013</td><td style="text-align:left">墙纸窗口</td></tr><tr><td style="text-align:left">TYPE_STATUS_BAR_PANEL=2014</td><td style="text-align:left">滑动状态条后出现的窗口</td></tr><tr><td style="text-align:left">TYPE_SECURE_SYSTEM_OVERLAY=2015</td><td style="text-align:left">安全系统覆盖窗口</td></tr><tr><td style="text-align:left">……</td><td style="text-align:left">……</td></tr><tr><td style="text-align:left">LAST_SYSTEM_WINDOW=2999</td><td style="text-align:left">最后一个系统窗口</td></tr></tbody></table><p>那么，这个type层级到底有什么作用呢？ Window是分层的，每个Window都有对应的z-ordered，（z轴，从1层层叠加到2999，你可以将屏幕想成三维坐标模式）层级大的会覆盖在层级小的Window上面。</p><p>在三类Window中，应用Window的层级范围是1~99。子Window的层级范围是1000~1999，系统Window的层级范围是2000~2999，这些层级范围对应着WindowManager.LayoutParams的type参数。如果想要Window位于所有Window的最顶层，那么采用较大的层级即可。另外有些系统层级的使用是需要声明权限的。</p><h2 id="（二）、Window-Size（大小）和-Window-Position（位置）-计算过程"><a href="#（二）、Window-Size（大小）和-Window-Position（位置）-计算过程" class="headerlink" title="（二）、Window Size（大小）和 Window Position（位置） 计算过程"></a>（二）、Window Size（大小）和 Window Position（位置） 计算过程</h2><p>之前在【Android 7.1.2 (Android N) Android Graphics 系统分析 [i.wonder~]】分析过，当Vsync事件到来时，就会通过Choreographer的postCallback()，接着执行mTraversalRunnable对象的run()方法。 mTraversalRunnable对象的类型为TraversalRunnable，该类实现了Runnable接口，在其run()函数中调用了doTraversal()函数来完成窗口布局。为了分析的连贯性，这里重新贴一下源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ViewRootImpl.java]</span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TraversalRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        doTraversal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> TraversalRunnable mTraversalRunnable = <span class="keyword">new</span> TraversalRunnable();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">false</span>;</span><br><span class="line">        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line">        ......</span><br><span class="line">        performTraversals();</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>performTraversals()函数相当复杂，其主要实现以下几个重要步骤：</p><p>1.执行窗口测量；</p><p>2.执行窗口注册；</p><p>3.执行窗口布局；</p><p>4.执行窗口绘图；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ViewRootImpl.java]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/****************执行窗口测量******************/</span>  </span><br><span class="line">    <span class="keyword">if</span> (layoutRequested) &#123;</span><br><span class="line">        windowSizeMayChange |= measureHierarchy(host, lp, res,</span><br><span class="line">                desiredWindowWidth, desiredWindowHeight);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/****************向WMS服务添加窗口******************/</span>  </span><br><span class="line">    <span class="keyword">if</span> (mFirst || windowShouldResize || insetsChanged ||</span><br><span class="line">            viewVisibilityChanged || params != <span class="keyword">null</span> || mForceNextWindowRelayout) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ......</span><br><span class="line">            relayoutResult = relayoutWindow(params, viewVisibility, insetsPending);</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/****************执行窗口布局******************/</span></span><br><span class="line">    <span class="keyword">if</span> (didLayout) &#123;</span><br><span class="line">        performLayout(lp, mWidth, mHeight);</span><br><span class="line">        ......</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">/****************执行窗口绘制******************/</span>  </span><br><span class="line">    <span class="keyword">if</span> (!cancelDraw &amp;&amp; !newSurface) &#123;</span><br><span class="line">        ......</span><br><span class="line">        performDraw();</span><br><span class="line">    &#125; ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1、-Android-屏幕区域介绍"><a href="#2-1、-Android-屏幕区域介绍" class="headerlink" title="2.1、 Android 屏幕区域介绍"></a>2.1、 Android 屏幕区域介绍</h3><p>首先来看relayoutWindow()。relayoutWindow() 是Window Manager Service 重要工作之一，它的流程如下图所示：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.wms/06-Android-WMS-relayoutWindow-flow.png.png" alt="Markdown"></p><p>每个View将期望窗口尺寸交给WMS（WindowManager Service). WMS 将所有的窗口大小以及当前的Overscan区域传给WPM （WindowManager Policy). WPM根据用户配置确定每个Window在最终Display输出上的位置以及需要分配的Surface大小。 返回这些信息给每个View，他们将在给会的区域空间里绘图。 Android里定义了很多区域,如下图所示<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.wms/07-Android-WMS-OverSan-area.png" alt="Markdown"></p><p><strong>Overscan:</strong> Overscan 是电视特有的概念，上图中黄色部分就是Overscan区域，指的是电视机屏幕四周某些不可见的区域（因为电视特性，这部分区域的buffer内容显示时被丢弃），也意味着如果窗口的某些内容画在这个区域里，它在某些电视上就会看不到。为了避免这种情况发生，通常要求UI不要画在屏幕的边角上，而是预留一定的空间。因为Overscan的区域大小随着电视不 同而不同，它一般由终端用户通过UI指定，（比如说GoogleTV里就有确定Overscan大小的应用）。</p><p><strong>OverscanScreen, Screen:</strong> OverscanScreen 是包含Overscan区域的屏幕大小,而Screen则为去除Overscan区域后的屏幕区域, OverscanScreen &gt; Screen.</p><p><strong>Restricted and Unrestricted:</strong> 某些区域是被系统保留的，比如说手机屏幕上方的状态栏(如图纸绿色区域）和下方的导航栏，根据是否包括这些预留的区域，Android把区域分为Unrestricted Area 和 Resctrited Aread, 前者包括这部分预留区域，后者则不包含, Unrestricted area &gt; Rectricted area。</p><p><strong>mFrame, mDisplayFrame, mContainingFrame</strong> Frame指的是一片内存区域, 对应于屏幕上的一块矩形区域. mFrame的大小就是Surface的大小, 如上上图中的蓝色区域. mDisplayFrame 和 mContainingFrame 一般和mFrame 大小一致. mXXX 是Window(ViewRootImpl, Windowstate) 里面定义的成员变量.</p><p><strong>mContentFrame, mVisibleFrame</strong> 一个Surface的所有内容不一定在屏幕上都得到显示, 与Overscan重叠的部分会被截掉, 系统的其他窗口也会遮挡掉部分区域 (比如短信窗口，ContentFrame是800x600(没有Status Bar), 但当输入法窗口弹出是，变成了800x352), 剩下的区域称为Visible Frame, UI内容只有画在这个区域里才能确保可见. 所以也称为Content Frame. mXXX也是Window(ViewRootImpl, WindowState) 里面定义的成员变量.<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.wms/08-Android-WMS-Content-Insets.png" alt="Markdown"></p><p><strong>Insets</strong> insets的定义如上图所示, 用了表示某个Frame的边缘大小.</p><h3 id="2-2、-Window-大小位置计算过程"><a href="#2-2、-Window-大小位置计算过程" class="headerlink" title="2.2、 Window 大小位置计算过程"></a>2.2、 Window 大小位置计算过程</h3><p>在Android系统中，Activity窗口的大小是由WindowManagerService服务来计算的。WindowManagerService服务会根据屏幕及其装饰区的大小来决定Activity窗口的大小。一个Activity窗口只有知道自己的大小之后，才能对它里面的UI元素进行测量、布局以及绘制。 一般来说，Activity窗口的大小等于整个屏幕的大小，但是它并不占据着整块屏幕。为了理解这一点，我们首先分析一下Activity窗口的区域是如何划分的。 我们知道，Activity窗口的上方一般会有一个状态栏，用来显示3G信号、电量使用等图标，如图<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.wms/09-Android-WMS-Content-Visible-Frame.png" alt="Markdown"></p><p>从Activity窗口剔除掉状态栏所占用的区域之后，所得到的区域就称为内容区域（Content Region）。顾名思义，内容区域就是用来显示Activity窗口的内容的。我们再抽象一下，假设Activity窗口的四周都有一块类似状态栏的区域，那么将这些区域剔除之后，得到中间的那一块区域就称为内容区域，而被剔除出来的区域所组成的区域就称为内容边衬区域（Content Insets）。Activity窗口的内容边衬区域可以用一个四元组（content-left, content-top, content-right, content-bottom）来描述，其中，content-left、content-right、content-top、content-bottom分别用来描述内容区域与窗口区域的左右上下边界距离。 我们还知道，Activity窗口有时候需要显示输入法窗口，如图。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.wms/10-Android-WMS-InputMethod-Content-Frame.png" alt="Markdown"></p><p>这时候Activity窗口的内容区域的大小有可能没有发生变化，这取决于它的Soft Input Mode。我们假设Activity窗口的内容区域没有发生变化，但是它在底部的一些区域被输入法窗口遮挡了，即它在底部的一些内容是不可见的。从Activity窗口剔除掉状态栏和输入法窗口所占用的区域之后，所得到的区域就称为可见区域（Visible Region）。同样，我们再抽象一下，假设Activity窗口的四周都有一块类似状态栏和输入法窗口的区域，那么将这些区域剔除之后，得到中间的那一块区域就称为可见区域，而被剔除出来的区域所组成的区域就称为可见边衬区域（Visible Insets）。Activity窗口的可见边衬区域可以用一个四元组（visible-left, visible-top, visible-right, visible-bottom）来描述，其中，visible-left、visible-right、visible-top、visible-bottom分别用来描述可见区域与窗口区域的左右上下边界距离。</p><p>在大多数情况下，Activity窗口的内容区域和可见区域的大小是一致的，而状态栏和输入法窗口所占用的区域又称为屏幕装饰区。理解了这些概念之后，我们就可以推断，WindowManagerService服务实际上就是需要根据屏幕以及可能出现的状态栏和输入法窗口的大小来计算出Activity窗口的整体大小及其内容区域边衬和可见区域边衬的大小。有了这三个数据之后，Activity窗口就可以对它里面的UI元素进行测量、布局以及绘制等操作了。 总体流程图：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.wms/11-Android-WMS-relayoutWindow-time-diagram.png" alt="Markdown"></p><p>这个过程可以分为13个步骤，接下来我们就详细分析每一个步骤。</p><h3 id="2-2-1、ViewRootImpl-performTraversals"><a href="#2-2-1、ViewRootImpl-performTraversals" class="headerlink" title="2.2.1、ViewRootImpl.performTraversals()"></a>2.2.1、ViewRootImpl.performTraversals()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ViewRootImpl.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// cache mView since it is used so much below...</span></span><br><span class="line">    <span class="keyword">final</span> View host = mView;</span><br><span class="line">    ......</span><br><span class="line">    WindowManager.LayoutParams lp = mWindowAttributes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> desiredWindowWidth;</span><br><span class="line">    <span class="keyword">int</span> desiredWindowHeight;</span><br><span class="line">    ......</span><br><span class="line">    Rect frame = mWinFrame;</span><br><span class="line">    <span class="keyword">if</span> (mFirst) &#123;</span><br><span class="line">        mFullRedrawNeeded = <span class="keyword">true</span>;</span><br><span class="line">        mLayoutRequested = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//第一次被请求执行测量、布局和绘制操作，desiredWindowWidth和desiredWindowHeight等于Display Size，否则mWinFrame保存的宽度和高度值。</span></span><br><span class="line">        <span class="keyword">if</span> (shouldUseDisplaySize(lp)) &#123;</span><br><span class="line">            Point size = <span class="keyword">new</span> Point();</span><br><span class="line">            mDisplay.getRealSize(size);</span><br><span class="line">            desiredWindowWidth = size.x;</span><br><span class="line">            desiredWindowHeight = size.y;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Configuration config = mContext.getResources().getConfiguration();</span><br><span class="line">            desiredWindowWidth = dipToPx(config.screenWidthDp);</span><br><span class="line">            desiredWindowHeight = dipToPx(config.screenHeightDp);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        host.dispatchAttachedToWindow(mAttachInfo, <span class="number">0</span>);</span><br><span class="line">        mAttachInfo.mTreeObserver.dispatchOnWindowAttachedChange(<span class="keyword">true</span>);</span><br><span class="line">        dispatchApplyInsets(host);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//不是第一次请求，当desiredWindowWidth != mWidth || desiredWindowHeight != mHeight，说明Activity窗口的大小发生了变化，这时候windowSizeMayChange = true，以便接下来对Activity窗口大小变化进行处理</span></span><br><span class="line">        desiredWindowWidth = frame.width();</span><br><span class="line">        desiredWindowHeight = frame.height();</span><br><span class="line">        <span class="keyword">if</span> (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) &#123;</span><br><span class="line">            mFullRedrawNeeded = <span class="keyword">true</span>;</span><br><span class="line">            mLayoutRequested = <span class="keyword">true</span>;</span><br><span class="line">            windowSizeMayChange = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这段代码用来获得Activity窗口的当前宽度desiredWindowWidth和当前高度desiredWindowHeight。</p><p>继续阅读代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ViewRootImpl.java::performTraversals()]</span><br><span class="line"><span class="keyword">boolean</span> layoutRequested = mLayoutRequested &amp;&amp; (!mStopped || mReportNextDraw);</span><br><span class="line"><span class="keyword">if</span> (layoutRequested) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Resources res = mView.getContext().getResources();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mFirst) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//AttachInfo对象用来描述Activity窗口的属性,mContentInsets和mVisibleInsets分别用来描述Activity窗口的当前内容边衬大小和可见边衬大小。</span></span><br><span class="line">        <span class="comment">//判断Activity窗口的OverscanInsets、ContentInsets、StableInsets、VisibleInsets大小是否发生了变化</span></span><br><span class="line">        <span class="keyword">if</span> (!mPendingOverscanInsets.equals(mAttachInfo.mOverscanInsets)) &#123;</span><br><span class="line">            insetsChanged = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//WRAP_CONTENT表明Activity窗口的大小要等于内容区域的大小，同时等于Display size</span></span><br><span class="line">        <span class="keyword">if</span> (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT</span><br><span class="line">                || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">            windowSizeMayChange = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (shouldUseDisplaySize(lp)) &#123;</span><br><span class="line">                Point size = <span class="keyword">new</span> Point();</span><br><span class="line">                mDisplay.getRealSize(size);</span><br><span class="line">                desiredWindowWidth = size.x;</span><br><span class="line">                desiredWindowHeight = size.y;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Configuration config = res.getConfiguration();</span><br><span class="line">                desiredWindowWidth = dipToPx(config.screenWidthDp);</span><br><span class="line">                desiredWindowHeight = dipToPx(config.screenHeightDp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Ask host how big it wants to be</span></span><br><span class="line">    <span class="comment">//知道了顶层Activity窗口大小从而计算Activity内各个子View的大小</span></span><br><span class="line">    windowSizeMayChange |= measureHierarchy(host, lp, res,</span><br><span class="line">            desiredWindowWidth, desiredWindowHeight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码用来在Activity窗口主动请求WindowManagerService服务计算大小之前，对它的顶层视图进行一次测量操作。</p><p>继续阅读代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ViewRootImpl.java::performTraversals()]</span><br><span class="line"> <span class="keyword">if</span> (mFirst || windowShouldResize || insetsChanged ||</span><br><span class="line">        viewVisibilityChanged || params != <span class="keyword">null</span> || mForceNextWindowRelayout) &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//relayoutWindow来请求WMS计算Activity窗口的大小以及xxxInsets大小，并保存在PendingxxxInsets中</span></span><br><span class="line">        relayoutResult = relayoutWindow(params, viewVisibility, insetsPending);</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (contentInsetsChanged) &#123;</span><br><span class="line">            mAttachInfo.mContentInsets.set(mPendingContentInsets);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (visibleInsetsChanged) &#123;</span><br><span class="line">            mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//将计算得到的Activity窗口的左上角坐标保存在变量attachInfo所指向的一个AttachInfo对象的成员变量mWindowLeft和mWindowTop</span></span><br><span class="line">    mAttachInfo.mWindowLeft = frame.left;</span><br><span class="line">    mAttachInfo.mWindowTop = frame.top;</span><br><span class="line">    <span class="comment">//将计算得到的Activity窗口的宽度和高度保存在ViewRootImpl类的成员变量mWidth和mHeight中</span></span><br><span class="line">    <span class="keyword">if</span> (mWidth != frame.width() || mHeight != frame.height()) &#123;</span><br><span class="line">        mWidth = frame.width();</span><br><span class="line">        mHeight = frame.height();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这段代码主要调用relayoutWindow()来请求WMS计算Activity窗口的大小以及边忖xxxInsets大小。计算完毕之后，分别保存在mPendingXXXInsets中。</p><p>继续阅读代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ViewRootImpl.java::performTraversals()]</span><br><span class="line"> <span class="keyword">if</span> (!mStopped || mReportNextDraw) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> focusChangedDueToTouchMode = ensureTouchModeLocally(</span><br><span class="line">                    (relayoutResult&amp;WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth()</span><br><span class="line">                    || mHeight != host.getMeasuredHeight() || contentInsetsChanged ||</span><br><span class="line">                    updatedConfiguration) &#123;</span><br><span class="line">                <span class="keyword">int</span> childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);</span><br><span class="line">                <span class="keyword">int</span> childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);</span><br><span class="line">                ......</span><br><span class="line">                 <span class="comment">// Ask host how big it wants to be</span></span><br><span class="line">                performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line"></span><br><span class="line">                ......</span><br><span class="line">                <span class="keyword">int</span> width = host.getMeasuredWidth();</span><br><span class="line">                <span class="keyword">int</span> height = host.getMeasuredHeight();</span><br><span class="line">                <span class="keyword">boolean</span> measureAgain = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (lp.horizontalWeight &gt; <span class="number">0.0f</span>) &#123;</span><br><span class="line">                    width += (<span class="keyword">int</span>) ((mWidth - width) * lp.horizontalWeight);</span><br><span class="line">                    childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(width,</span><br><span class="line">                            MeasureSpec.EXACTLY);</span><br><span class="line">                    measureAgain = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (lp.verticalWeight &gt; <span class="number">0.0f</span>) &#123;</span><br><span class="line">                    height += (<span class="keyword">int</span>) ((mHeight - height) * lp.verticalWeight);</span><br><span class="line">                    childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(height,</span><br><span class="line">                            MeasureSpec.EXACTLY);</span><br><span class="line">                    measureAgain = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (measureAgain) &#123;</span><br><span class="line">                    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                layoutRequested = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这段代码用来检查是否需要重新测量Activity窗口的大小。</p><p>经过前面漫长的操作后，Activity窗口的大小测量工作终于尘埃落定，这时候就可以对Activity窗口的内容进行布局 performLayout(lp, mWidth, mHeight)和进行绘画了，performDraw()，由于主要关注Activity窗口大小计算过程，在此不做继续分析。</p><h3 id="2-2-2、ViewRootImpl-relayoutWindow"><a href="#2-2-2、ViewRootImpl-relayoutWindow" class="headerlink" title="2.2.2、ViewRootImpl.relayoutWindow()"></a>2.2.2、ViewRootImpl.relayoutWindow()</h3><p>通过调用这个Session对象的成员函数relayout()来请求WindowManagerService服务计算Activity窗口的大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ViewRootImpl.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">relayoutWindow</span><span class="params">(WindowManager.LayoutParams params, <span class="keyword">int</span> viewVisibility,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> insetsPending)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    .....</span><br><span class="line">    <span class="keyword">int</span> relayoutResult = mWindowSession.relayout(</span><br><span class="line">            mWindow, mSeq, params,</span><br><span class="line">            (<span class="keyword">int</span>) (mView.getMeasuredWidth() * appScale + <span class="number">0.5f</span>),</span><br><span class="line">            (<span class="keyword">int</span>) (mView.getMeasuredHeight() * appScale + <span class="number">0.5f</span>),</span><br><span class="line">            viewVisibility, insetsPending ? WindowManagerGlobal.RELAYOUT_INSETS_PENDING : <span class="number">0</span>,</span><br><span class="line">            mWinFrame, mPendingOverscanInsets, mPendingContentInsets, mPendingVisibleInsets,</span><br><span class="line">            mPendingStableInsets, mPendingOutsets, mPendingBackDropFrame, mPendingConfiguration,</span><br><span class="line">            mSurface);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> relayoutResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数说明： 1、mWindow 用来标志要计算的是哪一个Activity窗口的大小p 2、Activity窗口的顶层视图经过测量后得到的宽度和高度 3、Activity窗口的可见状态，即viewVisibility 4、Activity窗口是否有额外的内容区域边衬和可见区域边衬等待告诉给WindowManagerService服务，即参数insetsPending 5、mWinFrame，这是一个输出参数，用来保存WindowManagerService服务计算后得到的Activity窗口的大小 6、mPendingOverscanInsets用来保存Overscan边衬，mPendingContentInsets用来保存内容区域边衬，mPendingVisibleInsets用来保存可见区域边衬，mPendingStableInsets用来保存可能被系统UI元素部分或完全遮蔽的全屏窗口区域 7、mPendingConfiguration，这是一个输出参数，用来保存WindowManagerService服务返回来的Activity窗口的配置信息 8、mSurface，这是一个输出参数，用来保存WindowManagerService服务返回来的Activity窗口的绘图表面</p><h3 id="2-2-3、Session-relayout"><a href="#2-2-3、Session-relayout" class="headerlink" title="2.2.3、Session.relayout()"></a>2.2.3、Session.relayout()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;Session.java]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">relayout</span><span class="params">(IWindow window, <span class="keyword">int</span> seq, WindowManager.LayoutParams attrs,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> requestedWidth, <span class="keyword">int</span> requestedHeight, <span class="keyword">int</span> viewFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> flags, Rect outFrame, Rect outOverscanInsets, Rect outContentInsets,</span></span></span><br><span class="line"><span class="function"><span class="params">        Rect outVisibleInsets, Rect outStableInsets, Rect outsets, Rect outBackdropFrame,</span></span></span><br><span class="line"><span class="function"><span class="params">        Configuration outConfig, Surface outSurface)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = mService.relayoutWindow(<span class="keyword">this</span>, window, seq, attrs,</span><br><span class="line">            requestedWidth, requestedHeight, viewFlags, flags,</span><br><span class="line">            outFrame, outOverscanInsets, outContentInsets, outVisibleInsets,</span><br><span class="line">            outStableInsets, outsets, outBackdropFrame, outConfig, outSurface);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只是调用了WindowManagerService类的成员函数relayoutWindow来进一步计算参数window所描述的一个Activity窗品的大小</p><h3 id="2-2-4、WindowManagerService-relayoutWindow"><a href="#2-2-4、WindowManagerService-relayoutWindow" class="headerlink" title="2.2.4、WindowManagerService.relayoutWindow()"></a>2.2.4、WindowManagerService.relayoutWindow()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowManagerService.java]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">relayoutWindow</span><span class="params">(Session session, IWindow client, <span class="keyword">int</span> seq,</span></span></span><br><span class="line"><span class="function"><span class="params">        WindowManager.LayoutParams attrs, <span class="keyword">int</span> requestedWidth,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> requestedHeight, <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">        Rect outFrame, Rect outOverscanInsets, Rect outContentInsets,</span></span></span><br><span class="line"><span class="function"><span class="params">        Rect outVisibleInsets, Rect outStableInsets, Rect outOutsets, Rect outBackdropFrame,</span></span></span><br><span class="line"><span class="function"><span class="params">        Configuration outConfig, Surface outSurface)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">synchronized</span>(mWindowMap) &#123;</span><br><span class="line">        WindowState win = windowForClientLocked(session, client, <span class="keyword">false</span>);</span><br><span class="line">        WindowStateAnimator winAnimator = win.mWinAnimator;</span><br><span class="line">        <span class="keyword">if</span> (viewVisibility != View.GONE) &#123;</span><br><span class="line">            win.setRequestedSize(requestedWidth, requestedHeight);</span><br><span class="line">        &#125;</span><br><span class="line">        .....</span><br><span class="line">        <span class="keyword">if</span> (attrs != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mPolicy.adjustWindowParamsLw(attrs);</span><br><span class="line">                ......</span><br><span class="line">        &#125;</span><br><span class="line">        win.setWindowScale(win.mRequestedWidth, win.mRequestedHeight);</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (viewVisibility == View.VISIBLE &amp;&amp;</span><br><span class="line">                (win.mAppToken == <span class="keyword">null</span> || !win.mAppToken.clientHidden)) &#123;</span><br><span class="line">            result = relayoutVisibleWindow(outConfig, result, win, winAnimator, attrChanges,</span><br><span class="line">                    oldVisibility);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                result = createSurfaceControl(outSurface, result, win, winAnimator);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                ......</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">            win.adjustStartingWindowFlags();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        mWindowPlacerLocked.performSurfacePlacement();</span><br><span class="line">        ......</span><br><span class="line">        outFrame.set(win.mCompatFrame);</span><br><span class="line">        outOverscanInsets.set(win.mOverscanInsets);</span><br><span class="line">        outContentInsets.set(win.mContentInsets);</span><br><span class="line">        outVisibleInsets.set(win.mVisibleInsets);</span><br><span class="line">        outStableInsets.set(win.mStableInsets);</span><br><span class="line">        outOutsets.set(win.mOutsets);</span><br><span class="line">        outBackdropFrame.set(win.getBackdropFrame(win.mFrame));</span><br><span class="line">        ......</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只关注relayoutWindow中与窗口大小计算有关的逻辑，计算过程如下所示： 1、参数requestedWidth和requestedHeight描述的是应用程序进程请求设置Activity窗口中的宽度和高度，它们会被记录在WindowState对象win的成员变量mRequestedWidth和mRequestedHeight中 2、WindowState对象win的成员变量mAttrs，它指向的是一个WindowManager.LayoutParams对象，用来描述Activity窗口的布局参数 3、调用WindowSurfacePlacer.performSurfacePlacement()来计算Activity窗口的大小。计算完成之后，参数client所描述的Activity窗口的大小、内容区域边衬大小和可见区域边边衬大小就会分别保存在WindowState对象win的成员变量mCompatFrame、mOverscanInsets、mContentInsets、mVisibleInsets、mStableInsets、mOutsets中 4、 将WindowState对象win的成员变量mCompatFrame、mOverscanInsets、mContentInsets、mVisibleInsets、mStableInsets、mOutsets拷贝赋值对应变量中，以便可以返回给应用程序进程</p><p>经过上述4个操作后，Activity窗口的大小计算过程就完成了，接下来我们继续分析WindowSurfacePlacer.performSurfacePlacement()的实现，以便可以详细了解Activity窗口的大小计算过程</p><h3 id="2-2-5、WindowSurfacePlacer-performSurfacePlacement"><a href="#2-2-5、WindowSurfacePlacer-performSurfacePlacement" class="headerlink" title="2.2.5、WindowSurfacePlacer.performSurfacePlacement()"></a>2.2.5、WindowSurfacePlacer.performSurfacePlacement()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowSurfacePlacer.java]</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performSurfacePlacement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDeferDepth &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> loopCount = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">false</span>;</span><br><span class="line">        performSurfacePlacementLoop();</span><br><span class="line">        mService.mH.removeMessages(DO_TRAVERSAL);</span><br><span class="line">        loopCount--;</span><br><span class="line">    &#125; <span class="keyword">while</span> (mTraversalScheduled &amp;&amp; loopCount &gt; <span class="number">0</span>);</span><br><span class="line">    mWallpaperActionPending = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-6-WindowSurfacePlacer-performSurfacePlacementLoop"><a href="#2-2-6-WindowSurfacePlacer-performSurfacePlacementLoop" class="headerlink" title="2.2.6.WindowSurfacePlacer.performSurfacePlacementLoop()"></a>2.2.6.WindowSurfacePlacer.performSurfacePlacementLoop()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowSurfacePlacer.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performSurfacePlacementLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       mInLayout = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">boolean</span> recoveringMemory = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!mService.mForceRemoves.isEmpty()) &#123;</span><br><span class="line">            recoveringMemory = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (!mService.mForceRemoves.isEmpty()) &#123;</span><br><span class="line">                WindowState ws = mService.mForceRemoves.remove(<span class="number">0</span>);</span><br><span class="line">                mService.removeWindowInnerLocked(ws);</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        performSurfacePlacementInner(recoveringMemory);</span><br><span class="line"></span><br><span class="line">        mInLayout = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mService.needsLayout()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (++mLayoutRepeatCount &lt; <span class="number">6</span>) &#123;</span><br><span class="line">                requestTraversal();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Slog.e(TAG, <span class="string">"Performed 6 layouts in a row. Skipping"</span>);</span><br><span class="line">                mLayoutRepeatCount = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mLayoutRepeatCount = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mService.mWindowsChanged &amp;&amp; !mService.mWindowChangeListeners.isEmpty()) &#123;</span><br><span class="line">            mService.mH.removeMessages(REPORT_WINDOWS_CHANGE);</span><br><span class="line">            mService.mH.sendEmptyMessage(REPORT_WINDOWS_CHANGE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        mInLayout = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用成员函数performSurfacePlacementInner()刷新系统UI的前后 1、检查系统中是否存在强制删除的窗口 2、检查系统中是否有窗口需要移除</p><h3 id="2-2-7、WindowSurfacePlacer-performSurfacePlacementInner"><a href="#2-2-7、WindowSurfacePlacer-performSurfacePlacementInner" class="headerlink" title="2.2.7、WindowSurfacePlacer.performSurfacePlacementInner()"></a>2.2.7、WindowSurfacePlacer.performSurfacePlacementInner()</h3><p>继续分析的performSurfacePlacementInner()实现，以便可以了解Activity窗口的大小计算过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowSurfacePlacer.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performSurfacePlacementInner</span><span class="params">(<span class="keyword">boolean</span> recoveringMemory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_WINDOW_TRACE) Slog.v(TAG, <span class="string">"performSurfacePlacementInner: entry. Called by "</span></span><br><span class="line">            + Debug.getCallers(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> DisplayContent defaultDisplay = mService.getDefaultDisplayContentLocked();</span><br><span class="line">    <span class="keyword">final</span> DisplayInfo defaultInfo = defaultDisplay.getDisplayInfo();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> defaultDw = defaultInfo.logicalWidth;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> defaultDh = defaultInfo.logicalHeight;</span><br><span class="line">    SurfaceControl.openTransaction();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        applySurfaceChangesTransaction(recoveringMemory, numDisplays, defaultDw, defaultDh);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        Slog.wtf(TAG, <span class="string">"Unhandled exception in Window Manager"</span>, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        SurfaceControl.closeTransaction();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> WindowList defaultWindows = defaultDisplay.getWindowList();</span><br><span class="line">    ......</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = mService.mPendingRemove.size();</span><br><span class="line">        <span class="keyword">if</span> (N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mService.mPendingRemoveTmp.length &lt; N) &#123;</span><br><span class="line">                mService.mPendingRemoveTmp = <span class="keyword">new</span> WindowState[N+<span class="number">10</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            mService.mPendingRemove.toArray(mService.mPendingRemoveTmp);</span><br><span class="line">            mService.mPendingRemove.clear();</span><br><span class="line">            DisplayContentList displayList = <span class="keyword">new</span> DisplayContentList();</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">                WindowState w = mService.mPendingRemoveTmp[i];</span><br><span class="line">                mService.removeWindowInnerLocked(w);</span><br><span class="line">                <span class="keyword">final</span> DisplayContent displayContent = w.getDisplayContent();</span><br><span class="line">                <span class="keyword">if</span> (displayContent != <span class="keyword">null</span> &amp;&amp; !displayList.contains(displayContent)) &#123;</span><br><span class="line">                    displayList.add(displayContent);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (DisplayContent displayContent : displayList) &#123;</span><br><span class="line">                mService.mLayersController.assignLayersLocked(displayContent.getWindowList());</span><br><span class="line">                displayContent.layoutNeeded = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        mService.scheduleAnimationLocked();</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到进一步调用applySurfaceChangesTransaction()方法进行进一步计算</p><h3 id="2-2-8、WindowSurfacePlacer-applySurfaceChangesTransaction"><a href="#2-2-8、WindowSurfacePlacer-applySurfaceChangesTransaction" class="headerlink" title="2.2.8、WindowSurfacePlacer.applySurfaceChangesTransaction()"></a>2.2.8、WindowSurfacePlacer.applySurfaceChangesTransaction()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowSurfacePlacer.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">applySurfaceChangesTransaction</span><span class="params">(<span class="keyword">boolean</span> recoveringMemory, <span class="keyword">int</span> numDisplays,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> defaultDw, <span class="keyword">int</span> defaultDh)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">boolean</span> focusDisplayed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> displayNdx = <span class="number">0</span>; displayNdx &lt; numDisplays; ++displayNdx) &#123;</span><br><span class="line">        <span class="keyword">final</span> DisplayContent displayContent = mService.mDisplayContents.valueAt(displayNdx);</span><br><span class="line">        <span class="keyword">boolean</span> updateAllDrawn = <span class="keyword">false</span>;</span><br><span class="line">        WindowList windows = displayContent.getWindowList();</span><br><span class="line">        DisplayInfo displayInfo = displayContent.getDisplayInfo();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> displayId = displayContent.getDisplayId();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> dw = displayInfo.logicalWidth;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> dh = displayInfo.logicalHeight;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> innerDw = displayInfo.appWidth;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> innerDh = displayInfo.appHeight;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isDefaultDisplay = (displayId == Display.DEFAULT_DISPLAY);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reset for each display.</span></span><br><span class="line">        mDisplayHasContent = <span class="keyword">false</span>;</span><br><span class="line">        mPreferredRefreshRate = <span class="number">0</span>;</span><br><span class="line">        mPreferredModeId = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> repeats = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            repeats++;</span><br><span class="line">            <span class="keyword">if</span> (repeats &gt; <span class="number">6</span>) &#123;<span class="comment">//最多执行7次的while循环</span></span><br><span class="line">                displayContent.layoutNeeded = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//通知SurfaceFlinger服务了，也就是让SurfaceFlinger服务更新它里面的各个Layer的属性值，以便可以对这些Layer执行可见性计算、合成等操作，最后渲染到硬件帧缓冲区中去</span></span><br><span class="line">            <span class="keyword">if</span> ((displayContent.pendingLayoutChanges &amp; FINISH_LAYOUT_REDO_WALLPAPER) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    mWallpaperControllerLocked.adjustWallpaperWindows()) &#123;</span><br><span class="line">                mService.mLayersController.assignLayersLocked(windows);</span><br><span class="line">                displayContent.layoutNeeded = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">           ......</span><br><span class="line">            <span class="keyword">if</span> ((displayContent.pendingLayoutChanges &amp; FINISH_LAYOUT_REDO_LAYOUT) != <span class="number">0</span>) &#123;</span><br><span class="line">                displayContent.layoutNeeded = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// FIRST LOOP: Perform a layout, if needed.</span></span><br><span class="line">            <span class="comment">//计算各个窗品的大小</span></span><br><span class="line">            <span class="keyword">if</span> (repeats &lt; LAYOUT_REPEAT_THRESHOLD) &#123;</span><br><span class="line">                performLayoutLockedInner(displayContent, repeats == <span class="number">1</span>,</span><br><span class="line">                        <span class="keyword">false</span> <span class="comment">/* updateInputWindows */</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// FIRST AND ONE HALF LOOP: Make WindowManagerPolicy think</span></span><br><span class="line">            <span class="comment">// it is animating.</span></span><br><span class="line">            displayContent.pendingLayoutChanges = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isDefaultDisplay) &#123;</span><br><span class="line">                mService.mPolicy.beginPostLayoutPolicyLw(dw, dh);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = windows.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                    WindowState w = windows.get(i);</span><br><span class="line">                    <span class="keyword">if</span> (w.mHasSurface) &#123;</span><br><span class="line">                        mService.mPolicy.applyPostLayoutPolicyLw(w, w.mAttrs,</span><br><span class="line">                                w.mAttachedWindow);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                displayContent.pendingLayoutChanges |=</span><br><span class="line">                        mService.mPolicy.finishPostLayoutPolicyLw();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (displayContent.pendingLayoutChanges != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-9、WindowSurfacePlacer-applySurfaceChangesTransaction"><a href="#2-2-9、WindowSurfacePlacer-applySurfaceChangesTransaction" class="headerlink" title="2.2.9、WindowSurfacePlacer.applySurfaceChangesTransaction()"></a>2.2.9、WindowSurfacePlacer.applySurfaceChangesTransaction()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowSurfacePlacer.java]</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performLayoutLockedInner</span><span class="params">(<span class="keyword">final</span> DisplayContent displayContent,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> initial, <span class="keyword">boolean</span> updateInputWindows)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    displayContent.layoutNeeded = <span class="keyword">false</span>;</span><br><span class="line">    WindowList windows = displayContent.getWindowList();</span><br><span class="line">    <span class="keyword">boolean</span> isDefaultDisplay = displayContent.isDefaultDisplay;</span><br><span class="line"></span><br><span class="line">    DisplayInfo displayInfo = displayContent.getDisplayInfo();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> dw = displayInfo.logicalWidth;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> dh = displayInfo.logicalHeight;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> N = windows.size();</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    mService.mPolicy.beginLayoutLw(isDefaultDisplay, dw, dh, mService.mRotation,</span><br><span class="line">            mService.mCurConfiguration.uiMode);</span><br><span class="line">    ......</span><br><span class="line">    displayContent.resize(mTmpContentRect);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> seq = mService.mLayoutSeq+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (seq &lt; <span class="number">0</span>) seq = <span class="number">0</span>;</span><br><span class="line">    mService.mLayoutSeq = seq;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> behindDream = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> topAttached = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = N-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">final</span> WindowState win = windows.get(i);</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> gone = (behindDream &amp;&amp; mService.mPolicy.canBeForceHidden(win, win.mAttrs))</span><br><span class="line">                || win.isGoneForLayoutLw();</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (!gone || !win.mHaveFrame || win.mLayoutNeeded</span><br><span class="line">                || ((win.isConfigChanged() || win.setReportResizeHints())</span><br><span class="line">                        &amp;&amp; !win.isGoneForLayoutLw() &amp;&amp;</span><br><span class="line">                        ((win.mAttrs.privateFlags &amp; PRIVATE_FLAG_KEYGUARD) != <span class="number">0</span> ||</span><br><span class="line">                        (win.mHasSurface &amp;&amp; win.mAppToken != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                        win.mAppToken.layoutConfigChanges)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!win.mLayoutAttached) &#123;</span><br><span class="line">                ......</span><br><span class="line">                win.mLayoutNeeded = <span class="keyword">false</span>;</span><br><span class="line">                win.prelayout();</span><br><span class="line">                mService.mPolicy.layoutWindowLw(win, <span class="keyword">null</span>);</span><br><span class="line">                win.mLayoutSeq = seq;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Window frames may have changed. Update dim layer with the new bounds.</span></span><br><span class="line">                <span class="keyword">final</span> Task task = win.getTask();</span><br><span class="line">                <span class="keyword">if</span> (task != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    displayContent.mDimLayerController.updateDimLayer(task);</span><br><span class="line">                &#125;</span><br><span class="line">                ......</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> attachedBehindDream = <span class="keyword">false</span>;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">for</span> (i = topAttached; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">final</span> WindowState win = windows.get(i);</span><br><span class="line">        <span class="keyword">if</span> (win.mLayoutAttached) &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">if</span> ((win.mViewVisibility != View.GONE &amp;&amp; win.mRelayoutCalled)</span><br><span class="line">                    || !win.mHaveFrame || win.mLayoutNeeded) &#123;</span><br><span class="line">                ......</span><br><span class="line">                win.mLayoutNeeded = <span class="keyword">false</span>;</span><br><span class="line">                win.prelayout();</span><br><span class="line">                mService.mPolicy.layoutWindowLw(win, win.mAttachedWindow);</span><br><span class="line">                win.mLayoutSeq = seq;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (win.mAttrs.type == TYPE_DREAM) &#123;</span><br><span class="line">            attachedBehindDream = behindDream;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Window frames may have changed. Tell the input dispatcher about it.</span></span><br><span class="line">    mService.mInputMonitor.setUpdateInputWindowsNeededLw();</span><br><span class="line">    <span class="keyword">if</span> (updateInputWindows) &#123;</span><br><span class="line">        mService.mInputMonitor.updateInputWindowsLw(<span class="keyword">false</span> <span class="comment">/*force*/</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mService.mPolicy.finishLayoutLw();</span><br><span class="line">    mService.mH.sendEmptyMessage(UPDATE_DOCKED_STACK_DIVIDER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、mPolicy指向的是一个窗口管理策略类，即PhoneWindowManager对象，主要是用来制定窗口的大小计算策略 2、准备阶段：调用PhoneWindowManager.beginLayoutLw()来设置屏幕的大小。包括NavigationBar、StatusBar大小计算 3、计算阶段：调用PhoneWindowManager.layoutWindowLw()来计算各个窗口的大小、内容区域边衬大小以及可见区域边衬大小。 4、结束阶段：调用PhoneWindowManager类的成员函数finishLayoutLw()来执行一些清理工作。</p><h3 id="2-2-10、PhoneWindowManager-beginLayoutLw"><a href="#2-2-10、PhoneWindowManager-beginLayoutLw" class="headerlink" title="2.2.10、PhoneWindowManager.beginLayoutLw()"></a>2.2.10、PhoneWindowManager.beginLayoutLw()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;PhoneWindowManager.java]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beginLayoutLw</span><span class="params">(<span class="keyword">boolean</span> isDefaultDisplay, <span class="keyword">int</span> displayWidth, <span class="keyword">int</span> displayHeight,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> displayRotation, <span class="keyword">int</span> uiMode)</span> </span>&#123;</span><br><span class="line">    mDisplayRotation = displayRotation;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> overscanLeft, overscanTop, overscanRight, overscanBottom;</span><br><span class="line">    <span class="keyword">if</span> (isDefaultDisplay) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (displayRotation) &#123;</span><br><span class="line">            <span class="keyword">case</span> Surface.ROTATION_90:</span><br><span class="line">                overscanLeft = mOverscanTop;</span><br><span class="line">                overscanTop = mOverscanRight;</span><br><span class="line">                overscanRight = mOverscanBottom;</span><br><span class="line">                overscanBottom = mOverscanLeft;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        overscanLeft = <span class="number">0</span>;</span><br><span class="line">        overscanTop = <span class="number">0</span>;</span><br><span class="line">        overscanRight = <span class="number">0</span>;</span><br><span class="line">        overscanBottom = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mOverscanScreenLeft = mRestrictedOverscanScreenLeft = <span class="number">0</span>;</span><br><span class="line">    mOverscanScreenTop = mRestrictedOverscanScreenTop = <span class="number">0</span>;</span><br><span class="line">    mOverscanScreenWidth = mRestrictedOverscanScreenWidth = displayWidth;</span><br><span class="line">    mOverscanScreenHeight = mRestrictedOverscanScreenHeight = displayHeight;</span><br><span class="line">    mSystemLeft = <span class="number">0</span>;</span><br><span class="line">    mSystemTop = <span class="number">0</span>;</span><br><span class="line">    mSystemRight = displayWidth;</span><br><span class="line">    mSystemBottom = displayHeight;</span><br><span class="line">    mUnrestrictedScreenLeft = overscanLeft;</span><br><span class="line">    mUnrestrictedScreenTop = overscanTop;</span><br><span class="line">    mUnrestrictedScreenWidth = displayWidth - overscanLeft - overscanRight;</span><br><span class="line">    mUnrestrictedScreenHeight = displayHeight - overscanTop - overscanBottom;</span><br><span class="line">    mRestrictedScreenLeft = mUnrestrictedScreenLeft;</span><br><span class="line">    mRestrictedScreenTop = mUnrestrictedScreenTop;</span><br><span class="line">    mRestrictedScreenWidth = mSystemGestures.screenWidth = mUnrestrictedScreenWidth;</span><br><span class="line">    mRestrictedScreenHeight = mSystemGestures.screenHeight = mUnrestrictedScreenHeight;</span><br><span class="line">    mDockLeft = mContentLeft = mVoiceContentLeft = mStableLeft = mStableFullscreenLeft</span><br><span class="line">            = mCurLeft = mUnrestrictedScreenLeft;</span><br><span class="line">    mDockTop = mContentTop = mVoiceContentTop = mStableTop = mStableFullscreenTop</span><br><span class="line">            = mCurTop = mUnrestrictedScreenTop;</span><br><span class="line">    mDockRight = mContentRight = mVoiceContentRight = mStableRight = mStableFullscreenRight</span><br><span class="line">            = mCurRight = displayWidth - overscanRight;</span><br><span class="line">    mDockBottom = mContentBottom = mVoiceContentBottom = mStableBottom = mStableFullscreenBottom</span><br><span class="line">            = mCurBottom = displayHeight - overscanBottom;</span><br><span class="line">    mDockLayer = <span class="number">0x10000000</span>;</span><br><span class="line">    mStatusBarLayer = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// start with the current dock rect, which will be (0,0,displayWidth,displayHeight)</span></span><br><span class="line">    <span class="keyword">final</span> Rect pf = mTmpParentFrame;</span><br><span class="line">    <span class="keyword">final</span> Rect df = mTmpDisplayFrame;</span><br><span class="line">    <span class="keyword">final</span> Rect of = mTmpOverscanFrame;</span><br><span class="line">    <span class="keyword">final</span> Rect vf = mTmpVisibleFrame;</span><br><span class="line">    <span class="keyword">final</span> Rect dcf = mTmpDecorFrame;</span><br><span class="line">    pf.left = df.left = of.left = vf.left = mDockLeft;</span><br><span class="line">    pf.top = df.top = of.top = vf.top = mDockTop;</span><br><span class="line">    pf.right = df.right = of.right = vf.right = mDockRight;</span><br><span class="line">    pf.bottom = df.bottom = of.bottom = vf.bottom = mDockBottom;</span><br><span class="line">    dcf.setEmpty();  <span class="comment">// Decor frame N/A for system bars.</span></span><br><span class="line">        .......</span><br><span class="line">        <span class="keyword">if</span> (isDefaultDisplay) &#123;</span><br><span class="line">        navVisible |= !canHideNavigationBar();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> updateSysUiVisibility = layoutNavigationBar(displayWidth, displayHeight,</span><br><span class="line">                displayRotation, uiMode, overscanLeft, overscanRight, overscanBottom, dcf, navVisible, navTranslucent,navAllowedHidden, statusBarExpandedNotKeyguard);</span><br><span class="line">        updateSysUiVisibility |= layoutStatusBar(pf, df, of, vf, dcf, sysui, isKeyguardShowing);</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (updateSysUiVisibility) &#123;</span><br><span class="line">            updateSystemUiVisibilityLw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、初始化Overscan、UnrestrictedScreen、RestrictedScreen等屏幕区域变量 2、计算NavigationBar和StatusBar大小</p><h3 id="2-2-11、PhoneWindowManager-layoutWindowLw"><a href="#2-2-11、PhoneWindowManager-layoutWindowLw" class="headerlink" title="2.2.11、PhoneWindowManager.layoutWindowLw()"></a>2.2.11、PhoneWindowManager.layoutWindowLw()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;PhoneWindowManager.java]</span><br><span class="line">Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layoutWindowLw</span><span class="params">(WindowState win, WindowState attached)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> fl = PolicyControl.getWindowFlags(win, attrs);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> pfl = attrs.privateFlags;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> sim = attrs.softInputMode;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> sysUiFl = PolicyControl.getSystemUiVisibility(win, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Rect pf = mTmpParentFrame;</span><br><span class="line">    <span class="keyword">final</span> Rect df = mTmpDisplayFrame;</span><br><span class="line">    <span class="keyword">final</span> Rect of = mTmpOverscanFrame;</span><br><span class="line">    <span class="keyword">final</span> Rect cf = mTmpContentFrame;</span><br><span class="line">    <span class="keyword">final</span> Rect vf = mTmpVisibleFrame;</span><br><span class="line">    <span class="keyword">final</span> Rect dcf = mTmpDecorFrame;</span><br><span class="line">    <span class="keyword">final</span> Rect sf = mTmpStableFrame;</span><br><span class="line">    Rect osf = <span class="keyword">null</span>;</span><br><span class="line">    dcf.setEmpty();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> hasNavBar = (isDefaultDisplay &amp;&amp; mHasNavigationBar</span><br><span class="line">            &amp;&amp; mNavigationBar != <span class="keyword">null</span> &amp;&amp; mNavigationBar.isVisibleLw());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> adjust = sim &amp; SOFT_INPUT_MASK_ADJUST;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isDefaultDisplay) &#123;</span><br><span class="line">        sf.set(mStableLeft, mStableTop, mStableRight, mStableBottom);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sf.set(mOverscanLeft, mOverscanTop, mOverscanRight, mOverscanBottom);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isDefaultDisplay) &#123;</span><br><span class="line">        <span class="keyword">if</span> (attached != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// If this window is attached to another, our display</span></span><br><span class="line">            <span class="comment">// frame is the same as the one we are attached to.</span></span><br><span class="line">            setAttachedWindowFrames(win, fl, adjust, attached, <span class="keyword">true</span>, pf, df, of, cf, vf);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Give the window full screen.</span></span><br><span class="line">            pf.left = df.left = of.left = cf.left = mOverscanScreenLeft;</span><br><span class="line">            pf.top = df.top = of.top = cf.top = mOverscanScreenTop;</span><br><span class="line">            pf.right = df.right = of.right = cf.right</span><br><span class="line">                    = mOverscanScreenLeft + mOverscanScreenWidth;</span><br><span class="line">            pf.bottom = df.bottom = of.bottom = cf.bottom</span><br><span class="line">                    = mOverscanScreenTop + mOverscanScreenHeight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; ......</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    win.computeFrameLw(pf, df, of, cf, vf, dcf, sf, osf);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后调用WindowState.computeFrameLw来计算窗口win的具体大小了。计算的结果便得到了窗口win的大小，以及它的内容区域边衬大小和可见区域边衬大小。</p><h3 id="2-2-12、WindowState-computeFrameLw"><a href="#2-2-12、WindowState-computeFrameLw" class="headerlink" title="2.2.12、WindowState.computeFrameLw()"></a>2.2.12、WindowState.computeFrameLw()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowState.java]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computeFrameLw</span><span class="params">(Rect pf, Rect df, Rect of, Rect cf, Rect vf, Rect dcf, Rect sf,</span></span></span><br><span class="line"><span class="function"><span class="params">        Rect osf)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">final</span> Task task = getTask();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> fullscreenTask = !isInMultiWindowMode();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> windowsAreFloating = task != <span class="keyword">null</span> &amp;&amp; task.isFloating();</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">final</span> Rect layoutContainingFrame;</span><br><span class="line">    <span class="keyword">final</span> Rect layoutDisplayFrame;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The offset from the layout containing frame to the actual containing frame.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> layoutXDiff;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> layoutYDiff;</span><br><span class="line">    <span class="keyword">if</span> (fullscreenTask || layoutInParentFrame()) &#123;</span><br><span class="line">        <span class="comment">// We use the parent frame as the containing frame for fullscreen and child windows</span></span><br><span class="line">        mContainingFrame.set(pf);</span><br><span class="line">        mDisplayFrame.set(df);</span><br><span class="line">        layoutDisplayFrame = df;</span><br><span class="line">        layoutContainingFrame = pf;</span><br><span class="line">        layoutXDiff = <span class="number">0</span>;</span><br><span class="line">        layoutYDiff = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        task.getBounds(mContainingFrame);</span><br><span class="line">        ......</span><br><span class="line">        mDisplayFrame.set(mContainingFrame);</span><br><span class="line">        layoutXDiff = !mInsetFrame.isEmpty() ? mInsetFrame.left - mContainingFrame.left : <span class="number">0</span>;</span><br><span class="line">        layoutYDiff = !mInsetFrame.isEmpty() ? mInsetFrame.top - mContainingFrame.top : <span class="number">0</span>;</span><br><span class="line">        layoutContainingFrame = !mInsetFrame.isEmpty() ? mInsetFrame : mContainingFrame;</span><br><span class="line">        mTmpRect.set(<span class="number">0</span>, <span class="number">0</span>, mDisplayContent.getDisplayInfo().logicalWidth,</span><br><span class="line">                mDisplayContent.getDisplayInfo().logicalHeight);</span><br><span class="line">        subtractInsets(mDisplayFrame, layoutContainingFrame, df, mTmpRect);</span><br><span class="line">        ......</span><br><span class="line">        layoutDisplayFrame = df;</span><br><span class="line">        layoutDisplayFrame.intersect(layoutContainingFrame);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> pw = mContainingFrame.width();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> ph = mContainingFrame.height();</span><br><span class="line">    ......</span><br><span class="line">    mOverscanFrame.set(of);</span><br><span class="line">    mContentFrame.set(cf);</span><br><span class="line">    mVisibleFrame.set(vf);</span><br><span class="line">    mDecorFrame.set(dcf);</span><br><span class="line">    mStableFrame.set(sf);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> hasOutsets = osf != <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> fw = mFrame.width();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> fh = mFrame.height();</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (windowsAreFloating &amp;&amp; !mFrame.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> height = Math.min(mFrame.height(), mContentFrame.height());</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> width = Math.min(mContentFrame.width(), mFrame.width());</span><br><span class="line">        <span class="keyword">final</span> DisplayMetrics displayMetrics = getDisplayContent().getDisplayMetrics();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> minVisibleHeight = Math.min(height, WindowManagerService.dipToPixel(</span><br><span class="line">                MINIMUM_VISIBLE_HEIGHT_IN_DP, displayMetrics));</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> minVisibleWidth = Math.min(width, WindowManagerService.dipToPixel(</span><br><span class="line">                MINIMUM_VISIBLE_WIDTH_IN_DP, displayMetrics));</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> top = Math.max(mContentFrame.top,</span><br><span class="line">                Math.min(mFrame.top, mContentFrame.bottom - minVisibleHeight));</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> left = Math.max(mContentFrame.left + minVisibleWidth - width,</span><br><span class="line">                Math.min(mFrame.left, mContentFrame.right - minVisibleWidth));</span><br><span class="line">        mFrame.set(left, top, left + width, top + height);</span><br><span class="line">        mContentFrame.set(mFrame);</span><br><span class="line">        mVisibleFrame.set(mContentFrame);</span><br><span class="line">        mStableFrame.set(mContentFrame);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mAttrs.type == TYPE_DOCK_DIVIDER) &#123;</span><br><span class="line">        mDisplayContent.getDockedDividerController().positionDockedStackedDivider(mFrame);</span><br><span class="line">        mContentFrame.set(mFrame);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mContentFrame.set(......);</span><br><span class="line"></span><br><span class="line">        mVisibleFrame.set(......);</span><br><span class="line"></span><br><span class="line">        mStableFrame.set(......);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fullscreenTask &amp;&amp; !windowsAreFloating) &#123;</span><br><span class="line">        <span class="comment">// Windows that are not fullscreen can be positioned outside of the display frame,</span></span><br><span class="line">        mOverscanInsets.set(......);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mAttrs.type == TYPE_DOCK_DIVIDER) &#123;</span><br><span class="line">        mStableInsets.set(......);</span><br><span class="line">        mContentInsets.setEmpty();</span><br><span class="line">        mVisibleInsets.setEmpty();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        getDisplayContent().getLogicalDisplayRect(mTmpRect);</span><br><span class="line">        <span class="keyword">boolean</span> overrideRightInset = !fullscreenTask &amp;&amp; mFrame.right &gt; mTmpRect.right;</span><br><span class="line">        <span class="keyword">boolean</span> overrideBottomInset = !fullscreenTask &amp;&amp; mFrame.bottom &gt; mTmpRect.bottom;</span><br><span class="line">        mContentInsets.set(......);</span><br><span class="line"></span><br><span class="line">        mVisibleInsets.set(......);</span><br><span class="line"></span><br><span class="line">        mStableInsets.set(......);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Offset the actual frame by the amount layout frame is off.</span></span><br><span class="line">    mFrame.offset(-layoutXDiff, -layoutYDiff);</span><br><span class="line">    mCompatFrame.offset(-layoutXDiff, -layoutYDiff);</span><br><span class="line">    mContentFrame.offset(-layoutXDiff, -layoutYDiff);</span><br><span class="line">    mVisibleFrame.offset(-layoutXDiff, -layoutYDiff);</span><br><span class="line">    mStableFrame.offset(-layoutXDiff, -layoutYDiff);</span><br><span class="line"></span><br><span class="line">    mCompatFrame.set(mFrame);</span><br><span class="line">    <span class="keyword">if</span> (mEnforceSizeCompat) &#123;</span><br><span class="line">        mOverscanInsets.scale(mInvGlobalScale);</span><br><span class="line">        mContentInsets.scale(mInvGlobalScale);</span><br><span class="line">        mVisibleInsets.scale(mInvGlobalScale);</span><br><span class="line">        mStableInsets.scale(mInvGlobalScale);</span><br><span class="line">        mOutsets.scale(mInvGlobalScale);</span><br><span class="line">        mCompatFrame.scale(mInvGlobalScale);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个窗口大小保存在WindowState类的成员变量mFrame中，而窗品的内容区域边衬大小和可见区域边衬大小分别保在WindowState类的成员变量mContentInsets和mVisibleInsets中</p><h3 id="2-2-13、PhoneWindowManager-finishLayoutLw"><a href="#2-2-13、PhoneWindowManager-finishLayoutLw" class="headerlink" title="2.2.13、PhoneWindowManager.finishLayoutLw()"></a>2.2.13、PhoneWindowManager.finishLayoutLw()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[WindowState.java]</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finishLayoutLw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="（三）、Window-Z-Order-计算和调整过程"><a href="#（三）、Window-Z-Order-计算和调整过程" class="headerlink" title="（三）、Window Z-Order 计算和调整过程"></a>（三）、Window Z-Order 计算和调整过程</h2><p>口的UI最终是需要通过SurfaceFlinger服务来统一渲染的，而SurfaceFlinger服务在渲染窗口的UI之前，需要计算基于各个窗口的Z轴位置来计算它们的可见区域。因此，WindowManagerService服务计算好每一个窗口的Z轴位置之后，还需要将它们设置到SurfaceFlinger服务中去，以便SurfaceFlinger服务可以正确地渲染每一个窗口的UI。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.wms/12-Android-WMS-Z-Order.png" alt="Markdown"></p><h3 id="3-1、需要重新计算窗口Z轴位置的情景"><a href="#3-1、需要重新计算窗口Z轴位置的情景" class="headerlink" title="3.1、需要重新计算窗口Z轴位置的情景"></a>3.1、需要重新计算窗口Z轴位置的情景</h3><p>在【Android 7.1.2 (Android N) Activity-Window加载显示流程分析】中已经详细介绍Window添加过程，这里直接从 WMS.addWindow开始分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowManagerService.java]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addWindow</span><span class="params">(Session session, IWindow client, <span class="keyword">int</span> seq,</span></span></span><br><span class="line"><span class="function"><span class="params">        WindowManager.LayoutParams attrs, <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> displayId,</span></span></span><br><span class="line"><span class="function"><span class="params">        Rect outContentInsets, Rect outStableInsets, Rect outOutsets,</span></span></span><br><span class="line"><span class="function"><span class="params">        InputChannel outInputChannel)</span> </span>&#123;</span><br><span class="line">    .......</span><br><span class="line">    <span class="keyword">synchronized</span>(mWindowMap) &#123;</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> addToken = <span class="keyword">false</span>;</span><br><span class="line">        WindowToken token = mTokenMap.get(attrs.token);</span><br><span class="line">        AppWindowToken atoken = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> addToastWindowRequiresToken = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        WindowState win = <span class="keyword">new</span> WindowState(<span class="keyword">this</span>, session, client, token,</span><br><span class="line">                attachedWindow, appOp[<span class="number">0</span>], seq, attrs, viewVisibility, displayContent);</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        origId = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (addToken) &#123;</span><br><span class="line">            mTokenMap.put(attrs.token, token);</span><br><span class="line">        &#125;</span><br><span class="line">        win.attach();</span><br><span class="line">        mWindowMap.put(client.asBinder(), win);</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> imMayMove = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (type == TYPE_INPUT_METHOD) &#123;</span><br><span class="line">            win.mGivenInsetsPending = <span class="keyword">true</span>;</span><br><span class="line">            mInputMethodWindow = win;</span><br><span class="line">            addInputMethodWindowToListLocked(win);</span><br><span class="line">            imMayMove = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == TYPE_INPUT_METHOD_DIALOG) &#123;</span><br><span class="line">            mInputMethodDialogs.add(win);</span><br><span class="line">            addWindowToListInOrderLocked(win, <span class="keyword">true</span>);</span><br><span class="line">            moveInputMethodDialogsLocked(findDesiredInputMethodWindowIndexLocked(<span class="keyword">true</span>));</span><br><span class="line">            imMayMove = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addWindowToListInOrderLocked(win, <span class="keyword">true</span>);</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//重新计算系统中所有窗口的Z轴位置</span></span><br><span class="line">        mLayersController.assignLayersLocked(displayContent.getWindowList());</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WMS.relayoutWindow()也会调用WindowLayersController.assignLayersLocked()重新计算、调整系统中所有窗口的Z轴位置，由于原理类似这里不做解释。</p><h3 id="3-2、计算系统中所有窗口的Z轴位置"><a href="#3-2、计算系统中所有窗口的Z轴位置" class="headerlink" title="3.2、计算系统中所有窗口的Z轴位置"></a>3.2、计算系统中所有窗口的Z轴位置</h3><p>接下来我们就通过WindowState类的构造函数来分析一个窗口的BaseLayer值是如何确定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[WindowState.java]</span><br><span class="line">WindowState(WindowManagerService service, Session s, IWindow c, WindowToken token,</span><br><span class="line">       WindowState attachedWindow, <span class="keyword">int</span> appOp, <span class="keyword">int</span> seq, WindowManager.LayoutParams a,</span><br><span class="line">       <span class="keyword">int</span> viewVisibility, <span class="keyword">final</span> DisplayContent displayContent) &#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((mAttrs.type &gt;= FIRST_SUB_WINDOW &amp;&amp;</span><br><span class="line">            mAttrs.type &lt;= LAST_SUB_WINDOW)) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//windowTypeToLayerLw的返回值并且不是一个窗口的最终的BaseLayer值，而是要将它的返回值乘以一个常量TYPE_LAYER_MULTIPLIER，再加上另外一个常量TYPE_LAYER_OFFSET之后，才得到最终的BaseLayer值</span></span><br><span class="line">        mBaseLayer = mPolicy.windowTypeToLayerLw(</span><br><span class="line">                attachedWindow.mAttrs.type) * WindowManagerService.TYPE_LAYER_MULTIPLIER</span><br><span class="line">                + WindowManagerService.TYPE_LAYER_OFFSET;</span><br><span class="line">        mSubLayer = mPolicy.subWindowTypeToLayerLw(a.type);</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个窗口除了有一个BaseLayer值之外，还有一个SubLayer值，分别保存在一个对应的WindowState对象的成员变量mBaseLayer和mSubLayer。SubLayer值是用来描述一个窗口是否是另外一个窗口的子窗口的。 在继续分析WindowLayersController.assignLayersLocked()之前，我们首先分析PhoneWindowManager.windowTypeToLayerLw()和subWindowTypeToLayerLw()的实现，以便可以了解一个窗口的BaseLayer值和SubLayer值是如何确定的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;PhoneWindowManager.java]</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">windowTypeToLayerLw</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (type &gt;= FIRST_APPLICATION_WINDOW &amp;&amp; type &lt;= LAST_APPLICATION_WINDOW) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">   ......</span><br><span class="line">    <span class="keyword">case</span> TYPE_SYSTEM_DIALOG:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">case</span> TYPE_TOAST:</span><br><span class="line">        <span class="comment">// toasts and the plugged-in battery thing</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">   ......</span><br><span class="line">    <span class="keyword">case</span> TYPE_SYSTEM_ALERT:</span><br><span class="line">        <span class="comment">// like the ANR / app crashed dialogs</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">case</span> TYPE_STATUS_BAR_SUB_PANEL:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">case</span> TYPE_STATUS_BAR:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">case</span> TYPE_STATUS_BAR_PANEL:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">17</span>;</span><br><span class="line">    <span class="keyword">case</span> TYPE_KEYGUARD_DIALOG:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">18</span>;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">case</span> TYPE_NAVIGATION_BAR:</span><br><span class="line">        <span class="comment">// the navigation bar, if available, shows atop most things</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">21</span>;</span><br><span class="line">    <span class="keyword">case</span> TYPE_NAVIGATION_BAR_PANEL:</span><br><span class="line">        <span class="comment">// some panels (e.g. search) need to show on top of the navigation bar</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">22</span>;</span><br><span class="line">    ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** &#123;<span class="doctag">@inheritDoc</span>&#125; */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subWindowTypeToLayerLw</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> TYPE_APPLICATION_PANEL:</span><br><span class="line">    <span class="keyword">case</span> TYPE_APPLICATION_ATTACHED_DIALOG:</span><br><span class="line">        <span class="keyword">return</span> APPLICATION_PANEL_SUBLAYER;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">case</span> TYPE_APPLICATION_ABOVE_SUB_PANEL:</span><br><span class="line">        <span class="keyword">return</span> APPLICATION_ABOVE_SUB_PANEL_SUBLAYER;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要根据不同的Window Type返回不一样的数值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowManagerService.java]</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_LAYER_MULTIPLIER = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_LAYER_OFFSET = <span class="number">1000</span>;</span><br></pre></td></tr></table></figure><p>我们可以用adb shell dumpsys window -a 命令查看一下Layer的数值，可以看到StatusBar的数值计算： mBaseLayer = 16 _WindowManagerService.TYPE_LAYER_MULTIPLIER+ WindowManagerService.TYPE_LAYER<em>OFFSET StatusBar.mBaseLayer = 16</em> 10000 + 1000 = 161000 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Window #4 Window&#123;3c1f1fb u0 StatusBar&#125;:</span><br><span class="line">  mBaseLayer=<span class="number">161000</span> mSubLayer=<span class="number">0</span> mAnimLayer=<span class="number">161000</span>+<span class="number">0</span>=<span class="number">161000</span> mLastLayer=<span class="number">161000</span></span><br><span class="line">Window #3 Window&#123;fe4aae2 u0 KeyguardScrim&#125;:</span><br><span class="line">  mBaseLayer=<span class="number">141000</span> mSubLayer=<span class="number">0</span> mAnimLayer=<span class="number">141000</span>+<span class="number">0</span>=<span class="number">141000</span> mLastLayer=<span class="number">141000</span></span><br><span class="line">Window #2 Window&#123;173ee76 u0 DockedStackDivider&#125;:</span><br><span class="line">  mBaseLayer=<span class="number">21000</span> mSubLayer=<span class="number">0</span> mAnimLayer=<span class="number">21010</span>+<span class="number">0</span>=<span class="number">21010</span> mLastLayer=<span class="number">0</span></span><br><span class="line">Window #1 Window&#123;3a83a4a u0 com.android.launcher&#125;:</span><br><span class="line">  mBaseLayer=<span class="number">21000</span> mSubLayer=<span class="number">0</span> mAnimLayer=<span class="number">21005</span>+<span class="number">0</span>=<span class="number">21005</span> mLastLayer=<span class="number">21005</span></span><br><span class="line">Window #0 Window&#123;aefb7bc u0 com.android.systemui.ImageWallpaper&#125;:</span><br><span class="line">  mBaseLayer=<span class="number">21000</span> mSubLayer=<span class="number">0</span> mAnimLayer=<span class="number">21000</span>+<span class="number">0</span>=<span class="number">21000</span> mLastLayer=<span class="number">21000</span></span><br></pre></td></tr></table></figure><p>理解了窗口的BaseLayer值和SubLayer值的计算过程之外，接下来我们就可以分析WindowManagerService类的成员函数assignLayersLocked()的实现了</p><h3 id="3-2-1、WindowLayersController-assignLayersLocked"><a href="#3-2-1、WindowLayersController-assignLayersLocked" class="headerlink" title="3.2.1、WindowLayersController.assignLayersLocked()"></a>3.2.1、WindowLayersController.assignLayersLocked()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowLayersController.java]</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">assignLayersLocked</span><span class="params">(WindowList windows)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_LAYERS) Slog.v(TAG_WM, <span class="string">"Assigning layers based on windows="</span> + windows,</span><br><span class="line">            <span class="keyword">new</span> RuntimeException(<span class="string">"here"</span>).fillInStackTrace());</span><br><span class="line">    clear();</span><br><span class="line">    <span class="keyword">int</span> curBaseLayer = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> curLayer = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> anyLayerChanged = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, windowCount = windows.size(); i &lt; windowCount; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> WindowState w = windows.get(i);</span><br><span class="line">        <span class="keyword">boolean</span> layerChanged = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> oldLayer = w.mLayer;</span><br><span class="line">        <span class="keyword">if</span> (w.mBaseLayer == curBaseLayer || w.mIsImWindow || (i &gt; <span class="number">0</span> &amp;&amp; w.mIsWallpaper)) &#123;</span><br><span class="line">            curLayer += WINDOW_LAYER_MULTIPLIER;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            curBaseLayer = curLayer = w.mBaseLayer;</span><br><span class="line">        &#125;</span><br><span class="line">        assignAnimLayer(w, curLayer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Preserved old behavior of code here but not sure comparing</span></span><br><span class="line">        <span class="comment">// oldLayer to mAnimLayer and mLayer makes sense...though the</span></span><br><span class="line">        <span class="comment">// worst case would be unintentionalp layer reassignment.</span></span><br><span class="line">        <span class="keyword">if</span> (w.mLayer != oldLayer || w.mWinAnimator.mAnimLayer != oldLayer) &#123;</span><br><span class="line">            layerChanged = <span class="keyword">true</span>;</span><br><span class="line">            anyLayerChanged = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (w.mAppToken != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mHighestApplicationLayer = Math.max(mHighestApplicationLayer,</span><br><span class="line">                    w.mWinAnimator.mAnimLayer);</span><br><span class="line">        &#125;</span><br><span class="line">        collectSpecialWindows(w);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (layerChanged) &#123;</span><br><span class="line">            w.scheduleAnimationIfDimming();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    adjustSpecialWindows();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 assignAnimLayer() 进行Layer调整：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowLayersController.java]</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">assignAnimLayer</span><span class="params">(WindowState w, <span class="keyword">int</span> layer)</span> </span>&#123;</span><br><span class="line">        w.mLayer = layer;</span><br><span class="line">        w.mWinAnimator.mAnimLayer = w.mLayer + w.getAnimLayerAdjustment() +</span><br><span class="line">                    getSpecialWindowAnimLayerAdjustment(w);</span><br><span class="line">        <span class="keyword">if</span> (w.mAppToken != <span class="keyword">null</span> &amp;&amp; w.mAppToken.mAppAnimator.thumbnailForceAboveLayer &gt; <span class="number">0</span></span><br><span class="line">                &amp;&amp; w.mWinAnimator.mAnimLayer &gt; w.mAppToken.mAppAnimator.thumbnailForceAboveLayer) &#123;</span><br><span class="line">            w.mAppToken.mAppAnimator.thumbnailForceAboveLayer = w.mWinAnimator.mAnimLayer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="3-3、设置窗口的Z轴位置到SurfaceFlinger服务中去"><a href="#3-3、设置窗口的Z轴位置到SurfaceFlinger服务中去" class="headerlink" title="3.3、设置窗口的Z轴位置到SurfaceFlinger服务中去"></a>3.3、设置窗口的Z轴位置到SurfaceFlinger服务中去</h3><p>WindowManagerService服务在刷新系统的UI的时候，就会将系统中已经计算好了的窗口Z轴位置设置到SurfaceFlinger服务中去，以便SurfaceFlinger服务可以对系统中的窗口进行可见性计算以及合成和渲染等操作 首先看一下堆栈信息：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">WindowSurfaceController.showSurface()添加打印Log</span><br><span class="line">Slog.i(<span class="string">"zhoujinjian"</span>, <span class="string">"zhoujinjian"</span>,<span class="keyword">new</span> RuntimeException(<span class="string">"here"</span>).fillInStackTrace());</span><br><span class="line"><span class="number">03</span><span class="number">-01</span> <span class="number">19</span>:<span class="number">06</span>:<span class="number">45.229</span>: I/zhoujinjian(<span class="number">1424</span>): zhoujinjian</span><br><span class="line"><span class="number">03</span><span class="number">-01</span> <span class="number">19</span>:<span class="number">06</span>:<span class="number">45.229</span>: I/zhoujinjian(<span class="number">1424</span>): java.lang.RuntimeException: here</span><br><span class="line"><span class="number">03</span><span class="number">-01</span> <span class="number">19</span>:<span class="number">06</span>:<span class="number">45.229</span>: I/zhoujinjian(<span class="number">1424</span>):     at com.android.server.wm.WindowSurfaceController.showSurface(WindowSurfaceController.java:<span class="number">414</span>)</span><br><span class="line"><span class="number">03</span><span class="number">-01</span> <span class="number">19</span>:<span class="number">06</span>:<span class="number">45.229</span>: I/zhoujinjian(<span class="number">1424</span>):     at com.android.server.wm.WindowSurfaceController.updateVisibility(WindowSurfaceController.java:<span class="number">402</span>)</span><br><span class="line"><span class="number">03</span><span class="number">-01</span> <span class="number">19</span>:<span class="number">06</span>:<span class="number">45.229</span>: I/zhoujinjian(<span class="number">1424</span>):     at com.android.server.wm.WindowSurfaceController.showRobustlyInTransaction(WindowSurfaceController.java:<span class="number">391</span>)</span><br><span class="line"><span class="number">03</span><span class="number">-01</span> <span class="number">19</span>:<span class="number">06</span>:<span class="number">45.229</span>: I/zhoujinjian(<span class="number">1424</span>):     at com.android.server.wm.WindowStateAnimator.showSurfaceRobustlyLocked(WindowStateAnimator.java:<span class="number">1814</span>)</span><br><span class="line"><span class="number">03</span><span class="number">-01</span> <span class="number">19</span>:<span class="number">06</span>:<span class="number">45.229</span>: I/zhoujinjian(<span class="number">1424</span>):     at com.android.server.wm.WindowStateAnimator.prepareSurfaceLocked(WindowStateAnimator.java:<span class="number">1609</span>)</span><br><span class="line"><span class="number">03</span><span class="number">-01</span> <span class="number">19</span>:<span class="number">06</span>:<span class="number">45.229</span>: I/zhoujinjian(<span class="number">1424</span>):     at com.android.server.wm.WindowAnimator.animateLocked(WindowAnimator.java:<span class="number">791</span>)</span><br><span class="line"><span class="number">03</span><span class="number">-01</span> <span class="number">19</span>:<span class="number">06</span>:<span class="number">45.229</span>: I/zhoujinjian(<span class="number">1424</span>):     at com.android.server.wm.WindowAnimator.-wrap0(WindowAnimator.java)</span><br><span class="line"><span class="number">03</span><span class="number">-01</span> <span class="number">19</span>:<span class="number">06</span>:<span class="number">45.229</span>: I/zhoujinjian(<span class="number">1424</span>):     at com.android.server.wm.WindowAnimator$<span class="number">1.</span>doFrame(WindowAnimator.java:<span class="number">166</span>)</span><br><span class="line"><span class="number">03</span><span class="number">-01</span> <span class="number">19</span>:<span class="number">06</span>:<span class="number">45.229</span>: I/zhoujinjian(<span class="number">1424</span>):     at android.view.Choreographer$CallbackRecord.run(Choreographer.java:<span class="number">879</span>)</span><br><span class="line"><span class="number">03</span><span class="number">-01</span> <span class="number">19</span>:<span class="number">06</span>:<span class="number">45.229</span>: I/zhoujinjian(<span class="number">1424</span>):     at android.view.Choreographer.doCallbacks(Choreographer.java:<span class="number">693</span>)</span><br><span class="line"><span class="number">03</span><span class="number">-01</span> <span class="number">19</span>:<span class="number">06</span>:<span class="number">45.229</span>: I/zhoujinjian(<span class="number">1424</span>):     at android.view.Choreographer.doFrame(Choreographer.java:<span class="number">625</span>)</span><br><span class="line"><span class="number">03</span><span class="number">-01</span> <span class="number">19</span>:<span class="number">06</span>:<span class="number">45.229</span>: I/zhoujinjian(<span class="number">1424</span>):     at android.view.Choreographer$FrameDisplayEventReceiver.run(Choreographer.java:<span class="number">867</span>)</span><br><span class="line"><span class="number">03</span><span class="number">-01</span> <span class="number">19</span>:<span class="number">06</span>:<span class="number">45.229</span>: I/zhoujinjian(<span class="number">1424</span>):     at android.os.Handler.handleCallback(Handler.java:<span class="number">751</span>)</span><br><span class="line"><span class="number">03</span><span class="number">-01</span> <span class="number">19</span>:<span class="number">06</span>:<span class="number">45.229</span>: I/zhoujinjian(<span class="number">1424</span>):     at android.os.Handler.dispatchMessage(Handler.java:<span class="number">95</span>)</span><br><span class="line"><span class="number">03</span><span class="number">-01</span> <span class="number">19</span>:<span class="number">06</span>:<span class="number">45.229</span>: I/zhoujinjian(<span class="number">1424</span>):     at android.os.Looper.loop(Looper.java:<span class="number">154</span>)</span><br><span class="line"><span class="number">03</span><span class="number">-01</span> <span class="number">19</span>:<span class="number">06</span>:<span class="number">45.229</span>: I/zhoujinjian(<span class="number">1424</span>):     at android.os.HandlerThread.run(HandlerThread.java:<span class="number">61</span>)</span><br><span class="line"><span class="number">03</span><span class="number">-01</span> <span class="number">19</span>:<span class="number">06</span>:<span class="number">45.229</span>: I/zhoujinjian(<span class="number">1424</span>):     at com.android.server.ServiceThread.run(ServiceThread.java:<span class="number">46</span>)</span><br></pre></td></tr></table></figure><p>为了了解WMS是如何将Z轴位置设置到SurfaceFlinger服务中去，首先看一下WMS构造方法中关键对象WindowAnimator的创建</p><h3 id="3-3-1、Vsync刷新UI回调过程"><a href="#3-3-1、Vsync刷新UI回调过程" class="headerlink" title="3.3.1、Vsync刷新UI回调过程"></a>3.3.1、Vsync刷新UI回调过程</h3><p>开机启动时会初始化WMS。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowManagerService.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">WindowManagerService</span><span class="params">(Context context, InputManagerService inputManager,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> haveInputMethods, <span class="keyword">boolean</span> showBootMsgs, <span class="keyword">boolean</span> onlyCore)</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        mAnimator = <span class="keyword">new</span> WindowAnimator(<span class="keyword">this</span>);</span><br><span class="line">        ......</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>调用WindowAnimator构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowAnimator.java]</span><br><span class="line">WindowAnimator(<span class="keyword">final</span> WindowManagerService service) &#123;</span><br><span class="line">    mService = service;</span><br><span class="line">    mContext = service.mContext;</span><br><span class="line">    mPolicy = service.mPolicy;</span><br><span class="line">    mWindowPlacerLocked = service.mWindowPlacerLocked;</span><br><span class="line"></span><br><span class="line">    mAnimationFrameCallback = <span class="keyword">new</span> Choreographer.FrameCallback() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFrame</span><span class="params">(<span class="keyword">long</span> frameTimeNs)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mService.mWindowMap) &#123;</span><br><span class="line">                mService.mAnimationScheduled = <span class="keyword">false</span>;</span><br><span class="line">                animateLocked(frameTimeNs);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到创建了Choreographer.FrameCallback()，前面在【Android-7-1-2-Android-N-Activity-Window加载显示流程】分析过，FrameDisplayEventReceiver（在Choreographer构造方法中初始化）对象用于请求并接收Vsync信号，当Vsync信号到来时，系统会自动调用其onVsync()函数，后面会回调到FrameDisplayEventReceiver.run()方法，再回调函数中执行doFrame()实现屏幕刷新，doFrame()会顺序执行CALLBACK_INPUT、CALLBACK_ANIMATION、CALLBACK_TRAVERSAL 和CALLBACK_COMMIT 对应CallbackQueue队列中注册的回调，从而会执行CallbackRecord.run()，在执行其回调函数时，就需要区别这两种对象类型，如果注册的是Runnable对象，则调用其run()函数，如果注册的是FrameCallback对象，则调用它的doFrame()函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;Choreographer.java]</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CallbackRecord</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> CallbackRecord next;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> dueTime;</span><br><span class="line">    <span class="keyword">public</span> Object action; <span class="comment">// Runnable or FrameCallback</span></span><br><span class="line">    <span class="keyword">public</span> Object token;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">long</span> frameTimeNanos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (token == FRAME_CALLBACK_TOKEN) &#123;</span><br><span class="line">            ((FrameCallback)action).doFrame(frameTimeNanos);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ((Runnable)action).run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此种情况下会执行FrameCallback对象的doFrame()函数（原因稍后再分析动画时详细分析），由WindowAnimator构造函数中可知接着就会执行WindowAnimator.animateLocked()</p><h3 id="3-3-2、准备刷新UI"><a href="#3-3-2、准备刷新UI" class="headerlink" title="3.3.2、准备刷新UI"></a>3.3.2、准备刷新UI</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowAnimator.java]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">animateLocked</span><span class="params">(<span class="keyword">long</span> frameTimeNs)</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (SHOW_TRANSACTIONS) Slog.i(</span><br><span class="line">                TAG, <span class="string">"&gt;&gt;&gt; OPEN TRANSACTION animateLocked"</span>);</span><br><span class="line">        SurfaceControl.openTransaction();</span><br><span class="line">        SurfaceControl.setAnimationTransaction();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> numDisplays = mDisplayContentsAnimators.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numDisplays; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> displayId = mDisplayContentsAnimators.keyAt(i);</span><br><span class="line">                updateAppWindowsLocked(displayId);</span><br><span class="line">                DisplayContentsAnimator displayAnimator = mDisplayContentsAnimators.valueAt(i);</span><br><span class="line">                ......</span><br><span class="line">                updateWindowsLocked(displayId);</span><br><span class="line">                updateWallpaperLocked(displayId);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> WindowList windows = mService.getWindowListLocked(displayId);</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> N = windows.size();</span><br><span class="line">                <span class="comment">//通过一个for循环来遍历保存在窗口堆栈的每一个WindowState对象，以便可以对系统中的每一个窗口的绘图表面进行更新</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">                    windows.get(j).mWinAnimator.prepareSurfaceLocked(<span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">        <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            SurfaceControl.closeTransaction();</span><br><span class="line">            <span class="keyword">if</span> (SHOW_TRANSACTIONS) Slog.i(</span><br><span class="line">                    TAG, <span class="string">"&lt;&lt;&lt; CLOSE TRANSACTION animateLocked"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先获取windows列表，然后循环调用windows.get(j).mWinAnimator.prepareSurfaceLocked(true)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowStateAnimator.java]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepareSurfaceLocked</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> recoveringMemory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> WindowState w = mWin;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> displayed = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//确定该窗口实际要显示的大小、位置、Alpha通道和变换矩阵等信息</span></span><br><span class="line">    computeShownFrameLocked();</span><br><span class="line"></span><br><span class="line">    setSurfaceBoundariesLocked(recoveringMemory);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mIsWallpaper &amp;&amp; !mWin.mWallpaperVisible) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (w.mAttachedHidden || !w.isOnScreen()) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mLastLayer != mAnimLayer</span><br><span class="line">            || mLastAlpha != mShownAlpha</span><br><span class="line">            || mLastDsDx != mDsDx</span><br><span class="line">            || mLastDtDx != mDtDx</span><br><span class="line">            || mLastDsDy != mDsDy</span><br><span class="line">            || mLastDtDy != mDtDy</span><br><span class="line">            || w.mLastHScale != w.mHScale</span><br><span class="line">            || w.mLastVScale != w.mVScale</span><br><span class="line">            || mLastHidden) &#123;</span><br><span class="line">        displayed = <span class="keyword">true</span>;</span><br><span class="line">        mLastAlpha = mShownAlpha;</span><br><span class="line">        mLastLayer = mAnimLayer;</span><br><span class="line">        mLastDsDx = mDsDx;</span><br><span class="line">        mLastDtDx = mDtDx;</span><br><span class="line">        mLastDsDy = mDsDy;</span><br><span class="line">        mLastDtDy = mDtDy;</span><br><span class="line">        w.mLastHScale = w.mHScale;</span><br><span class="line">        w.mLastVScale = w.mVScale;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">boolean</span> prepared =</span><br><span class="line">            mSurfaceController.prepareToShowInTransaction(mShownAlpha, mAnimLayer,</span><br><span class="line">                    mDsDx * w.mHScale * mExtraHScale,</span><br><span class="line">                    mDtDx * w.mVScale * mExtraVScale,</span><br><span class="line">                    mDsDy * w.mHScale * mExtraHScale,</span><br><span class="line">                    mDtDy * w.mVScale * mExtraVScale,</span><br><span class="line">                    recoveringMemory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (prepared &amp;&amp; mLastHidden &amp;&amp; mDrawState == HAS_DRAWN) &#123;</span><br><span class="line">            <span class="keyword">if</span> (showSurfaceRobustlyLocked()) &#123;</span><br><span class="line">                markPreservedSurfaceForDestroy();</span><br><span class="line">                mAnimator.requestRemovalOfReplacedWindows(w);</span><br><span class="line">                mLastHidden = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (mIsWallpaper) &#123;</span><br><span class="line">                    mWallpaperControllerLocked.dispatchWallpaperVisibility(w, <span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                ......</span><br><span class="line">                mAnimator.setPendingLayoutChanges(w.getDisplayId(),</span><br><span class="line">                        WindowManagerPolicy.FINISH_LAYOUT_REDO_ANIM);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                w.mOrientationChanging = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (hasSurface()) &#123;</span><br><span class="line">            w.mToken.hasVisible = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        displayed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用prepareToShowInTransaction()将alph、alayer、setMatrix设置到mSurfaceControl中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">boolean prepareToShowInTransaction(float alpha, int layer, float dsdx, float dtdx, float dsdy,</span><br><span class="line">           float dtdy, boolean recoveringMemory) &#123;</span><br><span class="line">       if (mSurfaceControl != null) &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">               mSurfaceAlpha = alpha;</span><br><span class="line">               mSurfaceControl.setAlpha(alpha);</span><br><span class="line">               mSurfaceLayer = layer;</span><br><span class="line">               mSurfaceControl.setLayer(layer);</span><br><span class="line">               mSurfaceControl.setMatrix(</span><br><span class="line">                       dsdx, dtdx, dsdy, dtdy);</span><br><span class="line"></span><br><span class="line">           &#125; catch (RuntimeException e) &#123;</span><br><span class="line">               .......</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>setSurfaceBoundariesLocked()方法中会调用SurfaceControl.setPosition()等等方法将计算好的数值设置到mSurfaceControl中。 说明：一个窗口的显示和隐藏，以及大小、X轴和Y轴位置、Z轴位置、Alpha通道和变换矩阵设置，是通过调用Java层的SurfaceControl类的成员函数show、hide、setSize、setPosition、setLayer、setAlpha和setMatrix来实现的，它们最终都是通过调用JNI方法实现的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">SurfaceControl.java</span><br><span class="line">......</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAlpha</span><span class="params">(<span class="keyword">float</span> alpha)</span> </span>&#123;</span><br><span class="line">    checkNotReleased();</span><br><span class="line">    nativeSetAlpha(mNativeObject, alpha);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMatrix</span><span class="params">(<span class="keyword">float</span> dsdx, <span class="keyword">float</span> dtdx, <span class="keyword">float</span> dsdy, <span class="keyword">float</span> dtdy)</span> </span>&#123;</span><br><span class="line">    checkNotReleased();</span><br><span class="line">    nativeSetMatrix(mNativeObject, dsdx, dtdx, dsdy, dtdy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWindowCrop</span><span class="params">(Rect crop)</span> </span>&#123;</span><br><span class="line">    checkNotReleased();</span><br><span class="line">    <span class="keyword">if</span> (crop != <span class="keyword">null</span>) &#123;</span><br><span class="line">        nativeSetWindowCrop(mNativeObject,</span><br><span class="line">            crop.left, crop.top, crop.right, crop.bottom);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        nativeSetWindowCrop(mNativeObject, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFinalCrop</span><span class="params">(Rect crop)</span> </span>&#123;</span><br><span class="line">    checkNotReleased();</span><br><span class="line">    <span class="keyword">if</span> (crop != <span class="keyword">null</span>) &#123;</span><br><span class="line">        nativeSetFinalCrop(mNativeObject,</span><br><span class="line">            crop.left, crop.top, crop.right, crop.bottom);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        nativeSetFinalCrop(mNativeObject, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">....</span><br></pre></td></tr></table></figure><h3 id="3-3-3、告知SurfaceFlinger显示UI"><a href="#3-3-3、告知SurfaceFlinger显示UI" class="headerlink" title="3.3.3、告知SurfaceFlinger显示UI"></a>3.3.3、告知SurfaceFlinger显示UI</h3><p>如果WindowState对象w所描述的窗口满足条件：prepared &amp;&amp; mLastHidden &amp;&amp; mDrawState == HAS_DRAWN 那么就说明现在是时候要将WindowState对象w所描述的窗口显示出来了，通过调用showSurfaceRobustlyLocked实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowStateAnimator.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">showSurfaceRobustlyLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Task task = mWin.getTask();</span><br><span class="line">    <span class="keyword">if</span> (task != <span class="keyword">null</span> &amp;&amp; StackId.windowsAreScaleable(task.mStack.mStackId)) &#123;</span><br><span class="line">        mSurfaceController.forceScaleableInTransaction(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> shown = mSurfaceController.showRobustlyInTransaction();</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (mWin.mTurnOnScreen) &#123;</span><br><span class="line">        ......</span><br><span class="line">        mWin.mTurnOnScreen = <span class="keyword">false</span>;</span><br><span class="line">        mAnimator.mBulkUpdateParams |= SET_TURN_ON_SCREEN;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接调用WindowSurfaceController.showRobustlyInTransaction() –&gt; updateVisibility()–&gt;showSurface()-&gt;SurfaceControl.show()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowSurfaceController.java]</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">showRobustlyInTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        mHiddenForOtherReasons = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> updateVisibility();</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">updateVisibility</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mHiddenForCrop || mHiddenForOtherReasons) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mSurfaceShown) &#123;hideSurface();&#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mSurfaceShown) &#123;<span class="keyword">return</span> showSurface();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">showSurface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mSurfaceShown = <span class="keyword">true</span>;</span><br><span class="line">            mSurfaceControl.show();</span><br><span class="line">             Slog.i(<span class="string">"zhoujinjian"</span>, <span class="string">"zhoujinjian"</span>,<span class="keyword">new</span> RuntimeException(<span class="string">"here"</span>).fillInStackTrace());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//出现异常,回收系统内存资源</span></span><br><span class="line">        mAnimator.reclaimSomeSurfaceMemory(<span class="string">"show"</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;SurfaceControl.java]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    checkNotReleased();</span><br><span class="line">    nativeSetFlags(mNativeObject, <span class="number">0</span>, SURFACE_HIDDEN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过JNI调用android_view_SurfaceControl.cpp的nativeSetFlags函数，可以看到flags == 0；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;android_view_SurfaceControl.cpp]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeSetFlags</span><span class="params">(JNIEnv* env, jclass clazz, jlong nativeObject, jint flags, jint mask)</span> </span>&#123;</span><br><span class="line">    SurfaceControl* <span class="keyword">const</span> ctrl = <span class="keyword">reinterpret_cast</span>&lt;SurfaceControl *&gt;(nativeObject);</span><br><span class="line">    <span class="keyword">status_t</span> err = ctrl-&gt;setFlags(flags, mask);</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span> &amp;&amp; err != NO_INIT) &#123;</span><br><span class="line">        doThrowIAE(env);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用SurfaceControl.cpp的setFlags()函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;SurfaceControl.cpp]</span><br><span class="line"><span class="keyword">status_t</span> SurfaceControl::setFlags(<span class="keyword">uint32_t</span> flags, <span class="keyword">uint32_t</span> mask) &#123;</span><br><span class="line">    <span class="keyword">status_t</span> err = validate();</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) <span class="keyword">return</span> err;</span><br><span class="line">    <span class="keyword">return</span> mClient-&gt;setFlags(mHandle, flags, mask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进一步通过Binder IPC机制，SurfaceComposerClient.cpp-&gt;Composer::setFlags()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;SurfaceComposerClient.cpp]</span><br><span class="line"><span class="keyword">status_t</span> Composer::setFlags(<span class="keyword">const</span> sp&lt;SurfaceComposerClient&gt;&amp; client,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; id, <span class="keyword">uint32_t</span> flags,</span><br><span class="line">        <span class="keyword">uint32_t</span> mask) &#123;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    <span class="keyword">layer_state_t</span>* s = getLayerStateLocked(client, id);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> ((mask &amp; <span class="keyword">layer_state_t</span>::eLayerOpaque) ||</span><br><span class="line">            (mask &amp; <span class="keyword">layer_state_t</span>::eLayerHidden) ||</span><br><span class="line">            (mask &amp; <span class="keyword">layer_state_t</span>::eLayerSecure)) &#123;</span><br><span class="line">        s-&gt;what |= <span class="keyword">layer_state_t</span>::eFlagsChanged;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;flags &amp;= ~mask;</span><br><span class="line">    s-&gt;flags |= (flags &amp; mask);</span><br><span class="line">    s-&gt;mask |= mask;</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体数值就不详细计算了，前面分析【Android 7.1.2 (Android N) Android Graphics 系统分析 [i.wonder~]】可知，SurfaceFlinger接收Vsync信号与App有一个offset间隔时间，当SurfaceFlinger接收Vsync信号时，就可以根据flags是否显示 和 上面设置的一系列数值进行渲染合成，最终显示到屏幕上。</p><h2 id="（四）、Activity启动窗口-Starting-Window-添加过程"><a href="#（四）、Activity启动窗口-Starting-Window-添加过程" class="headerlink" title="（四）、Activity启动窗口(Starting Window)添加过程"></a>（四）、Activity启动窗口(Starting Window)添加过程</h2><h3 id="4-1、Activity组件的启动窗口-Starting-Window-的添加过程"><a href="#4-1、Activity组件的启动窗口-Starting-Window-的添加过程" class="headerlink" title="4.1、Activity组件的启动窗口(Starting Window)的添加过程"></a>4.1、Activity组件的启动窗口(Starting Window)的添加过程</h3><p>时序图：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.wms/13-Android-WMS-Starting-Window-addview.png" alt="Markdown"></p><h3 id="4-1-1、-ActivityStack-startActivityLocked"><a href="#4-1-1、-ActivityStack-startActivityLocked" class="headerlink" title="4.1.1、 ActivityStack.startActivityLocked()"></a>4.1.1、 ActivityStack.startActivityLocked()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ActivityStack.java]</span><br><span class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startActivityLocked</span><span class="params">(ActivityRecord r, <span class="keyword">boolean</span> newTask, <span class="keyword">boolean</span> keepCurTransition,</span></span></span><br><span class="line"><span class="function"><span class="params">            ActivityOptions options)</span> </span>&#123;</span><br><span class="line">            ......</span><br><span class="line">                    <span class="keyword">if</span> (!isHomeStack() || numActivities() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">if</span> ((r.intent.getFlags() &amp; Intent.FLAG_ACTIVITY_NO_ANIMATION) != <span class="number">0</span>) &#123;</span><br><span class="line">                mWindowManager.prepareAppTransition(TRANSIT_NONE, keepCurTransition);</span><br><span class="line">                mNoAnimActivities.add(r);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mWindowManager.prepareAppTransition(newTask</span><br><span class="line">                        ? r.mLaunchTaskBehind</span><br><span class="line">                                ? TRANSIT_TASK_OPEN_BEHIND</span><br><span class="line">                                : TRANSIT_TASK_OPEN</span><br><span class="line">                        : TRANSIT_ACTIVITY_OPEN, keepCurTransition);</span><br><span class="line">                mNoAnimActivities.remove(r);</span><br><span class="line">            &#125;</span><br><span class="line">            addConfigOverride(r, task);</span><br><span class="line">            <span class="keyword">boolean</span> doShow = <span class="keyword">true</span>;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">if</span> (r.mLaunchTaskBehind) &#123;</span><br><span class="line">                .......</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SHOW_APP_STARTING_PREVIEW &amp;&amp; doShow) &#123;</span><br><span class="line">                ActivityRecord prev = r.task.topRunningActivityWithStartingWindowLocked();</span><br><span class="line">                <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// We don't want to reuse the previous starting preview if:</span></span><br><span class="line">                    <span class="comment">// (1) The current activity is in a different task.</span></span><br><span class="line">                    <span class="keyword">if</span> (prev.task != r.task) &#123;</span><br><span class="line">                        prev = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// (2) The current activity is already displayed.</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (prev.nowVisible) &#123;</span><br><span class="line">                        prev = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                r.showStartingWindow(prev, showStartingIcon);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到直接调用ActivityRecord.showStartingWindow()进一步添加启动窗口</p><h3 id="4-1-2、-ActivityRecord-showStartingWindow"><a href="#4-1-2、-ActivityRecord-showStartingWindow" class="headerlink" title="4.1.2、 ActivityRecord.showStartingWindow()"></a>4.1.2、 ActivityRecord.showStartingWindow()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ActivityRecord.java]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showStartingWindow</span><span class="params">(ActivityRecord prev, <span class="keyword">boolean</span> createIfNeeded)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> CompatibilityInfo compatInfo =</span><br><span class="line">            service.compatibilityInfoForPackageLocked(info.applicationInfo);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> shown = service.mWindowManager.setAppStartingWindow(</span><br><span class="line">            appToken, packageName, theme, compatInfo, nonLocalizedLabel, labelRes, icon,</span><br><span class="line">            logo, windowFlags, prev != <span class="keyword">null</span> ? prev.appToken : <span class="keyword">null</span>, createIfNeeded);</span><br><span class="line">    <span class="keyword">if</span> (shown) &#123;</span><br><span class="line">        mStartingWindowState = STARTING_WINDOW_SHOWN;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-1-2、ActivityRecord-setAppStartingWindow"><a href="#4-1-2、ActivityRecord-setAppStartingWindow" class="headerlink" title="4.1.2、ActivityRecord.setAppStartingWindow()"></a>4.1.2、ActivityRecord.setAppStartingWindow()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ActivityRecord.java]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">setAppStartingWindow</span><span class="params">(IBinder token, String pkg,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> theme, CompatibilityInfo compatInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">        CharSequence nonLocalizedLabel, <span class="keyword">int</span> labelRes, <span class="keyword">int</span> icon, <span class="keyword">int</span> logo,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> windowFlags, IBinder transferFrom, <span class="keyword">boolean</span> createIfNeeded)</span> </span>&#123;</span><br><span class="line">   ......</span><br><span class="line">  <span class="keyword">synchronized</span>(mWindowMap) &#123;</span><br><span class="line">   AppWindowToken wtoken = findAppWindowToken(token);</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (transferStartingWindow(transferFrom, wtoken)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        wtoken.startingData = <span class="keyword">new</span> StartingData(pkg, theme, compatInfo, nonLocalizedLabel,</span><br><span class="line">                labelRes, icon, logo, windowFlags);</span><br><span class="line">        Message m = mH.obtainMessage(H.ADD_STARTING, wtoken);</span><br><span class="line">        mH.sendMessageAtFrontOfQueue(m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果参数transferFrom所描述的Activity组件没有启动窗口或者启动窗口数据转移给参数token所描述的Activity组件，那么接下来就可能需要为参数token所描述的Activity组件创建一个新的启动窗口</p><h3 id="4-1-3、-H-handleMessage"><a href="#4-1-3、-H-handleMessage" class="headerlink" title="4.1.3、 H.handleMessage()"></a>4.1.3、 H.handleMessage()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowManagerService.java::H]</span><br><span class="line"><span class="keyword">case</span> ADD_STARTING: &#123;</span><br><span class="line">    <span class="keyword">final</span> AppWindowToken wtoken = (AppWindowToken)msg.obj;</span><br><span class="line">    <span class="keyword">final</span> StartingData sd = wtoken.startingData;</span><br><span class="line">    ......</span><br><span class="line">    View view = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Configuration overrideConfig = wtoken != <span class="keyword">null</span> &amp;&amp; wtoken.mTask != <span class="keyword">null</span></span><br><span class="line">                ? wtoken.mTask.mOverrideConfig : <span class="keyword">null</span>;</span><br><span class="line">        view = mPolicy.addStartingWindow(wtoken.token, sd.pkg, sd.theme,</span><br><span class="line">            sd.compatInfo, sd.nonLocalizedLabel, sd.labelRes, sd.icon, sd.logo,</span><br><span class="line">            sd.windowFlags, overrideConfig);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> abort = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">synchronized</span>(mWindowMap) &#123;</span><br><span class="line">            <span class="keyword">if</span> (wtoken.removed || wtoken.startingData == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    wtoken.startingWindow = <span class="keyword">null</span>;</span><br><span class="line">                    wtoken.startingData = <span class="keyword">null</span>;</span><br><span class="line">                    abort = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                wtoken.startingView = view;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (abort) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mPolicy.removeStartingWindow(wtoken.token, view);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>PhoneWindowManager实现WindowManagerPolicy，所以会调用PhoneWindowManager中的方法 继续分析PhoneWindowManager.addStartingWindow()</p><h3 id="4-1-4、PhoneWindowManager-addStartingWindow"><a href="#4-1-4、PhoneWindowManager-addStartingWindow" class="headerlink" title="4.1.4、PhoneWindowManager.addStartingWindow()"></a>4.1.4、PhoneWindowManager.addStartingWindow()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;PhoneWindowManager.java]</span><br><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">addStartingWindow</span><span class="params">(IBinder appToken, String packageName, <span class="keyword">int</span> theme,</span></span></span><br><span class="line"><span class="function"><span class="params">        CompatibilityInfo compatInfo, CharSequence nonLocalizedLabel, <span class="keyword">int</span> labelRes,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> icon, <span class="keyword">int</span> logo, <span class="keyword">int</span> windowFlags, Configuration overrideConfig)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    WindowManager wm = <span class="keyword">null</span>;</span><br><span class="line">    View view = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Context context = mContext;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">final</span> PhoneWindow win = <span class="keyword">new</span> PhoneWindow(context);</span><br><span class="line">        win.setIsStartingWindow(<span class="keyword">true</span>);</span><br><span class="line">        ......</span><br><span class="line">        win.setType(</span><br><span class="line">            WindowManager.LayoutParams.TYPE_APPLICATION_STARTING);</span><br><span class="line">        ......</span><br><span class="line">        win.setLayout(WindowManager.LayoutParams.MATCH_PARENT,</span><br><span class="line">                WindowManager.LayoutParams.MATCH_PARENT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> WindowManager.LayoutParams params = win.getAttributes();</span><br><span class="line">        params.token = appToken;</span><br><span class="line">        params.packageName = packageName;</span><br><span class="line">        params.windowAnimations = win.getWindowStyle().getResourceId(</span><br><span class="line">                com.android.internal.R.styleable.Window_windowAnimationStyle, <span class="number">0</span>);</span><br><span class="line">        ......</span><br><span class="line">        params.setTitle(<span class="string">"Starting "</span> + packageName);</span><br><span class="line">        wm = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line">        view = win.getDecorView();</span><br><span class="line">       ......</span><br><span class="line">        wm.addView(view, params);</span><br><span class="line">        <span class="keyword">return</span> view.getParent() != <span class="keyword">null</span> ? view : <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (WindowManager.BadTokenException e) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (view != <span class="keyword">null</span> &amp;&amp; view.getParent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            wm.removeViewImmediate(view);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建PhoneWindow对象，接下来继续设置所创建的窗口win的以下属性： 1、窗口类型：设置为WindowManager.LayoutParams.TYPE_APPLICATION_STARTING，即设置为启动窗口类型；</p><p>2、窗口标题：由参数labelRes、nonLocalizedLabel，以及窗口的运行上下文context来确定；</p><p>3、窗口标志：分别将indowManager.LayoutParams.FLAG_NOT_TOUCHABLE、WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE和WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM位设置为1，即不可接受触摸事件和不可获得焦点，但是可以接受输入法窗口；</p><p>4、窗口大小：设置为WindowManager.LayoutParams.MATCH_PARENT，即与父窗口一样大，但是由于这是一个顶层窗口，因此实际上是指与屏幕一样大；</p><p>5、布局参数：包括窗口所对应的窗口令牌（token）和包名（packageName），以及窗口所使用的动画类型（windowAnimations）和标题（title）。</p><p>wm.addView(view, params)，一个新创建的Activity组件的启动窗口就增加到WindowManagerService服务中去了，这样，WindowManagerService服务就可以下次刷新系统UI时，将该启动窗口显示出来</p><h2 id="（五）、WMS切换Activity窗口（App-Transition）过程"><a href="#（五）、WMS切换Activity窗口（App-Transition）过程" class="headerlink" title="（五）、WMS切换Activity窗口（App Transition）过程"></a>（五）、WMS切换Activity窗口（App Transition）过程</h2><p>WindowManagerService服务在执行Activity窗口的切换操作的时候，会给参与切换操作的Activity组件的设置一个动画，以便可以向用户展现一个Activity组件切换效果，从而提高用户体验。 首先看一下App Transition动态图：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.wms/14-Android-WMS-ezgif.com-video-to-gif-WMS-App-Transition.gif" alt="Markdown"></p><p>时序图：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.wms/15-Android-WMS-executeAppTransition.png" alt="Markdown"></p><p>我们直接分析App Transition过程的prepareAppTransition、executeAppTransition 关于Activity启动过程请参考：【Android-7-1-2-Android-N-Activity启动流程分析】</p><h3 id="5-1、prepareAppTransition-过程"><a href="#5-1、prepareAppTransition-过程" class="headerlink" title="5.1、prepareAppTransition()过程"></a>5.1、prepareAppTransition()过程</h3><h3 id="5-1-1、ActivityStack-startActivityLocked"><a href="#5-1-1、ActivityStack-startActivityLocked" class="headerlink" title="5.1.1、ActivityStack.startActivityLocked()"></a>5.1.1、ActivityStack.startActivityLocked()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ActivityStack.java]</span><br><span class="line">......</span><br><span class="line">mWindowManager.prepareAppTransition(newTask</span><br><span class="line">        ? r.mLaunchTaskBehind</span><br><span class="line">                ? TRANSIT_TASK_OPEN_BEHIND</span><br><span class="line">                : TRANSIT_TASK_OPEN</span><br><span class="line">        : TRANSIT_ACTIVITY_OPEN, keepCurTransition);</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h3 id="5-1-2、WindowManagerService-prepareAppTransition"><a href="#5-1-2、WindowManagerService-prepareAppTransition" class="headerlink" title="5.1.2、WindowManagerService.prepareAppTransition()"></a>5.1.2、WindowManagerService.prepareAppTransition()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowManagerService.java]</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepareAppTransition</span><span class="params">(<span class="keyword">int</span> transit, <span class="keyword">boolean</span> alwaysKeepCurrent)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">synchronized</span>(mWindowMap) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> prepared = mAppTransition.prepareAppTransitionLocked(</span><br><span class="line">                transit, alwaysKeepCurrent);</span><br><span class="line">        <span class="keyword">if</span> (prepared &amp;&amp; okToDisplay()) &#123;</span><br><span class="line">            mSkipAppTransitionAnimation = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现是直接调用AppTransition.prepareAppTransitionLocked()实现的。</p><h3 id="5-1-3、AppTransition-prepareAppTransitionLocked"><a href="#5-1-3、AppTransition-prepareAppTransitionLocked" class="headerlink" title="5.1.3、AppTransition.prepareAppTransitionLocked()"></a>5.1.3、AppTransition.prepareAppTransitionLocked()</h3><p>进一步调用setAppTransition()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setAppTransition</span><span class="params">(<span class="keyword">int</span> transit)</span> </span>&#123;</span><br><span class="line">    mNextAppTransition = transit;</span><br><span class="line">    setLastAppTransition(TRANSIT_UNSET, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现只是将transit（即AppTransition动画类型）赋值给变量mNextAppTransition</p><h3 id="5-2、AppTransition-animation设置过程"><a href="#5-2、AppTransition-animation设置过程" class="headerlink" title="5.2、AppTransition animation设置过程"></a>5.2、AppTransition animation设置过程</h3><p>继续分析ActivityStackSupervisor.realStartActivityLocked()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ActivityStackSupervisor.java]</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">realStartActivityLocked</span><span class="params">(ActivityRecord r, ProcessRecord app,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> andResume, <span class="keyword">boolean</span> checkConfig)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line">    <span class="keyword">if</span> (andResume) &#123;</span><br><span class="line">        r.startFreezingScreenLocked(app, <span class="number">0</span>);</span><br><span class="line">        mWindowManager.setAppVisibility(r.appToken, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// schedule launch ticks to collect information about slow apps.</span></span><br><span class="line">        r.startLaunchTickingLocked();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先会通知WindowManagerService服务将参数r.appToken所描述的Activity组件的可见性设置为true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowManagerService.java]</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAppVisibility</span><span class="params">(IBinder token, <span class="keyword">boolean</span> visible)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    AppWindowToken wtoken;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span>(mWindowMap) &#123;</span><br><span class="line">        wtoken = findAppWindowToken(token);</span><br><span class="line">        ......</span><br><span class="line">        mOpeningApps.remove(wtoken);</span><br><span class="line">        mClosingApps.remove(wtoken);</span><br><span class="line">        ......</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">            wtoken.inPendingTransaction = <span class="keyword">false</span>;</span><br><span class="line">            setTokenVisibilityLocked(wtoken, <span class="keyword">null</span>, visible, AppTransition.TRANSIT_UNSET,</span><br><span class="line">                    <span class="keyword">true</span>, wtoken.voiceInteraction);</span><br><span class="line">            wtoken.updateReportedVisibilityLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>调用WindowManagerService.setTokenVisibilityLocked()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowManagerService.java]</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">setTokenVisibilityLocked</span><span class="params">(AppWindowToken wtoken, WindowManager.LayoutParams lp,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> visible, <span class="keyword">int</span> transit, <span class="keyword">boolean</span> performLayout, <span class="keyword">boolean</span> isVoiceInteraction)</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (wtoken.hidden == visible || (wtoken.hidden &amp;&amp; wtoken.mIsExiting) ||</span><br><span class="line">                (visible &amp;&amp; wtoken.waitingForReplacement())) &#123;</span><br><span class="line">           ......</span><br><span class="line">            <span class="keyword">if</span> (transit != AppTransition.TRANSIT_UNSET) &#123;</span><br><span class="line">                ......</span><br><span class="line">                <span class="keyword">if</span> (applyAnimationLocked(wtoken, lp, transit, visible, isVoiceInteraction)) &#123;</span><br><span class="line">                    delayed = runningAppAnimation = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ......</span><br><span class="line">                changed = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>调用WindowManagerService.applyAnimationLocked()设置AppTransition动画</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowManagerService.java]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">applyAnimationLocked</span><span class="params">(AppWindowToken atoken, WindowManager.LayoutParams lp,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> transit, <span class="keyword">boolean</span> enter, <span class="keyword">boolean</span> isVoiceInteraction)</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (okToDisplay()) &#123;</span><br><span class="line">        Animation a = mAppTransition.loadAnimation(lp, transit, enter, mCurConfiguration.uiMode,</span><br><span class="line">        mCurConfiguration.orientation, frame, displayFrame, insets, surfaceInsets,</span><br><span class="line">        isVoiceInteraction, freeform, atoken.mTask.mTaskId);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>终于到了AppTransition真正设置过程了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;AppTransition.java]</span><br><span class="line">Animation loadAnimation(WindowManager.LayoutParams lp, int transit, boolean enter, int uiMode,</span><br><span class="line">            int orientation, Rect frame, Rect displayFrame, Rect insets,</span><br><span class="line">            @Nullable Rect surfaceInsets, boolean isVoiceInteraction, boolean freeform,</span><br><span class="line">            int taskId) &#123;</span><br><span class="line">        Animation a;</span><br><span class="line">      if()&#123;&#125;</span><br><span class="line">      ......</span><br><span class="line">      &#125; else if()&#123;</span><br><span class="line">      ......</span><br><span class="line">      &#125;else &#123;</span><br><span class="line">        int animAttr = 0;</span><br><span class="line">        switch (transit) &#123;</span><br><span class="line">            case TRANSIT_ACTIVITY_OPEN:</span><br><span class="line">                animAttr = enter</span><br><span class="line">                        ? WindowAnimation_activityOpenEnterAnimation</span><br><span class="line">                        : WindowAnimation_activityOpenExitAnimation;</span><br><span class="line">                break;</span><br><span class="line">            case TRANSIT_ACTIVITY_CLOSE:</span><br><span class="line">                animAttr = enter</span><br><span class="line">                        ? WindowAnimation_activityCloseEnterAnimation</span><br><span class="line">                        : WindowAnimation_activityCloseExitAnimation;</span><br><span class="line">                break;</span><br><span class="line">            case TRANSIT_DOCK_TASK_FROM_RECENTS:</span><br><span class="line">            case TRANSIT_TASK_OPEN:</span><br><span class="line">                animAttr = enter</span><br><span class="line">                        ? WindowAnimation_taskOpenEnterAnimation</span><br><span class="line">                        : WindowAnimation_taskOpenExitAnimation;</span><br><span class="line">                break;</span><br><span class="line">            case TRANSIT_TASK_CLOSE:</span><br><span class="line">                animAttr = enter</span><br><span class="line">                        ? WindowAnimation_taskCloseEnterAnimation</span><br><span class="line">                        : WindowAnimation_taskCloseExitAnimation;</span><br><span class="line">                break;</span><br><span class="line">            case TRANSIT_TASK_TO_FRONT:</span><br><span class="line">                animAttr = enter</span><br><span class="line">                        ? WindowAnimation_taskToFrontEnterAnimation</span><br><span class="line">                        : WindowAnimation_taskToFrontExitAnimation;</span><br><span class="line">                break;</span><br><span class="line">            case TRANSIT_TASK_TO_BACK:</span><br><span class="line">                animAttr = enter</span><br><span class="line">                        ? WindowAnimation_taskToBackEnterAnimation</span><br><span class="line">                        : WindowAnimation_taskToBackExitAnimation;</span><br><span class="line">                break;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">        a = animAttr != 0 ? loadAnimationAttr(lp, animAttr) : null;</span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后通过<strong>loadAnimationAttr</strong>加载xml文件加载动画，动画xml文件的存放路径（/frameworks/base/core/res/res/anim/）<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.wms/16-Android-WMS-executeAppTransition-xml.png" alt="Markdown"></p><h3 id="5-3、executeAppTransition过程"><a href="#5-3、executeAppTransition过程" class="headerlink" title="5.3、executeAppTransition过程"></a>5.3、executeAppTransition过程</h3><blockquote><p>ActivityStackSupervisor.realStartActivityLocked()</p><blockquote><p>ActivityStack.minimalResumeActivityLocked() ActivityStack.completeResumeLocked() ActivityStackSupervisor.reportResumedActivityLocked()</p></blockquote></blockquote><p>继续分析ActivityStackSupervisor.reportResumedActivityLocked()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ActivityStackSupervisor.java]</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">reportResumedActivityLocked</span><span class="params">(ActivityRecord r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ActivityStack stack = r.task.stack;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (allResumedActivitiesComplete()) &#123;</span><br><span class="line">        ensureActivitiesVisibleLocked(<span class="keyword">null</span>, <span class="number">0</span>, !PRESERVE_WINDOWS);</span><br><span class="line">        mWindowManager.executeAppTransition();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是Activity组件的可见性设置，然后执行executeAppTransition()</p><h3 id="5-3-1-WindowManagerService-executeAppTransition"><a href="#5-3-1-WindowManagerService-executeAppTransition" class="headerlink" title="5.3.1.WindowManagerService.executeAppTransition()"></a>5.3.1.WindowManagerService.executeAppTransition()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowManagerService.java]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeAppTransition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       ......</span><br><span class="line">        <span class="keyword">synchronized</span>(mWindowMap) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mAppTransition.isTransitionSet()) &#123;</span><br><span class="line">                mAppTransition.setReady();</span><br><span class="line">                ......</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    mWindowPlacerLocked.performSurfacePlacement();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    ......</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>而WindowSurfacePlacer.performSurfacePlacement()请看前面第二节分析</p><h2 id="（六）、Activity-Window-动画显示过程"><a href="#（六）、Activity-Window-动画显示过程" class="headerlink" title="（六）、Activity Window 动画显示过程"></a>（六）、Activity Window 动画显示过程</h2><h3 id="6-1、动画的设置过程"><a href="#6-1、动画的设置过程" class="headerlink" title="6.1、动画的设置过程"></a>6.1、动画的设置过程</h3><p>在Android系统中，窗口动画的本质就是对原始窗口施加一个变换（Transformation）。在线性数学中，对物体的形状进行变换是通过乘以一个矩阵（Matrix）来实现，目的就是对物体进行偏移、旋转、缩放、切变、反射和投影等。因此，给窗口设置动画实际上就给窗口设置一个变换矩阵（Transformation Matrix）。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.wms/17-Android-WMS-Transformation-matrix.png" alt="Markdown"></p><p>窗口被设置的动画虽然可以达到三个，但是这三个动画可以归结为两类，一类是普通动画，例如，窗口在打开过程中被设置的进入动画和在关闭过程中被设置的退出动画，另一类是切换动画。其中，Self Transformation和Attached Transformation都是属于普通动画，而App Transformation属于切换动画。前面已经分析过App Transformation的设置过程 接下来分析普通动画的设置过程。</p><h3 id="6-1、普通动画的设置过程"><a href="#6-1、普通动画的设置过程" class="headerlink" title="6.1、普通动画的设置过程"></a>6.1、普通动画的设置过程</h3><p>普通动画的设置过程也是通过setTokenVisibilityLocked()设置的</p><h3 id="6-1-1、WindowManagerService-setTokenVisibilityLocked"><a href="#6-1-1、WindowManagerService-setTokenVisibilityLocked" class="headerlink" title="6.1.1、WindowManagerService.setTokenVisibilityLocked()"></a>6.1.1、WindowManagerService.setTokenVisibilityLocked()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowManagerService.java]</span><br><span class="line">    boolean setTokenVisibilityLocked(AppWindowToken wtoken, WindowManager.LayoutParams lp,</span><br><span class="line">            boolean visible, int transit, boolean performLayout, boolean isVoiceInteraction) &#123;</span><br><span class="line">        ......</span><br><span class="line">        if (wtoken.hidden == visible || (wtoken.hidden &amp;&amp; wtoken.mIsExiting) ||</span><br><span class="line">                (visible &amp;&amp; wtoken.waitingForReplacement())) &#123;</span><br><span class="line">           ......</span><br><span class="line">            if (transit != AppTransition.TRANSIT_UNSET) &#123;</span><br><span class="line">                ......</span><br><span class="line">                if (applyAnimationLocked(wtoken, lp, transit, visible, isVoiceInteraction)) &#123;</span><br><span class="line">                    delayed = runningAppAnimation = true;</span><br><span class="line">                &#125;</span><br><span class="line">                ......</span><br><span class="line">                changed = true;</span><br><span class="line">            &#125;</span><br><span class="line">            final int windowsCount = wtoken.allAppWindows.size();</span><br><span class="line">            for (int i = 0; i &lt; windowsCount; i++) &#123;</span><br><span class="line">                WindowState win = wtoken.allAppWindows.get(i);</span><br><span class="line">                ......</span><br><span class="line">                if (visible) &#123;</span><br><span class="line">                    if (!win.isVisibleNow()) &#123;</span><br><span class="line">                        if (!runningAppAnimation) &#123;</span><br><span class="line">                            win.mWinAnimator.applyAnimationLocked(</span><br><span class="line">                                    WindowManagerPolicy.TRANSIT_ENTER, true);</span><br><span class="line">                            ......</span><br><span class="line">                        &#125;</span><br><span class="line">                        changed = true;</span><br><span class="line">                        win.setDisplayLayoutNeeded();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else if (win.isVisibleNow()) &#123;</span><br><span class="line">                    if (!runningAppAnimation) &#123;</span><br><span class="line">                        win.mWinAnimator.applyAnimationLocked(</span><br><span class="line">                                WindowManagerPolicy.TRANSIT_EXIT, false);</span><br><span class="line">                        ......</span><br><span class="line">                    &#125;</span><br><span class="line">                    changed = true;</span><br><span class="line">                    win.setDisplayLayoutNeeded();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            wtoken.hidden = wtoken.hiddenRequested = !visible;</span><br><span class="line">            visibilityChanged = true;</span><br><span class="line">            ......</span><br><span class="line">            if (changed) &#123;</span><br><span class="line">                mInputMonitor.setUpdateInputWindowsNeededLw();</span><br><span class="line">                if (performLayout) &#123;</span><br><span class="line">                    updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES,</span><br><span class="line">                            false /*updateInputWindows*/);</span><br><span class="line">                    mWindowPlacerLocked.performSurfacePlacement();</span><br><span class="line">                &#125;</span><br><span class="line">                mInputMonitor.updateInputWindowsLw(false /*force*/);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到普通动画是通过win.mWinAnimator.applyAnimationLocked(WindowManagerPolicy.TRANSIT_ENTER, true)</p><h3 id="6-1-1-WindowStateAnimator-applyAnimationLocked"><a href="#6-1-1-WindowStateAnimator-applyAnimationLocked" class="headerlink" title="6.1.1.WindowStateAnimator.applyAnimationLocked()"></a>6.1.1.WindowStateAnimator.applyAnimationLocked()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowStateAnimator.java]</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">applyAnimationLocked</span><span class="params">(<span class="keyword">int</span> transit, <span class="keyword">boolean</span> isEntrance)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (mService.okToDisplay()) &#123;</span><br><span class="line">        <span class="keyword">int</span> anim = mPolicy.selectAnimationLw(mWin, transit);</span><br><span class="line">        <span class="keyword">int</span> attr = -<span class="number">1</span>;</span><br><span class="line">        Animation a = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (anim != <span class="number">0</span>) &#123;</span><br><span class="line">            a = anim != -<span class="number">1</span> ? AnimationUtils.loadAnimation(mContext, anim) : <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (transit) &#123;</span><br><span class="line">                <span class="keyword">case</span> WindowManagerPolicy.TRANSIT_ENTER:</span><br><span class="line">                    attr = com.android.internal.R.styleable.WindowAnimation_windowEnterAnimation;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> WindowManagerPolicy.TRANSIT_EXIT:</span><br><span class="line">                    attr = com.android.internal.R.styleable.WindowAnimation_windowExitAnimation;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> WindowManagerPolicy.TRANSIT_SHOW:</span><br><span class="line">                    attr = com.android.internal.R.styleable.WindowAnimation_windowShowAnimation;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> WindowManagerPolicy.TRANSIT_HIDE:</span><br><span class="line">                    attr = com.android.internal.R.styleable.WindowAnimation_windowHideAnimation;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (attr &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                a = mService.mAppTransition.loadAnimationAttr(mWin.mAttrs, attr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">            setAnimation(a);</span><br><span class="line">            mAnimationIsEntrance = isEntrance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        clearAnimation();</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> mAnimation != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到也是根据动画类型从而通过AppTransition.loadAnimationAttr(mWin.mAttrs, attr)加载不同的anim xml文件。</p><h3 id="6-2、窗口动画的显示框架"><a href="#6-2、窗口动画的显示框架" class="headerlink" title="6.2、窗口动画的显示框架"></a>6.2、窗口动画的显示框架</h3><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.wms/19-Android-WMS-animationLocked.png" alt="Markdown"><br>通过堆栈信息可以看到，由Vsync信号驱动，然后调用Choreographer.doFrame完成动画的相关操作，关于Vsync这部分之前文章已经分析过，这里不再分析了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowAnimator.java]</span><br><span class="line"><span class="comment">/** Locked on mService.mWindowMap. */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">animateLocked</span><span class="params">(<span class="keyword">long</span> frameTimeNs)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    mCurrentTime = frameTimeNs / TimeUtils.NANOS_PER_MS;</span><br><span class="line">    mBulkUpdateParams = SET_ORIENTATION_CHANGE_COMPLETE;</span><br><span class="line">    <span class="keyword">boolean</span> wasAnimating = mAnimating;</span><br><span class="line">    setAnimating(<span class="keyword">false</span>);</span><br><span class="line">    mAppWindowAnimating = <span class="keyword">false</span>;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (SHOW_TRANSACTIONS) Slog.i(</span><br><span class="line">            TAG, <span class="string">"&gt;&gt;&gt; OPEN TRANSACTION animateLocked"</span>);</span><br><span class="line">    SurfaceControl.openTransaction();</span><br><span class="line">    SurfaceControl.setAnimationTransaction();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> numDisplays = mDisplayContentsAnimators.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numDisplays; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> displayId = mDisplayContentsAnimators.keyAt(i);</span><br><span class="line">            <span class="comment">//1、Activity组件切换动画的推进过程</span></span><br><span class="line">            updateAppWindowsLocked(displayId);</span><br><span class="line">            DisplayContentsAnimator displayAnimator = mDisplayContentsAnimators.valueAt(i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> ScreenRotationAnimation screenRotationAnimation =</span><br><span class="line">                    displayAnimator.mScreenRotationAnimation;</span><br><span class="line">            <span class="keyword">if</span> (screenRotationAnimation != <span class="keyword">null</span> &amp;&amp; screenRotationAnimation.isAnimating()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (screenRotationAnimation.stepAnimationLocked(mCurrentTime)) &#123;</span><br><span class="line">                    setAnimating(<span class="keyword">true</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mBulkUpdateParams |= SET_UPDATE_ROTATION;</span><br><span class="line">                    screenRotationAnimation.kill();</span><br><span class="line">                    displayAnimator.mScreenRotationAnimation = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//TODO (multidisplay): Accessibility supported only for the default display.</span></span><br><span class="line">                    <span class="keyword">if</span> (mService.mAccessibilityController != <span class="keyword">null</span></span><br><span class="line">                            &amp;&amp; displayId == Display.DEFAULT_DISPLAY) &#123;</span><br><span class="line">                        <span class="comment">// We just finished rotation animation which means we did not</span></span><br><span class="line">                        <span class="comment">// anounce the rotation and waited for it to end, announce now.</span></span><br><span class="line">                        mService.mAccessibilityController.onRotationChangedLocked(</span><br><span class="line">                                mService.getDefaultDisplayContentLocked(), mService.mRotation);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Update animations of all applications, including those</span></span><br><span class="line">            <span class="comment">// associated with exiting/removed apps</span></span><br><span class="line">            <span class="comment">//2、窗口动画的推进过程</span></span><br><span class="line">            updateWindowsLocked(displayId);</span><br><span class="line">            <span class="comment">//壁纸动画的推进过程</span></span><br><span class="line">            updateWallpaperLocked(displayId);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> WindowList windows = mService.getWindowListLocked(displayId);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> N = windows.size();</span><br><span class="line">            <span class="comment">//3、通过一个for循环来遍历保存在窗口堆栈的每一个WindowState对象，以便可以对系统中的每一个窗口的绘图表面进行更新</span></span><br><span class="line">            <span class="comment">//确定该窗口实际要显示的大小、位置、Alpha通道和变换矩阵等信息</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">                windows.get(j).mWinAnimator.prepareSurfaceLocked(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numDisplays; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> displayId = mDisplayContentsAnimators.keyAt(i);</span><br><span class="line"></span><br><span class="line">            testTokenMayBeDrawnLocked(displayId);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> ScreenRotationAnimation screenRotationAnimation =</span><br><span class="line">                    mDisplayContentsAnimators.valueAt(i).mScreenRotationAnimation;</span><br><span class="line">            <span class="keyword">if</span> (screenRotationAnimation != <span class="keyword">null</span>) &#123;</span><br><span class="line">                screenRotationAnimation.updateSurfacesInTransaction();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            orAnimating(mService.getDisplayContentLocked(displayId).animateDimLayers());</span><br><span class="line">            orAnimating(mService.getDisplayContentLocked(displayId).getDockedDividerController()</span><br><span class="line">                    .animate(mCurrentTime));</span><br><span class="line">            <span class="comment">//TODO (multidisplay): Magnification is supported only for the default display.</span></span><br><span class="line">            <span class="keyword">if</span> (mService.mAccessibilityController != <span class="keyword">null</span></span><br><span class="line">                    &amp;&amp; displayId == Display.DEFAULT_DISPLAY) &#123;</span><br><span class="line">                mService.mAccessibilityController.drawMagnifiedRegionBorderIfNeededLocked();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//4、触发下一帧动画逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (mAnimating) &#123;</span><br><span class="line">            mService.scheduleAnimationLocked();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mService.mWatermark != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mService.mWatermark.drawIfNeeded();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        SurfaceControl.closeTransaction();</span><br><span class="line">        <span class="keyword">if</span> (SHOW_TRANSACTIONS) Slog.i(</span><br><span class="line">                TAG, <span class="string">"&lt;&lt;&lt; CLOSE TRANSACTION animateLocked"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> hasPendingLayoutChanges = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> numDisplays = mService.mDisplayContents.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> displayNdx = <span class="number">0</span>; displayNdx &lt; numDisplays; ++displayNdx) &#123;</span><br><span class="line">        <span class="keyword">final</span> DisplayContent displayContent = mService.mDisplayContents.valueAt(displayNdx);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> pendingChanges = getPendingLayoutChanges(displayContent.getDisplayId());</span><br><span class="line">        <span class="keyword">if</span> ((pendingChanges &amp; WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != <span class="number">0</span>) &#123;</span><br><span class="line">            mBulkUpdateParams |= SET_WALLPAPER_ACTION_PENDING;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pendingChanges != <span class="number">0</span>) &#123;</span><br><span class="line">            hasPendingLayoutChanges = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> doRequest = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (mBulkUpdateParams != <span class="number">0</span>) &#123;</span><br><span class="line">        doRequest = mWindowPlacerLocked.copyAnimToLayoutParamsLocked();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5、刷新系统UI</span></span><br><span class="line">    <span class="keyword">if</span> (hasPendingLayoutChanges || doRequest) &#123;</span><br><span class="line">        mWindowPlacerLocked.requestTraversal();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (mRemoveReplacedWindows) &#123;</span><br><span class="line">        removeReplacedWindowsLocked();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mService.stopUsingSavedSurfaceLocked();</span><br><span class="line">    mService.destroyPreservedSurfaceLocked();</span><br><span class="line">    mService.mWindowPlacerLocked.destroyPendingSurfaces();</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、Activity组件切换动画的推进、 2、窗口动画的推进、壁纸动画推进 3、循环遍历保存在窗口堆栈的每一个WindowState对象，以便可以对系统中的每一个窗口的绘图表面进行更新 确定该窗口实际要显示的大小、位置、Alpha通道和变换矩阵等信息 4、触发下一帧动画逻辑 5、刷新系统UI 其中第3点 prepareSurfaceLocked在3.3.小节已经分析过了、第5点最终会调用mWindowPlacerLocked.performSurfacePlacement来刷新UI，也已经分析过了。 接下来分析Activity组件切换动画、窗口动画的推进过程。</p><h3 id="6-3、Activity组件切换动画"><a href="#6-3、Activity组件切换动画" class="headerlink" title="6.3、Activity组件切换动画"></a>6.3、Activity组件切换动画</h3><p>AppWindowAnimator:属于AppWindowToken，它的成员变量mAppAnimator代表了此应用程序所属的AppWindowAnimator WindowStateAnimator:WMS记录了所有窗口的WindowState，其中WindowState.mWinAnimator是一个WindowStateAnimator对象，它和上面AppWindowAnimator一样可以由开发人员定制</p><p>WindowAnimator.updateAppWindowsLocked()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowAnimator.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateAppWindowsLocked</span><span class="params">(<span class="keyword">int</span> displayId)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;TaskStack&gt; stacks = mService.getDisplayContentLocked(displayId).getStacks();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> stackNdx = stacks.size() - <span class="number">1</span>; stackNdx &gt;= <span class="number">0</span>; --stackNdx) &#123;</span><br><span class="line">        <span class="keyword">final</span> TaskStack stack = stacks.get(stackNdx);</span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;Task&gt; tasks = stack.getTasks();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> taskNdx = tasks.size() - <span class="number">1</span>; taskNdx &gt;= <span class="number">0</span>; --taskNdx) &#123;</span><br><span class="line">            <span class="keyword">final</span> AppTokenList tokens = tasks.get(taskNdx).mAppTokens;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> tokenNdx = tokens.size() - <span class="number">1</span>; tokenNdx &gt;= <span class="number">0</span>; --tokenNdx) &#123;</span><br><span class="line">                <span class="keyword">final</span> AppWindowAnimator appAnimator = tokens.get(tokenNdx).mAppAnimator;</span><br><span class="line">                appAnimator.wasAnimating = appAnimator.animating;</span><br><span class="line">                <span class="keyword">if</span> (appAnimator.stepAnimationLocked(mCurrentTime, displayId)) &#123;</span><br><span class="line">                    appAnimator.animating = <span class="keyword">true</span>;</span><br><span class="line">                    setAnimating(<span class="keyword">true</span>);</span><br><span class="line">                    mAppWindowAnimating = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (appAnimator.wasAnimating) &#123;</span><br><span class="line">                    <span class="comment">// stopped animating, do one more pass through the layout</span></span><br><span class="line">                    setAppLayoutChanges(appAnimator,</span><br><span class="line">                            WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER,</span><br><span class="line">                            <span class="string">"appToken "</span> + appAnimator.mAppToken + <span class="string">" done"</span>, displayId);</span><br><span class="line">                    ......</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>调用stepAnimationLocked()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;AppWindowAnimator.java]</span><br><span class="line">    <span class="comment">// This must be called while inside a transaction.</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">stepAnimationLocked</span><span class="params">(<span class="keyword">long</span> currentTime, <span class="keyword">final</span> <span class="keyword">int</span> displayId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mService.okToDisplay()) &#123;</span><br><span class="line">            ......</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((mAppToken.allDrawn || animating || mAppToken.startingDisplayed)</span><br><span class="line">                    &amp;&amp; animation != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ......</span><br><span class="line">                <span class="keyword">if</span> (stepAnimation(currentTime)) &#123;</span><br><span class="line">                    <span class="comment">// animation isn't over, step any thumbnail and that's</span></span><br><span class="line">                    <span class="comment">// it for now.</span></span><br><span class="line">                    <span class="keyword">if</span> (thumbnail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        stepThumbnailAnimation(currentTime);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (animation != <span class="keyword">null</span>) &#123;</span><br><span class="line">            animating = <span class="keyword">true</span>;</span><br><span class="line">            animation = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用stepAnimation()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;AppWindowAnimator.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">stepAnimation</span><span class="params">(<span class="keyword">long</span> currentTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (animation == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1.</span></span><br><span class="line">    transformation.clear();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> animationFrameTime = getAnimationFrameTime(animation, currentTime);</span><br><span class="line">    <span class="comment">//2.</span></span><br><span class="line">    <span class="keyword">boolean</span> hasMoreFrames = animation.getTransformation(animationFrameTime, transformation);</span><br><span class="line">    <span class="keyword">if</span> (!hasMoreFrames) &#123;</span><br><span class="line">        <span class="keyword">if</span> (deferThumbnailDestruction &amp;&amp; !deferFinalFrameCleanup) &#123;</span><br><span class="line">            deferFinalFrameCleanup = <span class="keyword">true</span>;</span><br><span class="line">            hasMoreFrames = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            deferFinalFrameCleanup = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (mProlongAnimation == PROLONG_ANIMATION_AT_END) &#123;</span><br><span class="line">                hasMoreFrames = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                setNullAnimation();</span><br><span class="line">                clearThumbnail();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    hasTransformation = hasMoreFrames;</span><br><span class="line">    <span class="keyword">return</span> hasMoreFrames;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.将成员变量transformation所描述的变换矩阵的数据清空 2.调用Animation.getTransformation()来计算Activity组件切换动画下一步所对应的变换矩阵，并且将这个变换矩阵的数据保存在成员变量transformation</p><h3 id="6-4、窗口动画的推进过程"><a href="#6-4、窗口动画的推进过程" class="headerlink" title="6.4、窗口动画的推进过程"></a>6.4、窗口动画的推进过程</h3><p>继续分析WindowAnimator.animateLocked()的updateWindowsLocked()</p><h3 id="6-4-1、WindowAnimator-updateWindowsLocked"><a href="#6-4-1、WindowAnimator-updateWindowsLocked" class="headerlink" title="6.4.1、WindowAnimator.updateWindowsLocked()"></a>6.4.1、WindowAnimator.updateWindowsLocked()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowAnimator.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateWindowsLocked</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> displayId)</span> </span>&#123;</span><br><span class="line">    ++mAnimTransactionSequence;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> WindowList windows = mService.getWindowListLocked(displayId);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = windows.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        WindowState win = windows.get(i);</span><br><span class="line">        WindowStateAnimator winAnimator = win.mWinAnimator;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> flags = win.mAttrs.flags;</span><br><span class="line">        <span class="keyword">boolean</span> canBeForceHidden = mPolicy.canBeForceHidden(win, win.mAttrs);</span><br><span class="line">        <span class="keyword">boolean</span> shouldBeForceHidden = shouldForceHide(win);</span><br><span class="line">        <span class="keyword">if</span> (winAnimator.hasSurface()) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> wasAnimating = winAnimator.mWasAnimating;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> nowAnimating = winAnimator.stepAnimationLocked(mCurrentTime);</span><br><span class="line">            winAnimator.mWasAnimating = nowAnimating;</span><br><span class="line">            orAnimating(nowAnimating);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WindowStateAnimator.stepAnimationLocked() 如果窗口的动画尚未结束显示，那么stepAnimationLocked()会返回一个true值给调用者，否则的话，就会返回一个false值给调用者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowStateAnimator.java]</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">stepAnimationLocked</span><span class="params">(<span class="keyword">long</span> currentTime)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Save the animation state as it was before this step so WindowManagerService can tell if</span></span><br><span class="line">        <span class="comment">// we just started or just stopped animating by comparing mWasAnimating with isAnimationSet().</span></span><br><span class="line">        mWasAnimating = mAnimating;</span><br><span class="line">        <span class="keyword">final</span> DisplayContent displayContent = mWin.getDisplayContent();</span><br><span class="line">        <span class="keyword">if</span> (displayContent != <span class="keyword">null</span> &amp;&amp; mService.okToDisplay()) &#123;</span><br><span class="line">            <span class="comment">// We will run animations as long as the display isn't frozen.</span></span><br><span class="line">            <span class="keyword">if</span> (mWin.isDrawnLw() &amp;&amp; mAnimation != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mHasTransformation = <span class="keyword">true</span>;</span><br><span class="line">                mHasLocalTransformation = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (!mLocalAnimating) &#123;</span><br><span class="line">                    <span class="keyword">final</span> DisplayInfo displayInfo = displayContent.getDisplayInfo();</span><br><span class="line">                    <span class="keyword">if</span> (mAnimateMove) &#123;</span><br><span class="line">                        mAnimateMove = <span class="keyword">false</span>;</span><br><span class="line">                        mAnimation.initialize(mWin.mFrame.width(), mWin.mFrame.height(),</span><br><span class="line">                                mAnimDx, mAnimDy);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mAnimation.initialize(mWin.mFrame.width(), mWin.mFrame.height(),</span><br><span class="line">                                displayInfo.appWidth, displayInfo.appHeight);</span><br><span class="line">                    &#125;</span><br><span class="line">                    mAnimDx = displayInfo.appWidth;</span><br><span class="line">                    mAnimDy = displayInfo.appHeight;</span><br><span class="line">                    mAnimation.setStartTime(mAnimationStartTime != -<span class="number">1</span></span><br><span class="line">                            ? mAnimationStartTime</span><br><span class="line">                            : currentTime);</span><br><span class="line">                    mLocalAnimating = <span class="keyword">true</span>;</span><br><span class="line">                    mAnimating = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ((mAnimation != <span class="keyword">null</span>) &amp;&amp; mLocalAnimating) &#123;</span><br><span class="line">                    mLastAnimationTime = currentTime;</span><br><span class="line">                    <span class="keyword">if</span> (stepAnimation(currentTime)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ......</span><br><span class="line">            &#125;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowStateAnimator.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">stepAnimation</span><span class="params">(<span class="keyword">long</span> currentTime)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    currentTime = getAnimationFrameTime(mAnimation, currentTime);</span><br><span class="line">    <span class="comment">//1.</span></span><br><span class="line">    mTransformation.clear();</span><br><span class="line">    <span class="comment">//2.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> more = mAnimation.getTransformation(currentTime, mTransformation);</span><br><span class="line">    <span class="keyword">if</span> (mAnimationStartDelayed &amp;&amp; mAnimationIsEntrance) &#123;</span><br><span class="line">        mTransformation.setAlpha(<span class="number">0f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> more;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、将成员变量mTransformation所描述的变换矩阵的数据清空。 2、调用mAnimation.getTransformation()来计算窗口动画下一步所对应的变换矩阵，并且将这个变换矩阵的数据保存在成员变量mTransformation。</p><p>然后就是动画过后，窗口大小计算、渲染合成等等显示步骤了，由于之前已经分析过了，不再分析了： 3、循环遍历保存在窗口堆栈的每一个WindowState对象，以便可以对系统中的每一个窗口的绘图表面进行更新 确定该窗口实际要显示的大小、位置、Alpha通道和变换矩阵等信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowAnimator.java::animateLocked()]</span><br><span class="line"><span class="comment">//确定该窗口实际要显示的大小、位置、Alpha通道和变换矩阵等信息</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">    windows.get(j).mWinAnimator.prepareSurfaceLocked(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、触发下一帧动画逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowAnimator.java::animateLocked()]</span><br><span class="line"><span class="keyword">if</span> (mAnimating) &#123;</span><br><span class="line">    mService.scheduleAnimationLocked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、刷新系统UI</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowAnimator.java::animateLocked()]</span><br><span class="line"><span class="keyword">if</span> (hasPendingLayoutChanges || doRequest) &#123;</span><br><span class="line">    mWindowPlacerLocked.requestTraversal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终经过SurfaceFlinger合成显示到屏幕上。 总体流程图(…)：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.wms/20-Android-WMS-animation_Locked-time-diagram.png" alt="Markdown"></p><h2 id="（七）、参考文档-特别感谢各位前辈的分析和图示-："><a href="#（七）、参考文档-特别感谢各位前辈的分析和图示-：" class="headerlink" title="（七）、参考文档(特别感谢各位前辈的分析和图示)："></a>（七）、参考文档(特别感谢各位前辈的分析和图示)：</h2><p><a href="https://www.bbsmax.com/A/n2d9gjgJDv/" target="_blank" rel="noopener">浅析 Android 的窗口</a><br><a href="https://www.jianshu.com/p/2faedc664d11" target="_blank" rel="noopener">WMS:窗口大小的计算</a><br><a href="http://blog.csdn.net/luozirong/article/details/70256809" target="_blank" rel="noopener">Android 窗口的计算过程</a><br><a href="http://blog.csdn.net/qian520ao/article/details/78555397" target="_blank" rel="noopener">Android Window 机制探索</a><br><a href="https://calvinlee.github.io/blog/2012/04/21/android-window-management-architecture/" target="_blank" rel="noopener">Android 窗口管理 - 且听风吟</a><br><a href="http://www.cnblogs.com/all-for-fiona/p/4054527.html" target="_blank" rel="noopener">Android 关于Window Overscan</a><br><a href="http://blog.csdn.net/guoqifa29/article/details/49273065" target="_blank" rel="noopener">WindowManagerService动画分析</a><br><a href="http://blog.csdn.net/guoqifa29/article/details/46819377" target="_blank" rel="noopener">深入理解Activity—-Token之旅 - CSDN博客</a><br><a href="http://blog.csdn.net/jinzhuojun/article/details/37737439" target="_blank" rel="noopener">Android 4.4(KitKat)窗口管理子系统 - 体系框架</a><br><a href="https://www.jianshu.com/p/c2e48b3e33a0" target="_blank" rel="noopener">Android窗口系统第四篇—Activity动画的设置过程</a><br><a href="http://blog.csdn.net/lin20044140410/article/details/78798048" target="_blank" rel="noopener">Android 7.1 GUI系统-窗口管理WMS-Surface管理（四）</a><br><a href="http://www.cnblogs.com/samchen2009/p/3367496.html" target="_blank" rel="noopener">Android 的窗口管理系统 (View, Canvas, WindowManager)</a><br><a href="http://gityuan.com/2017/01/15/wms_starting_window/" target="_blank" rel="noopener">WMS–启动窗口(StartingWindow) - Gityuan博客 | 袁辉辉博客</a><br><a href="https://www.jianshu.com/p/a65861e946cb" target="_blank" rel="noopener">View绘制流程及源码解析(一)—-performTraversals()源码分析</a><br><a href="http://blog.csdn.net/u013263323/article/details/78482141" target="_blank" rel="noopener">Android窗口系统第三篇—WindowManagerService中窗口的组织方式</a><br><a href="https://juejin.im/entry/58c899bea22b9d006411241c" target="_blank" rel="noopener">google 进入分屏后在横屏模式按 home 键界面错乱 (二) - Android - 掘金</a><br><a href="http://blog.csdn.net/yanbober/article/details/46361191" target="_blank" rel="noopener">Android应用Activity、Dialog、PopWindow、Toast窗口添加机制及源码分析</a><br><a href="http://blog.csdn.net/luoshengyang/article/details/8462738" target="_blank" rel="noopener">Android窗口管理服务WindowManagerService的简要介绍和学习计划 - CSDN博客</a><br><a href="https://www.jianshu.com/p/40776c123adb" target="_blank" rel="noopener">Android窗口管理分析（2）：WindowManagerService窗口管理之Window添加流程</a><br><a href="http://blog.csdn.net/luoshengyang/article/details/8611754" target="_blank" rel="noopener">Android窗口管理服务WindowManagerService显示窗口动画的原理分析 - CSDN博客</a><br><a href="http://blog.csdn.net/kc58236582/article/details/53782138" target="_blank" rel="noopener">Android6.0 WMS（五） WMS计算Activity窗口大小的过程分析（二）WMS的relayoutWindow</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;窗口管理系统WMS是Android中的主要子系统之一，它涉及到App中组件的管理，系统和应用窗口的管理和绘制等工作。由于其涉及模块众多，且与用户体验密切相关，所以它也是Android当中最为复杂的子系统之一。一个App从启动到主窗口显示出来，需要App，ActivityManagerService（AMS），WindowManagerService（WMS），SurfaceFlinger（SF）等几个模块相互合作。App负责业务逻辑，绘制自己的视图；AMS管理组件、进程信息和Activity的堆栈及状态等等；WMS管理Activity对应的窗口及子窗口，还有系统窗口等；SF用于管理图形缓冲区，将App绘制的东西合成渲染在屏幕上。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://zhoujinjian.cc/categories/Android/"/>
    
    
      <category term="Android" scheme="http://zhoujinjian.cc/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android 7.1.2 (Android N) Android Graphics 系统 分析 [i.wonder~]</title>
    <link href="http://zhoujinjian.cc/2018/02/01/Android-7-1-2-Android-N-Android-Graphics-%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/"/>
    <id>http://zhoujinjian.cc/2018/02/01/Android-7-1-2-Android-N-Android-Graphics-系统分析/</id>
    <published>2018-01-31T16:00:00.000Z</published>
    <updated>2018-04-19T14:30:01.581Z</updated>
    
    <content type="html"><![CDATA[<p>Android系统图形框架由下往上主要的包括HAL(HWComposer和Gralloc两个moudle)，SurfaceFlinger（BufferQueue的消费者），WindowManagerService（窗口管理者），View（BufferQueue的生产者）四大模块。<br>● HAL: 包括HWComposer和Gralloc两个moudle，Android N上由SurfaceFlinger打开，因此在同一进程。 gralloc 用于BufferQueue的内存分配，同时也有fb的显示接口，HWComposer作为合成SurfaceFlinger里面的Layer，并显示（通过gralloc的post函数）<br>● SurfaceFlinger可以叫做LayerFlinger，作为Layer的管理者，同是也是BufferQueue的消费者，当每个Layer的生产者draw完完整的一帧时，会通知SurfaceFlinger，通知的方式采用BufferQueue。<br>● WindowManagerService: 作为Window的管理者，掌管着计算窗口大小，窗口切换等任务，同时也会将相应的参数设置给SurfaceFlinger，比如Window的在z-order，和窗口的大小。<br>● View: 作为BufferQueue的生产者，每当执行lockCanvas-&gt;draw-&gt;unlockCanvas，之后会存入一帧数据进入BufferQueue中。 嘿嘿(<em>^▽^</em>),但这也是无可奈何的事情，毕竟世上不可能有那么多十全十美的好事，做人在某些时候总是要有些取舍的。 <a id="more"></a></p><h2 id="【博客原图链接】"><a href="#【博客原图链接】" class="headerlink" title="【博客原图链接】"></a><a href="https://github.com/izhoujinjian/zhoujinjian.cc/tree/master/android.graphics" target="_blank" rel="noopener">【博客原图链接】</a></h2><h2 id="源码（部分）："><a href="#源码（部分）：" class="headerlink" title="源码（部分）："></a>源码（部分）：</h2><p><strong>/frameworks/native/services/surfaceflinger/</strong></p><ul><li>tests/Transaction_test.cpp</li><li>tests/vsync/vsync.cpp</li></ul><p><strong>/frameworks/native/include/gui/</strong></p><ul><li>BitTube.h</li><li>BufferSlot.h</li><li>BufferQueueCore.h</li><li>BufferQueueProducer.h</li></ul><p><strong>/frameworks/base/core/java/android/app/</strong></p><ul><li>Activity.java</li><li>ActivityThread.java</li><li>Instrumentation.java</li></ul><p><strong>/frameworks/base/core/jni/</strong></p><ul><li>android_view_DisplayEventReceiver.cpp</li><li>android_view_SurfaceControl.cpp</li><li>android_view_Surface.cpp</li><li>android_view_SurfaceSession.cpp</li></ul><p><strong>/frameworks/native/include/gui/</strong></p><ul><li>SurfaceComposerClient.h</li><li>IDisplayEventConnection.h</li><li>SurfaceComposerClient.h</li></ul><p><strong>/frameworks/native/services/surfaceflinger/</strong></p><ul><li>SurfaceFlinger.cpp</li><li>Client.cpp</li><li>main_surfaceflinger.cpp</li><li>DisplayDevice.cpp</li><li>DispSync.cpp</li><li>EventControlThread.cpp</li><li>EventThread.cpp</li><li>Layer.cpp</li><li>MonitoredProducer.cpp</li></ul><p><strong>/frameworks/base/core/java/android/view/</strong></p><ul><li>WindowManagerImpl.java</li><li>ViewManager.java</li><li>WindowManagerGlobal.java</li><li>ViewRootImpl.java</li><li>Choreographer.java</li><li>IWindowSession.aidl</li><li>DisplayEventReceiver.java</li><li>SurfaceControl.java</li><li>Surface.java</li><li>SurfaceSession.java</li></ul><p><strong>/frameworks/native/include/ui/</strong></p><ul><li>GraphicBuffer.h</li><li>GraphicBufferAllocator.h</li></ul><p><strong>/frameworks/base/services/core/java/com/android/server/wm/</strong></p><ul><li>WindowManagerService.java</li><li>Session.java</li><li>WindowState.java</li><li>WindowStateAnimator.java</li><li>WindowSurfaceController.java</li></ul><h2 id="【博客原图链接】-1"><a href="#【博客原图链接】-1" class="headerlink" title="【博客原图链接】"></a><a href="https://github.com/izhoujinjian/zhoujinjian.cc/tree/master/android.graphics" target="_blank" rel="noopener">【博客原图链接】</a></h2><h2 id="（一）、Android-Graphics-系统框架"><a href="#（一）、Android-Graphics-系统框架" class="headerlink" title="（一）、Android Graphics 系统框架"></a>（一）、Android Graphics 系统框架</h2><p>（试用限制？？？万恶的亿图(EDraw)强加水印~火~）<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.graphics/01-Android-Graphics-Architecture.png" alt="Markdown"></p><p><strong>App</strong> 基于Android系统的GUI框架开发完整的Apk应用。</p><p><strong>Android Graphics Stack Client(SurfaceFlinger Client)</strong><br>Android在客户端的绘图堆栈通常包括： OpenGL ES：使用GPU进行3D和2D的绘图的API EGL：衔接GLES和系统的Native Window系统的适配层 Vulkan：Vulkan为Khronos Group推出的下一代跨平台图形开发接口，用于替代历史悠久的OpenGL。Android从7.0(Nougat)开始加入了对其的支持。Vulkan与OpenGL相比，接口更底层，从而使开发者能更直接地控制GPU。由于更好的并行支持，及更小的开销，性能上也有一定的提升。<br><strong>Android Graphics Stack Server（SurfaceFlinger Server）</strong><br>SurfaceFlinger是Android用于管理Display和负责Window Composite（窗口混合），把应用的显示窗口输出到Display的系统服务。</p><p><strong>Android Drivers（HAL）</strong><br>Android的驱动层，通过Android本身的HAL（硬件抽象层）机制，运行于User Space，跟渲染相关的包括：</p><p>Hwcomposer：如果硬件支持，SurfaceFlinger可以请求hwcomposer去做窗口混合而不需要自己来做，这样的效率也会更高，减少对GPU资源的占用 Gralloc：用来管理Graphics Buffer的分配和管理系统的framebuffer OpenGL ES/EGL</p><p><strong>Linux Kernel and Drivers</strong><br>除了标准的Linux内核和驱动（例如fb是framebuffer驱动），硬件厂商自己的驱动外，Android自己的一些Patches：</p><p>Ashmem：异步共享内存，用于在进程间共享一块内存区域，并允许系统在资源紧张时回收不加锁的内存块 ION：内存管理器 ION是google在Android4.0 为了解决内存碎片管理而引入的通用内存管理器,在面向程序员编程方面，它和ashmem很相似。但ION比ashmem更强大 Binder：高效的进程间通信机制 Vsync：Android 4.1引入了Vsync(Vertical Syncronization)用于渲染同步，使得App UI和SurfaceFlinger可以按硬件产生的VSync节奏来进行工作 <strong>Hardware</strong> Display（显示器）、CPU、GPU、VPU（Video Process Unit）、和内存等等</p><h2 id="（二）、Android-Graphics-测试程序（C-）"><a href="#（二）、Android-Graphics-测试程序（C-）" class="headerlink" title="（二）、Android Graphics 测试程序（C++）"></a>（二）、Android Graphics 测试程序（C++）</h2><p>为了便于观察对原生测试程序显示图像大小做了如下修改：</p><blockquote><p>frameworks/native/services/surfaceflinger/tests/Transaction_test.cpp</p></blockquote><p><a href="https://github.com/izhoujinjian/izhoujinjian.github.io.doc/blob/master/Android-7.1.2-Qualcomm-MSM89XX-Disable_HWUI_GPU_HWC.patch" target="_blank" rel="noopener">Disable_HWUI_GPU_HWC.patch</a></p><p>原生SurfaceFlinger测试程序编译：<br>1、编译Android 7.1.2源码-userdebug版本，烧录重启<br>2、编译/frameworks/native/services/surfaceflinger/tests/会生成SurfaceFlinger_test<br>3、连接手机执行命令 adb root、adb remount、adb push SurfaceFlinger_test /system/bin/<br>4、adb shell setenforce 0(暂时关闭SELinux权限)<br>5、adb shell、cd system/bin/、chmod 0777 SurfaceFlinger_test<br>6、运行测试程序：./SurfaceFlinger_test</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.graphics/02-Android-graphics-SurfaceFlinger-Test-00.gif" alt="Markdown"></p><p>可以看到在Android 显示屏接替绘制了多个图像，并且会变换形状、位置、颜色、透明度等。 我们先看一下主要步骤： 1、 创建SurfaceComposerClient</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;SurfaceComposerClient&gt; mComposerClient;</span><br><span class="line">mComposerClient = <span class="keyword">new</span> SurfaceComposerClient;</span><br></pre></td></tr></table></figure><p>2、 客户端SurfaceComposerClient请求SurfaceFlinger创建Surface 注：App端对应SurfaceControl&lt;—&gt;SurfaceFlinger对应Layer</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;SurfaceControl&gt; mBGSurfaceControl;</span><br><span class="line">sp&lt;SurfaceControl&gt; mFGSurfaceControl;</span><br><span class="line">       <span class="comment">// Background surface</span></span><br><span class="line">mBGSurfaceControl = mComposerClient-&gt;createSurface(</span><br><span class="line">                String8(<span class="string">"BG Test Surface"</span>), displayWidth, displayHeight,</span><br><span class="line">                PIXEL_FORMAT_RGBA_8888, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">fillSurfaceRGBA8(mBGSurfaceControl, <span class="number">63</span>, <span class="number">63</span>, <span class="number">195</span>);</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.graphics/03-Android-Graphics-SF-test-color-blue.png" alt="Markdown"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Foreground surface</span></span><br><span class="line">mFGSurfaceControl = mComposerClient-&gt;createSurface(</span><br><span class="line">        String8(<span class="string">"FG Test Surface"</span>), <span class="number">64</span>, <span class="number">64</span>, PIXEL_FORMAT_RGBA_8888, <span class="number">0</span>);</span><br><span class="line">fillSurfaceRGBA8(mFGSurfaceControl, <span class="number">195</span>, <span class="number">63</span>, <span class="number">63</span>);</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.graphics/04-Android-Graphics-SF-test-color-red.png" alt="Markdown"></p><p>3、处理事务，将SurfaceControl（App）的变化更新到Layer（SurfaceFlinger）图层</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SurfaceComposerClient::openGlobalTransaction();</span><br><span class="line"></span><br><span class="line">   mComposerClient-&gt;setDisplayLayerStack(display, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">   ASSERT_EQ(NO_ERROR, mBGSurfaceControl-&gt;setLayer(INT_MAX<span class="number">-2</span>));</span><br><span class="line">   ASSERT_EQ(NO_ERROR, mBGSurfaceControl-&gt;show());</span><br><span class="line"></span><br><span class="line">   ASSERT_EQ(NO_ERROR, mFGSurfaceControl-&gt;setLayer(INT_MAX<span class="number">-1</span>));</span><br><span class="line">   ASSERT_EQ(NO_ERROR, mFGSurfaceControl-&gt;setPosition(<span class="number">64</span>, <span class="number">64</span>));</span><br><span class="line">   ASSERT_EQ(NO_ERROR, mFGSurfaceControl-&gt;show());</span><br><span class="line"></span><br><span class="line">   SurfaceComposerClient::closeGlobalTransaction(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>4、接受Vsync同步信号，渲染合成，推送到显示屏显示<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.graphics/05-Android-Graphics-SF-test-frame_01_delay-1s.gif" alt="Markdown"></p><p>接下来开始Android Graphics系统神秘探索之谜。</p><h2 id="（三）、Android-Graphics-禁用hwc和GPU"><a href="#（三）、Android-Graphics-禁用hwc和GPU" class="headerlink" title="（三）、Android Graphics 禁用hwc和GPU"></a>（三）、Android Graphics 禁用hwc和GPU</h2><h3 id="3-1、Disable-HWUI-GPU-HWC"><a href="#3-1、Disable-HWUI-GPU-HWC" class="headerlink" title="3.1、Disable_HWUI_GPU_HWC"></a>3.1、Disable_HWUI_GPU_HWC</h3><p>注：基于Android 7.1.2 Qualcomm MSM89XX源码，由于代码段较长，已放到GitHub <a href="https://github.com/izhoujinjian/izhoujinjian.github.io.doc/blob/master/Android-7.1.2-Qualcomm-MSM89XX-Disable_HWUI_GPU_HWC.patch" target="_blank" rel="noopener">Disable_HWUI_GPU_HWC.patch</a></p><p>编译userdebug版本，烧录开机: 运行测试程序：./SurfaceFlinger_test 结果跟上述一致，这里不再贴图了。</p><h3 id="3-2、Vsync测试程序"><a href="#3-2、Vsync测试程序" class="headerlink" title="3.2、Vsync测试程序"></a>3.2、Vsync测试程序</h3><p>Vsync(Vertical Syncronization)用于渲染同步，使得App UI和SurfaceFlinger可以按硬件产生的VSync节奏来进行工作。</p><p>查看frameworks/native/services/surfaceflinger/tests/下还有vsync测试程序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;android/looper.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gui/DisplayEventReceiver.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utils/Looper.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> android;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">receiver</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span>* data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DisplayEventReceiver* q = (DisplayEventReceiver*)data;</span><br><span class="line">    <span class="keyword">ssize_t</span> n;</span><br><span class="line">    DisplayEventReceiver::Event buffer[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">nsecs_t</span> oldTimeStamp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((n = q-&gt;getEvents(buffer, <span class="number">1</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;n ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (buffer[i].header.type == DisplayEventReceiver::DISPLAY_EVENT_VSYNC) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"event vsync: count=%d\t"</span>, buffer[i].vsync.count);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (oldTimeStamp) &#123;</span><br><span class="line">                <span class="keyword">float</span> t = <span class="keyword">float</span>(buffer[i].header.timestamp - oldTimeStamp) / s2ns(<span class="number">1</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%f ms (%f Hz)\n"</span>, t*<span class="number">1000</span>, <span class="number">1.0</span>/t);</span><br><span class="line">            &#125;</span><br><span class="line">            oldTimeStamp = buffer[i].header.timestamp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n&lt;<span class="number">0</span>) &#123;<span class="built_in">printf</span>(<span class="string">"error reading events (%s)\n"</span>, strerror(-n));&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DisplayEventReceiver myDisplayEvent;</span><br><span class="line">    sp&lt;Looper&gt; loop = <span class="keyword">new</span> Looper(<span class="literal">false</span>);</span><br><span class="line">    loop-&gt;addFd(myDisplayEvent.getFd(), <span class="number">0</span>, ALOOPER_EVENT_INPUT, receiver,</span><br><span class="line">            &amp;myDisplayEvent);</span><br><span class="line">    myDisplayEvent.setVsyncRate(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//printf("about to poll...\n");</span></span><br><span class="line">        <span class="keyword">int32_t</span> ret = loop-&gt;pollOnce(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">switch</span> (ret) &#123;</span><br><span class="line">            <span class="keyword">case</span> ALOOPER_POLL_WAKE:</span><br><span class="line">                <span class="comment">//("ALOOPER_POLL_WAKE\n");</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ALOOPER_POLL_CALLBACK:</span><br><span class="line">                <span class="comment">//("ALOOPER_POLL_CALLBACK\n");</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ALOOPER_POLL_TIMEOUT:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"ALOOPER_POLL_TIMEOUT\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ALOOPER_POLL_ERROR:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"ALOOPER_POLL_TIMEOUT\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"ugh? poll returned %d\n"</span>, ret);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行看看：可以看到vsync信号每隔16 ms一次，关于vsync知识稍后再分析。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">event vsync: count=<span class="number">2631</span> <span class="number">16.168612</span> ms (<span class="number">61.848231</span> Hz)</span><br><span class="line">event vsync: count=<span class="number">2632</span> <span class="number">16.168613</span> ms (<span class="number">61.848224</span> Hz)</span><br><span class="line">event vsync: count=<span class="number">2633</span> <span class="number">16.168312</span> ms (<span class="number">61.849378</span> Hz)</span><br><span class="line">event vsync: count=<span class="number">2634</span> <span class="number">16.168682</span> ms (<span class="number">61.847961</span> Hz)</span><br><span class="line">event vsync: count=<span class="number">2635</span> <span class="number">16.168596</span> ms (<span class="number">61.848288</span> Hz)</span><br><span class="line">event vsync: count=<span class="number">2636</span> <span class="number">16.168867</span> ms (<span class="number">61.847255</span> Hz)</span><br></pre></td></tr></table></figure><h2 id="（四）、Android-SurfaceFlinger-内部机制"><a href="#（四）、Android-SurfaceFlinger-内部机制" class="headerlink" title="（四）、Android SurfaceFlinger 内部机制"></a>（四）、Android SurfaceFlinger 内部机制</h2><h3 id="4-1、APP与SurfaceFlinger的数据结构"><a href="#4-1、APP与SurfaceFlinger的数据结构" class="headerlink" title="4.1、APP与SurfaceFlinger的数据结构"></a>4.1、APP与SurfaceFlinger的数据结构</h3><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.graphics/06-Android-Graphics-App-SurfaceFlinger.png" alt="Markdown"></p><h4 id="4-1-1、BufferQueue介绍"><a href="#4-1-1、BufferQueue介绍" class="headerlink" title="4.1.1、BufferQueue介绍"></a>4.1.1、BufferQueue介绍</h4><p>BufferQueue 类是 Android 中所有图形处理操作的核心。它的是将生成图形数据缓冲区的一方（生产者Producer）连接到接受数据以进行显示或进一步处理的一方（消费者Consumer）。几乎所有在系统中移动图形数据缓冲区的内容都依赖于 BufferQueue。 从上图APP与SurfaceFlinger交互中可以看出，BufferQueue内部维持着64个BufferSlot，每一个BufferSlot内部有一个GraphicBuffer指向分配的Graphic Buffer。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.graphics/07-Android-Graphics-SurfaceFlinger-BufferQueue.png.png" alt="Markdown"><br>先来看一下图中几个状态代表的含义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">frameworks/native/include/gui/BufferSlot.h</span><br><span class="line"></span><br><span class="line"><span class="comment">// A buffer can be in one of five states, represented as below:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//         | mShared | mDequeueCount | mQueueCount | mAcquireCount |</span></span><br><span class="line"><span class="comment">// --------|---------|---------------|-------------|---------------|</span></span><br><span class="line"><span class="comment">// FREE    |  false  |       0       |      0      |       0       |</span></span><br><span class="line"><span class="comment">// DEQUEUED|  false  |       1       |      0      |       0       |</span></span><br><span class="line"><span class="comment">// QUEUED  |  false  |       0       |      1      |       0       |</span></span><br><span class="line"><span class="comment">// ACQUIRED|  false  |       0       |      0      |       1       |</span></span><br><span class="line"><span class="comment">// SHARED  |  true   |      any      |     any     |      any      |</span></span><br></pre></td></tr></table></figure><p><strong>FREE :</strong> FREE表示缓冲区可由生产者（Producer）DEQUEUED出列。 该BufferSlot由BufferQueue”拥有”。 它转换到DEQUEUED 当调用dequeueBuffer时。</p><p><strong>DEQUEUED：</strong> DEQUEUED表示缓冲区已经被生产者（Producer）出列，但是尚未queued 或canceled。生产者（Producer）可以修改缓冲区的内容一旦相关的释放围栏被发信号通知。BufferSlot由Producer”拥有”。 它可以转换到QUEUED（通过 queueBuffer或者attachBuffer）或者返回FREE（通过cancelBuffer或者detachBuffer）。</p><p><strong>QUEUED：</strong> QUEUED表示缓冲区已经被生产者（Producer）填充排队等待消费者（Consumer）使用。 缓冲区内容可能被继续 修改在有限的时间内，所以内容不能被访问，直到关联的栅栏fence发信号。 该BufferSlot由BufferQueue”拥有”。 它 可以转换为ACQUIRED（通过acquireBuffer）或FREE（如果是另一个缓冲区以异步模式排队）。</p><p><strong>ACQUIRED：</strong> ACQUIRED表示缓冲区已被消费者（Consumer）获取。 如与QUEUED，内容不能被消费者访问，直到 获得栅栏fence信号。 BufferSlot由Consumer”拥有”。 它当releaseBuffer（或detachBuffer）被调用时转换为FREE。 一个 分离的缓冲区也可以通过attachBuffer进入ACQUIRED状态。</p><p><strong>SHARED：</strong> SHARED表示此缓冲区正在共享缓冲区中使用模式。 它可以同时在其他State的任何组合， 除了FREE （因为这不包括在任何其他State）。 它可以也可以出列，排队或多次获得。</p><p><strong>简单描述一下状态转换过程：</strong></p><p>1、首先生产者dequeue过来一块Buffer，此时该buffer的状态为DEQUEUED，所有者为PRODUCER，生产者可以填充数据了。在没有dequeue操作时，buffer的状态为free,所有者为BUFFERQUEUE。</p><p>2、生产者填充完数据后,进行queue操作，此时buffer的状态由DEQUEUED-&gt;QUEUED的转变，buffer所有者也变成了BufferQueue了。</p><p>3、上面已经通知消费者去拿buffer了，这个时候消费者就进行acquire操作将buffer拿过来，此时buffer的状态由QUEUED-&gt;ACQUIRED转变，buffer的拥有者由BufferQueue变成Consumer。</p><p>4、当消费者已经消费了这块buffer(已经合成，已经编码等)，就进行release操作释放buffer,将buffer归还给BufferQueue,buffer状态由ACQUIRED变成FREE.buffer拥有者由Consumer变成BufferQueue.</p><h4 id="4-1-2、生产者Producer"><a href="#4-1-2、生产者Producer" class="headerlink" title="4.1.2、生产者Producer"></a>4.1.2、生产者Producer</h4><p>生产者Producer实现IGraphicBufferProducer的接口，在实际运作过程中，应用（Client端）存在代理端BpGraphicBufferProducer，SurfaceFlinger（Server端）存在Native端BnGraphicBufferProducer。生产者代理端Bp通过Binder通信，不断的dequeueBuffer和queueBuffer操作，Native端同样响应这些操作请求，这样buffer就转了起来了。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.graphics/08-Android-Graphics-SurfaceFlinger-IGraphicsBufferProducer.png" alt="Markdown"></p><p>这里介绍几个非常重要的函数： <strong>1、requestBuffer</strong> requestBuffer为给定的索引请求一个新的Buffer。 服务器（即IGraphicBufferProducer实现）分配新创建的Buffer到给定的BufferSlot槽索引，并且客户端可以镜像slot-&gt;Buffer映射，这样就没有必要传输一个GraphicBuffer用于每个出队操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// requestBuffer requests a new buffer for the given index. The server (i.e.</span><br><span class="line">// the IGraphicBufferProducer implementation) assigns the newly created</span><br><span class="line">// buffer to the given slot index, and the client is expected to mirror the</span><br><span class="line">// slot-&gt;buffer mapping so that it&apos;s not necessary to transfer a</span><br><span class="line">// GraphicBuffer for every dequeue operation.</span><br><span class="line">//</span><br><span class="line">// The slot must be in the range of [0, NUM_BUFFER_SLOTS).</span><br><span class="line">virtual status_t requestBuffer(int slot, sp&lt;GraphicBuffer&gt;* buf) = 0;</span><br></pre></td></tr></table></figure><p><strong>2、dequeueBuffer</strong> dequeueBuffer请求一个新的Buffer Slot供客户端使用。 插槽的所有权被转移到客户端，这意味着服务器不会使用与该插槽关联的缓冲区的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// dequeueBuffer requests a new buffer slot for the client to use. Ownership</span><br><span class="line">// of the slot is transfered to the client, meaning that the server will not</span><br><span class="line">// use the contents of the buffer associated with that slot.</span><br><span class="line">//</span><br><span class="line">virtual status_t dequeueBuffer(int* slot, sp&lt;Fence&gt;* fence, uint32_t w,</span><br><span class="line">        uint32_t h, PixelFormat format, uint32_t usage) = 0;</span><br></pre></td></tr></table></figure><p><strong>3、detachBuffer</strong> detachBuffer尝试删除给定buffer 的所有权插槽从buffer queue。 如果这个请求成功，该slot将会被free，并且将无法从这个接口获得缓冲区。释放的插槽将保持未分配状态，直到被选中为止在dequeueBuffer中保存一个新分配的缓冲区，或者附加一个缓冲区到插槽。 缓冲区必须已经被取出，并且调用者必须已经拥有sp</p><graphicbuffer>（即必须调用requestBuffer）</graphicbuffer><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// detachBuffer attempts to remove all ownership of the buffer in the given</span><br><span class="line">// slot from the buffer queue. If this call succeeds, the slot will be</span><br><span class="line">// freed, and there will be no way to obtain the buffer from this interface.</span><br><span class="line">// The freed slot will remain unallocated until either it is selected to</span><br><span class="line">// hold a freshly allocated buffer in dequeueBuffer or a buffer is attached</span><br><span class="line">// to the slot. The buffer must have already been dequeued, and the caller</span><br><span class="line">// must already possesses the sp&lt;GraphicBuffer&gt; (i.e., must have called</span><br><span class="line">// requestBuffer).</span><br><span class="line">//</span><br><span class="line">virtual status_t detachBuffer(int slot) = 0;</span><br></pre></td></tr></table></figure><p><strong>4、attachBuffer</strong> attachBuffer尝试将缓冲区的所有权转移给缓冲区队列。 如果这个调用成功，就好像这个缓冲区已经出队一样从返回的插槽号码。 因此，如果连接，这个调用将失败这个缓冲区会导致很多的缓冲区同时出队。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// attachBuffer attempts to transfer ownership of a buffer to the buffer</span><br><span class="line">// queue. If this call succeeds, it will be as if this buffer was dequeued</span><br><span class="line">// from the returned slot number. As such, this call will fail if attaching</span><br><span class="line">// this buffer would cause too many buffers to be simultaneously dequeued.</span><br><span class="line">//</span><br><span class="line">virtual status_t attachBuffer(int* outSlot,</span><br><span class="line">        const sp&lt;GraphicBuffer&gt;&amp; buffer) = 0;</span><br></pre></td></tr></table></figure><h4 id="4-1-3、消费者Consumer"><a href="#4-1-3、消费者Consumer" class="headerlink" title="4.1.3、消费者Consumer"></a>4.1.3、消费者Consumer</h4><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.graphics/09-Android-Graphics-SurfaceFlinger-IGraphicsBufferConsumer.png" alt="Markdown"><br>这里介绍几个非常重要的函数： <strong>1、acquireBuffer</strong> acquireBuffer尝试获取下一个未决缓冲区的所有权BufferQueue。 如果没有缓冲区等待，则返回NO_BUFFER_AVAILABLE。 如果缓冲区被成功获取，有关缓冲区的信息将在BufferItem中返回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// acquireBuffer attempts to acquire ownership of the next pending buffer in</span><br><span class="line">// the BufferQueue.  If no buffer is pending then it returns</span><br><span class="line">// NO_BUFFER_AVAILABLE.  If a buffer is successfully acquired, the</span><br><span class="line">// information about the buffer is returned in BufferItem.</span><br><span class="line">//</span><br><span class="line">virtual status_t acquireBuffer(BufferItem* buffer, nsecs_t presentWhen,</span><br><span class="line">        uint64_t maxFrameNumber = 0) = 0;</span><br></pre></td></tr></table></figure><p><strong>2、releaseBuffer</strong> releaseBuffer从消费者释放一个BufferSlot回到BufferQueue。 这可以在缓冲区的内容仍然存在时完成被访问。 栅栏将在缓冲区不再正在使用时发出信号。 frameNumber用于标识返回的确切缓冲区。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// releaseBuffer releases a buffer slot from the consumer back to the</span><br><span class="line">// BufferQueue.  This may be done while the buffer&apos;s contents are still</span><br><span class="line">// being accessed.  The fence will signal when the buffer is no longer</span><br><span class="line">// in use. frameNumber is used to indentify the exact buffer returned.</span><br><span class="line">//</span><br><span class="line">virtual status_t releaseBuffer(int buf, uint64_t frameNumber,</span><br><span class="line">        EGLDisplay display, EGLSyncKHR fence,</span><br><span class="line">        const sp&lt;Fence&gt;&amp; releaseFence) = 0;</span><br></pre></td></tr></table></figure><p><strong>3、detachBuffer</strong> detachBuffer尝试删除给定缓冲区的所有权插槽从缓冲区队列。 如果这个请求成功，该插槽将会是释放，并且将无法从这个接口获得缓冲区。释放的插槽将保持未分配状态，直到被选中为止在dequeueBuffer中保存一个新分配的缓冲区，或者附加一个缓冲区到slot。 缓冲区必须已被acquired。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// detachBuffer attempts to remove all ownership of the buffer in the given</span></span><br><span class="line"><span class="comment">// slot from the buffer queue. If this call succeeds, the slot will be</span></span><br><span class="line"><span class="comment">// freed, and there will be no way to obtain the buffer from this interface.</span></span><br><span class="line"><span class="comment">// The freed slot will remain unallocated until either it is selected to</span></span><br><span class="line"><span class="comment">// hold a freshly allocated buffer in dequeueBuffer or a buffer is attached</span></span><br><span class="line"><span class="comment">// to the slot. The buffer must have already been acquired.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> status_t <span class="title">detachBuffer</span><span class="params">(<span class="keyword">int</span> slot)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><strong>4、attachBuffer</strong> attachBuffer尝试将缓冲区的所有权转移给缓冲区队列。 如果这个调用成功，就好像这个缓冲区被获取了一样从返回的插槽号码。 因此，如果连接，这个调用将失败这个缓冲区会导致太多的缓冲区被同时acquired。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// attachBuffer attempts to transfer ownership of a buffer to the buffer</span></span><br><span class="line"><span class="comment">// queue. If this call succeeds, it will be as if this buffer was acquired</span></span><br><span class="line"><span class="comment">// from the returned slot number. As such, this call will fail if attaching</span></span><br><span class="line"><span class="comment">// this buffer would cause too many buffers to be simultaneously acquired.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> status_t <span class="title">attachBuffer</span><span class="params">(<span class="keyword">int</span> *outSlot,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> sp&lt;GraphicBuffer&gt;&amp; buffer)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h2 id="4-2、App（Java层）请求创建Surface过程"><a href="#4-2、App（Java层）请求创建Surface过程" class="headerlink" title="4.2、App（Java层）请求创建Surface过程"></a>4.2、App（Java层）请求创建Surface过程</h2><h3 id="4-2-1、Activity启动流程"><a href="#4-2-1、Activity启动流程" class="headerlink" title="4.2.1、Activity启动流程"></a>4.2.1、Activity启动流程</h3><p>Activity创建过程这里不再叙述。 请参考<a href="https://izhoujinjian.github.io/2017/12/29/Android-7-1-2-Android-N-Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/#%E4%B8%89%E3%80%81-ActivityManagerService%E6%8E%A5%E6%94%B6%E5%90%AF%E5%8A%A8Activity%E7%9A%84%E8%AF%B7%E6%B1%82" target="_blank" rel="noopener">【Android 7.1.2 (Android N) Activity启动流程分析】</a> &amp;&amp; <a href="https://izhoujinjian.github.io/2018/01/02/Android-7-1-2-Android-N-Activity-Window%E5%8A%A0%E8%BD%BD%E6%98%BE%E7%A4%BA%E6%B5%81%E7%A8%8B/#%E5%8D%9A%E5%AE%A2%E5%8E%9F%E5%9B%BE%E9%93%BE%E6%8E%A5" target="_blank" rel="noopener">【Android 7.1.2 (Android N) Activity-Window加载显示流程分析】</a></p><blockquote><p>● ActivityManagerService接收启动Activity的请求</p><p>Activity.startActivity()<br>Activity.startActivityForResult()<br>Instrumentation.execStartActivity()<br>ActivityManagerProxy.startActivity()<br>ActivityManagerNative.onTransact()<br>ActivityManagerService.startActivity()<br>ActivityStarter.startActivityMayWait()<br>ActivityStarter.startActivityLocked()<br>ActivityStarter.startActivityUnchecked()<br>ActivityStackSupervisor.resumeFocusedStackTopActivityLocked() ActivityStack.resumeTopActivityUncheckedLocked()<br>ActivityStack.resumeTopActivityInnerLocked()<br>ActivityStackSupervisor.startSpecificActivityLocked()</p><p>●● 创建Activity所属的应用进程 ActivityManagerService.startProcessLocked()</p><p>●●● Zygote通过socket通信fork一个新的进程，并根据”android.app.ActivityThread”字符串<br>  ●●● 反射出该对象并执行ActivityThread的main方法<br>  ActivityThread.main()<br>  ActivityThread.attach()<br>  ActivityManagerProxy.attachApplication()<br>  ActivityManagerNative.onTransact()<br>  ActivityManagerService.attachApplication()<br>  ActivityManagerService.attachApplicationLocked()<br>  ActivityStackSupervisor.attachApplicationLocked()<br>  ActivityStackSupervisor.realStartActivityLocked()</p><p>●●●● 执行启动Acitivity<br>IApplicationThread.scheduleLaunchActivity()<br>ActivityThread.ApplicationThread.scheduleLaunchActivity()<br>ActivityThread.sendMessage() ActivityThread.H.handleMessage()<br>ActivityThread.handleLauncherActivity()<br>ActivityThread.performLauncherActivity()<br>ActivityThread.handleResumeActivity()</p><h5 id="4-2-2、Window加载显示流程"><a href="#4-2-2、Window加载显示流程" class="headerlink" title="4.2.2、Window加载显示流程"></a>4.2.2、Window加载显示流程</h5><p>画图，需要重新分析一下下，嘿嘿(<em>^▽^</em>)~</p><h5 id="4-2-2-1、ActivityThread-handleLaunchActivity"><a href="#4-2-2-1、ActivityThread-handleLaunchActivity" class="headerlink" title="4.2.2.1、ActivityThread.handleLaunchActivity()"></a>4.2.2.1、ActivityThread.handleLaunchActivity()</h5><p>接着从ActivityThread的handleLaunchActivity方法：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    [-&gt;ActivityThread.java]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent, String reason)</span></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//创建Activity  </span></span><br><span class="line">    Activity a = performLaunchActivity(r, customIntent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//启动Activity  </span></span><br><span class="line">        handleResumeActivity(r.token, <span class="keyword">false</span>, r.isForward,</span><br><span class="line">                !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason);</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-2-2、ActivityThread-handleResumeActivity"><a href="#4-2-2-2、ActivityThread-handleResumeActivity" class="headerlink" title="4.2.2.2、ActivityThread.handleResumeActivity()"></a>4.2.2.2、ActivityThread.handleResumeActivity()</h3><p>回到我们刚刚的handleLaunchActivity()方法，在调用完performLaunchActivity()方法之后，其有掉用了handleResumeActivity()法。performLaunchActivity()方法完成了两件事： 1) Activity窗口对象的创建，通过attach函数来完成； 2) Activity视图对象的创建，通过setContentView函数来完成； 这些准备工作完成后，就可以显示该Activity了，应用程序进程通过调用handleResumeActivity函数来启动Activity的显示过程。 [-&gt;ActivityThread.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">handleResumeActivity</span><span class="params">(IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> clearHide, <span class="keyword">boolean</span> isForward, <span class="keyword">boolean</span> reallyResume, <span class="keyword">int</span> seq, String reason)</span> </span>&#123;</span><br><span class="line">    ActivityClientRecord r = mActivities.get(token);</span><br><span class="line">    ......</span><br><span class="line">    r = performResumeActivity(token, clearHide, reason);</span><br><span class="line">    ......</span><br><span class="line">        <span class="keyword">if</span> (r.window == <span class="keyword">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">            <span class="comment">//获得为当前Activity创建的窗口PhoneWindow对象</span></span><br><span class="line">            r.window = r.activity.getWindow();</span><br><span class="line">            <span class="comment">//获取为窗口创建的视图DecorView对象</span></span><br><span class="line">            View decor = r.window.getDecorView();</span><br><span class="line">            decor.setVisibility(View.INVISIBLE);</span><br><span class="line">            <span class="comment">//在attach函数中就为当前Activity创建了WindowManager对象  </span></span><br><span class="line">            ViewManager wm = a.getWindowManager();</span><br><span class="line">            <span class="comment">//得到该视图对象的布局参数  </span></span><br><span class="line">            WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">            <span class="comment">//将视图对象保存到Activity的成员变量mDecor中  </span></span><br><span class="line">            a.mDecor = decor;</span><br><span class="line">            l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line">            l.softInputMode |= forwardBit;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">if</span> (a.mVisibleFromClient &amp;&amp; !a.mWindowAdded) &#123;</span><br><span class="line">                a.mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//将创建的视图对象DecorView添加到Activity的窗口管理器中  </span></span><br><span class="line">                wm.addView(decor, l);</span><br><span class="line">            &#125;</span><br><span class="line">        ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在前面的performLaunchActivity函数中完成Activity的创建后，会将当前当前创建的Activity在应用程序进程端的描述符ActivityClientRecord以键值对的形式保存到ActivityThread的成员变量mActivities中：mActivities.put(r.token, r)，r.token就是Activity的身份证，即是IApplicationToken.Proxy代理对象，也用于与AMS通信。上面的函数首先通过performResumeActivity从mActivities变量中取出Activity的应用程序端描述符ActivityClientRecord，然后取出前面为Activity创建的视图对象DecorView和窗口管理器WindowManager，最后将视图对象添加到窗口管理器中。 ViewManager.addView()真正实现的的地方在WindowManagerImpl.java中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ViewManager</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params)</span></span>;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[-&gt;WindowManagerImpl.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(@NonNull View view, @NonNull ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[-&gt;WindowManagerGlobal.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,</span></span></span><br><span class="line"><span class="function"><span class="params">        Display display, Window parentWindow)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    ViewRootImpl root;</span><br><span class="line">    View panelParentView = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        ......</span><br><span class="line">        root = <span class="keyword">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class="line">        view.setLayoutParams(wparams);</span><br><span class="line">        mViews.add(view);</span><br><span class="line">        mRoots.add(root);</span><br><span class="line">        mParams.add(wparams);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        root.setView(view, wparams, panelParentView);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-2-3、ViewRootImpl-构造过程："><a href="#4-2-2-3、ViewRootImpl-构造过程：" class="headerlink" title="4.2.2.3、ViewRootImpl()构造过程："></a>4.2.2.3、ViewRootImpl()构造过程：</h3><p>[ViewRootImpl.java # ViewRootImpl()]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">final</span> W mWindow;</span><br><span class="line">    <span class="keyword">final</span> Surface mSurface = <span class="keyword">new</span> Surface();</span><br><span class="line">    <span class="keyword">final</span> ViewRootHandler mHandler = <span class="keyword">new</span> ViewRootHandler();</span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ViewRootImpl</span><span class="params">(Context context, Display display)</span> </span>&#123;</span><br><span class="line">    mContext = context;</span><br><span class="line">    mWindowSession = WindowManagerGlobal.getWindowSession();<span class="comment">//IWindowSession的代理对象，该对象用于和WMS通信。</span></span><br><span class="line">    mDisplay = display;</span><br><span class="line">    ......</span><br><span class="line">    mWindow = <span class="keyword">new</span> W(<span class="keyword">this</span>);<span class="comment">//创建了一个W本地Binder对象，用于WMS通知应用程序进程</span></span><br><span class="line">    ......</span><br><span class="line">    mAttachInfo = <span class="keyword">new</span> View.AttachInfo(mWindowSession, mWindow, display, <span class="keyword">this</span>, mHandler, <span class="keyword">this</span>);</span><br><span class="line">    ......</span><br><span class="line">    mViewConfiguration = ViewConfiguration.get(context);</span><br><span class="line">    mDensity = context.getResources().getDisplayMetrics().densityDpi;</span><br><span class="line">    mNoncompatDensity = context.getResources().getDisplayMetrics().noncompatDensityDpi;</span><br><span class="line">    mFallbackEventHandler = <span class="keyword">new</span> PhoneFallbackEventHandler(context);</span><br><span class="line">    mChoreographer = Choreographer.getInstance();<span class="comment">//Choreographer对象</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ViewRootImpl的构造函数中初始化了一些成员变量，ViewRootImpl创建了以下几个主要对象：</p><p>(1) 通过WindowManagerGlobal.getWindowSession()得到IWindowSession的代理对象，该对象用于和WMS通信。</p><p>(2) 创建了一个W本地Binder对象，用于WMS通知应用程序进程。</p><p>(3) 采用单例模式创建了一个Choreographer对象，用于统一调度窗口绘图。</p><p>(4) 创建ViewRootHandler对象，用于处理当前视图消息。</p><p>(5) 构造一个AttachInfo对象；</p><p>●●●(6) 创建Surface对象，用于绘制当前视图，当然该Surface对象的真正创建是由WMS来完成的，只不过是WMS传递给应用程序进程的。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.graphics/10-Android-Graphics-App-WMS-Surface.png.png" alt="Markdown"></p><h3 id="4-2-2-4、IWindowSession代理获取过程"><a href="#4-2-2-4、IWindowSession代理获取过程" class="headerlink" title="4.2.2.4、IWindowSession代理获取过程"></a>4.2.2.4、IWindowSession代理获取过程</h3><p>[-&gt;WindowManagerGlobal.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> IWindowSession sWindowSession;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IWindowSession <span class="title">getWindowSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (WindowManagerGlobal.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sWindowSession == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            ......</span><br><span class="line">                <span class="comment">//得到IWindowSession代理对象</span></span><br><span class="line">                sWindowSession = windowManager.openSession(</span><br><span class="line">                        <span class="keyword">new</span> IWindowSessionCallback.Stub() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimatorScaleChanged</span><span class="params">(<span class="keyword">float</span> scale)</span> </span>&#123;</span><br><span class="line">                                ValueAnimator.setDurationScale(scale);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;,</span><br><span class="line">                        imm.getClient(), imm.getInputContext());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sWindowSession;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上函数通过WMS的openSession函数创建应用程序与WMS之间的连接通道，即获取IWindowSession代理对象，并将该代理对象保存到ViewRootImpl的静态成员变量sWindowSession中,因此在应用程序进程中有且只有一个IWindowSession代理对象。 [-&gt;WindowManagerService.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> IWindowSession <span class="title">openSession</span><span class="params">(IWindowSessionCallback callback, IInputMethodClient client,</span></span></span><br><span class="line"><span class="function"><span class="params">        IInputContext inputContext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (client == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"null client"</span>);</span><br><span class="line">    <span class="keyword">if</span> (inputContext == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"null inputContext"</span>);</span><br><span class="line">    Session session = <span class="keyword">new</span> Session(<span class="keyword">this</span>, callback, client, inputContext);</span><br><span class="line">    <span class="keyword">return</span> session;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在WMS服务端构造了一个Session实例对象。ViewRootImpl 是一很重要的类，类似 ActivityThread 负责跟AmS通信一样，ViewRootImpl 的一个重要职责就是跟 WmS 通信，它通静态变量 sWindowSession（IWindowSession实例）与 WmS 进行通信。每个应用进程，仅有一个 sWindowSession 对象，它对应了 WmS 中的 Session 子类，WmS 为每一个应用进程分配一个 Session 对象。WindowState 类有一个 IWindow mClient 参数，是在构造方法中赋值的，是由 Session 调用 addWindow 传递过来了，对应了 ViewRootImpl 中的 W 类的实例。</p><h3 id="4-2-2-5、视图View添加过程ViewRootImpl-setView"><a href="#4-2-2-5、视图View添加过程ViewRootImpl-setView" class="headerlink" title="4.2.2.5、视图View添加过程ViewRootImpl.setView()"></a>4.2.2.5、视图View添加过程ViewRootImpl.setView()</h3><p>窗口管理器WindowManagerImpl为当前添加的窗口创建好各种对象后，调用ViewRootImpl的setView函数向WMS服务添加一个窗口对象。 [-&gt;ViewRootImpl.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mView == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">////将DecorView保存到ViewRootImpl的成员变量mView中</span></span><br><span class="line">            mView = view;</span><br><span class="line">            ......</span><br><span class="line">            <span class="comment">//1）在添加窗口前进行UI布局  </span></span><br><span class="line">            requestLayout();</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ......</span><br><span class="line">                 <span class="comment">//2)将窗口添加到WMS服务中，mWindow为W本地Binder对象，通过Binder传输到WMS服务端后，变为IWindow代理对象  </span></span><br><span class="line">                res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">                        getHostVisibility(), mDisplay.getDisplayId(),</span><br><span class="line">                        mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</span><br><span class="line">                        mAttachInfo.mOutsets, mInputChannel);</span><br><span class="line">            &#125; ......</span><br><span class="line">            <span class="comment">//3)建立窗口消息通道  </span></span><br><span class="line">            <span class="keyword">if</span> (mInputChannel != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mInputQueueCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mInputQueue = <span class="keyword">new</span> InputQueue();</span><br><span class="line">                    mInputQueueCallback.onInputQueueCreated(mInputQueue);</span><br><span class="line">                &#125;</span><br><span class="line">                mInputEventReceiver = <span class="keyword">new</span> WindowInputEventReceiver(mInputChannel,</span><br><span class="line">                        Looper.myLooper());</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过前面的分析可以知道，用户自定义的UI作为一个子View被添加到DecorView中，然后将顶级视图DecorView添加到应用程序进程的窗口管理器中，窗口管理器首先为当前添加的View创建一个ViewRootImpl对象、一个布局参数对象ViewGroup.LayoutParams，然后将这三个对象分别保存到当前应用程序进程的窗口管理器WindowManagerImpl中，最后通过ViewRootImpl对象将当前视图对象注册到WMS服务中。</p><p>ViewRootImpl的setView函数向WMS服务添加一个窗口对象过程： (1) requestLayout()在应用程序进程中进行窗口UI布局； (2) WindowSession.addToDisplay()向WMS服务注册一个窗口对象； (3) 注册应用程序进程端的消息接收通道；</p><h3 id="4-2-2-6、requestLayout-在应用程序进程中进行窗口UI布局；"><a href="#4-2-2-6、requestLayout-在应用程序进程中进行窗口UI布局；" class="headerlink" title="4.2.2.6、requestLayout()在应用程序进程中进行窗口UI布局；"></a>4.2.2.6、requestLayout()在应用程序进程中进行窗口UI布局；</h3><p>2.10、窗口UI布局过程 requestLayout函数调用里面使用了Hanlder的一个小手段，那就是利用postSyncBarrier添加了一个Barrier（挡板），这个挡板的作用是阻塞普通的同步消息的执行，在挡板被撤销之前，只会执行异步消息，而requestLayout先添加了一个挡板Barrier，之后自己插入了一个异步任务mTraversalRunnable，其主要作用就是保证mTraversalRunnable在所有同步Message之前被执行，保证View绘制的最高优先级。具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        scheduleTraversals();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">true</span>;</span><br><span class="line">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">        mChoreographer.postCallback(</span><br><span class="line">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="keyword">null</span>);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里暂时不讨论Choreographer和Vsync知识，稍后再详细分析。 现在先说出结论：Choreographer构造函数中，构造了一个FrameDisplayEventReceiver对象，用于请求并接收Vsync信号。 此时FrameDisplayEventReceiver会Call requestNextVsync()来告诉系统我要在下一个VSYNC需要被trigger。Vsync信号每隔16ms一次，此时Vsync信号还未来到，继续分析mWindowSession.addToDisplay()。</p><h3 id="4-2-2-7、mWindowSession-addToDisplay-向WMS服务注册一个窗口对象；"><a href="#4-2-2-7、mWindowSession-addToDisplay-向WMS服务注册一个窗口对象；" class="headerlink" title="4.2.2.7、mWindowSession.addToDisplay()向WMS服务注册一个窗口对象；"></a>4.2.2.7、mWindowSession.addToDisplay()向WMS服务注册一个窗口对象；</h3><p>[Session.java]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Override</span><br><span class="line">public int addToDisplay(IWindow window, int seq, WindowManager.LayoutParams attrs,</span><br><span class="line">        int viewVisibility, int displayId, Rect outContentInsets, Rect outStableInsets,</span><br><span class="line">        Rect outOutsets, InputChannel outInputChannel) &#123;</span><br><span class="line">    return mService.addWindow(this, window, seq, attrs, viewVisibility, displayId,</span><br><span class="line">            outContentInsets, outStableInsets, outOutsets, outInputChannel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[WindowManagerService.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addWindow</span><span class="params">(Session session, IWindow client, <span class="keyword">int</span> seq,</span></span></span><br><span class="line"><span class="function"><span class="params">        WindowManager.LayoutParams attrs, <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> displayId,</span></span></span><br><span class="line"><span class="function"><span class="params">        Rect outContentInsets, Rect outStableInsets, Rect outOutsets,</span></span></span><br><span class="line"><span class="function"><span class="params">        InputChannel outInputChannel)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">synchronized</span>(mWindowMap) &#123;</span><br><span class="line">        ......</span><br><span class="line">        WindowState win = <span class="keyword">new</span> WindowState(<span class="keyword">this</span>, session, client, token,</span><br><span class="line">                attachedWindow, appOp[<span class="number">0</span>], seq, attrs, viewVisibility, displayContent);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> WindowManagerGlobal.ADD_APP_EXITING;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (addToken) &#123;</span><br><span class="line">            mTokenMap.put(attrs.token, token);</span><br><span class="line">        &#125;</span><br><span class="line">        win.attach();</span><br><span class="line">        mWindowMap.put(client.asBinder(), win);</span><br><span class="line">        ......</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造一个WindowState对象，并将添加的窗口信息记录到mTokenMap和mWindowMap哈希表中。 在WMS服务端创建了所需对象后，接着调用了WindowState的attach()来进一步完成窗口添加。 [WindowState.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (WindowManagerService.localLOGV) Slog.v(TAG, <span class="string">"Attaching "</span> + <span class="keyword">this</span> + <span class="string">" token="</span> + mToken</span><br><span class="line">        + <span class="string">", list="</span> + mToken.windows);</span><br><span class="line">    mSession.windowAddedLocked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[Session.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">windowAddedLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mSurfaceSession == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (WindowManagerService.localLOGV) Slog.v(</span><br><span class="line">            TAG_WM, <span class="string">"First window added to "</span> + <span class="keyword">this</span> + <span class="string">", creating SurfaceSession"</span>);</span><br><span class="line">        mSurfaceSession = <span class="keyword">new</span> SurfaceSession();</span><br><span class="line">        <span class="keyword">if</span> (SHOW_TRANSACTIONS) Slog.i(TAG_WM, <span class="string">"  NEW SURFACE SESSION "</span> + mSurfaceSession);</span><br><span class="line">        mService.mSessions.add(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (mLastReportedAnimatorScale != mService.getCurrentAnimatorScale()) &#123;</span><br><span class="line">            mService.dispatchNewAnimatorScaleLocked(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mNumWindow++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-2-8、SurfaceSession建立过程"><a href="#4-2-2-8、SurfaceSession建立过程" class="headerlink" title="4.2.2.8、SurfaceSession建立过程"></a>4.2.2.8、SurfaceSession建立过程</h3><p>SurfaceSession对象承担了应用程序与SurfaceFlinger之间的通信过程，每一个需要与SurfaceFlinger进程交互的应用程序端都需要创建一个SurfaceSession对象。</p><p>客户端请求 [SurfaceSession.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SurfaceSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mNativeClient = nativeCreate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java层的SurfaceSession对象构造过程会通过JNI在native层创建一个SurfaceComposerClient对象。 [android_view_SurfaceSession.cpp]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeCreate</span><span class="params">(JNIEnv* env, jclass clazz)</span> </span>&#123;</span><br><span class="line">SurfaceComposerClient* client = <span class="keyword">new</span> SurfaceComposerClient();</span><br><span class="line">client-&gt;incStrong((<span class="keyword">void</span>*)nativeCreate);</span><br><span class="line"><span class="keyword">return</span> reinterpret_cast&lt;jlong&gt;(client);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java层的SurfaceSession对象与C++层的SurfaceComposerClient对象之间是一对一关系。 是否似曾相识，就是前面最开始SurfaceFlinger_Test程序第一步：new SurfaceComposerClient的过程。 [SurfaceComposerClient.cpp]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SurfaceComposerClient::SurfaceComposerClient()</span><br><span class="line">: mStatus(NO_INIT), mComposer(Composer::getInstance())&#123;&#125;</span><br><span class="line"><span class="keyword">void</span> SurfaceComposerClient::onFirstRef() &#123;</span><br><span class="line"><span class="comment">//得到SurfaceFlinger的代理对象BpSurfaceComposer  </span></span><br><span class="line"><span class="function">sp&lt;ISurfaceComposer&gt; <span class="title">sm</span><span class="params">(ComposerService::getComposerService()</span>)</span>;</span><br><span class="line"><span class="keyword">if</span> (sm != <span class="number">0</span>) &#123;</span><br><span class="line">    sp&lt;ISurfaceComposerClient&gt; conn = sm-&gt;createConnection();</span><br><span class="line">    <span class="keyword">if</span> (conn != <span class="number">0</span>) &#123;</span><br><span class="line">        mClient = conn;</span><br><span class="line">        mStatus = NO_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SurfaceComposerClient继承于RefBase类，当第一次被强引用时，onFirstRef函数被回调，在该函数中SurfaceComposerClient会请求SurfaceFlinger为当前应用程序创建一个Client对象，专门接收该应用程序的请求，在SurfaceFlinger端创建好Client本地Binder对象后，将该Binder代理对象返回给应用程序端，并保存在SurfaceComposerClient的成员变量mClient中。</p><p>服务端处理 在SurfaceFlinger服务端为应用程序创建交互的Client对象 [SurfaceFlinger.cpp]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;ISurfaceComposerClient&gt; SurfaceFlinger::createConnection()</span><br><span class="line">&#123;</span><br><span class="line">sp&lt;ISurfaceComposerClient&gt; bclient;</span><br><span class="line"><span class="function">sp&lt;Client&gt; <span class="title">client</span><span class="params">(new Client(<span class="keyword">this</span>)</span>)</span>;</span><br><span class="line">status_t err = client-&gt;initCheck();</span><br><span class="line"><span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">    bclient = client;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bclient;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-3、App（C-层）请求创建SurfaceFlinger客户端-client-的过程"><a href="#4-2-3、App（C-层）请求创建SurfaceFlinger客户端-client-的过程" class="headerlink" title="4.2.3、App（C++层）请求创建SurfaceFlinger客户端(client)的过程"></a>4.2.3、App（C++层）请求创建SurfaceFlinger客户端(client)的过程</h3><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.graphics/11-Android-Graphics-App-Ask-SurfaceFlinger-Create-Client.png.png" alt="Markdown"></p><p>继续详细分析AppApp（C++层）请求创建SurfaceFlinger客户端(client)的过程</p><p>SurfaceComposerClient第一次强引用时，会执行onFirstRef() [SurfaceComposerClient.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SurfaceComposerClient::SurfaceComposerClient()</span><br><span class="line">: mStatus(NO_INIT), mComposer(Composer::getInstance())&#123;&#125;</span><br><span class="line"><span class="keyword">void</span> SurfaceComposerClient::onFirstRef() &#123;</span><br><span class="line"><span class="comment">//得到SurfaceFlinger的代理对象BpSurfaceComposer  </span></span><br><span class="line">sp&lt;ISurfaceComposer&gt; sm(ComposerService::getComposerService());</span><br><span class="line"><span class="keyword">if</span> (sm != <span class="number">0</span>) &#123;</span><br><span class="line">    sp&lt;ISurfaceComposerClient&gt; conn = sm-&gt;createConnection();</span><br><span class="line">    <span class="keyword">if</span> (conn != <span class="number">0</span>) &#123;</span><br><span class="line">        mClient = conn;</span><br><span class="line">        mStatus = NO_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一步：获取”SurfaceFlinger”服务 ComposerService::getComposerService()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*static*/</span> sp&lt;ISurfaceComposer&gt; ComposerService::getComposerService() &#123;</span><br><span class="line">    ComposerService&amp; instance = ComposerService::getInstance();</span><br><span class="line">    Mutex::Autolock _l(instance.mLock);</span><br><span class="line">    <span class="keyword">if</span> (instance.mComposerService == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ComposerService::getInstance().connectLocked();</span><br><span class="line">        assert(instance.mComposerService != <span class="literal">NULL</span>);</span><br><span class="line">        ALOGD(<span class="string">"ComposerService reconnected"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance.mComposerService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ComposerService::getInstance()会调用connectLocked()获取”SurfaceFlinger”服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ComposerService::ComposerService()</span><br><span class="line">: Singleton&lt;ComposerService&gt;() &#123;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    connectLocked();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ComposerService::connectLocked() &#123;</span><br><span class="line">    const String16 name(&quot;SurfaceFlinger&quot;);</span><br><span class="line">    while (getService(name, &amp;mComposerService) != NO_ERROR) &#123;</span><br><span class="line">        usleep(250000);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以前面instance.mComposerService其实返回的是”SurfaceFlinger”服务。 第二步：createConnection() 接下来就会调用”SurfaceFlinger”服务的createConnection()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;ISurfaceComposerClient&gt; SurfaceFlinger::createConnection()</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;ISurfaceComposerClient&gt; bclient;</span><br><span class="line">    sp&lt;Client&gt; client(<span class="keyword">new</span> Client(<span class="keyword">this</span>));</span><br><span class="line">    <span class="keyword">status_t</span> err = client-&gt;initCheck();</span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        bclient = client;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bclient;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-4、APP申请创建Surface过程"><a href="#4-2-4、APP申请创建Surface过程" class="headerlink" title="4.2.4、APP申请创建Surface过程"></a>4.2.4、APP申请创建Surface过程</h3><p>前面讲ViewRootImpl.setView时，requestLayout()需要Vsync trigger，加入现在Vsync信号来到，于是会继续执行。App申请创建Surface的过程就在其中。</p><p>当Vsync事件到来时，就会通过Choreographer的postCallback()，接着执行mTraversalRunnable对象的run()方法。 mTraversalRunnable对象的类型为TraversalRunnable，该类实现了Runnable接口，在其run()函数中调用了doTraversal()函数来完成窗口布局。 [-&gt;ViewRootImpl.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TraversalRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        doTraversal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> TraversalRunnable mTraversalRunnable = <span class="keyword">new</span> TraversalRunnable();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">false</span>;</span><br><span class="line">        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line">        ......</span><br><span class="line">        performTraversals();</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>performTraversals函数相当复杂，其主要实现以下几个重要步骤：</p><p>1.执行窗口测量；</p><p>2.执行窗口注册；</p><p>3.执行窗口布局；</p><p>4.执行窗口绘图；</p><p>[-&gt;ViewRootImpl.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/****************执行窗口测量******************/</span>  </span><br><span class="line">    <span class="keyword">if</span> (layoutRequested) &#123;</span><br><span class="line">        windowSizeMayChange |= measureHierarchy(host, lp, res,</span><br><span class="line">                desiredWindowWidth, desiredWindowHeight);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/****************向WMS服务添加窗口******************/</span>  </span><br><span class="line">    <span class="keyword">if</span> (mFirst || windowShouldResize || insetsChanged ||</span><br><span class="line">            viewVisibilityChanged || params != <span class="keyword">null</span> || mForceNextWindowRelayout) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ......</span><br><span class="line">            relayoutResult = relayoutWindow(params, viewVisibility, insetsPending);</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/****************执行窗口布局******************/</span></span><br><span class="line">    <span class="keyword">if</span> (didLayout) &#123;</span><br><span class="line">        performLayout(lp, mWidth, mHeight);</span><br><span class="line">        ......</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/****************执行窗口绘制******************/</span>  </span><br><span class="line">    <span class="keyword">if</span> (!cancelDraw &amp;&amp; !newSurface) &#123;</span><br><span class="line">        ......</span><br><span class="line">        performDraw();</span><br><span class="line">    &#125; ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、执行窗口测量performMeasure() [-&gt;ViewRootImpl.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performMeasure</span><span class="params">(<span class="keyword">int</span> childWidthMeasureSpec, <span class="keyword">int</span> childHeightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"measure"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">    &#125; ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-4-1、APP申请创建Surface过程-Java层"><a href="#4-2-4-1、APP申请创建Surface过程-Java层" class="headerlink" title="4.2.4.1、APP申请创建Surface过程(Java层)"></a>4.2.4.1、APP申请创建Surface过程(Java层)</h4><p>2、执行窗口注册relayoutWindow； [-&gt;ViewRootImpl.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">relayoutWindow</span><span class="params">(WindowManager.LayoutParams params, <span class="keyword">int</span> viewVisibility,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> insetsPending)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">int</span> relayoutResult = mWindowSession.relayout(</span><br><span class="line">            mWindow, mSeq, params,</span><br><span class="line">            (<span class="keyword">int</span>) (mView.getMeasuredWidth() * appScale + <span class="number">0.5f</span>),</span><br><span class="line">            (<span class="keyword">int</span>) (mView.getMeasuredHeight() * appScale + <span class="number">0.5f</span>),</span><br><span class="line">            viewVisibility, insetsPending ? WindowManagerGlobal.RELAYOUT_INSETS_PENDING : <span class="number">0</span>,</span><br><span class="line">            mWinFrame, mPendingOverscanInsets, mPendingContentInsets, mPendingVisibleInsets,</span><br><span class="line">            mPendingStableInsets, mPendingOutsets, mPendingBackDropFrame, mPendingConfiguration,</span><br><span class="line">            mSurface);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> relayoutResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里通过前面获取的IWindowSession代理对象请求WMS服务执行窗口布局，mSurface是ViewRootImpl的成员变量 [-&gt;ViewRootImpl.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Surface mSurface = <span class="keyword">new</span> Surface();</span><br></pre></td></tr></table></figure><p>[-&gt;Surface.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create an empty surface, which will later be filled in by readFromParcel().</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Surface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该Surface构造函数仅仅创建了一个空Surface对象，并没有对该Surface进程native层的初始化，到此我们知道应用程序进程为每个窗口对象都创建了一个Surface对象。并且将该Surface通过跨进程方式传输给WMS服务进程，我们知道，在Android系统中，如果一个对象需要在不同进程间传输，必须实现Parcelable接口，Surface类正好实现了Parcelable接口。ViewRootImpl通过IWindowSession接口请求WMS的完整过程如下： [-&gt;IWindowSession.java$ Proxy]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* This file is auto-generated.  DO NOT MODIFY</span></span><br><span class="line"><span class="comment">*  * Original file: frameworks/base/core/java/android/view/IWindowSession.aidl</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">relayout</span><span class="params">(android.view.IWindow window, <span class="keyword">int</span> seq, android.view.WindowManager.LayoutParams attrs, <span class="keyword">int</span> requestedWidth, <span class="keyword">int</span> requestedHeight, <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> flags, android.graphics.Rect outFrame, android.graphics.Rect outOverscanInsets, android.graphics.Rect outContentInsets, android.graphics.Rect outVisibleInsets, android.graphics.Rect outStableInsets, android.graphics.Rect outOutsets, android.graphics.Rect outBackdropFrame, android.content.res.Configuration outConfig, android.view.Surface outSurface)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line"><span class="keyword">int</span> _result;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    mRemote.transact(Stub.TRANSACTION_relayout, _data, _reply, <span class="number">0</span>);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> ((<span class="number">0</span> != _reply.readInt())) &#123;</span><br><span class="line">        outSurface.readFromParcel(_reply);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> _result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从该函数的实现可以看出，应用程序进程中创建的Surface对象并没有传递到WMS服务进程，只是读取WMS服务进程返回来的Surface。那么WMS服务进程是如何响应应用程序进程布局请求的呢？</p><p>[-&gt;IWindowSession.java$ Stub]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (code)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> TRANSACTION_relayout:</span><br><span class="line">  &#123;</span><br><span class="line">    ......</span><br><span class="line">    android.view.Surface _arg15;</span><br><span class="line">    _arg15 = <span class="keyword">new</span> android.view.Surface();</span><br><span class="line">    <span class="keyword">int</span> _result = <span class="keyword">this</span>.relayout(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10, _arg11, _arg12, _arg13, _arg14, _arg15);</span><br><span class="line">    reply.writeNoException();</span><br><span class="line">    reply.writeInt(_result);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> ((_arg15!=<span class="keyword">null</span>)) &#123;</span><br><span class="line">    reply.writeInt(<span class="number">1</span>);</span><br><span class="line">    _arg15.writeToParcel(reply, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数可以看出，WMS服务在响应应用程序进程请求添加窗口时，首先在当前进程空间创建一个Surface对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">android.view.Surface _arg15;</span><br><span class="line">_arg15 = <span class="keyword">new</span> android.view.Surface();</span><br></pre></td></tr></table></figure><p>然后调用Session的relayout()函数进一步完成窗口添加过程，最后将WMS服务中创建的Surface返回给应用程序进程。</p><p>到目前为止，在应用程序进程和WMS服务进程分别创建了一个Surface对象，但是他们调用的都是Surface的无参构造函数，在该构造函数中并未真正初始化native层的Surface，那native层的Surface是在那里创建的呢？ [-&gt;Session.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">relayout</span><span class="params">(IWindow window, <span class="keyword">int</span> seq, WindowManager.LayoutParams attrs,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> requestedWidth, <span class="keyword">int</span> requestedHeight, <span class="keyword">int</span> viewFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> flags, Rect outFrame, Rect outOverscanInsets, Rect outContentInsets,</span></span></span><br><span class="line"><span class="function"><span class="params">        Rect outVisibleInsets, Rect outStableInsets, Rect outsets, Rect outBackdropFrame,</span></span></span><br><span class="line"><span class="function"><span class="params">        Configuration outConfig, Surface outSurface)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = mService.relayoutWindow(<span class="keyword">this</span>, window, seq, attrs,</span><br><span class="line">            requestedWidth, requestedHeight, viewFlags, flags,</span><br><span class="line">            outFrame, outOverscanInsets, outContentInsets, outVisibleInsets,</span><br><span class="line">            outStableInsets, outsets, outBackdropFrame, outConfig, outSurface);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[-&gt;WindowManagerService.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">relayoutWindow</span><span class="params">(Session session, IWindow client, <span class="keyword">int</span> seq,</span></span></span><br><span class="line"><span class="function"><span class="params">        WindowManager.LayoutParams attrs, <span class="keyword">int</span> requestedWidth,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> requestedHeight, <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">        Rect outFrame, Rect outOverscanInsets, Rect outContentInsets,</span></span></span><br><span class="line"><span class="function"><span class="params">        Rect outVisibleInsets, Rect outStableInsets, Rect outOutsets, Rect outBackdropFrame,</span></span></span><br><span class="line"><span class="function"><span class="params">        Configuration outConfig, Surface outSurface)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    ......</span><br><span class="line">        <span class="keyword">if</span> (viewVisibility == View.VISIBLE &amp;&amp;</span><br><span class="line">                (win.mAppToken == <span class="keyword">null</span> || !win.mAppToken.clientHidden)) &#123;</span><br><span class="line">            result = relayoutVisibleWindow(outConfig, result, win, winAnimator, attrChanges,</span><br><span class="line">                    oldVisibility);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                result = createSurfaceControl(outSurface, result, win, winAnimator);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               ......</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[-&gt;WindowManagerService.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">createSurfaceControl</span><span class="params">(Surface outSurface, <span class="keyword">int</span> result, WindowState win,</span></span></span><br><span class="line"><span class="function"><span class="params">        WindowStateAnimator winAnimator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!win.mHasSurface) &#123;</span><br><span class="line">        result |= RELAYOUT_RES_SURFACE_CHANGED;</span><br><span class="line">    &#125;</span><br><span class="line">    WindowSurfaceController surfaceController = winAnimator.createSurfaceLocked();</span><br><span class="line">    <span class="keyword">if</span> (surfaceController != <span class="keyword">null</span>) &#123;</span><br><span class="line">        surfaceController.getSurface(outSurface);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        outSurface.release();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[-&gt;WindowSurfaceController.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getSurface</span><span class="params">(Surface outSurface)</span> </span>&#123;</span><br><span class="line">    outSurface.copyFrom(mSurfaceControl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[-&gt;WindowStateAnimator.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function">WindowSurfaceController <span class="title">createSurfaceLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">        mSurfaceController = <span class="keyword">new</span> WindowSurfaceController(mSession.mSurfaceSession,</span><br><span class="line">                attrs.getTitle().toString(),</span><br><span class="line">                width, height, format, flags, <span class="keyword">this</span>);</span><br><span class="line">        w.setHasSurface(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> mSurfaceController;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[-&gt;WindowSurfaceController.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WindowSurfaceController</span><span class="params">(SurfaceSession s,</span></span></span><br><span class="line"><span class="function"><span class="params">        String name, <span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> format, <span class="keyword">int</span> flags, WindowStateAnimator animator)</span> </span>&#123;</span><br><span class="line">    mAnimator = animator;</span><br><span class="line">    mSurfaceW = w;</span><br><span class="line">    mSurfaceH = h;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (animator.mWin.isChildWindow() &amp;&amp;</span><br><span class="line">            animator.mWin.mSubLayer &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            animator.mWin.mAppToken != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mSurfaceControl = <span class="keyword">new</span> SurfaceControl(</span><br><span class="line">                s, name, w, h, format, flags);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-4-1、APP申请创建Surface过程-C-层"><a href="#4-2-4-1、APP申请创建Surface过程-C-层" class="headerlink" title="4.2.4.1、APP申请创建Surface过程(C++层)"></a>4.2.4.1、APP申请创建Surface过程(C++层)</h4><p>SurfaceControl创建过程 [-&gt;SurfaceControl.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SurfaceControl</span><span class="params">(SurfaceSession session,</span></span></span><br><span class="line"><span class="function"><span class="params">        String name, <span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> format, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> OutOfResourcesException </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    mNativeObject = nativeCreate(session, name, w, h, format, flags);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[-&gt;android_view_SurfaceControl.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeCreate</span><span class="params">(JNIEnv* env, jclass clazz, jobject sessionObj,</span></span></span><br><span class="line"><span class="function"><span class="params">    jstring nameStr, jint w, jint h, jint format, jint flags)</span> </span>&#123;</span><br><span class="line"><span class="function">ScopedUtfChars <span class="title">name</span><span class="params">(env, nameStr)</span></span>;</span><br><span class="line">sp&lt;SurfaceComposerClient&gt; client(android_view_SurfaceSession_getClient(env, sessionObj));</span><br><span class="line">sp&lt;SurfaceControl&gt; surface = client-&gt;createSurface(</span><br><span class="line">        String8(name.c_str()), w, h, format, flags);</span><br><span class="line"><span class="keyword">if</span> (surface == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    jniThrowException(env, OutOfResourcesException, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">surface-&gt;incStrong((<span class="keyword">void</span> *)nativeCreate);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(surface.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数首先得到前面创建好的SurfaceComposerClient对象，通过该对象向SurfaceFlinger端的Client对象发送创建Surface的请求，最后得到一个SurfaceControl对象。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.graphics/12-Android-Graphics-App-Ask-SurfaceFlinger-CreateSurface.png" alt="Markdown"></p><p>[-&gt;SurfaceComposerClient.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;SurfaceControl&gt; SurfaceComposerClient::createSurface(</span><br><span class="line">    <span class="keyword">const</span> String8&amp; name,</span><br><span class="line">    <span class="keyword">uint32_t</span> w,</span><br><span class="line">    <span class="keyword">uint32_t</span> h,</span><br><span class="line">    PixelFormat format,</span><br><span class="line">    <span class="keyword">uint32_t</span> flags)</span><br><span class="line">    &#123;</span><br><span class="line">sp&lt;SurfaceControl&gt; sur;</span><br><span class="line"><span class="keyword">if</span> (mStatus == NO_ERROR) &#123;</span><br><span class="line">    sp&lt;IBinder&gt; handle;</span><br><span class="line">    sp&lt;IGraphicBufferProducer&gt; gbp;</span><br><span class="line">    <span class="keyword">status_t</span> err = mClient-&gt;createSurface(name, w, h, format, flags,</span><br><span class="line">            &amp;handle, &amp;gbp);</span><br><span class="line">    ALOGE_IF(err, <span class="string">"SurfaceComposerClient::createSurface error %s"</span>, strerror(-err));</span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        sur = <span class="keyword">new</span> SurfaceControl(<span class="keyword">this</span>, handle, gbp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SurfaceComposerClient将Surface创建请求转交给保存在其成员变量中的Bp SurfaceComposerClient对象来完成，在SurfaceFlinger端的Client本地对象会返回一个ISurface代理对象给应用程序，通过该代理对象为应用程序当前创建的Surface创建一个SurfaceControl对象。 [ISurfaceComposerClient.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">createSurface</span><span class="params">(<span class="keyword">const</span> String8&amp; name, <span class="keyword">uint32_t</span> width,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">uint32_t</span> height, PixelFormat format, <span class="keyword">uint32_t</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">        sp&lt;IBinder&gt;* handle,</span></span></span><br><span class="line"><span class="function"><span class="params">        sp&lt;IGraphicBufferProducer&gt;* gbp)</span> </span>&#123;</span><br><span class="line">    Parcel data, reply;</span><br><span class="line">    ......</span><br><span class="line">    remote()-&gt;transact(CREATE_SURFACE, data, &amp;reply);</span><br><span class="line">    *handle = reply.readStrongBinder();</span><br><span class="line">    *gbp = interface_cast&lt;IGraphicBufferProducer&gt;(reply.readStrongBinder());</span><br><span class="line">    <span class="keyword">return</span> reply.readInt32();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[Client.cpp] MessageCreateSurface消息是专门为应用程序请求创建Surface而定义的一种消息类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">status_t</span> Client::createSurface(</span><br><span class="line">        <span class="keyword">const</span> String8&amp; name,</span><br><span class="line">        <span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h, PixelFormat format, <span class="keyword">uint32_t</span> flags,</span><br><span class="line">        sp&lt;IBinder&gt;* handle,</span><br><span class="line">        sp&lt;IGraphicBufferProducer&gt;* gbp)&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * createSurface must be called from the GL thread so that it can</span></span><br><span class="line"><span class="comment">     * have access to the GL context.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MessageCreateLayer</span> :</span> <span class="keyword">public</span> MessageBase &#123;</span><br><span class="line">        SurfaceFlinger* flinger;</span><br><span class="line">        Client* client;</span><br><span class="line">        sp&lt;IBinder&gt;* handle;</span><br><span class="line">        sp&lt;IGraphicBufferProducer&gt;* gbp;</span><br><span class="line">        <span class="keyword">status_t</span> result;</span><br><span class="line">        <span class="keyword">const</span> String8&amp; name;</span><br><span class="line">        <span class="keyword">uint32_t</span> w, h;</span><br><span class="line">        PixelFormat format;</span><br><span class="line">        <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        MessageCreateLayer(SurfaceFlinger* flinger,</span><br><span class="line">                <span class="keyword">const</span> String8&amp; name, Client* client,</span><br><span class="line">                <span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h, PixelFormat format, <span class="keyword">uint32_t</span> flags,</span><br><span class="line">                sp&lt;IBinder&gt;* handle,</span><br><span class="line">                sp&lt;IGraphicBufferProducer&gt;* gbp)</span><br><span class="line">            : flinger(flinger), client(client),</span><br><span class="line">              handle(handle), gbp(gbp), result(NO_ERROR),</span><br><span class="line">              name(name), w(w), h(h), format(format), flags(flags) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">status_t</span> getResult() <span class="keyword">const</span> &#123; <span class="keyword">return</span> result; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            result = flinger-&gt;createLayer(name, client, w, h, format, flags,</span><br><span class="line">                    handle, gbp);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    sp&lt;MessageBase&gt; msg = <span class="keyword">new</span> MessageCreateLayer(mFlinger.get(),</span><br><span class="line">            name, <span class="keyword">this</span>, w, h, format, flags, handle, gbp);</span><br><span class="line">    mFlinger-&gt;postMessageSync(msg);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;MessageCreateLayer*&gt;( msg.get() )-&gt;getResult();</span><br><span class="line">    &#125;</span><br><span class="line">Client将应用程序创建Surface的请求转换为异步消息投递到SurfaceFlinger的消息队列中，将创建Surface的任务转交给SurfaceFlinger。</span><br><span class="line">[-&gt;SurfaceFlinger.cpp]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> SurfaceFlinger::createLayer(</span><br><span class="line">        <span class="keyword">const</span> String8&amp; name,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Client&gt;&amp; client,</span><br><span class="line">        <span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h, PixelFormat format, <span class="keyword">uint32_t</span> flags,</span><br><span class="line">        sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp)&#123;</span><br><span class="line">    <span class="comment">//ALOGD("createLayer for (%d x %d), name=%s", w, h, name.string());</span></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> result = NO_ERROR;</span><br><span class="line"></span><br><span class="line">    sp&lt;Layer&gt; layer;</span><br><span class="line">    <span class="comment">////根据flags创建不同类型的layer</span></span><br><span class="line">    <span class="keyword">switch</span> (flags &amp; ISurfaceComposerClient::eFXSurfaceMask) &#123;</span><br><span class="line">        <span class="keyword">case</span> ISurfaceComposerClient::eFXSurfaceNormal:</span><br><span class="line">            result = createNormalLayer(client,</span><br><span class="line">                    name, w, h, flags, format,</span><br><span class="line">                    handle, gbp, &amp;layer);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ISurfaceComposerClient::eFXSurfaceDim:</span><br><span class="line">            result = createDimLayer(client,</span><br><span class="line">                    name, w, h, flags,</span><br><span class="line">                    handle, gbp, &amp;layer);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            result = BAD_VALUE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将创建好的Layer对象保存在Client中  </span></span><br><span class="line">    result = addClientLayer(client, *handle, *gbp, layer);</span><br><span class="line">    <span class="keyword">if</span> (result != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setTransactionFlags(eTransactionNeeded);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>SurfaceFlinger根据标志位创建对应类型的Surface，当前系统定义了3种类型的Layer: [-&gt;ISurfaceComposerClient.h]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eFXSurfaceNormal    = <span class="number">0x00000000</span>,</span><br><span class="line">eFXSurfaceDim       = <span class="number">0x00020000</span>,</span><br><span class="line">eFXSurfaceMask      = <span class="number">0x000F0000</span></span><br></pre></td></tr></table></figure><p>[-&gt;SurfaceFlinger.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> SurfaceFlinger::createNormalLayer(<span class="keyword">const</span> sp&lt;Client&gt;&amp; client,</span><br><span class="line">    <span class="keyword">const</span> String8&amp; name, <span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h, <span class="keyword">uint32_t</span> flags, PixelFormat&amp; format,</span><br><span class="line">    sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp, sp&lt;Layer&gt;* outLayer)&#123;</span><br><span class="line"><span class="comment">// initialize the surfaces</span></span><br><span class="line"><span class="keyword">switch</span> (format) &#123;</span><br><span class="line"><span class="keyword">case</span> PIXEL_FORMAT_TRANSPARENT:</span><br><span class="line"><span class="keyword">case</span> PIXEL_FORMAT_TRANSLUCENT:</span><br><span class="line">    format = PIXEL_FORMAT_RGBA_8888;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> PIXEL_FORMAT_OPAQUE:</span><br><span class="line">    format = PIXEL_FORMAT_RGBX_8888;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在SurfaceFlinger端为应用程序的Surface创建对应的Layer对象  </span></span><br><span class="line">*outLayer = <span class="keyword">new</span> Layer(<span class="keyword">this</span>, client, name, w, h, flags);</span><br><span class="line"><span class="keyword">status_t</span> err = (*outLayer)-&gt;setBuffers(w, h, format, flags);</span><br><span class="line"><span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">    *handle = (*outLayer)-&gt;getHandle();</span><br><span class="line">    *gbp = (*outLayer)-&gt;getProducer();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ALOGE_IF(err, <span class="string">"createNormalLayer() failed (%s)"</span>, strerror(-err));</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在SurfaceFlinger服务端为应用程序创建的Surface创建对应的Layer对象。应用程序请求创建Surface过程如下：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.graphics/13-Android-Graphics-App-Ask-SurfaceFlinger-Create-Layer.png.png.png" alt="Markdown"><br>第一次强引用Layer对象时，onFirstRef()函数被回调 [Layer.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Layer::onFirstRef() &#123;</span><br><span class="line"><span class="comment">// Creates a custom BufferQueue for SurfaceFlingerConsumer to use</span></span><br><span class="line">sp&lt;IGraphicBufferProducer&gt; producer;</span><br><span class="line">sp&lt;IGraphicBufferConsumer&gt; consumer;</span><br><span class="line"><span class="comment">//创建BufferQueue对象</span></span><br><span class="line">BufferQueue::createBufferQueue(&amp;producer, &amp;consumer);</span><br><span class="line">mProducer = <span class="keyword">new</span> MonitoredProducer(producer, mFlinger);</span><br><span class="line">mSurfaceFlingerConsumer = <span class="keyword">new</span> SurfaceFlingerConsumer(consumer, mTextureName,</span><br><span class="line">        <span class="keyword">this</span>);</span><br><span class="line">mSurfaceFlingerConsumer-&gt;setConsumerUsageBits(getEffectiveUsage(<span class="number">0</span>));</span><br><span class="line">mSurfaceFlingerConsumer-&gt;setContentsChangedListener(<span class="keyword">this</span>);</span><br><span class="line">mSurfaceFlingerConsumer-&gt;setName(mName);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TARGET_DISABLE_TRIPLE_BUFFERING</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">warning</span> <span class="meta-string">"disabling triple buffering"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">mProducer-&gt;setMaxDequeuedBufferCount(<span class="number">2</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sp&lt;<span class="keyword">const</span> DisplayDevice&gt; hw(mFlinger-&gt;getDefaultDisplayDevice());</span><br><span class="line">updateTransformHint(hw);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据buffer可用监听器的注册过程，我们知道，当生产者也就是应用程序填充好图形buffer数据后，通过回调方式通知消费者的</p><h4 id="4-2-4-2、BufferQueue构造过程"><a href="#4-2-4-2、BufferQueue构造过程" class="headerlink" title="4.2.4.2、BufferQueue构造过程"></a>4.2.4.2、BufferQueue构造过程</h4><p>[-&gt;BufferQueue.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> BufferQueue::createBufferQueue(sp&lt;IGraphicBufferProducer&gt;* outProducer,</span><br><span class="line">    sp&lt;IGraphicBufferConsumer&gt;* outConsumer,</span><br><span class="line">    <span class="keyword">const</span> sp&lt;IGraphicBufferAlloc&gt;&amp; allocator) &#123;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">sp&lt;BufferQueueCore&gt; core(<span class="keyword">new</span> BufferQueueCore(allocator));</span><br><span class="line">sp&lt;IGraphicBufferProducer&gt; producer(<span class="keyword">new</span> BufferQueueProducer(core));</span><br><span class="line">sp&lt;IGraphicBufferConsumer&gt; consumer(<span class="keyword">new</span> BufferQueueConsumer(core));</span><br><span class="line">*outProducer = producer;</span><br><span class="line">*outConsumer = consumer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[-&gt;BufferQueueCore.cpp] 所以核心都是这个BufferQueueCore，他是管理图形缓冲区的中枢。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">BufferQueueCore::BufferQueueCore(<span class="keyword">const</span> sp&lt;IGraphicBufferAlloc&gt;&amp; allocator) :</span><br><span class="line">mAllocator(allocator),</span><br><span class="line">......</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (allocator == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    sp&lt;ISurfaceComposer&gt; composer(ComposerService::getComposerService());</span><br><span class="line">    mAllocator = composer-&gt;createGraphicBufferAlloc();</span><br><span class="line">    <span class="keyword">if</span> (mAllocator == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        BQ_LOGE(<span class="string">"createGraphicBufferAlloc failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> numStartingBuffers = getMaxBufferCountLocked();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; numStartingBuffers; s++) &#123;</span><br><span class="line">    mFreeSlots.insert(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = numStartingBuffers; s &lt; BufferQueueDefs::NUM_BUFFER_SLOTS;</span><br><span class="line">        s++) &#123;</span><br><span class="line">    mUnusedSlots.push_front(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BufferQueueCore类中定义了一个64项的数据mSlots，是一个容量大小为64的数组，因此BufferQueueCore可以管理最多64块的GraphicBuffer。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.graphics/14-Android-Graphics-App-SurfaceFlinger-BufferSlot.png.png" alt="Markdown"></p><p>[-&gt;ISurfaceComposer.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">virtual</span> sp&lt;IGraphicBufferAlloc&gt; createGraphicBufferAlloc()</span><br><span class="line">&#123;</span><br><span class="line">    Parcel data, reply;</span><br><span class="line">    data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());</span><br><span class="line">    remote()-&gt;transact(BnSurfaceComposer::CREATE_GRAPHIC_BUFFER_ALLOC, data, &amp;reply);</span><br><span class="line">    <span class="keyword">return</span> interface_cast&lt;IGraphicBufferAlloc&gt;(reply.readStrongBinder());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[-&gt;SurfaceFlinger.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IGraphicBufferAlloc&gt; SurfaceFlinger::createGraphicBufferAlloc()</span><br><span class="line">&#123;</span><br><span class="line">sp&lt;GraphicBufferAlloc&gt; gba(<span class="keyword">new</span> GraphicBufferAlloc());</span><br><span class="line"><span class="keyword">return</span> gba;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>GraphicBufferAlloc构造过程</strong></p><p>[-&gt;GraphicBufferAlloc.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;GraphicBuffer&gt; GraphicBufferAlloc::createGraphicBuffer(<span class="keyword">uint32_t</span> width,</span><br><span class="line">    <span class="keyword">uint32_t</span> height, PixelFormat format, <span class="keyword">uint32_t</span> usage,</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> requestorName, <span class="keyword">status_t</span>* error) &#123;</span><br><span class="line">sp&lt;GraphicBuffer&gt; graphicBuffer(<span class="keyword">new</span> GraphicBuffer(</span><br><span class="line">        width, height, format, usage, <span class="built_in">std</span>::move(requestorName)));</span><br><span class="line"><span class="keyword">status_t</span> err = graphicBuffer-&gt;initCheck();</span><br><span class="line">......</span><br><span class="line"><span class="keyword">return</span> graphicBuffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>图形缓冲区创建过程</strong> [-&gt;GraphicBuffer.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">GraphicBuffer::GraphicBuffer(<span class="keyword">uint32_t</span> inWidth, <span class="keyword">uint32_t</span> inHeight,</span><br><span class="line">    PixelFormat inFormat, <span class="keyword">uint32_t</span> inUsage, <span class="built_in">std</span>::<span class="built_in">string</span> requestorName)</span><br><span class="line">: BASE(), mOwner(ownData), mBufferMapper(GraphicBufferMapper::get()),</span><br><span class="line">  mInitCheck(NO_ERROR), mId(getUniqueId()), mGenerationNumber(<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">width  =</span><br><span class="line">height =</span><br><span class="line">stride =</span><br><span class="line">format =</span><br><span class="line">usage  = <span class="number">0</span>;</span><br><span class="line">handle = <span class="literal">NULL</span>;</span><br><span class="line">mInitCheck = initSize(inWidth, inHeight, inFormat, inUsage,</span><br><span class="line">        <span class="built_in">std</span>::move(requestorName));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>根据图形buffer的宽高、格式等信息为图形缓冲区分配存储空间。</p><p>使用GraphicBufferAllocator对象来为图形缓冲区分配内存空间，GraphicBufferAllocator是对Gralloc模块中的gpu设备的封装类。关于GraphicBufferAllocator内存分配过程请以后作分析，图形缓冲区分配完成后，还会映射到SurfaceFlinger服务进程的虚拟地址空间。</p><p><strong>Android图形缓冲区分配过程源码分析</strong></p><p>[-&gt;Layer.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Layer::Layer(SurfaceFlinger* flinger, <span class="keyword">const</span> sp&lt;Client&gt;&amp; client,</span><br><span class="line">    <span class="keyword">const</span> String8&amp; name, <span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h, <span class="keyword">uint32_t</span> flags)</span><br><span class="line">:   contentDirty(<span class="literal">false</span>),</span><br><span class="line">    sequence(<span class="keyword">uint32_t</span>(android_atomic_inc(&amp;sSequence))),</span><br><span class="line">    mFlinger(flinger),</span><br><span class="line">    mTextureName(<span class="number">-1U</span>),</span><br><span class="line">    mPremultipliedAlpha(<span class="literal">true</span>),</span><br><span class="line">    mName(<span class="string">"unnamed"</span>),</span><br><span class="line">    mFormat(PIXEL_FORMAT_NONE),</span><br><span class="line">    ......&#123;</span><br><span class="line">mCurrentCrop.makeInvalid();</span><br><span class="line">mFlinger-&gt;getRenderEngine().genTextures(<span class="number">1</span>, &amp;mTextureName);</span><br><span class="line">mTexture.init(Texture::TEXTURE_EXTERNAL, mTextureName);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此才算真正创建了一个可用于绘图的Surface (Layer)，从上面的分析我们可以看出，在WMS服务进程端，其实创建了两个Java层的Surface对象，第一个Surface使用了无参构造函数，仅仅构造一个Surface对象而已，而第二个Surface却使用了有参构造函数，参数指定了图象宽高等信息，这个Java层Surface对象还会在native层请求SurfaceFlinger创建一个真正能用于绘制图象的native层Surface。最后通过浅拷贝的方式将第二个Surface复制到第一个Surface中，最后通过writeToParcel方式写回到应用程序进程。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.graphics/15-Android-Graphics-App-WMS-SurfaceFlinger-Surface-SurfaceControl.png" alt="Markdown"></p><p>到目前为止，应用程序和WMS一共创建了3个Java层Surface（SurfaceControl）对象，如上图所示，而真正能用于绘图的Surface只有3号，那么3号Surface与2号Surface之间是什么关系呢？outSurface.copyFrom(surface)</p><p>[Surface.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyFrom</span><span class="params">(SurfaceControl other)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">long</span> surfaceControlPtr = other.mNativeObject;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">long</span> newNativeObject = nativeCreateFromSurfaceControl(surfaceControlPtr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mNativeObject != <span class="number">0</span>) &#123;</span><br><span class="line">            nativeRelease(mNativeObject);</span><br><span class="line">        &#125;</span><br><span class="line">        setNativeObjectLocked(newNativeObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[android_view_Surface.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeCreateFromSurfaceControl</span><span class="params">(JNIEnv* env, jclass clazz,</span></span></span><br><span class="line"><span class="function"><span class="params">    jlong surfaceControlNativeObj)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is used by the WindowManagerService just after constructing</span></span><br><span class="line"><span class="comment"> * a Surface and is necessary for returning the Surface reference to</span></span><br><span class="line"><span class="comment"> * the caller. At this point, we should only have a SurfaceControl.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">sp&lt;SurfaceControl&gt; ctrl(<span class="keyword">reinterpret_cast</span>&lt;SurfaceControl *&gt;(surfaceControlNativeObj));</span><br><span class="line">sp&lt;Surface&gt; surface(ctrl-&gt;getSurface());</span><br><span class="line"><span class="keyword">if</span> (surface != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    surface-&gt;incStrong(&amp;sRefBaseOwner);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(surface.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2号Surface引用到了3号Surface的SurfaceControl对象后，通过writeToParcel()函数写会到应用程序进程。 [Surface.java]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">        @Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel dest, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dest == null) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"dest must not be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> This must be kept synchronized with the native parceling code</span></span><br><span class="line">        <span class="comment">// in frameworks/native/libs/Surface.cpp</span></span><br><span class="line">        dest.writeString(mName);</span><br><span class="line">        dest.writeInt(mIsSingleBuffered ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        nativeWriteToParcel(mNativeObject, dest);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; Parcelable.PARCELABLE_WRITE_RETURN_VALUE) != <span class="number">0</span>) &#123;</span><br><span class="line">        release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[android_view_Surface.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeWriteToParcel</span><span class="params">(JNIEnv* env, jclass clazz,</span></span></span><br><span class="line"><span class="function"><span class="params">    jlong nativeObject, jobject parcelObj)</span> </span>&#123;</span><br><span class="line">Parcel* parcel = parcelForJavaObject(env, parcelObj);</span><br><span class="line"><span class="keyword">if</span> (parcel == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    doThrowNPE(env);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">sp&lt;Surface&gt; self(<span class="keyword">reinterpret_cast</span>&lt;Surface *&gt;(nativeObject));</span><br><span class="line">android::view::Surface surfaceShim;</span><br><span class="line"><span class="keyword">if</span> (self != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    surfaceShim.graphicBufferProducer = self-&gt;getIGraphicBufferProducer();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Calling code in Surface.java has already written the name of the Surface</span></span><br><span class="line"><span class="comment">// to the Parcel</span></span><br><span class="line">surfaceShim.writeToParcel(parcel, <span class="comment">/*nameAlreadyWritten*/</span><span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用程序进程中的1号Surface按相反顺序读取WMS服务端返回过来的Binder对象等数据，并构造一个native层的Surface对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFromParcel</span><span class="params">(Parcel source)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (source == null) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"source must not be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        <span class="comment">// nativeReadFromParcel() will either return mNativeObject, or</span></span><br><span class="line">        <span class="comment">// create a new native Surface and return it after reducing</span></span><br><span class="line">        <span class="comment">// the reference count on mNativeObject.  Either way, it is</span></span><br><span class="line">        <span class="comment">// not necessary to call nativeRelease() here.</span></span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> This must be kept synchronized with the native parceling code</span></span><br><span class="line">        <span class="comment">// in frameworks/native/libs/Surface.cpp</span></span><br><span class="line">        mName = source.readString();</span><br><span class="line">        mIsSingleBuffered = source.readInt() != <span class="number">0</span>;</span><br><span class="line">        setNativeObjectLocked(nativeReadFromParcel(mNativeObject, source));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用程序进程中的1号Surface按相反顺序读取WMS服务端返回过来的Binder对象等数据，并构造一个native层的Surface对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeCreateFromSurfaceControl</span><span class="params">(JNIEnv* env, jclass clazz,</span></span></span><br><span class="line"><span class="function"><span class="params">    jlong surfaceControlNativeObj)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is used by the WindowManagerService just after constructing</span></span><br><span class="line"><span class="comment"> * a Surface and is necessary for returning the Surface reference to</span></span><br><span class="line"><span class="comment"> * the caller. At this point, we should only have a SurfaceControl.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">sp&lt;SurfaceControl&gt; ctrl(<span class="keyword">reinterpret_cast</span>&lt;SurfaceControl *&gt;(surfaceControlNativeObj));</span><br><span class="line">sp&lt;Surface&gt; surface(ctrl-&gt;getSurface());</span><br><span class="line"><span class="keyword">if</span> (surface != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    surface-&gt;incStrong(&amp;sRefBaseOwner);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(surface.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个Activity可以有一个或多个Surface，默认情况下一个Activity只有一个Surface，当Activity中使用SurfaceView时，就存在多个Surface。Activity默认surface是在relayoutWindow过程中由WMS服务创建的，然后回传给应用程序进程，我们知道一个Surface其实就是应用程序端的本地窗口，关于Surface的初始化过程这里就不在介绍。</p><h4 id="4-2-4-2、生产者Producer构造过程"><a href="#4-2-4-2、生产者Producer构造过程" class="headerlink" title="4.2.4.2、生产者Producer构造过程"></a>4.2.4.2、生产者Producer构造过程</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IGraphicBufferProducer&gt; producer(<span class="keyword">new</span> BufferQueueProducer(core));</span><br><span class="line">sp&lt;IGraphicBufferConsumer&gt; consumer(<span class="keyword">new</span> BufferQueueConsumer(core));</span><br></pre></td></tr></table></figure><p>实例化BufferQueueProducer，这里初始化了mCore(core) 和 mSlots(core-&gt;mSlots)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BufferQueueProducer::BufferQueueProducer(<span class="keyword">const</span> sp&lt;BufferQueueCore&gt;&amp; core) :</span><br><span class="line">    mCore(core),</span><br><span class="line">    mSlots(core-&gt;mSlots),</span><br><span class="line">    mConsumerName(),</span><br><span class="line">    mStickyTransform(<span class="number">0</span>),</span><br><span class="line">    mLastQueueBufferFence(Fence::NO_FENCE),</span><br><span class="line">    mCallbackMutex(),</span><br><span class="line">    mNextCallbackTicket(<span class="number">0</span>),</span><br><span class="line">    mCurrentCallbackTicket(<span class="number">0</span>),</span><br><span class="line">    mCallbackCondition(),</span><br><span class="line">    mDequeueTimeout(<span class="number">-1</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-4-3、消费者Consumer构造过程"><a href="#4-2-4-3、消费者Consumer构造过程" class="headerlink" title="4.2.4.3、消费者Consumer构造过程"></a>4.2.4.3、消费者Consumer构造过程</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IGraphicBufferProducer&gt; producer(<span class="keyword">new</span> BufferQueueProducer(core));</span><br><span class="line">sp&lt;IGraphicBufferConsumer&gt; consumer(<span class="keyword">new</span> BufferQueueConsumer(core));</span><br></pre></td></tr></table></figure><p>实例化BufferQueueConsumer，这里初始化了mCore(core) 和 mSlots(core-&gt;mSlots)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BufferQueueConsumer::BufferQueueConsumer(<span class="keyword">const</span> sp&lt;BufferQueueCore&gt;&amp; core) :</span><br><span class="line">    mCore(core),</span><br><span class="line">    mSlots(core-&gt;mSlots),</span><br><span class="line">    mConsumerName() &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-4-4、SurfaceFlinger设置监听"><a href="#4-2-4-4、SurfaceFlinger设置监听" class="headerlink" title="4.2.4.4、SurfaceFlinger设置监听"></a>4.2.4.4、SurfaceFlinger设置监听</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mSurfaceFlingerConsumer = <span class="keyword">new</span> SurfaceFlingerConsumer(consumer, mTextureName,</span><br><span class="line">        <span class="keyword">this</span>);</span><br><span class="line">mSurfaceFlingerConsumer-&gt;setConsumerUsageBits(getEffectiveUsage(<span class="number">0</span>));</span><br><span class="line">mSurfaceFlingerConsumer-&gt;setContentsChangedListener(<span class="keyword">this</span>);</span><br><span class="line">mSurfaceFlingerConsumer-&gt;setName(mName);</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.graphics/16-Android-Graphics-App-Ask-SurfaceFlinger-ConsumeLisener-onFrameAvailable.png" alt="Markdown"></p><h4 id="4-2-4-5、应用程序本地窗口Surface创建过程"><a href="#4-2-4-5、应用程序本地窗口Surface创建过程" class="headerlink" title="4.2.4.5、应用程序本地窗口Surface创建过程"></a>4.2.4.5、应用程序本地窗口Surface创建过程</h4><p>从前面分析可知，SurfaceFlinger在处理应用程序请求创建Surface中，在SurfaceFlinger服务端仅仅创建了Layer对象，那么应用程序本地窗口Surface在什么时候、什么地方创建呢？</p><p>为应用程序创建好了Layer对象并返回ISurface的代理对象给应用程序，应用程序通过该代理对象创建了一个SurfaceControl对象，Java层Surface需要通过android_view_Surface.cpp中的JNI函数来操作native层的Surface，在操作native层Surface前，首先需要获取到native的Surface，应用程序本地窗口Surface就是在这个时候创建的。 [-&gt;SurfaceControl.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;Surface&gt; SurfaceControl::getSurface() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">Mutex::Autolock _l(mLock);</span><br><span class="line"><span class="keyword">if</span> (mSurfaceData == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// This surface is always consumed by SurfaceFlinger, so the</span></span><br><span class="line">    <span class="comment">// producerControlledByApp value doesn't matter; using false.</span></span><br><span class="line">    mSurfaceData = <span class="keyword">new</span> Surface(mGraphicBufferProducer, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mSurfaceData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[Surface.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Surface::Surface(</span><br><span class="line">    <span class="keyword">const</span> sp&lt;IGraphicBufferProducer&gt;&amp; bufferProducer,</span><br><span class="line">    <span class="keyword">bool</span> controlledByApp)</span><br><span class="line">: mGraphicBufferProducer(bufferProducer),</span><br><span class="line">  mCrop(Rect::EMPTY_RECT),</span><br><span class="line">  mGenerationNumber(<span class="number">0</span>),</span><br><span class="line">  mSharedBufferMode(<span class="literal">false</span>),</span><br><span class="line">  mAutoRefresh(<span class="literal">false</span>),</span><br><span class="line">  mSharedBufferSlot(BufferItem::INVALID_BUFFER_SLOT),</span><br><span class="line">  mSharedBufferHasBeenQueued(<span class="literal">false</span>),</span><br><span class="line">  mNextFrameNumber(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line"><span class="comment">// Initialize the ANativeWindow function pointers.</span></span><br><span class="line">ANativeWindow::setSwapInterval  = hook_setSwapInterval;</span><br><span class="line">ANativeWindow::dequeueBuffer    = hook_dequeueBuffer;</span><br><span class="line">ANativeWindow::cancelBuffer     = hook_cancelBuffer;</span><br><span class="line">ANativeWindow::queueBuffer      = hook_queueBuffer;</span><br><span class="line">ANativeWindow::query            = hook_query;</span><br><span class="line">ANativeWindow::perform          = hook_perform;</span><br><span class="line"></span><br><span class="line">ANativeWindow::dequeueBuffer_DEPRECATED = hook_dequeueBuffer_DEPRECATED;</span><br><span class="line">ANativeWindow::cancelBuffer_DEPRECATED  = hook_cancelBuffer_DEPRECATED;</span><br><span class="line">ANativeWindow::lockBuffer_DEPRECATED    = hook_lockBuffer_DEPRECATED;</span><br><span class="line">ANativeWindow::queueBuffer_DEPRECATED   = hook_queueBuffer_DEPRECATED;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(ANativeWindow::minSwapInterval) = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(ANativeWindow::maxSwapInterval) = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">mReqWidth = <span class="number">0</span>;</span><br><span class="line">mReqHeight = <span class="number">0</span>;</span><br><span class="line">mReqFormat = <span class="number">0</span>;</span><br><span class="line">mReqUsage = <span class="number">0</span>;</span><br><span class="line">......</span><br><span class="line">mSwapIntervalZero = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在创建完应用程序本地窗口Surface后，想要在该Surface上绘图，首先需要为该Surface分配图形buffer。我们前面介绍了Android应用程序图形缓冲区的分配都是由SurfaceFlinger服务进程来完成，在请求创建Surface时，在服务端创建了一个BufferQueue本地Binder对象，该对象负责管理应用程序一个本地窗口Surface的图形缓冲区。</p><h4 id="4-2-4-5、执行窗口布局performLayout"><a href="#4-2-4-5、执行窗口布局performLayout" class="headerlink" title="4.2.4.5、执行窗口布局performLayout()"></a>4.2.4.5、执行窗口布局performLayout()</h4><p>[-&gt;ViewRootImpl.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performLayout</span><span class="params">(WindowManager.LayoutParams lp, <span class="keyword">int</span> desiredWindowWidth,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> desiredWindowHeight)</span> </span>&#123;</span><br><span class="line">    mLayoutRequested = <span class="keyword">false</span>;</span><br><span class="line">    mScrollMayChange = <span class="keyword">true</span>;</span><br><span class="line">    mInLayout = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">final</span> View host = mView;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        host.layout(<span class="number">0</span>, <span class="number">0</span>, host.getMeasuredWidth(), host.getMeasuredHeight());</span><br><span class="line">        mInLayout = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> numViewsRequestingLayout = mLayoutRequesters.size();</span><br><span class="line">        <span class="keyword">if</span> (numViewsRequestingLayout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ......</span><br><span class="line">                measureHierarchy(host, lp, mView.getContext().getResources(),</span><br><span class="line">                        desiredWindowWidth, desiredWindowHeight);</span><br><span class="line">                mInLayout = <span class="keyword">true</span>;</span><br><span class="line">                host.layout(<span class="number">0</span>, <span class="number">0</span>, host.getMeasuredWidth(), host.getMeasuredHeight());</span><br><span class="line">                ......</span><br><span class="line">    &#125;</span><br><span class="line">    mInLayout = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-4-7、执行窗口绘制performDraw"><a href="#4-2-4-7、执行窗口绘制performDraw" class="headerlink" title="4.2.4.7、执行窗口绘制performDraw()"></a>4.2.4.7、执行窗口绘制performDraw()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ViewRootImpl.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performDraw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            draw(fullRedrawNeeded);</span><br><span class="line">        &#125;  ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Android是怎样将View画出来的？由于之前我们已经关闭了HWC、GPU、HWUI，这里只关注软件绘制。 [-&gt;ViewRootImpl.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">boolean</span> fullRedrawNeeded)</span> </span>&#123;</span><br><span class="line">    Surface surface = mSurface;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (!dirty.isEmpty() || mIsAnimating || accessibilityFocusDirty) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mAttachInfo.mHardwareRenderer != <span class="keyword">null</span> &amp;&amp; mAttachInfo.mHardwareRenderer.isEnabled()) &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">if</span> (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于渲染这个流程很复杂，我们后续章节再分析。</p><h2 id="4-3、APP申请-lock-Buffer的过程"><a href="#4-3、APP申请-lock-Buffer的过程" class="headerlink" title="4.3、APP申请(lock)Buffer的过程"></a>4.3、APP申请(lock)Buffer的过程</h2><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.graphics/17-Android-Graphics-App-SurfaceFlinger-lock-unlockpost.png" alt="Markdown"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">drawSoftware</span><span class="params">(Surface surface, AttachInfo attachInfo, <span class="keyword">int</span> xoff, <span class="keyword">int</span> yoff,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> scalingRequired, Rect dirty)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Draw with software renderer.</span></span><br><span class="line">    <span class="keyword">final</span> Canvas canvas;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">        canvas = mSurface.lockCanvas(dirty);</span><br><span class="line">        ......</span><br><span class="line">    &#125; ......</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            canvas.translate(-xoff, -yoff);</span><br><span class="line">            <span class="keyword">if</span> (mTranslator != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mTranslator.translateCanvas(canvas);</span><br><span class="line">            &#125;</span><br><span class="line">            canvas.setScreenDensity(scalingRequired ? mNoncompatDensity : <span class="number">0</span>);</span><br><span class="line">            attachInfo.mSetIgnoreDirtyState = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            mView.draw(canvas);</span><br><span class="line"></span><br><span class="line">            drawAccessibilityFocusedDrawableIfNeeded(canvas);</span><br><span class="line">        &#125;......</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            surface.unlockCanvasAndPost(canvas);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">           ......</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看看Surface的lockCanvas方法： [-&gt;Surface.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mCanvas 变量直接赋值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Canvas mCanvas = <span class="keyword">new</span> CompatibleCanvas();</span><br><span class="line"><span class="function"><span class="keyword">public</span> Canvas <span class="title">lockCanvas</span><span class="params">(Rect inOutDirty)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Surface.OutOfResourcesException, IllegalArgumentException </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">    checkNotReleasedLocked();</span><br><span class="line">    ......</span><br><span class="line">    mLockedObject = nativeLockCanvas(mNativeObject, mCanvas, inOutDirty);</span><br><span class="line">    <span class="keyword">return</span> mCanvas;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[-&gt;android_view_Surface.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeLockCanvas</span><span class="params">(JNIEnv* env, jclass clazz,</span></span></span><br><span class="line"><span class="function"><span class="params">    jlong nativeObject, jobject canvasObj, jobject dirtyRectObj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取java层的Surface保存的long型句柄</span></span><br><span class="line">sp&lt;Surface&gt; surface(<span class="keyword">reinterpret_cast</span>&lt;Surface *&gt;(nativeObject));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!isSurfaceValid(surface)) &#123;</span><br><span class="line">    doThrowIAE(env);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Rect <span class="title">dirtyRect</span><span class="params">(Rect::EMPTY_RECT)</span></span>;</span><br><span class="line">Rect* dirtyRectPtr = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//获取java层dirty Rect的位置大小信息</span></span><br><span class="line"><span class="keyword">if</span> (dirtyRectObj) &#123;</span><br><span class="line">    dirtyRect.left   = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.left);</span><br><span class="line">    dirtyRect.top    = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.top);</span><br><span class="line">    dirtyRect.right  = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.right);</span><br><span class="line">    dirtyRect.bottom = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.bottom);</span><br><span class="line">    dirtyRectPtr = &amp;dirtyRect;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ANativeWindow_Buffer outBuffer;</span><br><span class="line"> <span class="comment">//调用Surface的lock方法,将申请的图形缓冲区赋给outBuffer</span></span><br><span class="line"><span class="keyword">status_t</span> err = surface-&gt;lock(&amp;outBuffer, dirtyRectPtr);</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">SkImageInfo info = SkImageInfo::Make(outBuffer.width, outBuffer.height,</span><br><span class="line">                                     convertPixelFormat(outBuffer.format),</span><br><span class="line">                                     outBuffer.format == PIXEL_FORMAT_RGBX_8888 ?</span><br><span class="line">                                     kOpaque_SkAlphaType : kPremul_SkAlphaType);</span><br><span class="line"></span><br><span class="line">SkBitmap bitmap;</span><br><span class="line"><span class="comment">//创建一个SkBitmap</span></span><br><span class="line"><span class="comment">//图形缓冲区每一行像素大小</span></span><br><span class="line"><span class="keyword">ssize_t</span> bpr = outBuffer.stride * bytesPerPixel(outBuffer.format);</span><br><span class="line">bitmap.setInfo(info, bpr);</span><br><span class="line"><span class="keyword">if</span> (outBuffer.width &gt; <span class="number">0</span> &amp;&amp; outBuffer.height &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    bitmap.setPixels(outBuffer.bits);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// be safe with an empty bitmap.</span></span><br><span class="line">    bitmap.setPixels(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Canvas* nativeCanvas = GraphicsJNI::getNativeCanvas(env, canvasObj);</span><br><span class="line">nativeCanvas-&gt;setBitmap(bitmap);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dirtyRectPtr) &#123;</span><br><span class="line">    nativeCanvas-&gt;clipRect(dirtyRect.left, dirtyRect.top,</span><br><span class="line">            dirtyRect.right, dirtyRect.bottom);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dirtyRectObj) &#123;</span><br><span class="line">    env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.left,   dirtyRect.left);</span><br><span class="line">    env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.top,    dirtyRect.top);</span><br><span class="line">    env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.right,  dirtyRect.right);</span><br><span class="line">    env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.bottom, dirtyRect.bottom);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">sp&lt;Surface&gt; lockedSurface(surface);</span><br><span class="line">lockedSurface-&gt;incStrong(&amp;sRefBaseOwner);</span><br><span class="line"><span class="keyword">return</span> (jlong) lockedSurface.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码逻辑主要如下： 1）获取java层dirty 的Rect大小和位置信息； 2）调用Surface的lock方法,将申请的图形缓冲区赋给outBuffer； 3）创建一个Skbitmap，填充它用来保存申请的图形缓冲区，并赋值给Java层的Canvas对象； 4）将剪裁位置大小信息赋给java层Canvas对象。</p><h3 id="4-3-1、Surface管理图形缓冲区-APP申请-lock-Buffer的过程"><a href="#4-3-1、Surface管理图形缓冲区-APP申请-lock-Buffer的过程" class="headerlink" title="4.3.1、Surface管理图形缓冲区-APP申请(lock)Buffer的过程"></a>4.3.1、Surface管理图形缓冲区-APP申请(lock)Buffer的过程</h3><p>我们上边分析到了申请图形缓冲区，用到了Surface的lock函数，我们继续查看。 [-&gt;Surface.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> Surface::lock(</span><br><span class="line">    ANativeWindow_Buffer* outBuffer, ARect* inOutDirtyBounds)</span><br><span class="line">    &#123;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">ANativeWindowBuffer* out;</span><br><span class="line"><span class="keyword">int</span> fenceFd = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">//调用dequeueBuffer函数，申请图形缓冲区</span></span><br><span class="line"><span class="keyword">status_t</span> err = dequeueBuffer(&amp;out, &amp;fenceFd);</span><br><span class="line">ALOGE_IF(err, <span class="string">"dequeueBuffer failed (%s)"</span>, strerror(-err));</span><br><span class="line"><span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">    <span class="comment">//获取图形缓冲区区域大小,赋给后备缓冲区变量backBuffer</span></span><br><span class="line">    sp&lt;GraphicBuffer&gt; backBuffer(GraphicBuffer::getSelf(out));</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Rect <span class="title">bounds</span><span class="params">(backBuffer-&gt;width, backBuffer-&gt;height)</span></span>;</span><br><span class="line">    Region newDirtyRegion;</span><br><span class="line">    <span class="keyword">if</span> (inOutDirtyBounds) &#123;</span><br><span class="line">        <span class="comment">//如果上层指定乐刷新脏矩形区域，则用这个区域和缓冲区区域求交集，</span></span><br><span class="line">        <span class="comment">//然后将交集的结果设给需要去刷新的新区域</span></span><br><span class="line">        newDirtyRegion.<span class="built_in">set</span>(<span class="keyword">static_cast</span>&lt;Rect <span class="keyword">const</span>&amp;&gt;(*inOutDirtyBounds));</span><br><span class="line">        newDirtyRegion.andSelf(bounds);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        /如果上层没有指定脏矩形区域，所以刷新整个图形缓冲区</span><br><span class="line">        newDirtyRegion.<span class="built_in">set</span>(bounds);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// figure out if we can copy the frontbuffer back</span></span><br><span class="line">    <span class="comment">//上一次绘制的信息保存在mPostedBuffer中，而这个mPostedBuffer则要在unLockAndPost函数中设置</span></span><br><span class="line">    int backBufferSlot(getSlotFromBufferLocked(backBuffer.get()));</span><br><span class="line">    <span class="keyword">const</span> sp&lt;GraphicBuffer&gt;&amp; frontBuffer(mPostedBuffer);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> canCopyBack = (frontBuffer != <span class="number">0</span> &amp;&amp;</span><br><span class="line">            backBuffer-&gt;width  == frontBuffer-&gt;width &amp;&amp;</span><br><span class="line">            backBuffer-&gt;height == frontBuffer-&gt;height &amp;&amp;</span><br><span class="line">            backBuffer-&gt;format == frontBuffer-&gt;format);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (canCopyBack) &#123;</span><br><span class="line">        Mutex::<span class="function">Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">        Region oldDirtyRegion;</span><br><span class="line">        <span class="keyword">if</span>(mSlots[backBufferSlot].dirtyRegion.isEmpty()) &#123;</span><br><span class="line">            oldDirtyRegion.<span class="built_in">set</span>(bounds);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; NUM_BUFFER_SLOTS; i++ ) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i != backBufferSlot &amp;&amp; !mSlots[i].dirtyRegion.isEmpty())</span><br><span class="line">                    oldDirtyRegion.orSelf(mSlots[i].dirtyRegion);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        const Region copyback(oldDirtyRegion.subtract(newDirtyRegion));</span><br><span class="line">        <span class="keyword">if</span> (!copyback.isEmpty())</span><br><span class="line">        <span class="comment">//这里把mPostedBuffer中的旧数据拷贝到BackBuffer中。</span></span><br><span class="line">            <span class="comment">//后续的绘画只要更新脏区域就可以了，这会节约不少资源</span></span><br><span class="line">            copyBlt(backBuffer, frontBuffer, copyback);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// if we can't copy-back anything, modify the user's dirty</span></span><br><span class="line">        <span class="comment">// region to make sure they redraw the whole buffer</span></span><br><span class="line">        <span class="comment">//如果两次图形缓冲区大小不一致，我们就要修改用户指定的dirty区域大小为整个缓冲区大小，</span></span><br><span class="line">        <span class="comment">//然后去更新整个缓冲区</span></span><br><span class="line">        newDirtyRegion.<span class="built_in">set</span>(bounds);</span><br><span class="line">        Mutex::<span class="function">Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;NUM_BUFFER_SLOTS ; i++) &#123;</span><br><span class="line">            mSlots[i].dirtyRegion.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">// scope for the lock</span></span><br><span class="line">        Mutex::<span class="function">Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">        <span class="comment">//将新的dirty赋给这个bufferslot</span></span><br><span class="line">        mSlots[backBufferSlot].dirtyRegion = newDirtyRegion;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (inOutDirtyBounds) &#123;</span><br><span class="line">        *inOutDirtyBounds = newDirtyRegion.getBounds();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>* vaddr;</span><br><span class="line">     <span class="comment">//lock和unlock分别用来锁定和解锁一个指定的图形缓冲区，在访问一块图形缓冲区的时候，</span></span><br><span class="line">    <span class="comment">//例如，向一块图形缓冲写入内容的时候，需要将该图形缓冲区锁定，用来避免访问冲突,</span></span><br><span class="line">    <span class="comment">//锁定之后，就可以获得由参数参数l、t、w和h所圈定的一块缓冲区的起始地址，保存在输出参数vaddr中</span></span><br><span class="line">    <span class="keyword">status_t</span> res = backBuffer-&gt;lockAsync(</span><br><span class="line">            GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN,</span><br><span class="line">            newDirtyRegion.bounds(), &amp;vaddr, fenceFd);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Surface的lock函数用来申请图形缓冲区和一些操作，方法不长，大概工作有： 1）调用connect函数完成一些初始化； 2）调用dequeueBuffer函数，申请图形缓冲区； 3）计算需要绘制的新的dirty区域，旧的区域原样copy数据。 [-&gt;BufferQueueProducer.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Surface::dequeueBuffer(<span class="keyword">android_native_buffer_t</span>** buffer, <span class="keyword">int</span>* fenceFd) &#123;</span><br><span class="line"><span class="keyword">uint32_t</span> reqWidth;</span><br><span class="line"><span class="keyword">uint32_t</span> reqHeight;</span><br><span class="line">PixelFormat reqFormat;</span><br><span class="line"><span class="keyword">uint32_t</span> reqUsage;</span><br><span class="line">&#123;</span><br><span class="line"> ......</span><br><span class="line"><span class="comment">//申请图形缓冲区</span></span><br><span class="line"><span class="keyword">status_t</span> result = mGraphicBufferProducer-&gt;dequeueBuffer(&amp;buf, &amp;fence,</span><br><span class="line">        reqWidth, reqHeight, reqFormat, reqUsage);</span><br><span class="line">......</span><br><span class="line"><span class="comment">//根据index获取缓冲区</span></span><br><span class="line">sp&lt;GraphicBuffer&gt;&amp; gbuf(mSlots[buf].buffer);</span><br><span class="line">......</span><br><span class="line"><span class="keyword">if</span> ((result &amp; IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION) || gbuf == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//由于申请的内存是在surfaceflinger进程中，</span></span><br><span class="line">    <span class="comment">//BufferQueue中的图形缓冲区也是通过匿名共享内存和binder传递描述符映射过去的，</span></span><br><span class="line">    <span class="comment">//Surface通过调用requestBuffer将图形缓冲区映射到Surface所在进程</span></span><br><span class="line">    result = mGraphicBufferProducer-&gt;requestBuffer(buf, &amp;gbuf);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="comment">//获取这个这个buffer对象的指针内容</span></span><br><span class="line">*buffer = gbuf.get();</span><br><span class="line">......</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[-&gt;BufferQueueProducer.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> BufferQueueProducer::requestBuffer(<span class="keyword">int</span> slot, sp&lt;GraphicBuffer&gt;* buf) &#123;</span><br><span class="line">ATRACE_CALL();</span><br><span class="line">Mutex::<span class="function">Autolock <span class="title">lock</span><span class="params">(mCore-&gt;mMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">mSlots[slot].mRequestBufferCalled = <span class="literal">true</span>;</span><br><span class="line">*buf = mSlots[slot].mGraphicBuffer;</span><br><span class="line"><span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个比较简单，还是很好理解的额，就是根据指定index取出mSlots中的slot中的buffer。</p><h2 id="4-4、APP提交-unlockAndPost-Buffer的过程"><a href="#4-4、APP提交-unlockAndPost-Buffer的过程" class="headerlink" title="4.4、APP提交(unlockAndPost)Buffer的过程"></a>4.4、APP提交(unlockAndPost)Buffer的过程</h2><p>Surface绘制完毕后，unlockCanvasAndPost操作。 [-&gt;android_view_Surface.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeUnlockCanvasAndPost</span><span class="params">(JNIEnv* env, jclass clazz,</span></span></span><br><span class="line"><span class="function"><span class="params">    jlong nativeObject, jobject canvasObj)</span> </span>&#123;</span><br><span class="line">sp&lt;Surface&gt; surface(<span class="keyword">reinterpret_cast</span>&lt;Surface *&gt;(nativeObject));</span><br><span class="line"><span class="keyword">if</span> (!isSurfaceValid(surface)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// detach the canvas from the surface</span></span><br><span class="line">Canvas* nativeCanvas = GraphicsJNI::getNativeCanvas(env, canvasObj);</span><br><span class="line">nativeCanvas-&gt;setBitmap(SkBitmap());</span><br><span class="line"></span><br><span class="line"><span class="comment">// unlock surface</span></span><br><span class="line"><span class="keyword">status_t</span> err = surface-&gt;unlockAndPost();</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    doThrowIAE(env);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[-&gt;Surface.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> Surface::unlockAndPost()</span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">//解锁图形缓冲区，和前面的lockAsync成对出现</span></span><br><span class="line"><span class="keyword">status_t</span> err = mLockedBuffer-&gt;unlockAsync(&amp;fd);</span><br><span class="line"><span class="comment">//queueBuffer去归还图形缓冲区</span></span><br><span class="line">err = queueBuffer(mLockedBuffer.get(), fd);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mPostedBuffer = mLockedBuffer;</span><br><span class="line">mLockedBuffer = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里也比较简单，核心也是分两步： 1）解锁图形缓冲区，和前面的lockAsync成对出现； 2）queueBuffer去归还图形缓冲区； 所以我们还是重点分析第二步，查看queueBuffer的实现： [-&gt;Surface.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Surface::queueBuffer(<span class="keyword">android_native_buffer_t</span>* buffer, <span class="keyword">int</span> fenceFd) &#123;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">status_t</span> err = mGraphicBufferProducer-&gt;queueBuffer(i, input, &amp;output);</span><br><span class="line">mLastQueueDuration = systemTime() - now;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用BufferQueueProducer的queueBuffer归还缓冲区，将绘制后的图形缓冲区queue回去。 [-&gt;BufferQueueProducer.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> BufferQueueProducer::queueBuffer(<span class="keyword">int</span> slot,</span><br><span class="line">    <span class="keyword">const</span> QueueBufferInput &amp;input, QueueBufferOutput *output) &#123;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">&#123; <span class="comment">// scope for the lock</span></span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">lock</span><span class="params">(mCallbackMutex)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (callbackTicket != mCurrentCallbackTicket) &#123;</span><br><span class="line">        mCallbackCondition.wait(mCallbackMutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (frameAvailableListener != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        frameAvailableListener-&gt;onFrameAvailable(item);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (frameReplacedListener != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        frameReplacedListener-&gt;onFrameReplaced(item);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结： 1）从传入的QueueBufferInput ，解析填充一些变量； 2）改变入队Slot的状态为QUEUED，每次推进来，mFrameCounter都加1。这里的slot，上一篇讲分配缓冲区返回最老的FREE状态buffer，就是用这个mFrameCounter最小值判断，就是上一篇LRU算法的判断； 3）创建一个BufferItem来描述GraphicBuffer，用mSlots[slot]中的slot填充BufferItem； 4）将BufferItem塞进mCore的mQueue队列，依照指定规则； 5）然后通知SurfaceFlinger去消费。 Folw：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.graphics/18-Android-Graphics-App-WMS-SurfaceFlinger-All-Flow.png" alt="Markdown"></p><h2 id="（五）、通知SF消费合成"><a href="#（五）、通知SF消费合成" class="headerlink" title="（五）、通知SF消费合成"></a>（五）、通知SF消费合成</h2><p>当绘制完毕的GraphicBuffer入队之后，会通知SurfaceFlinger去消费，就是BufferQueueProducer的queueBuffer函数的最后几行，listener-&gt;onFrameAvailable()。 listener最终通过回调，会回到Layer当中，所以最终调用Layer的onFrameAvailable接口，我们看看它的实现： [Layer.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Layer::onFrameAvailable(<span class="keyword">const</span> BufferItem&amp; item) &#123;</span><br><span class="line"><span class="comment">// Add this buffer from our internal queue tracker</span></span><br><span class="line">&#123; <span class="comment">// Autolock scope</span></span><br><span class="line">    ......</span><br><span class="line">    mQueueItems.push_back(item);</span><br><span class="line">    android_atomic_inc(&amp;mQueuedFrames);</span><br><span class="line">    <span class="comment">// Wake up any pending callbacks</span></span><br><span class="line">    mLastFrameNumberReceived = item.mFrameNumber;</span><br><span class="line">    mQueueItemCondition.broadcast();</span><br><span class="line">&#125;</span><br><span class="line">mFlinger-&gt;signalLayerUpdate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里又调用SurfaceFlinger的signalLayerUpdate函数，继续查看： [SurfaceFlinger.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::signalLayerUpdate() &#123;</span><br><span class="line">mEventQueue.invalidate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里又调用MessageQueue的invalidate函数： [MessageQueue.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MessageQueue::invalidate() &#123;</span><br><span class="line">mEvents-&gt;requestNextVsync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>贴一下SurfaceFlinger的初始化请求vsync信号流程图：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.graphics/19-Android-Graphics-vsync-surfaceflinger.png" alt="Markdown"></p><p>最终结果会走到SurfaceFlinger的vsync信号接收逻辑，即SurfaceFlinger的onMessageReceived函数： [SurfaceFlinger.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::onMessageReceived(<span class="keyword">int32_t</span> what) &#123;</span><br><span class="line">ATRACE_CALL();</span><br><span class="line"><span class="keyword">switch</span> (what) &#123;</span><br><span class="line">    <span class="keyword">case</span> MessageQueue::INVALIDATE: &#123;</span><br><span class="line">        <span class="keyword">bool</span> frameMissed = !mHadClientComposition &amp;&amp;</span><br><span class="line">                mPreviousPresentFence != Fence::NO_FENCE &amp;&amp;</span><br><span class="line">                mPreviousPresentFence-&gt;getSignalTime() == INT64_MAX;</span><br><span class="line">        ATRACE_INT(<span class="string">"FrameMissed"</span>, <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(frameMissed));</span><br><span class="line">        <span class="keyword">if</span> (mPropagateBackpressure &amp;&amp; frameMissed) &#123;</span><br><span class="line">            signalLayerUpdate();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> refreshNeeded = handleMessageTransaction();</span><br><span class="line">        refreshNeeded |= handleMessageInvalidate();</span><br><span class="line">        refreshNeeded |= mRepaintEverything;</span><br><span class="line">        <span class="keyword">if</span> (refreshNeeded) &#123;</span><br><span class="line">            <span class="comment">// Signal a refresh if a transaction modified the window state,</span></span><br><span class="line">            <span class="comment">// a new buffer was latched, or if HWC has requested a full</span></span><br><span class="line">            <span class="comment">// repaint</span></span><br><span class="line">            signalRefresh();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> MessageQueue::REFRESH: &#123;</span><br><span class="line">        handleMessageRefresh();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SurfaceFlinger收到了VSync信号后，调用了handleMessageRefresh函数 [SurfaceFlinger.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::handleMessageRefresh() &#123;</span><br><span class="line">ATRACE_CALL();</span><br><span class="line"></span><br><span class="line"><span class="keyword">nsecs_t</span> refreshStartTime = systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line"></span><br><span class="line">preComposition();</span><br><span class="line">rebuildLayerStacks();</span><br><span class="line">setUpHWComposer();</span><br><span class="line">doDebugFlashRegions();</span><br><span class="line">doComposition();</span><br><span class="line">postComposition(refreshStartTime);</span><br><span class="line"></span><br><span class="line">mPreviousPresentFence = mHwc-&gt;getRetireFence(HWC_DISPLAY_PRIMARY);</span><br><span class="line"></span><br><span class="line">mHadClientComposition = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> displayId = <span class="number">0</span>; displayId &lt; mDisplays.size(); ++displayId) &#123;</span><br><span class="line">    <span class="keyword">const</span> sp&lt;DisplayDevice&gt;&amp; displayDevice = mDisplays[displayId];</span><br><span class="line">    mHadClientComposition = mHadClientComposition ||</span><br><span class="line">            mHwc-&gt;hasClientComposition(displayDevice-&gt;getHwcDisplayId());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Release any buffers which were replaced this frame</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; layer : mLayersWithQueuedFrames) &#123;</span><br><span class="line">    layer-&gt;releasePendingBuffer();</span><br><span class="line">&#125;</span><br><span class="line">mLayersWithQueuedFrames.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们主要看下下面几个函数。 [SurfaceFlinger.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">preComposition();</span><br><span class="line">rebuildLayerStacks();</span><br><span class="line">setUpHWComposer();</span><br><span class="line">doDebugFlashRegions();</span><br><span class="line">doComposition();</span><br><span class="line">postComposition(refreshStartTime);</span><br></pre></td></tr></table></figure><h3 id="一、preComposition-函数"><a href="#一、preComposition-函数" class="headerlink" title="一、preComposition()函数"></a>一、preComposition()函数</h3><p>我们先来看第一个函数preComposition() [SurfaceFlinger.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::preComposition()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">bool</span> needExtraInvalidate = <span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> LayerVector&amp; <span class="title">layers</span><span class="params">(mDrawingState.layersSortedByZ)</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> count = layers.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;count ; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (layers[i]-&gt;onPreComposition()) &#123;</span><br><span class="line">        needExtraInvalidate = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (needExtraInvalidate) &#123;</span><br><span class="line">    signalLayerUpdate();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面函数先是调用了mDrawingState的layersSortedByZ来得到上次绘图的Layer层列表。并不是所有的Layer都会参与屏幕图像的绘制，因此SurfaceFlinger用state对象来记录参与绘制的Layer对象。 记得我们之前分析过createLayer函数来创建Layer，创建之后会调用addClientLayer函数。 [SurfaceFlinger.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> SurfaceFlinger::addClientLayer(<span class="keyword">const</span> sp&lt;Client&gt;&amp; client,</span><br><span class="line">    <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; handle,</span><br><span class="line">    <span class="keyword">const</span> sp&lt;IGraphicBufferProducer&gt;&amp; gbc,</span><br><span class="line">    <span class="keyword">const</span> sp&lt;Layer&gt;&amp; lbc)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">// add this layer to the current state list</span></span><br><span class="line">&#123;</span><br><span class="line">    Mutex::Autolock _l(mStateLock);</span><br><span class="line">    <span class="keyword">if</span> (mCurrentState.layersSortedByZ.size() &gt;= MAX_LAYERS) &#123;</span><br><span class="line">        <span class="keyword">return</span> NO_MEMORY;</span><br><span class="line">    &#125;</span><br><span class="line">    mCurrentState.layersSortedByZ.add(lbc);</span><br><span class="line">    mGraphicBufferProducerList.add(IInterface::asBinder(gbc));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// attach this layer to the client</span></span><br><span class="line">client-&gt;attachLayer(handle, lbc);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看下addClientLayer函数，这里会把Layer对象放在mCurrentState的layersSortedByZ对象中。而mDrawingState和mCurrentState什么关系呢？在后面我们会介绍，mDrawingState代表上一次绘图时的状态，处理完之后会把mCurrentState赋给mDrawingState。 回到preComposition函数，遍历所有的Layer对象，调用其onPreComposition函数来检测Layer层中的图像是否有变化。</p><h2 id="1-1、每个Layer的onFrameAvailable函数"><a href="#1-1、每个Layer的onFrameAvailable函数" class="headerlink" title="1.1、每个Layer的onFrameAvailable函数"></a>1.1、每个Layer的onFrameAvailable函数</h2><p>onPreComposition函数来根据mQueuedFrames来判断图像是否发生了变化，或者是mSidebandStreamChanged、mAutoRefresh。 [Layer.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> Layer::onPreComposition() &#123;</span><br><span class="line">mRefreshPending = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> mQueuedFrames &gt; <span class="number">0</span> || mSidebandStreamChanged || mAutoRefresh;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当Layer所对应的Surface更新图像后，它所对应的Layer对象的onFrameAvailable函数会被调用来通知这种变化。 在SurfaceFlinger的preComposition函数中当有Layer的图像改变了，最后也会调用SurfaceFlinger的signalLayerUpdate函数。 SurfaceFlinger::signalLayerUpdate是调用了MessageQueue的invalidate函数 最后处理还是调用了SurfaceFlinger的onMessageReceived函数。看看SurfaceFlinger的onMessageReceived函数对NVALIDATE的处理 handleMessageInvalidate函数中调用了handlePageFlip函数，这个函数将会处理Layer中的缓冲区，把更新过的图像缓冲区切换到前台，等待VSync信号更新到FrameBuffer。</p><h2 id="1-2、绘制流程"><a href="#1-2、绘制流程" class="headerlink" title="1.2、绘制流程"></a>1.2、绘制流程</h2><p>用户进程更新Surface图像，将导致SurfaceFlinger中的Layer发送invalidate消息，处理该消息会调用handleTransaction函数和handlePageFilp函数来更新Layer对象。一旦VSync信号到来，再调用rebuildlayerStacks setUpHWComposer doComposition postComposition函数将所有Layer的图像混合后更新到显示设备上去。</p><h3 id="二、handleTransaction-handPageFlip更新Layer对象"><a href="#二、handleTransaction-handPageFlip更新Layer对象" class="headerlink" title="二、handleTransaction handPageFlip更新Layer对象"></a>二、handleTransaction handPageFlip更新Layer对象</h3><p>在上一节中的绘图的流程中，我们看到了handleTransaction和handPageFlip这两个函数通常是在用户进程更新Surface图像时会调用，来更新Layer对象。这节就主要讲解这两个函数。</p><h2 id="2-1、handleTransaction函数"><a href="#2-1、handleTransaction函数" class="headerlink" title="2.1、handleTransaction函数"></a>2.1、handleTransaction函数</h2><p>handleTransaction函数的参数是transactionFlags，不过函数中没有使用这个参数，而是通过getTransactionFlags(eTransactionMask)来重新对transactionFlags赋值，然后使用它作为参数来调用函数 handleTransactionLocked。 [SurfaceFlinger.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::handleTransaction(<span class="keyword">uint32_t</span> transactionFlags)</span><br><span class="line">&#123;</span><br><span class="line">ATRACE_CALL();</span><br><span class="line"></span><br><span class="line">Mutex::Autolock _l(mStateLock);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">nsecs_t</span> now = systemTime();</span><br><span class="line">mDebugInTransaction = now;</span><br><span class="line"></span><br><span class="line">transactionFlags = getTransactionFlags(eTransactionMask);</span><br><span class="line">handleTransactionLocked(transactionFlags);</span><br><span class="line"></span><br><span class="line">mLastTransactionTime = systemTime() - now;</span><br><span class="line">mDebugInTransaction = <span class="number">0</span>;</span><br><span class="line">invalidateHwcGeometry();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getTransactionFlags函数的参数是eTransactionMask只是屏蔽其他位。 handleTransactionLocked函数会调用每个Layer类的doTransaction函数，在分析handleTransactionLocked函数之前，我们先看看Layer类 的doTransaction函数。</p><h2 id="2-2、Layer的doTransaction函数"><a href="#2-2、Layer的doTransaction函数" class="headerlink" title="2.2、Layer的doTransaction函数"></a>2.2、Layer的doTransaction函数</h2><p>下面是Layer的doTransaction函数代码 [Layer.cpp]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">uint32_t Layer::doTransaction(uint32_t flags) &#123;</span><br><span class="line">ATRACE_CALL();</span><br><span class="line"></span><br><span class="line">pushPendingState();<span class="comment">//上次绘制的State对象  </span></span><br><span class="line">Layer::State c = getCurrentState();<span class="comment">//当前使用的State对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Layer::State&amp; s(getDrawingState());</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bool sizeChanged = (c.requested.w != s.requested.w) ||</span><br><span class="line">                         (c.requested.h != s.requested.h);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sizeChanged) &#123;</span><br><span class="line">    <span class="comment">// the size changed, we need to ask our client to request a new buffer</span></span><br><span class="line">    <span class="comment">//如果Layer的尺寸发生变化，就要改变Surface的缓冲区的尺寸</span></span><br><span class="line">    <span class="comment">// record the new size, form this point on, when the client request</span></span><br><span class="line">    <span class="comment">// a buffer, it'll get the new size.</span></span><br><span class="line">    mSurfaceFlingerConsumer-&gt;setDefaultBufferSize(</span><br><span class="line">            c.requested.w, c.requested.h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bool resizePending = (c.requested.w != c.active.w) ||</span><br><span class="line">        (c.requested.h != c.active.h);</span><br><span class="line"><span class="keyword">if</span> (!isFixedSize()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (resizePending &amp;&amp; mSidebandStream == NULL) &#123;</span><br><span class="line">    <span class="comment">//如果Layer不是固定尺寸的类型，比较它的实际大小和要求的改变大小  </span></span><br><span class="line">        flags |= eDontUpdateGeometryState;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果没有eDontUpdateGeometryState标志，更新active的值为request  </span></span><br><span class="line"><span class="keyword">if</span> (flags &amp; eDontUpdateGeometryState)  &#123;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Layer::State&amp; editCurrentState(getCurrentState());</span><br><span class="line">    <span class="keyword">if</span> (mFreezePositionUpdates) &#123;</span><br><span class="line">        <span class="keyword">float</span> tx = c.active.transform.tx();</span><br><span class="line">        <span class="keyword">float</span> ty = c.active.transform.ty();</span><br><span class="line">        c.active = c.requested;</span><br><span class="line">        c.active.transform.set(tx, ty);</span><br><span class="line">        editCurrentState.active = c.active;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        editCurrentState.active = editCurrentState.requested;</span><br><span class="line">        c.active = c.requested;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果当前state的active和以前的State的active不等，设置更新标志  </span></span><br><span class="line"><span class="keyword">if</span> (s.active != c.active) &#123;</span><br><span class="line">    <span class="comment">// invalidate and recompute the visible regions if needed</span></span><br><span class="line">    flags |= Layer::eVisibleRegion;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果当前state的sequence和以前state的sequence不等，设置更新标志</span></span><br><span class="line"><span class="keyword">if</span> (c.sequence != s.sequence) &#123;</span><br><span class="line">    <span class="comment">// invalidate and recompute the visible regions if needed</span></span><br><span class="line">    flags |= eVisibleRegion;</span><br><span class="line">    <span class="keyword">this</span>-&gt;contentDirty = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we may use linear filtering, if the matrix scales us</span></span><br><span class="line">    <span class="keyword">const</span> uint8_t type = c.active.transform.getType();</span><br><span class="line">    mNeedsFiltering = (!c.active.transform.preserveRects() ||</span><br><span class="line">            (type &gt;= Transform::SCALE));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If the layer is hidden, signal and clear out all local sync points so</span></span><br><span class="line"><span class="comment">// that transactions for layers depending on this layer's frames becoming</span></span><br><span class="line"><span class="comment">// visible are not blocked</span></span><br><span class="line"><span class="keyword">if</span> (c.flags &amp; layer_state_t::eLayerHidden) &#123;</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">lock</span><span class="params">(mLocalSyncPointMutex)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (auto&amp; point : mLocalSyncPoints) &#123;</span><br><span class="line">        point-&gt;setFrameAvailable();</span><br><span class="line">    &#125;</span><br><span class="line">    mLocalSyncPoints.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Commit the transaction</span></span><br><span class="line">commitTransaction(c);</span><br><span class="line"><span class="keyword">return</span> flags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Layer类中的两个类型为Layer::State的成员变量mDrawingState、mCurrentState，这里为什么要两个对象呢？Layer对象在绘制图形时，使用的是mDrawingState变量，用户调用接口设置Layer对象属性是，设置的值保存在mCurrentState对象中，这样就不会因为用户的操作而干扰Layer对象的绘制了。 Layer的doTransaction函数据你是比较这两个变量，如果有不同的地方，说明在上次绘制以后，用户改变的Layer的设置，要把这种变化通过flags返回。 State的结构中有两个Geometry字段，active和requested。他们表示layer的尺寸，其中requested保存是用户设置的尺寸，而active保存的值通过计算后的实际尺寸。 State中的z字段的值就是Layer在显示轴的位置，值越小位置越靠下。 layerStack字段是用户指定的一个值，用户可以给DisplayDevice也指定一个layerStack值，只有Layer对象和DisplayDevice对象的layerStack相等，这个Layer才能在这个显示设备上输出，这样的好处是可以让显示设备只显示某个Surface的内容。例如，可以让HDMI显示设备只显示手机上播放视频的Surface窗口，但不显示Activity窗口。 sequence字段是个序列值，每当用户调用了Layer的接口，例如setAlpha、setSize或者setLayer等改变Layer对象属性的哈数，这个值都会加1。因此在doTransaction函数中能通过比较sequence值来判断Layer的属性值有没有变化。 doTransaction函数最后会调用commitTransaction函数，就是把mCurrentState赋值给mDrawingState [Layer.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Layer::commitTransaction(<span class="keyword">const</span> State&amp; stateToCommit) &#123;</span><br><span class="line">mDrawingState = stateToCommit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3、handleTransactionLocked函数"><a href="#2-3、handleTransactionLocked函数" class="headerlink" title="2.3、handleTransactionLocked函数"></a>2.3、handleTransactionLocked函数</h3><p>下面我们来分析handleTransactionLocked函数，这个函数比较长，我们分段分析</p><p>2.3.1 处理Layer的事务 [SurfaceFlinger.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::handleTransactionLocked(<span class="keyword">uint32_t</span> transactionFlags)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">const</span> LayerVector&amp; <span class="title">currentLayers</span><span class="params">(mCurrentState.layersSortedByZ)</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> count = currentLayers.size();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Notify all layers of available frames</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">    currentLayers[i]-&gt;notifyAvailableFrames();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (transactionFlags &amp; eTraversalNeeded) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;count ; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Layer&gt;&amp; layer(currentLayers[i]);</span><br><span class="line">        <span class="keyword">uint32_t</span> trFlags = layer-&gt;getTransactionFlags(eTransactionNeeded);</span><br><span class="line">        <span class="keyword">if</span> (!trFlags) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">uint32_t</span> flags = layer-&gt;doTransaction(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; Layer::eVisibleRegion)</span><br><span class="line">            mVisibleRegionsDirty = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在SurfaceFlinger中也有两个类型为State的变量mCurrentState和mDrawingState，但是和Layer中的不要混起来。它的名字相同而已</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">State</span> &#123;</span></span><br><span class="line">    LayerVector layersSortedByZ;</span><br><span class="line">    DefaultKeyedVector&lt; wp&lt;IBinder&gt;, DisplayDeviceState&gt; displays;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结构layersSortedByZ字段保存所有参与绘制的Layer对象，而字段displays保存的是所有输出设备的DisplayDeviceState对象 这里用两个变量的目的是和Layer中使用两个变量是一样的。 上面代码根据eTraversalNeeded标志来决定是否要检查所有的Layer对象。如果某个Layer对象中有eTransactionNeeded标志，将调用它的doTransaction函数。Layer的doTransaction函数返回的flags如果有eVisibleRegion，说明这个Layer需要更新，就把mVisibleRegionsDirty设置为true</p><h3 id="2-3-2、处理显示设备的变化"><a href="#2-3-2、处理显示设备的变化" class="headerlink" title="2.3.2、处理显示设备的变化"></a>2.3.2、处理显示设备的变化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (transactionFlags &amp; eDisplayTransactionNeeded) &#123;</span><br><span class="line">    <span class="comment">// here we take advantage of Vector's copy-on-write semantics to</span></span><br><span class="line">    <span class="comment">// improve performance by skipping the transaction entirely when</span></span><br><span class="line">    <span class="comment">// know that the lists are identical</span></span><br><span class="line">    <span class="keyword">const</span> KeyedVector&lt;  wp&lt;IBinder&gt;, DisplayDeviceState&gt;&amp; curr(mCurrentState.displays);</span><br><span class="line">    <span class="keyword">const</span> KeyedVector&lt;  wp&lt;IBinder&gt;, DisplayDeviceState&gt;&amp; draw(mDrawingState.displays);</span><br><span class="line">    <span class="keyword">if</span> (!curr.isIdenticalTo(draw)) &#123;</span><br><span class="line">        mVisibleRegionsDirty = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">size_t</span> cc = curr.size();</span><br><span class="line">              <span class="keyword">size_t</span> dc = draw.size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// find the displays that were removed</span></span><br><span class="line">        <span class="comment">// (ie: in drawing state but not in current state)</span></span><br><span class="line">        <span class="comment">// also handle displays that changed</span></span><br><span class="line">        <span class="comment">// (ie: displays that are in both lists)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;dc ; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">ssize_t</span> j = curr.indexOfKey(draw.keyAt(i));</span><br><span class="line">            <span class="keyword">if</span> (j &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// in drawing state but not in current state</span></span><br><span class="line">                <span class="keyword">if</span> (!draw[i].isMainDisplay()) &#123;</span><br><span class="line">                    <span class="comment">// Call makeCurrent() on the primary display so we can</span></span><br><span class="line">                    <span class="comment">// be sure that nothing associated with this display</span></span><br><span class="line">                    <span class="comment">// is current.</span></span><br><span class="line">                    <span class="keyword">const</span> sp&lt;<span class="keyword">const</span> DisplayDevice&gt; defaultDisplay(getDefaultDisplayDevice());</span><br><span class="line">                    defaultDisplay-&gt;makeCurrent(mEGLDisplay, mEGLContext);</span><br><span class="line">                    sp&lt;DisplayDevice&gt; hw(getDisplayDevice(draw.keyAt(i)));</span><br><span class="line">                    <span class="keyword">if</span> (hw != <span class="literal">NULL</span>)</span><br><span class="line">                        hw-&gt;disconnect(getHwComposer());</span><br><span class="line">                    <span class="keyword">if</span> (draw[i].type &lt; DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES)</span><br><span class="line">                        mEventThread-&gt;onHotplugReceived(draw[i].type, <span class="literal">false</span>);</span><br><span class="line">                    mDisplays.removeItem(draw.keyAt(i));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ALOGW(<span class="string">"trying to remove the main display"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// this display is in both lists. see if something changed.</span></span><br><span class="line">                <span class="keyword">const</span> DisplayDeviceState&amp; state(curr[j]);</span><br><span class="line">                <span class="keyword">const</span> wp&lt;IBinder&gt;&amp; display(curr.keyAt(j));</span><br><span class="line">                <span class="keyword">const</span> sp&lt;IBinder&gt; state_binder = IInterface::asBinder(state.surface);</span><br><span class="line">                <span class="keyword">const</span> sp&lt;IBinder&gt; draw_binder = IInterface::asBinder(draw[i].surface);</span><br><span class="line">                <span class="keyword">if</span> (state_binder != draw_binder) &#123;</span><br><span class="line">                    <span class="comment">// changing the surface is like destroying and</span></span><br><span class="line">                    <span class="comment">// recreating the DisplayDevice, so we just remove it</span></span><br><span class="line">                    <span class="comment">// from the drawing state, so that it get re-added</span></span><br><span class="line">                    <span class="comment">// below.</span></span><br><span class="line">                    sp&lt;DisplayDevice&gt; hw(getDisplayDevice(display));</span><br><span class="line">                    <span class="keyword">if</span> (hw != <span class="literal">NULL</span>)</span><br><span class="line">                        hw-&gt;disconnect(getHwComposer());</span><br><span class="line">                    mDisplays.removeItem(display);</span><br><span class="line">                    mDrawingState.displays.removeItemsAt(i);</span><br><span class="line">                    dc--; i--;</span><br><span class="line">                    <span class="comment">// at this point we must loop to the next item</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">const</span> sp&lt;DisplayDevice&gt; disp(getDisplayDevice(display));</span><br><span class="line">                <span class="keyword">if</span> (disp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (state.layerStack != draw[i].layerStack) &#123;</span><br><span class="line">                        disp-&gt;setLayerStack(state.layerStack);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> ((state.orientation != draw[i].orientation)</span><br><span class="line">                            || (state.viewport != draw[i].viewport)</span><br><span class="line">                            || (state.frame != draw[i].frame))</span><br><span class="line">                    &#123;</span><br><span class="line">                        disp-&gt;setProjection(state.orientation,</span><br><span class="line">                                state.viewport, state.frame);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (state.width != draw[i].width || state.height != draw[i].height) &#123;</span><br><span class="line">                        disp-&gt;setDisplaySize(state.width, state.height);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// find displays that were added</span></span><br><span class="line">        <span class="comment">// (ie: in current state but not in drawing state)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;cc ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (draw.indexOfKey(curr.keyAt(i)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="function"><span class="keyword">const</span> DisplayDeviceState&amp; <span class="title">state</span><span class="params">(curr[i])</span></span>;</span><br><span class="line"></span><br><span class="line">                sp&lt;DisplaySurface&gt; dispSurface;</span><br><span class="line">                sp&lt;IGraphicBufferProducer&gt; producer;</span><br><span class="line">                sp&lt;IGraphicBufferProducer&gt; bqProducer;</span><br><span class="line">                sp&lt;IGraphicBufferConsumer&gt; bqConsumer;</span><br><span class="line">                BufferQueue::createBufferQueue(&amp;bqProducer, &amp;bqConsumer,</span><br><span class="line">                        <span class="keyword">new</span> GraphicBufferAlloc());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int32_t</span> hwcDisplayId = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">if</span> (state.isVirtualDisplay()) &#123;</span><br><span class="line">                    <span class="comment">// Virtual displays without a surface are dormant:</span></span><br><span class="line">                    <span class="comment">// they have external state (layer stack, projection,</span></span><br><span class="line">                    <span class="comment">// etc.) but no internal state (i.e. a DisplayDevice).</span></span><br><span class="line">                    <span class="keyword">if</span> (state.surface != <span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">int</span> width = <span class="number">0</span>;</span><br><span class="line">                        DisplayUtils* displayUtils = DisplayUtils::getInstance();</span><br><span class="line">                        <span class="keyword">int</span> status = state.surface-&gt;query(</span><br><span class="line">                                NATIVE_WINDOW_WIDTH, &amp;width);</span><br><span class="line">                        ALOGE_IF(status != NO_ERROR,</span><br><span class="line">                                <span class="string">"Unable to query width (%d)"</span>, status);</span><br><span class="line">                        <span class="keyword">int</span> height = <span class="number">0</span>;</span><br><span class="line">                        status = state.surface-&gt;query(</span><br><span class="line">                            NATIVE_WINDOW_HEIGHT, &amp;height);</span><br><span class="line">                        ALOGE_IF(status != NO_ERROR,</span><br><span class="line">                            <span class="string">"Unable to query height (%d)"</span>, status);</span><br><span class="line">                        <span class="keyword">if</span> (MAX_VIRTUAL_DISPLAY_DIMENSION == <span class="number">0</span> ||</span><br><span class="line">                            (width &lt;= MAX_VIRTUAL_DISPLAY_DIMENSION &amp;&amp;</span><br><span class="line">                             height &lt;= MAX_VIRTUAL_DISPLAY_DIMENSION)) &#123;</span><br><span class="line">                            <span class="keyword">int</span> usage = <span class="number">0</span>;</span><br><span class="line">                            status = state.surface-&gt;query(</span><br><span class="line">                                NATIVE_WINDOW_CONSUMER_USAGE_BITS, &amp;usage);</span><br><span class="line">                            ALOGW_IF(status != NO_ERROR,</span><br><span class="line">                                <span class="string">"Unable to query usage (%d)"</span>, status);</span><br><span class="line">                            <span class="keyword">if</span> ( (status == NO_ERROR) &amp;&amp;</span><br><span class="line">                                  displayUtils-&gt;canAllocateHwcDisplayIdForVDS(usage)) &#123;</span><br><span class="line">                                hwcDisplayId = allocateHwcDisplayId(state.type);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        displayUtils-&gt;initVDSInstance(mHwc, hwcDisplayId, state.surface,</span><br><span class="line">                                dispSurface, producer, bqProducer, bqConsumer,</span><br><span class="line">                                state.displayName, state.isSecure, state.type);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ALOGE_IF(state.surface!=<span class="literal">NULL</span>,</span><br><span class="line">                            <span class="string">"adding a supported display, but rendering "</span></span><br><span class="line">                            <span class="string">"surface is provided (%p), ignoring it"</span>,</span><br><span class="line">                            state.surface.get());</span><br><span class="line">                    hwcDisplayId = allocateHwcDisplayId(state.type);</span><br><span class="line">                    <span class="comment">// for supported (by hwc) displays we provide our</span></span><br><span class="line">                    <span class="comment">// own rendering surface</span></span><br><span class="line">                    dispSurface = <span class="keyword">new</span> FramebufferSurface(*mHwc, state.type,</span><br><span class="line">                            bqConsumer);</span><br><span class="line">                    producer = bqProducer;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">const</span> wp&lt;IBinder&gt;&amp; display(curr.keyAt(i));</span><br><span class="line">                <span class="keyword">if</span> (dispSurface != <span class="literal">NULL</span> &amp;&amp; producer != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    sp&lt;DisplayDevice&gt; hw = <span class="keyword">new</span> DisplayDevice(<span class="keyword">this</span>,</span><br><span class="line">                            state.type, hwcDisplayId,</span><br><span class="line">                            mHwc-&gt;getFormat(hwcDisplayId), state.isSecure,</span><br><span class="line">                            display, dispSurface, producer,</span><br><span class="line">                            mRenderEngine-&gt;getEGLConfig());</span><br><span class="line">                    hw-&gt;setLayerStack(state.layerStack);</span><br><span class="line">                    hw-&gt;setProjection(state.orientation,</span><br><span class="line">                            state.viewport, state.frame);</span><br><span class="line">                    hw-&gt;setDisplayName(state.displayName);</span><br><span class="line">                    <span class="comment">// When a new display device is added update the active</span></span><br><span class="line">                    <span class="comment">// config by querying HWC otherwise the default config</span></span><br><span class="line">                    <span class="comment">// (config 0) will be used.</span></span><br><span class="line">                    <span class="keyword">if</span> (hwcDisplayId &gt;= DisplayDevice::DISPLAY_PRIMARY &amp;&amp;</span><br><span class="line">                            hwcDisplayId &lt; DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES) &#123;</span><br><span class="line">                        <span class="keyword">int</span> activeConfig = mHwc-&gt;getActiveConfig(hwcDisplayId);</span><br><span class="line">                        <span class="keyword">if</span> (activeConfig &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            hw-&gt;setActiveConfig(activeConfig);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    mDisplays.add(display, hw);</span><br><span class="line">                    <span class="keyword">if</span> (state.isVirtualDisplay()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (hwcDisplayId &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            mHwc-&gt;setVirtualDisplayProperties(hwcDisplayId,</span><br><span class="line">                                    hw-&gt;getWidth(), hw-&gt;getHeight(),</span><br><span class="line">                                    hw-&gt;getFormat());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mEventThread-&gt;onHotplugReceived(state.type, <span class="literal">true</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的作用是处理显示设备的变化，分成3种情况： 1.显示设备减少了，需要把显示设备对应的DisplayDevice移除 2.显示设备发生了变化，例如用户设置了Surface、重新设置了layerStack、旋转了屏幕等，这就需要重新设置显示对象的属性 3.显示设备增加了，创建新的DisplayDevice加入系统中。</p><h3 id="2-3-3、设置TransfromHit"><a href="#2-3-3、设置TransfromHit" class="headerlink" title="2.3.3、设置TransfromHit"></a>2.3.3、设置TransfromHit</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (transactionFlags &amp; (eTraversalNeeded|eDisplayTransactionNeeded)) &#123;</span><br><span class="line">    ......</span><br><span class="line">    sp&lt;<span class="keyword">const</span> DisplayDevice&gt; disp;</span><br><span class="line">    <span class="keyword">uint32_t</span> currentlayerStack = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span>; i&lt;count; i++) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> we rely on the fact that layers are sorted by</span></span><br><span class="line">        <span class="comment">// layerStack first (so we don't have to traverse the list</span></span><br><span class="line">        <span class="comment">// of displays for every layer).</span></span><br><span class="line">        <span class="keyword">const</span> sp&lt;Layer&gt;&amp; layer(currentLayers[i]);</span><br><span class="line">        <span class="keyword">uint32_t</span> layerStack = layer-&gt;getDrawingState().layerStack;</span><br><span class="line">        <span class="keyword">if</span> (i==<span class="number">0</span> || currentlayerStack != layerStack) &#123;</span><br><span class="line">            currentlayerStack = layerStack;</span><br><span class="line">            <span class="comment">// figure out if this layerstack is mirrored</span></span><br><span class="line">            <span class="comment">// (more than one display) if so, pick the default display,</span></span><br><span class="line">            <span class="comment">// if not, pick the only display it's on.</span></span><br><span class="line">            disp.clear();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> dpy=<span class="number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">                sp&lt;<span class="keyword">const</span> DisplayDevice&gt; hw(mDisplays[dpy]);</span><br><span class="line">                <span class="keyword">if</span> (hw-&gt;getLayerStack() == currentlayerStack) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (disp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                        disp = hw;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        disp = <span class="literal">NULL</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (disp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">NOTE:</span> TEMPORARY FIX ONLY. Real fix should cause layers to</span></span><br><span class="line">            <span class="comment">// redraw after transform hint changes. See bug 8508397.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// could be null when this layer is using a layerStack</span></span><br><span class="line">            <span class="comment">// that is not visible on any display. Also can occur at</span></span><br><span class="line">            <span class="comment">// screen off/on times.</span></span><br><span class="line">            disp = getDefaultDisplayDevice();</span><br><span class="line">        &#125;</span><br><span class="line">        layer-&gt;updateTransformHint(disp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的作用是根据每种显示设备的不同，设置和显示设备关联在一起的Layer（主要看Layer的layerStack是否和DisplayDevice的layerStack）的TransformHint（主要指设备的显示方向orientation）。</p><h3 id="2-3-4、处理Layer增加情况"><a href="#2-3-4、处理Layer增加情况" class="headerlink" title="2.3.4、处理Layer增加情况"></a>2.3.4、处理Layer增加情况</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Perform our own transaction if needed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> LayerVector&amp; <span class="title">layers</span><span class="params">(mDrawingState.layersSortedByZ)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (currentLayers.size() &gt; layers.size()) &#123;</span><br><span class="line">    <span class="comment">// layers have been added</span></span><br><span class="line">    mVisibleRegionsDirty = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// some layers might have been removed, so</span></span><br><span class="line"><span class="comment">// we need to update the regions they're exposing.</span></span><br><span class="line"><span class="keyword">if</span> (mLayersRemoved) &#123;</span><br><span class="line">    mLayersRemoved = <span class="literal">false</span>;</span><br><span class="line">    mVisibleRegionsDirty = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> count = layers.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;count ; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Layer&gt;&amp; layer(layers[i]);</span><br><span class="line">        <span class="keyword">if</span> (currentLayers.indexOf(layer) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// this layer is not visible anymore</span></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> we could traverse the tree from front to back and</span></span><br><span class="line">            <span class="comment">//       compute the actual visible region</span></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> we could cache the transformed region</span></span><br><span class="line">            const Layer::State&amp; s(layer-&gt;getDrawingState());</span><br><span class="line">            Region visibleReg = s.active.transform.transform(</span><br><span class="line">                    Region(Rect(s.active.w, s.active.h)));</span><br><span class="line">            invalidateLayerStack(s.layerStack, visibleReg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码处理Layer的增加情况，如果Layer增加了，需要重新计算设备的更新区域，因此把mVisibleRegionsDirty设为true，如果Layer删除了，需要把Layer的可见区域加入到系统需要更新的区域中。</p><h3 id="2-3-5、设置mDrawingState"><a href="#2-3-5、设置mDrawingState" class="headerlink" title="2.3.5、设置mDrawingState"></a>2.3.5、设置mDrawingState</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">commitTransaction();</span><br><span class="line">updateCursorAsync();</span><br></pre></td></tr></table></figure><p>调用commitTransaction和updateCursorAsync函数 commitTransaction函数作用是把mDrawingState的值设置成mCurrentState的值。而updateCursorAsync函数会更新所有显示设备中光标的位置。</p><p>2.3.6 小结 handleTransaction函数的作用的就是处理系统在两次刷新期间的各种变化。SurfaceFlinger模块中不管是SurfaceFlinger类还是Layer类，都采用了双缓冲的方式来保存他们的属性，这样的好处是刚改变SurfaceFlinger对象或者Layer类对象的属性是，不需要上锁，大大的提高了系统效率。只有在最后的图像输出是，才进行一次上锁，并进行内存的属性变化处理。正因此，应用进程必须收到VSync信号才开始改变Surface的内容。</p><h2 id="2-4、handlePageFlip函数"><a href="#2-4、handlePageFlip函数" class="headerlink" title="2.4、handlePageFlip函数"></a>2.4、handlePageFlip函数</h2><p>handlePageFlip函数代码如下： [SurfaceFlinger.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> SurfaceFlinger::handlePageFlip()</span><br><span class="line">&#123;</span><br><span class="line">Region dirtyRegion;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> visibleRegions = <span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> LayerVector&amp; <span class="title">layers</span><span class="params">(mDrawingState.layersSortedByZ)</span></span>;</span><br><span class="line"><span class="keyword">bool</span> frameQueued = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Store the set of layers that need updates. This set must not change as</span></span><br><span class="line"><span class="comment">// buffers are being latched, as this could result in a deadlock.</span></span><br><span class="line"><span class="comment">// Example: Two producers share the same command stream and:</span></span><br><span class="line"><span class="comment">// 1.) Layer 0 is latched</span></span><br><span class="line"><span class="comment">// 2.) Layer 0 gets a new frame</span></span><br><span class="line"><span class="comment">// 2.) Layer 1 gets a new frame</span></span><br><span class="line"><span class="comment">// 3.) Layer 1 is latched.</span></span><br><span class="line"><span class="comment">// Display is now waiting on Layer 1's frame, which is behind layer 0's</span></span><br><span class="line"><span class="comment">// second frame. But layer 0's second frame could be waiting on display.</span></span><br><span class="line">Vector&lt;Layer*&gt; layersWithQueuedFrames;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>, count = layers.size(); i&lt;count ; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> sp&lt;Layer&gt;&amp; layer(layers[i]);</span><br><span class="line">    <span class="keyword">if</span> (layer-&gt;hasQueuedFrame()) &#123;</span><br><span class="line">        frameQueued = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (layer-&gt;shouldPresentNow(mPrimaryDispSync)) &#123;</span><br><span class="line">            layersWithQueuedFrames.push_back(layer.get());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            layer-&gt;useEmptyDamage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        layer-&gt;useEmptyDamage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>, count = layersWithQueuedFrames.size() ; i&lt;count ; i++) &#123;</span><br><span class="line">    Layer* layer = layersWithQueuedFrames[i];</span><br><span class="line">    const Region dirty(layer-&gt;latchBuffer(visibleRegions));</span><br><span class="line">    layer-&gt;useSurfaceDamage();</span><br><span class="line">    const Layer::State&amp; s(layer-&gt;getDrawingState());</span><br><span class="line">    invalidateLayerStack(s.layerStack, dirty);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mVisibleRegionsDirty |= visibleRegions;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If we will need to wake up at some time in the future to deal with a</span></span><br><span class="line"><span class="comment">// queued frame that shouldn't be displayed during this vsync period, wake</span></span><br><span class="line"><span class="comment">// up during the next vsync period to check again.</span></span><br><span class="line"><span class="keyword">if</span> (frameQueued &amp;&amp; layersWithQueuedFrames.empty()) &#123;</span><br><span class="line">    signalLayerUpdate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Only continue with the refresh if there is actually new work to do</span></span><br><span class="line"><span class="keyword">return</span> !layersWithQueuedFrames.empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>handlePageFlip函数先调用每个Layer对象的hasQueuedFrame函数，确定这个Layer对象是否有需要更新的图层，然后把需要更新的Layer对象放到layersWithQueuedFrames中。 我们先来看Layer的hasQueuedFrame方法就是看其mQueuedFrames是否大于0 和mSidebandStreamChanged。前面小节分析只要Surface有数据写入，就会调用Layer的onFrameAvailable函数，然后mQueuedFrames值加1. 继续看handlePageFlip函数，接着调用需要更新的Layer对象的latchBuffer函数，然后根据返回的更新区域调用invalidateLayerStack函数来设置更新设备对象的更新区域。 下面我们看看latchBuffer函数</p><p>LatchBuffer函数调用updateTextImage来得到需要的图像。这里参数r是Reject对象，其作用是判断在缓冲区的尺寸是否符合要求。调用updateTextImage函数如果得到的结果是PRESENT_LATER,表示推迟处理，然后调用signalLayerUpdate函数来发送invalidate消息，这次绘制过程就不处理这个Surface的图像了。 如果不需要推迟处理，把mQueuedFrames的值减1. 最后LatchBuffer函数调用mSurfaceFlingerConsumer的getCurrentBuffer来取回当前的图像缓冲区指针，保存在mActiveBuffer中。</p><h3 id="2-5-小结"><a href="#2-5-小结" class="headerlink" title="2.5 小结"></a>2.5 小结</h3><p>这样经过handleTransaction handlePageFlip两个函数处理，SurfaceFlinger中无论是Layer属性的变化还是图像的变化都处理好了，只等VSync信号到来就可以输出了。</p><h2 id="三、rebuildLayerStacks函数"><a href="#三、rebuildLayerStacks函数" class="headerlink" title="三、rebuildLayerStacks函数"></a>三、rebuildLayerStacks函数</h2><p>前面介绍，VSync信号到来后，先是调用了rebuildLayerStacks函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::rebuildLayerStacks() &#123;</span><br><span class="line">updateExtendedMode();</span><br><span class="line"><span class="comment">// rebuild the visible layer list per screen</span></span><br><span class="line"><span class="keyword">if</span> (CC_UNLIKELY(mVisibleRegionsDirty)) &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    mVisibleRegionsDirty = <span class="literal">false</span>;</span><br><span class="line">    invalidateHwcGeometry();</span><br><span class="line">    <span class="comment">//计算每个显示设备上可见的Layer  </span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> LayerVector&amp; <span class="title">layers</span><span class="params">(mDrawingState.layersSortedByZ)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> dpy=<span class="number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">        Region opaqueRegion;</span><br><span class="line">        Region dirtyRegion;</span><br><span class="line">        Vector&lt; sp&lt;Layer&gt; &gt; layersSortedByZ;</span><br><span class="line">        <span class="keyword">const</span> sp&lt;DisplayDevice&gt;&amp; hw(mDisplays[dpy]);</span><br><span class="line">        const Transform&amp; tr(hw-&gt;getTransform());</span><br><span class="line">        const Rect bounds(hw-&gt;getBounds());</span><br><span class="line">        <span class="keyword">if</span> (hw-&gt;isDisplayOn()) &#123;</span><br><span class="line">            <span class="comment">//计算每个layer的可见区域，确定设备需要重新绘制的区域  </span></span><br><span class="line">            computeVisibleRegions(hw-&gt;getHwcDisplayId(), layers,</span><br><span class="line">                    hw-&gt;getLayerStack(), dirtyRegion, opaqueRegion);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">size_t</span> count = layers.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;count ; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> sp&lt;Layer&gt;&amp; layer(layers[i]);</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//只需要和显示设备的LayerStack相同的layer  </span></span><br><span class="line">                    <span class="function">Region <span class="title">drawRegion</span><span class="params">(tr.transform(</span></span></span><br><span class="line">                            layer-&gt;visibleNonTransparentRegion));</span><br><span class="line">                    drawRegion.andSelf(bounds);</span><br><span class="line">                    <span class="keyword">if</span> (!drawRegion.isEmpty()) &#123;</span><br><span class="line">                    <span class="comment">//如果Layer的显示区域和显示设备的窗口有交集  </span></span><br><span class="line">                        <span class="comment">//把Layer加入列表中</span></span><br><span class="line">                        layersSortedByZ.add(layer);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置显示设备的可见Layer列表  </span></span><br><span class="line">        hw-&gt;setVisibleLayersSortedByZ(layersSortedByZ);</span><br><span class="line">        hw-&gt;undefinedRegion.<span class="built_in">set</span>(bounds);</span><br><span class="line">        hw-&gt;undefinedRegion.subtractSelf(tr.transform(opaqueRegion));</span><br><span class="line">        hw-&gt;dirtyRegion.orSelf(dirtyRegion);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rebuildLayerStacks函数的作用是重建每个显示设备的可见layer对象列表。对于按显示轴（Z轴）排列的Layer对象，排在最前面的当然会优先显示，但是Layer图像可能有透明域，也可能有尺寸没有覆盖整个屏幕，因此下面的layer也有显示的机会。rebuildLayerStacks函数对每个显示设备，先计算和显示设备具有相同layerStack值的Layer对象在该显示设备上的可见区域。然后将可见区域和显示设备的窗口区域有交集的layer组成一个新的列表，最后把这个列表设置到显示设备对象中。 computeVisibleRegions函数首先计算每个Layer在设备上的可见区域visibleRegion。计算方法就是用整个Layer的区域减去上层所有不透明区域aboveOpaqueLayers。而上层所有不透明区域值是一个逐层累计的过程，每层都需要把自己的不透明区域累加到aboveOpaqueLayers中。 而每层的不透明区域的计算方法：如果Layer的alpha的值为255，并且layer的isOpaque函数为true，则本层的不透明区域等于Layer所在区域，否则为0.这样一层层算下来，就很容易得到每层的可见区域大小了。 其次，计算整个显示设备需要更新的区域outDirtyRegion。outDirtyRegion的值也是累计所有层的需要重回的区域得到的。如果Layer中的显示内容发生了变化，则整个可见区域visibleRegion都需要更新，同时还要包括上一次的可见区域，然后在去掉被上层覆盖后的区域得到的就是Layer需要更新的区域。如果Layer显示的内容没有变化，但是考虑到窗口大小的变化或者上层窗口的变化，因此Layer中还是有区域可以需要重绘的地方。这种情况下最简单的算法是用Layer计算出可见区域减去以前的可见区域就可以了。但是在computeVisibleRegions函数还引入了被覆盖区域，通常被覆盖区域和可见区域并不重复，因此函数中计算暴露区域是用可见区域减去被覆盖区域的。</p><h3 id="四、setUpHWComposer函数"><a href="#四、setUpHWComposer函数" class="headerlink" title="四、setUpHWComposer函数"></a>四、setUpHWComposer函数</h3><p>setUpHWComposer函数的作用是更新HWComposer对象中图层对象列表以及图层属性。 [SurfaceFlinger.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::setUpHWComposer() &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> dpy=<span class="number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">    <span class="keyword">bool</span> dirty = !mDisplays[dpy]-&gt;getDirtyRegion(<span class="literal">false</span>).isEmpty();</span><br><span class="line">    <span class="keyword">bool</span> empty = mDisplays[dpy]-&gt;getVisibleLayersSortedByZ().size() == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> wasEmpty = !mDisplays[dpy]-&gt;lastCompositionHadVisibleLayers;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">bool</span> mustRecompose = dirty &amp;&amp; !(empty &amp;&amp; wasEmpty);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    mDisplays[dpy]-&gt;beginFrame(mustRecompose);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mustRecompose) &#123;</span><br><span class="line">        mDisplays[dpy]-&gt;lastCompositionHadVisibleLayers = !empty;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//得到系统HWComposer对象  </span></span><br><span class="line">HWComposer&amp; hwc(getHwComposer());</span><br><span class="line"><span class="keyword">if</span> (hwc.initCheck() == NO_ERROR) &#123;</span><br><span class="line">    <span class="comment">// build the h/w work list</span></span><br><span class="line">    <span class="keyword">if</span> (CC_UNLIKELY(mHwWorkListDirty)) &#123;</span><br><span class="line">        mHwWorkListDirty = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> dpy=<span class="number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">            sp&lt;<span class="keyword">const</span> DisplayDevice&gt; hw(mDisplays[dpy]);</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int32_t</span> id = hw-&gt;getHwcDisplayId();</span><br><span class="line">            <span class="keyword">if</span> (id &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> Vector&lt; sp&lt;Layer&gt; &gt;&amp; currentLayers(</span><br><span class="line">                    hw-&gt;getVisibleLayersSortedByZ());</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">size_t</span> count = currentLayers.size();</span><br><span class="line">                <span class="comment">//根据Layer数量在HWComposer中创建hwc_layer_list_t列表  </span></span><br><span class="line">                <span class="keyword">if</span> (hwc.createWorkList(id, count) == NO_ERROR) &#123;</span><br><span class="line">                    HWComposer::LayerListIterator cur = hwc.begin(id);</span><br><span class="line">                    <span class="keyword">const</span> HWComposer::LayerListIterator end = hwc.end(id);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; cur!=end &amp;&amp; i&lt;count ; ++i, ++cur) &#123;</span><br><span class="line">                        <span class="keyword">const</span> sp&lt;Layer&gt;&amp; layer(currentLayers[i]);</span><br><span class="line">                        layer-&gt;setGeometry(hw, *cur);</span><br><span class="line">                        <span class="keyword">if</span> (mDebugDisableHWC || mDebugRegion || mDaltonize || mHasColorMatrix) &#123;</span><br><span class="line">                            cur-&gt;setSkip(<span class="literal">true</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set the per-frame data</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> dpy=<span class="number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">        sp&lt;<span class="keyword">const</span> DisplayDevice&gt; hw(mDisplays[dpy]);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int32_t</span> id = hw-&gt;getHwcDisplayId();</span><br><span class="line">        <span class="keyword">if</span> (id &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">bool</span> freezeSurfacePresent = <span class="literal">false</span>;</span><br><span class="line">            isfreezeSurfacePresent(freezeSurfacePresent, hw, id);</span><br><span class="line">            <span class="keyword">const</span> Vector&lt; sp&lt;Layer&gt; &gt;&amp; currentLayers(</span><br><span class="line">                hw-&gt;getVisibleLayersSortedByZ());</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">size_t</span> count = currentLayers.size();</span><br><span class="line">            HWComposer::LayerListIterator cur = hwc.begin(id);</span><br><span class="line">            <span class="keyword">const</span> HWComposer::LayerListIterator end = hwc.end(id);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; cur!=end &amp;&amp; i&lt;count ; ++i, ++cur) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * update the per-frame h/w composer data for each layer</span></span><br><span class="line"><span class="comment">                 * and build the transparent region of the FB</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">const</span> sp&lt;Layer&gt;&amp; layer(currentLayers[i]);</span><br><span class="line">                <span class="comment">//将Layer的mActiveBuffer设置到HWComposer中</span></span><br><span class="line">                layer-&gt;setPerFrameData(hw, *cur);</span><br><span class="line">                setOrientationEventControl(freezeSurfacePresent,id);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If possible, attempt to use the cursor overlay on each display.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> dpy=<span class="number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">        sp&lt;<span class="keyword">const</span> DisplayDevice&gt; hw(mDisplays[dpy]);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int32_t</span> id = hw-&gt;getHwcDisplayId();</span><br><span class="line">        <span class="keyword">if</span> (id &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> Vector&lt; sp&lt;Layer&gt; &gt;&amp; currentLayers(</span><br><span class="line">                hw-&gt;getVisibleLayersSortedByZ());</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">size_t</span> count = currentLayers.size();</span><br><span class="line">            HWComposer::LayerListIterator cur = hwc.begin(id);</span><br><span class="line">            <span class="keyword">const</span> HWComposer::LayerListIterator end = hwc.end(id);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; cur!=end &amp;&amp; i&lt;count ; ++i, ++cur) &#123;</span><br><span class="line">                <span class="keyword">const</span> sp&lt;Layer&gt;&amp; layer(currentLayers[i]);</span><br><span class="line">                <span class="keyword">if</span> (layer-&gt;isPotentialCursor()) &#123;</span><br><span class="line">                    cur-&gt;setIsCursorLayerHint();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dumpDrawCycle(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err = hwc.prepare();</span><br><span class="line">    ALOGE_IF(err, <span class="string">"HWComposer::prepare failed (%s)"</span>, strerror(-err));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> dpy=<span class="number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">        sp&lt;<span class="keyword">const</span> DisplayDevice&gt; hw(mDisplays[dpy]);</span><br><span class="line">        hw-&gt;prepareFrame(hwc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HWComposer中有一个类型为DisplayData结构的数组mDisplayData，它维护着每个显示设备的信息。DisplayData结构中有一个类型为hwc_display_contents_l字段list，这个字段又有一个hwc_layer_l类型的数组hwLayers，记录该显示设备所有需要输出的Layer信息。 setUpHWComposer函数调用HWComposer的createWorkList函数就是根据每种显示设备的Layer数量，创建和初始化hwc_display_contents_l对象和hwc_layer_l数组 创建完HWComposer中的列表后，接下来是对每个Layer对象调用它的setPerFrameData函数，参数是HWComposer和HWCLayerInterface。setPerFrameData函数将Layer对象的当前图像缓冲区mActiveBuffer设置到HWCLayerInterface对象对应的hwc_layer_l对象中。 HWComposer类中除了前面介绍的Gralloc还管理着Composer模块，这个模块实现了硬件的图像合成功能。setUpHWComposer函数接下来调用HWComposer类的prepare函数，而prepare函数会调用Composer模块的prepare接口。最后到各个厂家的实现hwc_prepare函数将每种HWComposer中的所有图层的类型都设置为HWC_FRAMEBUFFER就结束了。</p><h3 id="五、合成所有层的图像-（doComposition-函数）"><a href="#五、合成所有层的图像-（doComposition-函数）" class="headerlink" title="五、合成所有层的图像 （doComposition()函数）"></a>五、合成所有层的图像 （doComposition()函数）</h3><p>doComposition函数是合成所有层的图像，代码如下： [SurfaceFlinger.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::doComposition() &#123;</span><br><span class="line">ATRACE_CALL();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">bool</span> repaintEverything = android_atomic_and(<span class="number">0</span>, &amp;mRepaintEverything);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> dpy=<span class="number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">    <span class="keyword">const</span> sp&lt;DisplayDevice&gt;&amp; hw(mDisplays[dpy]);</span><br><span class="line">    <span class="keyword">if</span> (hw-&gt;isDisplayOn()) &#123;</span><br><span class="line">        <span class="comment">// transform the dirty region into this screen's coordinate space</span></span><br><span class="line">        const Region dirtyRegion(hw-&gt;getDirtyRegion(repaintEverything));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// repaint the framebuffer (if needed)</span></span><br><span class="line">        doDisplayComposition(hw, dirtyRegion);</span><br><span class="line"></span><br><span class="line">        hw-&gt;dirtyRegion.clear();</span><br><span class="line">        hw-&gt;flip(hw-&gt;swapRegion);</span><br><span class="line">        hw-&gt;swapRegion.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// inform the h/w that we're done compositing</span></span><br><span class="line">    hw-&gt;compositionComplete();</span><br><span class="line">&#125;</span><br><span class="line">postFramebuffer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>doComposition函数针对每种显示设备调用doDisplayComposition函数来合成，合成后调用postFramebuffer函数，我们先来看看doDisplayComposition函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::doDisplayComposition(<span class="keyword">const</span> sp&lt;<span class="keyword">const</span> DisplayDevice&gt;&amp; hw,</span><br><span class="line">    <span class="keyword">const</span> Region&amp; inDirtyRegion)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">// We only need to actually compose the display if:</span></span><br><span class="line"><span class="comment">// 1) It is being handled by hardware composer, which may need this to</span></span><br><span class="line"><span class="comment">//    keep its virtual display state machine in sync, or</span></span><br><span class="line"><span class="comment">// 2) There is work to be done (the dirty region isn't empty)</span></span><br><span class="line"><span class="keyword">bool</span> isHwcDisplay = hw-&gt;getHwcDisplayId() &gt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (!isHwcDisplay &amp;&amp; inDirtyRegion.isEmpty()) &#123;</span><br><span class="line">    ALOGV(<span class="string">"Skipping display composition"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ALOGV(<span class="string">"doDisplayComposition"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">Region <span class="title">dirtyRegion</span><span class="params">(inDirtyRegion)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compute the invalid region</span></span><br><span class="line"><span class="comment">//swapRegion设置为需要更新的区域  </span></span><br><span class="line">hw-&gt;swapRegion.orSelf(dirtyRegion);</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint32_t</span> flags = hw-&gt;getFlags();<span class="comment">//获得显示设备支持的更新方式标志  </span></span><br><span class="line"><span class="keyword">if</span> (flags &amp; DisplayDevice::SWAP_RECTANGLE) &#123;</span><br><span class="line">    <span class="comment">// we can redraw only what's dirty, but since SWAP_RECTANGLE only</span></span><br><span class="line">    <span class="comment">// takes a rectangle, we must make sure to update that whole</span></span><br><span class="line">    <span class="comment">// rectangle in that case</span></span><br><span class="line">    dirtyRegion.<span class="built_in">set</span>(hw-&gt;swapRegion.bounds());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; DisplayDevice::PARTIAL_UPDATES) &#123;<span class="comment">//支持部分更新  </span></span><br><span class="line">        <span class="comment">// We need to redraw the rectangle that will be updated</span></span><br><span class="line">        <span class="comment">// (pushed to the framebuffer).</span></span><br><span class="line">        <span class="comment">// This is needed because PARTIAL_UPDATES only takes one</span></span><br><span class="line">        <span class="comment">// rectangle instead of a region (see DisplayDevice::flip())</span></span><br><span class="line">        <span class="comment">//将更新区域调整为整个窗口大小  </span></span><br><span class="line">        dirtyRegion.<span class="built_in">set</span>(hw-&gt;swapRegion.bounds());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// we need to redraw everything (the whole screen)</span></span><br><span class="line">        dirtyRegion.<span class="built_in">set</span>(hw-&gt;bounds());</span><br><span class="line">        hw-&gt;swapRegion = dirtyRegion;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//合成  </span></span><br><span class="line"><span class="keyword">if</span> (!doComposeSurfaces(hw, dirtyRegion)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// update the swap region and clear the dirty region</span></span><br><span class="line">hw-&gt;swapRegion.orSelf(dirtyRegion);</span><br><span class="line"><span class="comment">//没有硬件composer的情况，输出图像</span></span><br><span class="line"><span class="comment">// swap buffers (presentation)</span></span><br><span class="line">hw-&gt;swapBuffers(getHwComposer());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>doDisplayComposition函数根据显示设备支持的更新方式，重新设置需要更新区域的大小。 真正的合成工作是在doComposerSurfaces函数中完成，这个函数在layer的类型为HWC_FRAMEBUFFER,或者不支持硬件的composer的情况下，调用layer的draw函数来一层一层低合成最后的图像。 合成完后，doDisplayComposition函数调用了hw的swapBuffers函数，这个函数前面介绍过了，它将在系统不支持硬件的composer情况下调用eglSwapBuffers来输出图像到显示设备。</p><h3 id="六、postFramebuffer-函数"><a href="#六、postFramebuffer-函数" class="headerlink" title="六、postFramebuffer()函数"></a>六、postFramebuffer()函数</h3><p>上一节的doComposition函数最后调用了postFramebuffer函数，代码如下： [SurfaceFlinger.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::postFramebuffer()</span><br><span class="line">&#123;</span><br><span class="line">ATRACE_CALL();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">nsecs_t</span> now = systemTime();</span><br><span class="line">mDebugInSwapBuffers = now;</span><br><span class="line"></span><br><span class="line">HWComposer&amp; hwc(getHwComposer());</span><br><span class="line"><span class="keyword">if</span> (hwc.initCheck() == NO_ERROR) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!hwc.supportsFramebufferTarget()) &#123;</span><br><span class="line">        <span class="comment">// EGL spec says:</span></span><br><span class="line">        <span class="comment">//   "surface must be bound to the calling thread's current context,</span></span><br><span class="line">        <span class="comment">//    for the current rendering API."</span></span><br><span class="line">        getDefaultDisplayDevice()-&gt;makeCurrent(mEGLDisplay, mEGLContext);</span><br><span class="line">    &#125;</span><br><span class="line">    hwc.commit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// make the default display current because the VirtualDisplayDevice code cannot</span></span><br><span class="line"><span class="comment">// deal with dequeueBuffer() being called outside of the composition loop; however</span></span><br><span class="line"><span class="comment">// the code below can call glFlush() which is allowed (and does in some case) call</span></span><br><span class="line"><span class="comment">// dequeueBuffer().</span></span><br><span class="line">getDefaultDisplayDevice()-&gt;makeCurrent(mEGLDisplay, mEGLContext);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> dpy=<span class="number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">    sp&lt;<span class="keyword">const</span> DisplayDevice&gt; hw(mDisplays[dpy]);</span><br><span class="line">    <span class="keyword">const</span> Vector&lt; sp&lt;Layer&gt; &gt;&amp; currentLayers(hw-&gt;getVisibleLayersSortedByZ());</span><br><span class="line">    hw-&gt;onSwapBuffersCompleted(hwc);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> count = currentLayers.size();</span><br><span class="line">    <span class="keyword">int32_t</span> id = hw-&gt;getHwcDisplayId();</span><br><span class="line">    <span class="keyword">if</span> (id &gt;=<span class="number">0</span> &amp;&amp; hwc.initCheck() == NO_ERROR) &#123;</span><br><span class="line">        HWComposer::LayerListIterator cur = hwc.begin(id);</span><br><span class="line">        <span class="keyword">const</span> HWComposer::LayerListIterator end = hwc.end(id);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; cur != end &amp;&amp; i &lt; count; ++i, ++cur) &#123;</span><br><span class="line">            currentLayers[i]-&gt;onLayerDisplayed(hw, &amp;*cur);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            currentLayers[i]-&gt;onLayerDisplayed(hw, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mLastSwapBufferTime = systemTime() - now;</span><br><span class="line">mDebugInSwapBuffers = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint32_t</span> flipCount = getDefaultDisplayDevice()-&gt;getPageFlipCount();</span><br><span class="line"><span class="keyword">if</span> (flipCount % LOG_FRAME_STATS_PERIOD == <span class="number">0</span>) &#123;</span><br><span class="line">    logFrameStats();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>postFramebuffer先判断系统是否支持composer，如果不支持，我们知道图像已经在doComposition函数时调用hw-&gt;swapBuffers输出了，就返回了。如果支持硬件composer，postFramebuffer函数将调用HWComposer的commit函数继续执行。 [HWComposer.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> HWComposer::commit() &#123;</span><br><span class="line"><span class="keyword">int</span> err = NO_ERROR;</span><br><span class="line"><span class="keyword">if</span> (mHwc) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1)) &#123;</span><br><span class="line">        <span class="comment">// On version 1.0, the OpenGL ES target surface is communicated</span></span><br><span class="line">        <span class="comment">// by the (dpy, sur) fields and we are guaranteed to have only</span></span><br><span class="line">        <span class="comment">// a single display.</span></span><br><span class="line">        mLists[<span class="number">0</span>]-&gt;dpy = eglGetCurrentDisplay();</span><br><span class="line">        mLists[<span class="number">0</span>]-&gt;sur = eglGetCurrentSurface(EGL_DRAW);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=VIRTUAL_DISPLAY_ID_BASE; i&lt;mNumDisplays; i++) &#123;</span><br><span class="line">        <span class="function">DisplayData&amp; <span class="title">disp</span><span class="params">(mDisplayData[i])</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (disp.outbufHandle) &#123;</span><br><span class="line">            mLists[i]-&gt;outbuf = disp.outbufHandle;</span><br><span class="line">            mLists[i]-&gt;outbufAcquireFenceFd =</span><br><span class="line">                    disp.outbufAcquireFence-&gt;dup();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = mHwc-&gt;<span class="built_in">set</span>(mHwc, mNumDisplays, mLists);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;mNumDisplays ; i++) &#123;</span><br><span class="line">        <span class="function">DisplayData&amp; <span class="title">disp</span><span class="params">(mDisplayData[i])</span></span>;</span><br><span class="line">        disp.lastDisplayFence = disp.lastRetireFence;</span><br><span class="line">        disp.lastRetireFence = Fence::NO_FENCE;</span><br><span class="line">        <span class="keyword">if</span> (disp.<span class="built_in">list</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (disp.<span class="built_in">list</span>-&gt;retireFenceFd != <span class="number">-1</span>) &#123;</span><br><span class="line">                disp.lastRetireFence = <span class="keyword">new</span> Fence(disp.<span class="built_in">list</span>-&gt;retireFenceFd);</span><br><span class="line">                disp.<span class="built_in">list</span>-&gt;retireFenceFd = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            disp.<span class="built_in">list</span>-&gt;flags &amp;= ~HWC_GEOMETRY_CHANGED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">status_t</span>)err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>合成效果图：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.graphics/20-Android-Graphics-SurfaceFlinger-composition.png" alt="Markdown"></p><h2 id="（六）、Android-SurfaceFlinger-VSync工作原理"><a href="#（六）、Android-SurfaceFlinger-VSync工作原理" class="headerlink" title="（六）、Android SurfaceFlinger - VSync工作原理"></a>（六）、Android SurfaceFlinger - VSync工作原理</h2><h3 id="一、VSYNC-总体概念"><a href="#一、VSYNC-总体概念" class="headerlink" title="一、VSYNC 总体概念"></a>一、VSYNC 总体概念</h3><h3 id="6-1-1、VSYNC-概念"><a href="#6-1-1、VSYNC-概念" class="headerlink" title="6.1.1、VSYNC 概念"></a>6.1.1、VSYNC 概念</h3><p>VSYNC（Vertical Synchronization）是一个相当古老的概念，对于游戏玩家，它有一个更加大名鼎鼎的中文名字—垂直同步。 “垂直同步(vsync)”指的是显卡的输出帧数和屏幕的垂直刷新率相同，这完全是一个CRT显示器上的概念。其实无论是VSYNC还是垂直同步这个名字，因为LCD根本就没有垂直扫描的这种东西，因此这个名字本身已经没有意义。但是基于历史的原因，这个名称在图形图像领域被沿袭下来。 在当下，垂直同步的含义我们可以理解为，使得显卡生成帧的速度和屏幕刷新的速度的保持一致。举例来说，如果屏幕的刷新率为60Hz，那么生成帧的速度就应该被固定在1/60 s。</p><h3 id="6-1-2、Android-VSYNC-–-黄油计划"><a href="#6-1-2、Android-VSYNC-–-黄油计划" class="headerlink" title="6.1.2、Android VSYNC – 黄油计划"></a>6.1.2、Android VSYNC – 黄油计划</h3><p>谷歌为解决Android系统流畅性问题。在4.1版本引入了一个重大的改进–Project Butter黄油计划。 Project Butter对Android Display系统进行了重构，引入了三个核心元素，即VSYNC、Triple Buffer和Choreographer。 VSYNC最重要的作用是防止出现画面撕裂（screentearing）。所谓画面撕裂，就是指一个画面上出现了两帧画面的内容，如下图。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.graphics/21-Android-graphics-view-teaning.png" alt="Markdown"></p><p>为什么会出现这种情况呢？这种情况一般是因为显卡输出帧的速度高于显示器的刷新速度，导致显示器并不能及时处理输出的帧，而最终出现了多个帧的画面都留在了显示器上的问题。这也就是我们所说的画面撕裂。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.graphics/22-Android-Graphics-Draw-whithout-vsync.png" alt="Markdown"></p><p>这个图中有三个元素，Display是显示屏幕，GPU和CPU负责渲染帧数据，每个帧以方框表示，并以数字进行编号，如0、1、2等等。VSync用于指导双缓冲区的交换。 以时间的顺序来看下将会发生的异常： Step1. Display显示第0帧数据，此时CPU和GPU渲染第1帧画面，而且赶在Display显示下一帧前完成 Step2. 因为渲染及时，Display在第0帧显示完成后，也就是第1个VSync后，正常显示第1帧 Step3. 由于某些原因，比如CPU资源被占用，系统没有及时地开始处理第2帧，直到第2个VSync快来前才开始处理 Step4. 第2个VSync来时，由于第2帧数据还没有准备就绪，显示的还是第1帧。这种情况被Android开发组命名为”Jank”。 Step5. 当第2帧数据准备完成后，它并不会马上被显示，而是要等待下一个VSync。 所以总的来说，就是屏幕平白无故地多显示了一次第1帧。原因大家应该都看到了，就是CPU没有及时地开始着手处理第2帧的渲染工作，以致”延误军机”。</p><p>其实总结上面的这个情况之所以发生，首先的原因就在于第二帧没有及时的绘制（当然即使第二帧及时绘制，也依然可能出现Jank，这就是同时引入三重缓冲的作用。我们将在三重缓冲一节中再讲解这种情况）。那么如何使得第二帧即使被绘制呢？ 这就是我们在Graphic系统中引入VSYNC的原因，考虑下面这张图：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.graphics/23-Android-Graphics-Draw-whit-vsync.png" alt="Markdown"></p><p>如上图所示，一旦VSync出现后，立刻就开始执行下一帧的绘制工作。这样就可以大大降低Jank出现的概率。另外，VSYNC引入后，要求绘制也只能在收到VSYNC消息之后才能进行，因此，也就杜绝了另外一种极端情况的出现—CPU（GPU）一直不停的进行绘制，帧的生成速度高于屏幕的刷新速度，导致生成的帧不能被显示，只能丢弃，这样就出现了丢帧的情况—引入VSYNC后，绘制的速度就和屏幕刷新的速度保持一致了。</p><h3 id="二、VSync信号产生"><a href="#二、VSync信号产生" class="headerlink" title="二、VSync信号产生"></a>二、VSync信号产生</h3><p>那么VSYNC信号是如何生成的呢？ Android系统中VSYNC信号分为两种，一种是硬件生成的信号，一种是软件模拟的信号。 硬件信号是由HardwareComposer提供的，HWC封装了相关的HAL层，如果硬件厂商提供的HAL层实现能定时产生VSYNC中断，则直接使用硬件的VSYNC中断，否则HardwareComposer内部会通过VSyncThread来模拟产生VSYNC中断（其实现很简单，就是sleep固定时间，然后唤醒）。</p><p>SurfaceFlinger的启动过程中inti()会创建一个HWComposer对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">HWComposer::HWComposer(  </span><br><span class="line">        <span class="keyword">const</span> sp&lt;SurfaceFlinger&gt;&amp; flinger,  </span><br><span class="line">        EventHandler&amp; handler)  </span><br><span class="line">    : mFlinger(flinger),  </span><br><span class="line">      mFbDev(<span class="number">0</span>), mHwc(<span class="number">0</span>), mNumDisplays(<span class="number">1</span>),  </span><br><span class="line">      mCBContext(<span class="keyword">new</span> cb_context),  </span><br><span class="line">      mEventHandler(handler),  </span><br><span class="line">      mDebugForceFakeVSync(<span class="literal">false</span>)  </span><br><span class="line">&#123;  </span><br><span class="line">...  </span><br><span class="line">    <span class="comment">//首先是一些和VSYNC有关的信息的初始化  </span></span><br><span class="line">    <span class="comment">//因为在硬件支持的情况下，VSYNC的功能就是由HWC提供的  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;HWC_NUM_PHYSICAL_DISPLAY_TYPES ; i++) &#123;  </span><br><span class="line">        mLastHwVSync[i] = <span class="number">0</span>;  </span><br><span class="line">        mVSyncCounts[i] = <span class="number">0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//根据配置来看是否需要模拟VSYNC消息  </span></span><br><span class="line">    <span class="keyword">char</span> value[PROPERTY_VALUE_MAX];  </span><br><span class="line">    property_get(<span class="string">"debug.sf.no_hw_vsync"</span>, value, <span class="string">"0"</span>);  </span><br><span class="line">    mDebugForceFakeVSync = atoi(value);  </span><br><span class="line">    ...  </span><br><span class="line">    <span class="comment">// don't need a vsync thread if we have a hardware composer  </span></span><br><span class="line">    needVSyncThread = <span class="literal">false</span>;  </span><br><span class="line">    <span class="comment">// always turn vsync off when we start,只是暂时关闭信号，后面会再开启  </span></span><br><span class="line">    eventControl(HWC_DISPLAY_PRIMARY, HWC_EVENT_VSYNC, <span class="number">0</span>);      </span><br><span class="line"></span><br><span class="line">    <span class="comment">//显然，如果需要模拟VSync信号的话，我们需要线程来做这个工作  </span></span><br><span class="line">    <span class="keyword">if</span> (needVSyncThread) &#123;  </span><br><span class="line">        <span class="comment">// we don't have VSYNC support, we need to fake it  </span></span><br><span class="line">        <span class="comment">//VSyncThread类的实现很简单，无非就是一个计时器而已，定时发送消息而已  </span></span><br><span class="line">        <span class="comment">//TODO VSYNC专题  </span></span><br><span class="line">        mVSyncThread = <span class="keyword">new</span> VSyncThread(*<span class="keyword">this</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">...  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">HWComposer::HWComposer(  </span><br><span class="line">        <span class="keyword">const</span> sp&lt;SurfaceFlinger&gt;&amp; flinger,  </span><br><span class="line">        EventHandler&amp; handler)  </span><br><span class="line">    : mFlinger(flinger),  </span><br><span class="line">      mFbDev(<span class="number">0</span>), mHwc(<span class="number">0</span>), mNumDisplays(<span class="number">1</span>),  </span><br><span class="line">      mCBContext(<span class="keyword">new</span> cb_context),  </span><br><span class="line">      mEventHandler(handler),  </span><br><span class="line">      mDebugForceFakeVSync(<span class="literal">false</span>)  </span><br><span class="line">&#123;  </span><br><span class="line">...  </span><br><span class="line">    <span class="comment">//首先是一些和VSYNC有关的信息的初始化  </span></span><br><span class="line">    <span class="comment">//因为在硬件支持的情况下，VSYNC的功能就是由HWC提供的  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;HWC_NUM_PHYSICAL_DISPLAY_TYPES ; i++) &#123;  </span><br><span class="line">        mLastHwVSync[i] = <span class="number">0</span>;  </span><br><span class="line">        mVSyncCounts[i] = <span class="number">0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//根据配置来看是否需要模拟VSYNC消息  </span></span><br><span class="line">    <span class="keyword">char</span> value[PROPERTY_VALUE_MAX];  </span><br><span class="line">    property_get(<span class="string">"debug.sf.no_hw_vsync"</span>, value, <span class="string">"0"</span>);  </span><br><span class="line">    mDebugForceFakeVSync = atoi(value);  </span><br><span class="line">    ...  </span><br><span class="line">    <span class="comment">// don't need a vsync thread if we have a hardware composer  </span></span><br><span class="line">    needVSyncThread = <span class="literal">false</span>;  </span><br><span class="line">    <span class="comment">// always turn vsync off when we start,只是暂时关闭信号，后面会再开启  </span></span><br><span class="line">    eventControl(HWC_DISPLAY_PRIMARY, HWC_EVENT_VSYNC, <span class="number">0</span>);      </span><br><span class="line"></span><br><span class="line">    <span class="comment">//显然，如果需要模拟VSync信号的话，我们需要线程来做这个工作  </span></span><br><span class="line">    <span class="keyword">if</span> (needVSyncThread) &#123;  </span><br><span class="line">        <span class="comment">// we don't have VSYNC support, we need to fake it  </span></span><br><span class="line">        <span class="comment">//VSyncThread类的实现很简单，无非就是一个计时器而已，定时发送消息而已  </span></span><br><span class="line">        <span class="comment">//TODO VSYNC专题  </span></span><br><span class="line">        mVSyncThread = <span class="keyword">new</span> VSyncThread(*<span class="keyword">this</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看下上面这段代码。 首先mDebugForceFakeVSync是为了调制，可以通过这个变量设置强制使用软件VSYNC模拟。 然后针对不同的屏幕，初始化了他们的mLastHwVSync和mVSyncCounts值。 如果硬件支持，那么就把needVSyncThread设置为false，表示不需要软件模拟。 接着通过eventControl来暂时的关闭了VSYNC信号，这一点将在下面讲解eventControl时一并讲解。 最后，如果需要软件模拟Vsync信号的话，那么我们将通过一个单独的VSyncThread线程来做这个工作(fake VSYNC是这个线程唯一的作用)。我们来看下这个线程。</p><p><strong>软件模拟</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> HWComposer::VSyncThread::threadLoop() &#123;  </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">nsecs_t</span> period = mRefreshPeriod;  </span><br><span class="line">    <span class="comment">//当前的时间  </span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">nsecs_t</span> now = systemTime(CLOCK_MONOTONIC);  </span><br><span class="line">    <span class="comment">//下一次VSYNC到来的时间  </span></span><br><span class="line">    <span class="keyword">nsecs_t</span> next_vsync = mNextFakeVSync;  </span><br><span class="line">    <span class="comment">//为了等待下个时间到来应该休眠的时间  </span></span><br><span class="line">    <span class="keyword">nsecs_t</span> sleep = next_vsync - now;  </span><br><span class="line">    <span class="comment">//错过了VSYNC的时间  </span></span><br><span class="line">    <span class="keyword">if</span> (sleep &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="comment">// we missed, find where the next vsync should be  </span></span><br><span class="line">        <span class="comment">//重新计算下应该休息的时间  </span></span><br><span class="line">        sleep = (period - ((now - next_vsync) % period));  </span><br><span class="line">        <span class="comment">//更新下次VSYNC的时间  </span></span><br><span class="line">        next_vsync = now + sleep;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//更新下下次VSYNC的时间  </span></span><br><span class="line">    mNextFakeVSync = next_vsync + period;  </span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">spec</span>;</span>  </span><br><span class="line">    spec.tv_sec  = next_vsync / <span class="number">1000000000</span>;  </span><br><span class="line">    spec.tv_nsec = next_vsync % <span class="number">1000000000</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> err;  </span><br><span class="line">    <span class="keyword">do</span> &#123;  </span><br><span class="line">        <span class="comment">//纳秒精度级的休眠  </span></span><br><span class="line">        err = clock_nanosleep(CLOCK_MONOTONIC, TIMER_ABSTIME, &amp;spec, <span class="literal">NULL</span>);  </span><br><span class="line">    &#125; <span class="keyword">while</span> (err&lt;<span class="number">0</span> &amp;&amp; errno == EINTR);  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err == <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="comment">//休眠之后，到了该发生VSYNC的时间了  </span></span><br><span class="line">        mHwc.mEventHandler.onVSyncReceived(<span class="number">0</span>, next_vsync);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数其实很简单，无非就是一个简单的时间计算，计算过程我已经写在了程序注释里面。总之到了应该发生VSYNC信号的时候，就调用了mHwc.mEventHandler.onVSyncReceived(0, next_vsync)函数来通知VSYNC的到来。</p><p>我们注意到mEventHandler实际上是在HWC创建时被传入的，我们来看下HWC创建时的代码.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mHwc = new HWComposer(this,  </span><br><span class="line">        *static_cast&lt;HWComposer::EventHandler *&gt;(this));  </span><br><span class="line"></span><br><span class="line">class SurfaceFlinger : public BnSurfaceComposer,  </span><br><span class="line">                   private IBinder::DeathRecipient,  </span><br><span class="line">                   private HWComposer::EventHandler</span><br></pre></td></tr></table></figure><p>可以看到这个mEventHandler实际上就是SurfaceFlinger。也就是说，VSYNC信号到来时，SurfaceFlinger的onVSyncReceived函数处理了这个消息。 这里我们暂时先不展开SurfaceFlinger内的逻辑处理，等我们下面分析完硬件实现后，一并进行分析</p><p><strong>硬件实现</strong> 上面我们讲了软件如何模拟一个VSYNC信号并通知SurfaceFlinger,那么硬件又是如何实现这一点的呢？ 我们再一次回到HWC的创建过程中来：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mHwc) &#123;  </span><br><span class="line">       ALOGE(<span class="string">"Lee Using %s version %u.%u"</span>, HWC_HARDWARE_COMPOSER,  </span><br><span class="line">             (hwcApiVersion(mHwc) &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>,  </span><br><span class="line">             (hwcApiVersion(mHwc) &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>);  </span><br><span class="line">       <span class="keyword">if</span> (mHwc-&gt;registerProcs) &#123;  </span><br><span class="line">           mCBContext-&gt;hwc = <span class="keyword">this</span>;  </span><br><span class="line">           mCBContext-&gt;procs.invalidate = &amp;hook_invalidate;  </span><br><span class="line">           mCBContext-&gt;procs.vsync = &amp;hook_vsync;  </span><br><span class="line">           <span class="keyword">if</span> (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1))  </span><br><span class="line">               mCBContext-&gt;procs.hotplug = &amp;hook_hotplug;  </span><br><span class="line">           <span class="keyword">else</span>  </span><br><span class="line">               mCBContext-&gt;procs.hotplug = <span class="literal">NULL</span>;  </span><br><span class="line">           <span class="built_in">memset</span>(mCBContext-&gt;procs.zero, <span class="number">0</span>, <span class="keyword">sizeof</span>(mCBContext-&gt;procs.zero));  </span><br><span class="line">           mHwc-&gt;registerProcs(mHwc, &amp;mCBContext-&gt;procs);  </span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>来看下上面这段实现。 当HWC有vsync信号生成时，硬件模块会通过procs.vsync来通知软件部分，因此也就是调用了hook_vsync函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> HWComposer::hook_vsync(<span class="keyword">const</span> struct hwc_procs* procs, <span class="keyword">int</span> disp,  </span><br><span class="line">        <span class="keyword">int64_t</span> timestamp) &#123;  </span><br><span class="line">    cb_context* ctx = <span class="keyword">reinterpret_cast</span>&lt;cb_context*&gt;(  </span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">hwc_procs_t</span>*&gt;(procs));  </span><br><span class="line">    ctx-&gt;hwc-&gt;vsync(disp, timestamp);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> HWComposer::vsync(<span class="keyword">int</span> disp, <span class="keyword">int64_t</span> timestamp) &#123;  </span><br><span class="line">    <span class="comment">//只有真实的硬件设备才会产生VSYNC  </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">uint32_t</span>(disp) &lt; HWC_NUM_PHYSICAL_DISPLAY_TYPES) &#123;  </span><br><span class="line">        &#123;  </span><br><span class="line">            mLastHwVSync[disp] = timestamp;  </span><br><span class="line">        &#125;  </span><br><span class="line">        mEventHandler.onVSyncReceived(disp, timestamp);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现最后殊途同归，硬件信号最终也通过onVSyncReceived函数通知到了SurfaceFlinger了。下面我们来分析下SurfaceFlinger的处理过程。</p><h3 id="三、Surfaceflinger对VSYNC消息的处理"><a href="#三、Surfaceflinger对VSYNC消息的处理" class="headerlink" title="三、Surfaceflinger对VSYNC消息的处理"></a>三、Surfaceflinger对VSYNC消息的处理</h3><p>先来直接看下Surfaceflinger的onVSyncReceived函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::onVSyncReceived(<span class="keyword">int32_t</span> type, <span class="keyword">nsecs_t</span> timestamp) &#123;</span><br><span class="line">    <span class="keyword">bool</span> needsHwVsync = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">// Scope for the lock</span></span><br><span class="line">        Mutex::Autolock _l(mHWVsyncLock);</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">0</span> &amp;&amp; mPrimaryHWVsyncEnabled) &#123;</span><br><span class="line">            needsHwVsync = mPrimaryDispSync.addResyncSample(timestamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (needsHwVsync) &#123;</span><br><span class="line">        enableHardwareVsync();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        disableHardwareVsync(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mPrimaryDispSync是什么？addResyncSample有什么作用？ 要回答这三个问题，我们首先还是得回到SurfaceFlinger的init函数中来。</p><h3 id="6-3-1、Surfaceflinger-init"><a href="#6-3-1、Surfaceflinger-init" class="headerlink" title="6.3.1、Surfaceflinger.init()"></a>6.3.1、Surfaceflinger.init()</h3><p>先看一下总体flow：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.graphics/24-Android-Graphics-Vsync-surfaceflinger.init.png" alt="Markdown"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void SurfaceFlinger::init() &#123;</span><br><span class="line">    ALOGI(  &quot;SurfaceFlinger&apos;s main thread ready to run. &quot;</span><br><span class="line">            &quot;Initializing graphics H/W...&quot;);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        ......</span><br><span class="line">        // start the EventThread</span><br><span class="line">        sp&lt;VSyncSource&gt; vsyncSrc = new DispSyncSource(&amp;mPrimaryDispSync,</span><br><span class="line">                vsyncPhaseOffsetNs, true, &quot;app&quot;);</span><br><span class="line">        mEventThread = new EventThread(vsyncSrc, *this);</span><br><span class="line">        sp&lt;VSyncSource&gt; sfVsyncSrc = new DispSyncSource(&amp;mPrimaryDispSync,</span><br><span class="line">                sfVsyncPhaseOffsetNs, true, &quot;sf&quot;);</span><br><span class="line">        mSFEventThread = new EventThread(sfVsyncSrc, *this);</span><br><span class="line">        mEventQueue.setEventThread(mSFEventThread);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    mEventControlThread = new EventControlThread(this);</span><br><span class="line">    mEventControlThread-&gt;run(&quot;EventControl&quot;, PRIORITY_URGENT_DISPLAY);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2个EventThread对象分别是mEventThread，给app用，mSFEventThread，给surfaceflinger自己用。 下面给出这4个Thread关系图。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.graphics/25-Android-Graphics-SurfaceFlinger.init.DispSyncThread.png.png" alt="Markdown"></p><p>这两个DispSyncSource就是KK引入的重大变化。Android 4.4(KitKat)引入了VSync的虚拟化，即把硬件的VSync信号先同步到一个本地VSync模型中，再从中一分为二，引出两条VSync时间与之有固定偏移的线程。示意图如下：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.graphics/26-Android-Graphics-SurfaceFlinger-App-Vsync-offset.png.png" alt="Markdown"></p><p>Google这样修改的目的又是什么呢？ =在当前三重缓冲区的架构下，即对于一帧内容，先等App UI画完了，SurfaceFlinger再出场对其进行合并渲染后放入framebuffer，最后整到屏幕上。而现有的VSync模型是让大家一起开始干活。 这个架构其实会产生一个问题，因为App和SurfaceFlinger被同时唤醒，导致他们二者总是一起工作，必然导致VSync来临的时刻，这二者之间产生了CPU资源的抢占。因此，谷歌给这两个工作都加上一个小小的延迟，让这两个工作并不是同时被唤醒，这样大家就可以错开使用资源的高峰期，提高工作的效率。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.graphics/27-Android-graphics-SurfaceFlinger-Vsync-app-sf.png" alt="Markdown"></p><p>这两个延迟，其实就分别对应上面代码中的vsyncSrc（绘制延迟）和sfVsyncSrc（合成延迟）。 在创建了两个DispSyncSource变量后，我们使用它们来初始化了两个EventThread。下面我们来详细看下EventThread的创建流程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">EventThread::EventThread(<span class="keyword">const</span> sp&lt;VSyncSource&gt;&amp; src, SurfaceFlinger&amp; flinger)</span><br><span class="line">    : mVSyncSource(src),</span><br><span class="line">      mFlinger(flinger),</span><br><span class="line">      mUseSoftwareVSync(<span class="literal">false</span>),</span><br><span class="line">      mVsyncEnabled(<span class="literal">false</span>),</span><br><span class="line">      mDebugVsyncEnabled(<span class="literal">false</span>),</span><br><span class="line">      mVsyncHintSent(<span class="literal">false</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int32_t</span> i=<span class="number">0</span> ; i&lt;DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES ; i++) &#123;</span><br><span class="line">        mVSyncEvent[i].header.type = DisplayEventReceiver::DISPLAY_EVENT_VSYNC;</span><br><span class="line">        mVSyncEvent[i].header.id = <span class="number">0</span>;</span><br><span class="line">        mVSyncEvent[i].header.timestamp = <span class="number">0</span>;</span><br><span class="line">        mVSyncEvent[i].vsync.count =  <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigevent</span> <span class="title">se</span>;</span></span><br><span class="line">    se.sigev_notify = SIGEV_THREAD;</span><br><span class="line">    se.sigev_value.sival_ptr = <span class="keyword">this</span>;</span><br><span class="line">    se.sigev_notify_function = vsyncOffCallback;</span><br><span class="line">    se.sigev_notify_attributes = <span class="literal">NULL</span>;</span><br><span class="line">    timer_create(CLOCK_MONOTONIC, &amp;se, &amp;mTimerId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> EventThread::onFirstRef() &#123;</span><br><span class="line">    run(<span class="string">"EventThread"</span>, PRIORITY_URGENT_DISPLAY + PRIORITY_MORE_FAVORABLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EventThread的构造函数很简单。重点是它的onFirstRef函数启动了一个EventThread线程，于是下面的代码才是重点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> EventThread::threadLoop() &#123;</span><br><span class="line">    DisplayEventReceiver::Event event;</span><br><span class="line">    Vector&lt; sp&lt;EventThread::Connection&gt; &gt; signalConnections;</span><br><span class="line">    signalConnections = waitForEvent(&amp;event);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dispatch events to listeners...</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> count = signalConnections.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;count ; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Connection&gt;&amp; conn(signalConnections[i]);</span><br><span class="line">        <span class="comment">// now see if we still need to report this event</span></span><br><span class="line">        <span class="keyword">status_t</span> err = conn-&gt;postEvent(event);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数本身并不复杂，其中调用了一个waitForEvent的函数。这个函数相当之长，为了防止代码展开太多，我们这里暂时不再详细分析这个函数。我们目前只需要知道这个函数的最重要的作用是等待Event的到来，并且查找对event感兴趣的监听者，而在没有event到来时，线程处于休眠状态，等待event的唤醒（我们将下一篇VSYNC的接收和处理中展开分析这个函数）。 这样，EventThread线程就运行起来，处在等待被event唤醒的状态下。 <strong>MessageQueue和EventThread建立连接</strong> 简单说明完EventThread之后，我们再次回到SurfaceFlinger的init过程中来。回到init()函数代码中来： 将SurfaceFlinger的MessageQueue真正和我们刚才创建的EventThread建立起了连接，这样SurfaceFlinger才能真正接收到来自HWC的VSYNC信号。 我们来看下这段代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MessageQueue::setEventThread(<span class="keyword">const</span> sp&lt;EventThread&gt;&amp; eventThread)  </span><br><span class="line">&#123;  </span><br><span class="line">    mEventThread = eventThread;  </span><br><span class="line">    mEvents = eventThread-&gt;createEventConnection();  </span><br><span class="line">    mEventTube = mEvents-&gt;getDataChannel();  </span><br><span class="line">    mLooper-&gt;addFd(mEventTube-&gt;getFd(), <span class="number">0</span>, ALOOPER_EVENT_INPUT,  </span><br><span class="line">            MessageQueue::cb_eventReceiver, <span class="keyword">this</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里代码逻辑其实很简单，就是创建了一个到EventThread的连接，得到了发送VSYNC事件通知的BitTube，然后监控这个BitTube中的套接字，并且指定了收到通知后的回调函数，MessageQueue::cb_eventReceiver。这样一旦VSync信号传来，函数cb_eventReceiver将被调用。 <strong>向Eventhread注册一个事件的监听者—-createEventConnection</strong> 在SurfaceFlinger的init函数中，我们调用了mEventQueue.setEventThread(mSFEventThread)函数，我们在前面一章中已经提到过，这个函数将SurfaceFlinger的MessageQueue真正和我们刚才创建的EventThread建立起了连接。我们来看下这段代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;EventThread::Connection&gt; EventThread::createEventConnection() <span class="keyword">const</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Connection(<span class="keyword">const_cast</span>&lt;EventThread*&gt;(<span class="keyword">this</span>));  </span><br><span class="line">&#125;  </span><br><span class="line">EventThread::Connection::Connection(  </span><br><span class="line">        <span class="keyword">const</span> sp&lt;EventThread&gt;&amp; eventThread)  </span><br><span class="line">    : count(<span class="number">-1</span>), mEventThread(eventThread), mChannel(<span class="keyword">new</span> BitTube())  </span><br><span class="line">&#123;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">void</span> EventThread::Connection::onFirstRef() &#123;  </span><br><span class="line">    mEventThread-&gt;registerDisplayEventConnection(<span class="keyword">this</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">status_t</span> EventThread::registerDisplayEventConnection(  </span><br><span class="line">        <span class="keyword">const</span> sp&lt;EventThread::Connection&gt;&amp; connection) &#123;  </span><br><span class="line">    mDisplayEventConnections.add(connection);  </span><br><span class="line">    mCondition.broadcast();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数会导致一个Connection类的创建，而这个connection类会被保存在EventThread下的一个容器内。 通过createEventConnection这样一个简单的方法，我们其实就注册了一个事件的监听者，得到了发送VSYNC事件通知的BitTube，然后监控这个BitTube中的套接字，并且指定了收到通知后的回调函数，MessageQueue::cb_eventReceiver。这样一旦VSync信号传来，函数cb_eventReceiver将被调用。</p><h3 id="6-3-2、VSync信号的处理"><a href="#6-3-2、VSync信号的处理" class="headerlink" title="6.3.2、VSync信号的处理"></a>6.3.2、VSync信号的处理</h3><p>我们在前面一章也提到了无论是软件方式还是硬件方式，SurfaceFlinger收到VSync信号后，处理函数都是onVSyncReceived函数：</p><p><strong>VSync消息处理—-addResyncSample</strong><br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.graphics/28-Android-Graphics-SF-Vsync-addResyncSample.png.png" alt="Markdown"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> DispSync::addResyncSample(<span class="keyword">nsecs_t</span> timestamp) &#123;  </span><br><span class="line">    <span class="keyword">size_t</span> idx = (mFirstResyncSample + mNumResyncSamples) % MAX_RESYNC_SAMPLES;  </span><br><span class="line">    mResyncSamples[idx] = timestamp;  </span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    updateModelLocked();  </span><br><span class="line">    .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>粗略浏览下这个函数，发现前半部分其实在做一些简单的计数统计，重点实现显然是updateModelLocked函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">void DispSync::updateModelLocked() &#123;  </span><br><span class="line">    if (mNumResyncSamples &gt;= MIN_RESYNC_SAMPLES_FOR_UPDATE) &#123;  </span><br><span class="line">        nsecs_t durationSum = 0;  </span><br><span class="line">        for (size_t i = 1; i &lt; mNumResyncSamples; i++) &#123;  </span><br><span class="line">            size_t idx = (mFirstResyncSample + i) % MAX_RESYNC_SAMPLES;  </span><br><span class="line">            size_t prev = (idx + MAX_RESYNC_SAMPLES - 1) % MAX_RESYNC_SAMPLES;  </span><br><span class="line">            durationSum += mResyncSamples[idx] - mResyncSamples[prev];  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        mPeriod = durationSum / (mNumResyncSamples - 1);  </span><br><span class="line"></span><br><span class="line">        double sampleAvgX = 0;  </span><br><span class="line">        double sampleAvgY = 0;  </span><br><span class="line">        double scale = 2.0 * M_PI / double(mPeriod);  </span><br><span class="line">        for (size_t i = 0; i &lt; mNumResyncSamples; i++) &#123;  </span><br><span class="line">            size_t idx = (mFirstResyncSample + i) % MAX_RESYNC_SAMPLES;  </span><br><span class="line">            nsecs_t sample = mResyncSamples[idx];  </span><br><span class="line">            double samplePhase = double(sample % mPeriod) * scale;  </span><br><span class="line">            sampleAvgX += cos(samplePhase);  </span><br><span class="line">            sampleAvgY += sin(samplePhase);  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        sampleAvgX /= double(mNumResyncSamples);  </span><br><span class="line">        sampleAvgY /= double(mNumResyncSamples);  </span><br><span class="line"></span><br><span class="line">        mPhase = nsecs_t(atan2(sampleAvgY, sampleAvgX) / scale);  </span><br><span class="line">        ......</span><br><span class="line">        mThread-&gt;updateModel(mPeriod, mPhase);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不得不说，前面大段的数学计算让人有些困惑，我们暂且跳过，先分析下主线流程，也就是mThread-&gt;updateModel(mPeriod, mPhase)这个调用：</p><p><strong>DispSyncThread.updateModel的用途</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateModel</span><span class="params">(<span class="keyword">nsecs_t</span> period, <span class="keyword">nsecs_t</span> phase)</span> </span>&#123;  </span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;  </span><br><span class="line">    mPeriod = period;  </span><br><span class="line">    mPhase = phase;  </span><br><span class="line">    mCond.signal();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>updateModel是DispSyncThread类的函数，这个函数本身代码很短，其实它的主要作用是mCond.signal发送一个信号给等待中的线程。那么究竟是谁在等待这个条件呢？ 其实等待这个条件的正是DispSyncThread的循环函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">threadLoop</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">      <span class="keyword">status_t</span> err;  </span><br><span class="line">      <span class="keyword">nsecs_t</span> now = systemTime(SYSTEM_TIME_MONOTONIC);  </span><br><span class="line">      <span class="keyword">nsecs_t</span> nextEventTime = <span class="number">0</span>;  </span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;  </span><br><span class="line">          Vector&lt;CallbackInvocation&gt; callbackInvocations;  </span><br><span class="line">          <span class="keyword">nsecs_t</span> targetTime = <span class="number">0</span>;  </span><br><span class="line">          &#123; <span class="comment">// Scope for lock  </span></span><br><span class="line">              Mutex::<span class="function">Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;  </span><br><span class="line">              ......</span><br><span class="line">              <span class="keyword">if</span> (mPeriod == <span class="number">0</span>) &#123;  </span><br><span class="line">                  err = mCond.wait(mMutex);  </span><br><span class="line">                  ......</span><br><span class="line">              &#125;  </span><br><span class="line">              nextEventTime = computeNextEventTimeLocked(now);  </span><br><span class="line">              targetTime = nextEventTime;  </span><br><span class="line">              ......</span><br><span class="line">              &#125;  </span><br><span class="line">              now = systemTime(SYSTEM_TIME_MONOTONIC);  </span><br><span class="line">              ......</span><br><span class="line">              callbackInvocations = gatherCallbackInvocationsLocked(now);  </span><br><span class="line">          &#125;  </span><br><span class="line">          <span class="keyword">if</span> (callbackInvocations.size() &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">              fireCallbackInvocations(callbackInvocations);  </span><br><span class="line">          &#125;  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>大量的时间相关的计算和状态的转变我们不再深入研究，我们来看下这个线程被通知唤醒之后做的两个主要的函数的处理，gatherCallbackInvocationsLocked()和fireCallbackInvocations()。</p><p>gatherCallbackInvocationsLocked()的代码其实很简单：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Vector&lt;CallbackInvocation&gt; gatherCallbackInvocationsLocked(<span class="keyword">nsecs_t</span> now) &#123;  </span><br><span class="line">    Vector&lt;CallbackInvocation&gt; callbackInvocations;  </span><br><span class="line">    <span class="keyword">nsecs_t</span> ref = now - mPeriod;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mEventListeners.size(); i++) &#123;  </span><br><span class="line">        <span class="keyword">nsecs_t</span> t = computeListenerNextEventTimeLocked(mEventListeners[i],  </span><br><span class="line">                ref);  </span><br><span class="line">        <span class="keyword">if</span> (t &lt; now) &#123;  </span><br><span class="line">            CallbackInvocation ci;  </span><br><span class="line">            ci.mCallback = mEventListeners[i].mCallback;  </span><br><span class="line">            ci.mEventTime = t;  </span><br><span class="line">            callbackInvocations.push(ci);  </span><br><span class="line">            mEventListeners.editItemAt(i).mLastEventTime = t;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> callbackInvocations;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是从mEventListeners取出之前注册的事件监听者，放入callbackInvocations中，等待后面的调用。至于监听者从何处而来？在waitforevent时通过enableVSyncLocked注册的。</p><p>继续看下fireCallbackInvocations()函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fireCallbackInvocations</span><span class="params">(<span class="keyword">const</span> Vector&lt;CallbackInvocation&gt;&amp; callbacks)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; callbacks.size(); i++) &#123;  </span><br><span class="line">        callbacks[i].mCallback-&gt;onDispSyncEvent(callbacks[i].mEventTime);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;`</span><br></pre></td></tr></table></figure><p>我们目前只分析主线的走向,接下来调用了DispSyncSource的onDispSyncEvent在：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onDispSyncEvent</span><span class="params">(<span class="keyword">nsecs_t</span> when)</span> </span>&#123;  </span><br><span class="line">        sp&lt;VSyncSource::Callback&gt; callback;  </span><br><span class="line">        &#123;  </span><br><span class="line">            callback = mCallback;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (callback != <span class="literal">NULL</span>) &#123;  </span><br><span class="line">            callback-&gt;onVSyncEvent(when);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"><span class="keyword">void</span> EventThread::onVSyncEvent(<span class="keyword">nsecs_t</span> timestamp) &#123;  </span><br><span class="line">    Mutex::Autolock _l(mLock);  </span><br><span class="line">    mVSyncEvent[<span class="number">0</span>].header.type = DisplayEventReceiver::DISPLAY_EVENT_VSYNC;  </span><br><span class="line">    mVSyncEvent[<span class="number">0</span>].header.id = <span class="number">0</span>;  </span><br><span class="line">    mVSyncEvent[<span class="number">0</span>].header.timestamp = timestamp;  </span><br><span class="line">    mVSyncEvent[<span class="number">0</span>].vsync.count++;  </span><br><span class="line">    mCondition.broadcast();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到这里mCondition.broadcas发出了命令，那么EventThread中waitforEvent的等待就会被唤醒。而一旦唤醒，我们就回到了EventThread的loop中，我们来看下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">bool EventThread::threadLoop() &#123;  </span><br><span class="line">    DisplayEventReceiver::Event event;  </span><br><span class="line">    Vector&lt; sp&lt;EventThread::Connection&gt; &gt; signalConnections;  </span><br><span class="line">    signalConnections = waitForEvent(&amp;event);  </span><br><span class="line"></span><br><span class="line">    // dispatch events to listeners...  </span><br><span class="line">    const size_t count = signalConnections.size();  </span><br><span class="line">    for (size_t i=0 ; i&lt;count ; i++) &#123;  </span><br><span class="line">        const sp&lt;Connection&gt;&amp; conn(signalConnections[i]);  </span><br><span class="line">        // now see if we still need to report this event  </span><br><span class="line">        status_t err = conn-&gt;postEvent(event);  </span><br><span class="line">        ......</span><br><span class="line">    &#125;  </span><br><span class="line">    return true;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要就是通过conn-&gt;postEvent来分发事件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> EventThread::Connection::postEvent(  </span><br><span class="line">        <span class="keyword">const</span> DisplayEventReceiver::Event&amp; event) &#123;  </span><br><span class="line">    <span class="keyword">ssize_t</span> size = DisplayEventReceiver::sendEvents(mChannel, &amp;event, <span class="number">1</span>);  </span><br><span class="line">    <span class="keyword">return</span> size &lt; <span class="number">0</span> ? <span class="keyword">status_t</span>(size) : <span class="keyword">status_t</span>(NO_ERROR);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">ssize_t</span> DisplayEventReceiver::sendEvents(<span class="keyword">const</span> sp&lt;BitTube&gt;&amp; dataChannel,  </span><br><span class="line">        Event <span class="keyword">const</span>* events, <span class="keyword">size_t</span> count)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">return</span> BitTube::sendObjects(dataChannel, events, count);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.graphics/29-Android-Graphics-App-SurfaceFlinger-Vsync-postEvent.png.png" alt="Markdown"></p><p>其实看到这里的BitTube我们就明白了，在本文开始时候我们提到：</p><p>通过createEventConnection这样一个简单的方法，我们其实就注册了一个事件的监听者，得到了发送VSYNC事件通知的BitTube，然后监控这个BitTube中的套接字，并且指定了收到通知后的回调函数，MessageQueue::cb_eventReceiver。这样一旦VSync信号传来，函数cb_eventReceiver将被调用。</p><p>所以我们这里可以来看看MessageQueue::cb_eventReceiver函数了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> MessageQueue::cb_eventReceiver(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span>* data) &#123;  </span><br><span class="line">    MessageQueue* <span class="built_in">queue</span> = <span class="keyword">reinterpret_cast</span>&lt;MessageQueue *&gt;(data);  </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;eventReceiver(fd, events);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> MessageQueue::eventReceiver(<span class="keyword">int</span> fd, <span class="keyword">int</span> events) &#123;  </span><br><span class="line">    <span class="keyword">ssize_t</span> n;  </span><br><span class="line">    DisplayEventReceiver::Event buffer[<span class="number">8</span>];  </span><br><span class="line">    <span class="keyword">while</span> ((n = DisplayEventReceiver::getEvents(mEventTube, buffer, <span class="number">8</span>)) &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;n ; i++) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (buffer[i].header.type == DisplayEventReceiver::DISPLAY_EVENT_VSYNC) &#123;  </span><br><span class="line">                mHandler-&gt;dispatchInvalidate();  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到收到消息之后MessageQueue对消息进行了分发，我们目前走的是dispatchInvalidate()。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MessageQueue::Handler::dispatchInvalidate() &#123;  </span><br><span class="line">    <span class="keyword">if</span> ((android_atomic_or(eventMaskInvalidate, &amp;mEventMask) &amp; eventMaskInvalidate) == <span class="number">0</span>) &#123;  </span><br><span class="line">        mQueue.mLooper-&gt;sendMessage(<span class="keyword">this</span>, Message(MessageQueue::INVALIDATE));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MessageQueue::Handler::handleMessage(<span class="keyword">const</span> Message&amp; message) &#123;  </span><br><span class="line">    <span class="keyword">switch</span> (message.what) &#123;  </span><br><span class="line">        <span class="keyword">case</span> INVALIDATE:  </span><br><span class="line">            android_atomic_and(~eventMaskInvalidate, &amp;mEventMask);  </span><br><span class="line">            mQueue.mFlinger-&gt;onMessageReceived(message.what);  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        <span class="keyword">case</span> REFRESH:  </span><br><span class="line">            android_atomic_and(~eventMaskRefresh, &amp;mEventMask);  </span><br><span class="line">            mQueue.mFlinger-&gt;onMessageReceived(message.what);  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        <span class="keyword">case</span> TRANSACTION:  </span><br><span class="line">            android_atomic_and(~eventMaskTransaction, &amp;mEventMask);  </span><br><span class="line">            mQueue.mFlinger-&gt;onMessageReceived(message.what);  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SurfaceFlinger::onMessageReceived(<span class="keyword">int32_t</span> what) &#123;  </span><br><span class="line">    ATRACE_CALL();  </span><br><span class="line">    <span class="keyword">switch</span> (what) &#123;  </span><br><span class="line">    <span class="keyword">case</span> MessageQueue::TRANSACTION:  </span><br><span class="line">        handleMessageTransaction();  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line">    <span class="keyword">case</span> MessageQueue::INVALIDATE:  </span><br><span class="line">        handleMessageTransaction();  </span><br><span class="line">        handleMessageInvalidate();  </span><br><span class="line">        signalRefresh();  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line">    <span class="keyword">case</span> MessageQueue::REFRESH:  </span><br><span class="line">        handleMessageRefresh();  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到了这里，就进入了SurfaceFlinger的处理流程，我们看到对于INVALIDATE的消息，实际上系统在处理过程中实际还是会发送一个Refresh消息。</p><h3 id="6-4、App向Eventhread注册一个事件的监听者–createEventConnection"><a href="#6-4、App向Eventhread注册一个事件的监听者–createEventConnection" class="headerlink" title="6.4、App向Eventhread注册一个事件的监听者–createEventConnection()"></a>6.4、App向Eventhread注册一个事件的监听者–createEventConnection()</h3><p>在ViewRootImpl的构造函数中会实例化Choreographer对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ViewRootImpl</span><span class="params">(Context context, Display display)</span> </span>&#123;</span><br><span class="line">                . . . . .</span><br><span class="line">        mChoreographer = Choreographer.getInstance();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在mChoreographer 的构造函数中实例化FrameDisplayEventReceiver对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private Choreographer(Looper looper) &#123;</span><br><span class="line">               . . . . . .</span><br><span class="line">               mDisplayEventReceiver = USE_VSYNC ? new FrameDisplayEventReceiver(looper) : null;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在FrameDisplayEventReceiver的父类构造函数中会调用到，android_view_DisplayEventReceiver.cpp中的nativeInit方法,在nativeInit方法中有如下过程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeInit</span><span class="params">(JNIEnv* env, jclass clazz, jobject receiverWeak,</span></span></span><br><span class="line"><span class="function"><span class="params">        jobject messageQueueObj)</span> </span>&#123;</span><br><span class="line">        . . . . . .</span><br><span class="line">    sp&lt;NativeDisplayEventReceiver&gt; receiver = <span class="keyword">new</span> NativeDisplayEventReceiver(env,</span><br><span class="line">            receiverWeak, messageQueue);</span><br><span class="line">    <span class="keyword">status_t</span> status = receiver-&gt;initialize();</span><br><span class="line">    . . . . . .</span><br></pre></td></tr></table></figure><p>创建NativeDisplayEventReceiver类 类型指针 在NativeDisplayEventReceiver的构造函数中会调用DisplayEventReceiver类的无参构造函数实例化成员mReceiver；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DisplayEventReceiver::DisplayEventReceiver() &#123;</span><br><span class="line">    sp&lt;ISurfaceComposer&gt; sf(ComposerService::getComposerService());</span><br><span class="line">    <span class="keyword">if</span> (sf != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mEventConnection = sf-&gt;createDisplayEventConnection();</span><br><span class="line">        <span class="keyword">if</span> (mEventConnection != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            mDataChannel = mEventConnection-&gt;getDataChannel();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中获取Surfaceflinger服务的代理对象，然后通过Binder IPC创建BpDisplayEventConnection对象 该函数经由BnSurfaceComposer.onTransact函数辗转调用到SurfaceFlinger.createDisplayEventConnection函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IDisplayEventConnection&gt; SurfaceFlinger::createDisplayEventConnection() &#123;</span><br><span class="line">    <span class="keyword">return</span> mEventThread-&gt;createEventConnection();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出现了熟悉的面孔mEventThread，该对象是一个EventThread对象，该对象在SurfaceFlinger.init函数里面创建，但是创建运行以后，貌似还没有进行任何的动作，这里调用createEventConnection函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;EventThread::Connection&gt; EventThread::createEventConnection() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Connection(<span class="keyword">const_cast</span>&lt;EventThread*&gt;(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后mEventConnection-&gt;getDataChannel()方法再次通过Binder IPC创建 BitTube对象mDataChannel ，在Binder IPC创建mDataChannel 过程中会从服务端EventThread::Connection::Connection中（在EventThread类中定义）接收一个socketpair创建的FIFO文件描述符；</p><p>EventThread::Connection::Connection创建描述符的代码： Connection构造函数调用BitTube的无参构造函数，在BitTube的构造函数中调用init函数；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> BitTube::init(<span class="keyword">size_t</span> rcvbuf, <span class="keyword">size_t</span> sndbuf) &#123;</span><br><span class="line">    <span class="keyword">int</span> sockets[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (socketpair(AF_UNIX, SOCK_SEQPACKET, <span class="number">0</span>, sockets) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> size = DEFAULT_SOCKET_BUFFER_SIZE;</span><br><span class="line">        setsockopt(sockets[<span class="number">0</span>], SOL_SOCKET, SO_RCVBUF, &amp;rcvbuf, <span class="keyword">sizeof</span>(rcvbuf));</span><br><span class="line">        setsockopt(sockets[<span class="number">1</span>], SOL_SOCKET, SO_SNDBUF, &amp;sndbuf, <span class="keyword">sizeof</span>(sndbuf));</span><br><span class="line">        <span class="comment">// sine we don't use the "return channel", we keep it small...</span></span><br><span class="line">        setsockopt(sockets[<span class="number">0</span>], SOL_SOCKET, SO_SNDBUF, &amp;size, <span class="keyword">sizeof</span>(size));</span><br><span class="line">        setsockopt(sockets[<span class="number">1</span>], SOL_SOCKET, SO_RCVBUF, &amp;size, <span class="keyword">sizeof</span>(size));</span><br><span class="line">        fcntl(sockets[<span class="number">0</span>], F_SETFL, O_NONBLOCK);</span><br><span class="line">        fcntl(sockets[<span class="number">1</span>], F_SETFL, O_NONBLOCK);</span><br><span class="line">        mReceiveFd = sockets[<span class="number">0</span>];</span><br><span class="line">        mSendFd = sockets[<span class="number">1</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mReceiveFd = -errno;</span><br><span class="line">        ALOGE(<span class="string">"BitTube: pipe creation failed (%s)"</span>, strerror(-mReceiveFd));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用到NativeDisplayEventReceiver类的父类DisplayEventDispatcher中的initialize()方法， 将BpDisplayEventConnection对象获取到的mDataChannel （BitTube类型）中的文件描述符添加到UI主线程Looper的epoll中， 当文件描述符中被写入数据时，该epoll_wait会被唤醒； 直接看代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> NativeDisplayEventReceiver::initialize() &#123;</span><br><span class="line">    <span class="keyword">status_t</span> result = mReceiver.initCheck();</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        ALOGW(<span class="string">"Failed to initialize display event receiver, status=%d"</span>, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> rc = mMessageQueue-&gt;getLooper()-&gt;addFd(mReceiver.getFd(), <span class="number">0</span>, Looper::EVENT_INPUT, <span class="keyword">this</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的主要代码是mMessageQueue-&gt;getLooper()-&gt;addFd()这一行，其中的参数mReceiver.getFd()返回的是在创建NativeDisplayEventReceiver时从SurfaceFlinger服务端接收回来的socket接收端描述符，前面分析到 mMessageQueue是与当前应用线程关联的java层的MessageQueue对应的native层的MessageQueue对象，下面看一下Looper.addFd这个函数，上面调用时传进来的this指针对应的是一个NativeDisplayEventReceiver对象，该类继承了LooperCallback：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Looper::addFd(<span class="keyword">int</span> fd, <span class="keyword">int</span> ident, <span class="keyword">int</span> events, Looper_callbackFunc callback, <span class="keyword">void</span>* data) &#123;</span><br><span class="line">    <span class="keyword">return</span> addFd(fd, ident, events, callback ? <span class="keyword">new</span> SimpleLooperCallback(callback) : <span class="literal">NULL</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Looper::addFd(<span class="keyword">int</span> fd, <span class="keyword">int</span> ident, <span class="keyword">int</span> events, <span class="keyword">const</span> sp&lt;LooperCallback&gt;&amp; callback, <span class="keyword">void</span>* data) &#123;</span><br><span class="line">    <span class="keyword">int</span> epollEvents = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (events &amp; EVENT_INPUT) epollEvents |= EPOLLIN;</span><br><span class="line">    <span class="keyword">if</span> (events &amp; EVENT_OUTPUT) epollEvents |= EPOLLOUT;</span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">        Request request;</span><br><span class="line">        request.fd = fd;</span><br><span class="line">        request.ident = ident;</span><br><span class="line">        request.callback = callback;</span><br><span class="line">        request.data = data;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">eventItem</span>;</span></span><br><span class="line">        <span class="built_in">memset</span>(&amp; eventItem, <span class="number">0</span>, <span class="keyword">sizeof</span>(epoll_event)); <span class="comment">// zero out unused members of data field union</span></span><br><span class="line">        eventItem.events = epollEvents;</span><br><span class="line">        eventItem.data.fd = fd;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">ssize_t</span> requestIndex = mRequests.indexOfKey(fd);</span><br><span class="line">        <span class="keyword">if</span> (requestIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, fd, &amp; eventItem);</span><br><span class="line">            <span class="keyword">if</span> (epollResult &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            mRequests.add(fd, request);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_MOD, fd, &amp; eventItem);</span><br><span class="line">            <span class="keyword">if</span> (epollResult &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mRequests.replaceValueAt(requestIndex, request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先将上面传进来的NativeDisplayEventReceiver对象封装成一个SimpleLooperCallback对象，调用下面的addFd函数的时候主要步骤如下： （1）创建一个struct epoll_event结构体对象，将对应的内存全部用清0，并作对应的初始化； （2）查询通过addFd方法已经添加到epoll中监听的文件描述符； （3）查询不到的话，则调用epoll_ctl方法设置EPOLL_CTL_ADD属性将对应的文件描述符添加到epoll监听的描述符中； （4）根据前面addFd传入的参数EVENT_INPUT，说明当前应用线程的native层的Looper对象中的epoll机制已经开始监听来自于SurfaceFlinger服务端socket端的写入事件。</p><h3 id="6-5、App请求Vsync信号"><a href="#6-5、App请求Vsync信号" class="headerlink" title="6.5、App请求Vsync信号"></a>6.5、App请求Vsync信号</h3><p>前面讲解ViewRootImpl.setView()的时候，因涉及到Vsync信号知识，requestLayout()没有具体讲解，现在继续。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        scheduleTraversals();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">true</span>;</span><br><span class="line">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">        mChoreographer.postCallback(</span><br><span class="line">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="keyword">null</span>);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[-&gt;Choreographer.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postCallback</span><span class="params">(<span class="keyword">int</span> callbackType, Runnable action, Object token)</span> </span>&#123;</span><br><span class="line">    postCallbackDelayed(callbackType, action, token, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postCallbackDelayed</span><span class="params">(<span class="keyword">int</span> callbackType,</span></span></span><br><span class="line"><span class="function"><span class="params">        Runnable action, Object token, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    postCallbackDelayedInternal(callbackType, action, token, delayMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postCallbackDelayedInternal</span><span class="params">(<span class="keyword">int</span> callbackType,</span></span></span><br><span class="line"><span class="function"><span class="params">        Object action, Object token, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> dueTime = now + delayMillis;</span><br><span class="line">        <span class="comment">//将要执行的回调封装成CallbackRecord对象，保存到mCallbackQueues数组中</span></span><br><span class="line">        mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dueTime &lt;= now) &#123;</span><br><span class="line">            scheduleFrameLocked(now);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);</span><br><span class="line">            msg.arg1 = callbackType;</span><br><span class="line">            msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">            mHandler.sendMessageAtTime(msg, dueTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleFrameLocked</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mFrameScheduled) &#123;</span><br><span class="line">        mFrameScheduled = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (USE_VSYNC) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isRunningOnLooperThreadLocked()) &#123;</span><br><span class="line">                scheduleVsyncLocked();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC);</span><br><span class="line">                msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">                mHandler.sendMessageAtFrontOfQueue(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> nextFrameTime = Math.max(</span><br><span class="line">                    mLastFrameTimeNanos / TimeUtils.NANOS_PER_MS + sFrameDelay, now);</span><br><span class="line">            Message msg = mHandler.obtainMessage(MSG_DO_FRAME);</span><br><span class="line">            msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">            mHandler.sendMessageAtTime(msg, nextFrameTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消息处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FrameHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FrameHandler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(looper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> MSG_DO_SCHEDULE_VSYNC:</span><br><span class="line">                doScheduleVsync();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doScheduleVsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mFrameScheduled) &#123;</span><br><span class="line">            scheduleVsyncLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleVsyncLocked</span><span class="params">()</span> </span>&#123;  </span><br><span class="line"><span class="comment">//申请Vsync信号  </span></span><br><span class="line">mDisplayEventReceiver.scheduleVsync();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该函数中考虑了两种情况，一种是系统没有使用Vsync机制，在这种情况下，首先根据屏幕刷新频率计算下一次刷新时间，通过异步消息方式延时执行doFrame()函数实现屏幕刷新。如果系统使用了Vsync机制，并且当前线程具备消息循环，则直接请求Vsync信号，否则就通过主线程来请求Vsync信号。</p><h3 id="6-5-1、Vsync请求过程"><a href="#6-5-1、Vsync请求过程" class="headerlink" title="6.5.1、Vsync请求过程"></a>6.5.1、Vsync请求过程</h3><p>我们知道在Choreographer构造函数中，构造了一个FrameDisplayEventReceiver对象，用于请求并接收Vsync信号，Vsync信号请求过程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleVsyncLocked</span><span class="params">()</span> </span>&#123;  </span><br><span class="line"><span class="comment">//申请Vsync信号  </span></span><br><span class="line">mDisplayEventReceiver.scheduleVsync();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[-&gt;DisplayEventReceiver.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleVsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mReceiverPtr == <span class="number">0</span>) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">"Attempted to schedule a vertical sync pulse but the display event "</span></span><br><span class="line">                + <span class="string">"receiver has already been disposed."</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        nativeScheduleVsync(mReceiverPtr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[-&gt;android_view_DisplayEventReceiver.cpp ]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeScheduleVsync</span><span class="params">(JNIEnv* env, jclass clazz, jlong receiverPtr)</span> </span>&#123;</span><br><span class="line">sp&lt;NativeDisplayEventReceiver&gt; receiver =</span><br><span class="line">        reinterpret_cast&lt;NativeDisplayEventReceiver*&gt;(receiverPtr);</span><br><span class="line">status_t status = receiver-&gt;scheduleVsync();</span><br><span class="line"><span class="keyword">if</span> (status) &#123;</span><br><span class="line">    String8 message;</span><br><span class="line">    message.appendFormat(<span class="string">"Failed to schedule next vertical sync pulse.  status=%d"</span>, status);</span><br><span class="line">    jniThrowRuntimeException(env, message.string());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>VSync请求过程又转交给了DisplayEventReceiver： [-&gt;DisplayEventReceiver.cpp]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">status_t DisplayEventReceiver::requestNextVsync() &#123;</span><br><span class="line"><span class="keyword">if</span> (mEventConnection != NULL) &#123;</span><br><span class="line">    mEventConnection-&gt;requestNextVsync();</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> NO_INIT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的mEventConnection也是前面创建native层对象NativeDisplayEventReceiver时创建的，实际对象是一个BpDisplayEventConnection对象，也就是一个Binder客户端，对应的Binder服务端BnDisplayEventConnection是一个EventThread::Connection对象，对应的BpDisplayEventConnection.requestNextVsync函数和BnDisplayEventConnection.onTransact(REQUEST_NEXT_VSYNC)函数没有进行特别的处理，下面就调用到EventThread::Connection.requestNextVsync函数，从BnDisplayEventConnection.onTransact(REQUEST_NEXT_VSYNC)开始已经从用户进程将需要垂直同步信号的请求发送到了SurfaceFlinger进程，下面的函数调用开始进入SF进程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> EventThread::Connection::requestNextVsync() &#123;</span><br><span class="line">    mEventThread-&gt;requestNextVsync(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>辗转调用到EventThread.requestNextVsync函数，注意里面传了参数this，也就是当前的EventThread::Connection对象，需要明确的是，这里的mEventThread对象是创建EventThread::Connection对象的时候保存的，对应的是SurfaceFlinger对象的里面的mEventThread成员，该对象是一个在SurfaceFlinger.init里面创建并启动的线程对象，可见设计的时候就专门用这个SurfaceFlinger.mEventThread线程来接收来自应用进程的同步信号请求，每来一个应用进程同步信号请求，就通过SurfaceFlinger.mEventThread创建一个EventThread::Connection对象，并通过EventThread.registerDisplayEventConnection函数将创建的EventThread::Connection对象保存到EventThread.mDisplayEventConnections里面，上面有调用到了EventThread.requestNextVsync函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> EventThread::requestNextVsync(<span class="keyword">const</span> sp&lt;EventThread::Connection&gt;&amp; connection) &#123;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    <span class="keyword">if</span> (connection-&gt;count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        connection-&gt;count = <span class="number">0</span>;</span><br><span class="line">        mCondition.broadcast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传进来的是一个前面创建的EventThread::Connection对象，里面判断到了EventThread::Connection.count成员变量，看一下EventThread::Connection构造函数中初始变量的值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EventThread::Connection::Connection(<span class="keyword">const</span> sp&lt;EventThread&gt;&amp; eventThread)</span><br><span class="line">    : count(<span class="number">-1</span>), mEventThread(eventThread), mChannel(<span class="keyword">new</span> BitTube())&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到初始值是-1，这个值就是前面那个问题的关键，EventThread::Connection.count标示了这次应用进程的垂直同步信号的请求是一次性的，还是多次重复的，看一下注释里面对于这个变量的说明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// count &gt;= 1 : continuous event. count is the vsync rate</span></span><br><span class="line"><span class="comment">// count == 0 : one-shot event that has not fired</span></span><br><span class="line"><span class="comment">// count ==-1 : one-shot event that fired this round / disabled</span></span><br><span class="line"><span class="keyword">int32_t</span> count;</span><br></pre></td></tr></table></figure><p>很清楚的说明了，count = 0说明当前的垂直同步信号请求是一个一次性的请求，并且还没有被处理。上面EventThread::requestNextVsync里面将count设置成0，同时调用了mCondition.broadcast()唤醒所有正在等待mCondition的线程，这个会触发EventThread.waitForEvent函数从：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mCondition.wait(mLock);</span><br></pre></td></tr></table></figure><p>中醒来，醒来之后经过一轮do…while循环就会返回，返回以后调用序列如下： （1）EventThread::Connection.postEvent(event) （2）DisplayEventReceiver::sendEvents(mChannel, &amp;event, 1)，mChannel参数就是前面创建DisplayEventReceiver是创建的BitTube对象 （3）BitTube::sendObjects(dataChannel, events, count)，static函数，通过dataChannel指向BitTube对象 最终调用到BitTube::sendObjects函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> BitTube::sendObjects(<span class="keyword">const</span> sp&lt;BitTube&gt;&amp; tube, <span class="keyword">void</span> <span class="keyword">const</span>* events, <span class="keyword">size_t</span> count, <span class="keyword">size_t</span> objSize)&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* vaddr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(events);</span><br><span class="line">    <span class="keyword">ssize_t</span> size = tube-&gt;write(vaddr, count*objSize);</span><br><span class="line">    <span class="keyword">return</span> size &lt; <span class="number">0</span> ? size : size / <span class="keyword">static_cast</span>&lt;<span class="keyword">ssize_t</span>&gt;(objSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续调用到BitTube::write函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> BitTube::write(<span class="keyword">void</span> <span class="keyword">const</span>* vaddr, <span class="keyword">size_t</span> size)&#123;</span><br><span class="line">    <span class="keyword">ssize_t</span> err, len;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        len = ::send(mSendFd, vaddr, size, MSG_DONTWAIT | MSG_NOSIGNAL);</span><br><span class="line">        <span class="comment">// cannot return less than size, since we're using SOCK_SEQPACKET</span></span><br><span class="line">        err = len &lt; <span class="number">0</span> ? errno : <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (err == EINTR);</span><br><span class="line">    <span class="keyword">return</span> err == <span class="number">0</span> ? len : -err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用到了::send函数，::是作用域描述符，如果前面没有类名之类的，代表的就是全局的作用域，也就是调用全局函数send，这里很容易就能想到这是一个socket的写入函数，也就是将event事件数据写入到BitTube中互联的socket中，这样在另一端马上就能收到写入的数据，前面分析到这个BitTube的socket的两端连接着SurfaceFlinger进程和应用进程，也就是说通过调用BitTube::write函数，将最初由SurfaceFlinger捕获到的垂直信号事件经由BitTube中互联的socket从SurfaceFlinger进程发送到了应用进程中BitTube的socket接收端。 下面就要分析应用进程是如何接收并使用这个垂直同步信号事件的。</p><h3 id="6-5-2、应用进程接收VSync"><a href="#6-5-2、应用进程接收VSync" class="headerlink" title="6.5.2、应用进程接收VSync"></a>6.5.2、应用进程接收VSync</h3><h4 id="6-5-2-1、解析VSync事件"><a href="#6-5-2-1、解析VSync事件" class="headerlink" title="6.5.2.1、解析VSync事件"></a>6.5.2.1、解析VSync事件</h4><p>VSync同步信号事件已经发送到用户进程中的socket接收端，在前面NativeDisplayEventReceiver.initialize中分析到应用进程端的socket接收描述符已经被添加到Choreographer所在线程的native层的Looper机制中，在epoll中监听EPOLLIN事件，当socket收到数据后，epoll会马上返回，下面分步骤看一下Looper.pollInner()数： （1）epoll_wait</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">eventItems</span>[<span class="title">EPOLL_MAX_EVENTS</span>];</span></span><br><span class="line"><span class="keyword">int</span> eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);</span><br></pre></td></tr></table></figure><p>在监听到描述符对应的事件后，epoll_wait会马上返回，并将产生的具体事件类型写入到参数eventItems里面，最终返回的eventCount是监听到的事件的个数 （2）事件分析</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; eventCount; i++) &#123;</span><br><span class="line">     <span class="keyword">int</span> fd = eventItems[i].data.fd;</span><br><span class="line">     <span class="keyword">uint32_t</span> epollEvents = eventItems[i].events;</span><br><span class="line">     <span class="keyword">if</span> (fd == mWakeReadPipeFd) &#123;   <span class="comment">//判断是不是pipe读管道的事件   这里如果是EventThread,这里就是一个socket的描述符,而不是mWakeReadPipeFd</span></span><br><span class="line">         <span class="keyword">if</span> (epollEvents &amp; EPOLLIN) &#123;</span><br><span class="line">             awoken(); <span class="comment">// 清空读管道中的数据</span></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             ALOGW(<span class="string">"Ignoring unexpected epoll events 0x%x on wake read pipe."</span>, epollEvents);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//EventThread接收到同步信号走的这里</span></span><br><span class="line">         <span class="keyword">ssize_t</span> requestIndex = mRequests.indexOfKey(fd);</span><br><span class="line">         <span class="keyword">if</span> (requestIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">             <span class="keyword">int</span> events = <span class="number">0</span>;</span><br><span class="line">             <span class="keyword">if</span> (epollEvents &amp; EPOLLIN) events |= EVENT_INPUT;</span><br><span class="line">             <span class="keyword">if</span> (epollEvents &amp; EPOLLOUT) events |= EVENT_OUTPUT;</span><br><span class="line">             <span class="keyword">if</span> (epollEvents &amp; EPOLLERR) events |= EVENT_ERROR;</span><br><span class="line">             <span class="keyword">if</span> (epollEvents &amp; EPOLLHUP) events |= EVENT_HANGUP;</span><br><span class="line">             pushResponse(events, mRequests.valueAt(requestIndex));</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             ALOGW(<span class="string">"Ignoring unexpected epoll events 0x%x on fd %d that is "</span></span><br><span class="line">                     <span class="string">"no longer registered."</span>, epollEvents, fd);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>Looper目前了解到的主要监听的文件描述符种类有两种： 1）消息事件，epoll_wait监听pipe管道的接收端描述符mWakeReadPipeFd 2）与VSync信号，epoll_wait监听socket接收端描述符，并在addFd的过程中将相关的信息封装在一个Request结构中，并以fd为key存储到了mRequests中，具体可以回过头看3.1.2关于addFd的分析； 因此，上面走的是else的分支，辨别出当前的事件类型后，调用pushResponse：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Looper::pushResponse(<span class="keyword">int</span> events, <span class="keyword">const</span> Request&amp; request) &#123;</span><br><span class="line">    Response response;</span><br><span class="line">    response.events = events;</span><br><span class="line">    response.request = request;  <span class="comment">//复制不是引用，调用拷贝构造函数</span></span><br><span class="line">    mResponses.push(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数将Request和events封装在一个Response对象里面，存储到了mResponses里面，也就是mResponses里面放的是”某某fd上接收到了类别为events的时间”记录，继续向下看Looper.pollInner函数 （3）事件分发处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Invoke all response callbacks.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mResponses.size(); i++) &#123;</span><br><span class="line">    Response&amp; response = mResponses.editItemAt(i);</span><br><span class="line">    <span class="keyword">if</span> (response.request.ident == POLL_CALLBACK) &#123;</span><br><span class="line">        <span class="keyword">int</span> fd = response.request.fd;</span><br><span class="line">        <span class="keyword">int</span> events = response.events;</span><br><span class="line">        <span class="keyword">void</span>* data = response.request.data;</span><br><span class="line">        <span class="keyword">int</span> callbackResult = response.request.callback-&gt;handleEvent(fd, events, data);</span><br><span class="line">        <span class="keyword">if</span> (callbackResult == <span class="number">0</span>) &#123;</span><br><span class="line">            removeFd(fd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Clear the callback reference in the response structure promptly because we</span></span><br><span class="line">        <span class="comment">// will not clear the response vector itself until the next poll.</span></span><br><span class="line">        response.request.callback.clear();</span><br><span class="line">        result = POLL_CALLBACK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的response.request是从pushResponse里面复制过来的，里面的request对应的Request对象是在addFd的时候创建的，ident成员就是POLL_CALLBACK，所以继续走到response.request.callback-&gt;handleEvent这个函数，回忆一下3.1.2里面的addFd函数，这里的callback实际上是一个SimpleLooperCallback（定义在Looper.cpp中）对象，看一下里面的handleEvent函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> SimpleLooperCallback::handleEvent(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span>* data) &#123;</span><br><span class="line">    <span class="keyword">return</span> mCallback(fd, events, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的mCallback就是当时在addFd的时候传进来的callBack参数，实际上对应的就是NativeDisplayEventReceiver对象本身，因此最终就将垂直同步信号事件分发到了NativeDisplayEventReceiver.handleEvent函数中。</p><h3 id="6-5-3、VSync事件分发"><a href="#6-5-3、VSync事件分发" class="headerlink" title="6.5.3、VSync事件分发"></a>6.5.3、<strong>VSync事件分发</strong></h3><p>调用到NativeDisplayEventReceiver.handleEvent函数，该函数定义在android_view_DisplayEventReceiver.cpp中，直接列出该函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> NativeDisplayEventReceiver::handleEvent(<span class="keyword">int</span> receiveFd, <span class="keyword">int</span> events, <span class="keyword">void</span>* data) &#123;</span><br><span class="line">    <span class="keyword">if</span> (events &amp; (Looper::EVENT_ERROR | Looper::EVENT_HANGUP)) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Display event receiver pipe was closed or an error occurred.  "</span></span><br><span class="line">                <span class="string">"events=0x%x"</span>, events);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// remove the callback</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(events &amp; Looper::EVENT_INPUT)) &#123;</span><br><span class="line">        ALOGW(<span class="string">"Received spurious callback for unhandled poll event.  "</span></span><br><span class="line">                <span class="string">"events=0x%x"</span>, events);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// keep the callback</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Drain all pending events, keep the last vsync.</span></span><br><span class="line">    <span class="keyword">nsecs_t</span> vsyncTimestamp;</span><br><span class="line">    <span class="keyword">int32_t</span> vsyncDisplayId;</span><br><span class="line">    <span class="keyword">uint32_t</span> vsyncCount;</span><br><span class="line">    <span class="keyword">if</span> (processPendingEvents(&amp;vsyncTimestamp, &amp;vsyncDisplayId, &amp;vsyncCount)) &#123;</span><br><span class="line">        ALOGV(<span class="string">"receiver %p ~ Vsync pulse: timestamp=%"</span> PRId64 <span class="string">", id=%d, count=%d"</span>,</span><br><span class="line">                <span class="keyword">this</span>, vsyncTimestamp, vsyncDisplayId, vsyncCount);</span><br><span class="line">        mWaitingForVsync = <span class="literal">false</span>;</span><br><span class="line">        dispatchVsync(vsyncTimestamp, vsyncDisplayId, vsyncCount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// keep the callback</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先判断事件是不是正确的Looper::EVENT_INPUT事件，然后调用到NativeDisplayEventReceiver.processPendingEvents函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> NativeDisplayEventReceiver::processPendingEvents(<span class="keyword">nsecs_t</span>* outTimestamp, <span class="keyword">int32_t</span>* outId, <span class="keyword">uint32_t</span>* outCount) &#123;</span><br><span class="line">    <span class="keyword">bool</span> gotVsync = <span class="literal">false</span>;</span><br><span class="line">    DisplayEventReceiver::Event buf[EVENT_BUFFER_SIZE];</span><br><span class="line">    <span class="keyword">ssize_t</span> n;</span><br><span class="line">    <span class="keyword">while</span> ((n = mReceiver.getEvents(buf, EVENT_BUFFER_SIZE)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">ssize_t</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> DisplayEventReceiver::Event&amp; ev = buf[i];</span><br><span class="line">            <span class="keyword">switch</span> (ev.header.type) &#123;</span><br><span class="line">            <span class="keyword">case</span> DisplayEventReceiver::DISPLAY_EVENT_VSYNC:</span><br><span class="line">                <span class="comment">// Later vsync events will just overwrite the info from earlier</span></span><br><span class="line">                <span class="comment">// ones. That's fine, we only care about the most recent.</span></span><br><span class="line">                gotVsync = <span class="literal">true</span>;</span><br><span class="line">                *outTimestamp = ev.header.timestamp;</span><br><span class="line">                *outId = ev.header.id;</span><br><span class="line">                *outCount = ev.vsync.count;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DisplayEventReceiver::DISPLAY_EVENT_HOTPLUG:</span><br><span class="line">                dispatchHotplug(ev.header.timestamp, ev.header.id, ev.hotplug.connected);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                ALOGW(<span class="string">"receiver %p ~ ignoring unknown event type %#x"</span>, <span class="keyword">this</span>, ev.header.type);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGW(<span class="string">"Failed to get events from display event receiver, status=%d"</span>, <span class="keyword">status_t</span>(n));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> gotVsync;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的mReceiver也就是前面创建NativeDisplayEventReceiver对象是创建的成员变量对象DisplayEventReceiver，下面调用到DisplayEventReceiver.getEvents函数，应该是要从出现同步信号事件的socket中读取数据，上面Looper机制中epoll中监听到socket以后，返回到NativeDisplayEventReceiver.handleEvent里面，但是socket里面的数据还没有读取，下面的调用流程为： （1）mReceiver.getEvents(buf, EVENT_BUFFER_SIZE) —&gt; DisplayEventReceiver::getEvents(DisplayEventReceiver::Event _events, size<em>t count) （2）BitTube::recvObjects(dataChannel, events, count) —&gt; BitTube::recvObjects(const sp&amp; tube, void</em> events, size_t count, size_t objSize) 看一下这个recvObjects函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> BitTube::recvObjects(<span class="keyword">const</span> sp&lt;BitTube&gt;&amp; tube, <span class="keyword">void</span>* events, <span class="keyword">size_t</span> count, <span class="keyword">size_t</span> objSize)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span>* vaddr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(events);</span><br><span class="line">    <span class="keyword">ssize_t</span> size = tube-&gt;read(vaddr, count*objSize);</span><br><span class="line">    <span class="keyword">return</span> size &lt; <span class="number">0</span> ? size : size / <span class="keyword">static_cast</span>&lt;<span class="keyword">ssize_t</span>&gt;(objSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里在NativeDisplayEventReceiver中创建了一个缓冲区，并在recvObjects中将socket中的Event数据读到这个缓冲区中，这个Event.header.type一般都是DISPLAY_EVENT_VSYNC，因此在上面的processPendingEvents函数中会将Event数据保存在outCount所指向的内存中，并返回true。 接下来返回到NativeDisplayEventReceiver.handleEvent后会调用到dispatchVsync函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> NativeDisplayEventReceiver::dispatchVsync(<span class="keyword">nsecs_t</span> timestamp, <span class="keyword">int32_t</span> id, <span class="keyword">uint32_t</span> count) &#123;</span><br><span class="line">    JNIEnv* env = AndroidRuntime::getJNIEnv();</span><br><span class="line">    env-&gt;CallVoidMethod(mReceiverObjGlobal, gDisplayEventReceiverClassInfo.dispatchVsync, timestamp, id, count);</span><br><span class="line">    mMessageQueue-&gt;raiseAndClearException(env, <span class="string">"dispatchVsync"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的处理很直接，直接调用mReceiverObjGlobal对象在gDisplayEventReceiverClassInfo.dispatchVsync中指定的函数，将后面的timestamp（时间戳） id（设备ID） count（经过的同步信号的数量，一般没有设置采样频率应该都是1），下面分别看一下mReceiverObjGlobal以及gDisplayEventReceiverClassInfo.dispatchVsync代表的是什么？ （1）mReceiverObjGlobal</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NativeDisplayEventReceiver::NativeDisplayEventReceiver(JNIEnv* env, jobject receiverObj, <span class="keyword">const</span> sp&lt;MessageQueue&gt;&amp; messageQueue) :</span><br><span class="line">        mReceiverObjGlobal(env-&gt;NewGlobalRef(receiverObj)), mMessageQueue(messageQueue), mWaitingForVsync(<span class="literal">false</span>) &#123;</span><br><span class="line">    ALOGV(<span class="string">"receiver %p ~ Initializing input event receiver."</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到mReceiverObjGlobal是创建NativeDisplayEventReceiver对象时传进来的第二个参数，该对象是在nativeInit函数中创建：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp receiver = <span class="keyword">new</span> NativeDisplayEventReceiver(env, receiverObj, messageQueue);</span><br></pre></td></tr></table></figure><p>进一步的，receiverObj是调用nativeInit函数时传进来的第一个参数（第一个参数env是系统用于连接虚拟机时自动加上的），nativeInit函数又是在Choreographer中创建FrameDisplayEventReceiver对象时，在基类DisplayEventReceiver构造器中调用的，因此这里的mReceiverObjGlobal对应的就是Choreographer中的FrameDisplayEventReceiver成员mDisplayEventReceiver。 （2）gDisplayEventReceiverClassInfo.dispatchVsync 在JNI中有很多这样的类似的结构体对象，这些对象都是全局结构体对象，这里的gDisplayEventReceiverClassInfo就是这样的一个对象，里面描述了一些在整个文件内可能会调用到的java层的相关类以及成员函数的相关信息，看一下gDisplayEventReceiverClassInfo：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    jclass clazz;</span><br><span class="line">    jmethodID dispatchVsync;</span><br><span class="line">    jmethodID dispatchHotplug;</span><br><span class="line">&#125; gDisplayEventReceiverClassInfo;</span><br></pre></td></tr></table></figure><p>看一下里面的变量名称就能知道大致的含义，clazz成员代表的是某个java层的类的class信息，dispatchVsync和dispatchHotplug代表的是java层类的方法的方法信息，看一下该文件中注册JNI函数的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">register_android_view_DisplayEventReceiver</span><span class="params">(JNIEnv* env)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = RegisterMethodsOrDie(env, <span class="string">"android/view/DisplayEventReceiver"</span>, gMethods, NELEM(gMethods));</span><br><span class="line">    jclass clazz = FindClassOrDie(env, <span class="string">"android/view/DisplayEventReceiver"</span>);</span><br><span class="line">    gDisplayEventReceiverClassInfo.clazz = MakeGlobalRefOrDie(env, clazz);</span><br><span class="line">    gDisplayEventReceiverClassInfo.dispatchVsync = GetMethodIDOrDie(env, gDisplayEventReceiverClassInfo.clazz, <span class="string">"dispatchVsync"</span>, <span class="string">"(JII)V"</span>);</span><br><span class="line">    gDisplayEventReceiverClassInfo.dispatchHotplug = GetMethodIDOrDie(env, gDisplayEventReceiverClassInfo.clazz, <span class="string">"dispatchHotplug"</span>, <span class="string">"(JIZ)V"</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RegisterMethodsOrDie调用注册了java层调用native方法时链接到的函数的入口，下面clazz对应的就是java层的”android/view/DisplayEventReceiver.java”类，gDisplayEventReceiverClassInfo.dispatchVsync里面保存的就是clazz类信息中与dispatchVsync方法相关的信息，同样dispatchHotplug也是。 分析到这里，就知道应用进程native接收到同步信号事件后，会调用Choreographer中的FrameDisplayEventReceiver成员mDisplayEventReceiver的dispatchVsync方法。</p><h3 id="6-5-4、应用接收Vsync"><a href="#6-5-4、应用接收Vsync" class="headerlink" title="6.5.4、应用接收Vsync"></a>6.5.4、应用接收Vsync</h3><p>看一下FrameDisplayEventReceiver.dispatchVsync方法，也就是DisplayEventReceiver.dispatchVsync方法(Choreographer.java)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">// Called from native code.   </span><br><span class="line"> @SuppressWarnings(&quot;unused&quot;)</span><br><span class="line"> private void dispatchVsync(long timestampNanos, int builtInDisplayId, int frame) &#123;</span><br><span class="line">     onVsync(timestampNanos, builtInDisplayId, frame);</span><br><span class="line"> &#125;</span><br><span class="line"> 注释表明这个方法是从native代码调用的，该函数然后会调用FrameDisplayEventReceiver.onVsync方法：</span><br><span class="line">     @Override</span><br><span class="line">     public void onVsync(long timestampNanos, int builtInDisplayId, int frame) &#123;</span><br><span class="line">         // Ignore vsync from secondary display.</span><br><span class="line">         // This can be problematic because the call to scheduleVsync() is a one-shot.</span><br><span class="line">         // We need to ensure that we will still receive the vsync from the primary</span><br><span class="line">         // display which is the one we really care about.  Ideally we should schedule</span><br><span class="line">         // vsync for a particular display.</span><br><span class="line">         // At this time Surface Flinger won&apos;t send us vsyncs for secondary displays</span><br><span class="line">         // but that could change in the future so let&apos;s log a message to help us remember</span><br><span class="line">         // that we need to fix this.</span><br><span class="line">         //注释：忽略来自非主显示器的Vsync信号，但是我们前面调用的scheduleVsync函数只能请求到一次Vsync信号，因此需要重新调用scheduleVsync函数</span><br><span class="line">         //请求来自主显示设备的Vsync信号</span><br><span class="line">         if (builtInDisplayId != SurfaceControl.BUILT_IN_DISPLAY_ID_MAIN) &#123;</span><br><span class="line">             Log.d(TAG, &quot;Received vsync from secondary display, but we don&apos;t support &quot;</span><br><span class="line">                     + &quot;this case yet.  Choreographer needs a way to explicitly request &quot;</span><br><span class="line">                     + &quot;vsync for a specific display to ensure it doesn&apos;t lose track &quot;</span><br><span class="line">                     + &quot;of its scheduled vsync.&quot;);</span><br><span class="line">             scheduleVsync();</span><br><span class="line">             return;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         // Post the vsync event to the Handler.</span><br><span class="line">         // The idea is to prevent incoming vsync events from completely starving</span><br><span class="line">         // the message queue.  If there are no messages in the queue with timestamps</span><br><span class="line">         // earlier than the frame time, then the vsync event will be processed immediately.</span><br><span class="line">         // Otherwise, messages that predate the vsync event will be handled first.</span><br><span class="line">         long now = System.nanoTime();</span><br><span class="line">         if (timestampNanos &gt; now) &#123;</span><br><span class="line">             Log.w(TAG, &quot;Frame time is &quot; + ((timestampNanos - now) * 0.000001f)</span><br><span class="line">                     + &quot; ms in the future!  Check that graphics HAL is generating vsync &quot;</span><br><span class="line">                     + &quot;timestamps using the correct timebase.&quot;);</span><br><span class="line">             timestampNanos = now;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         if (mHavePendingVsync) &#123;</span><br><span class="line">             Log.w(TAG, &quot;Already have a pending vsync event.  There should only be &quot;</span><br><span class="line">                     + &quot;one at a time.&quot;);</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">             mHavePendingVsync = true;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         mTimestampNanos = timestampNanos;  //同步信号时间戳</span><br><span class="line">         mFrame = frame;                //同步信号的个数，理解就是从调用scheduleVsync到onVsync接收到信号之间经历的同步信号的个数，一般都是1</span><br><span class="line">         Message msg = Message.obtain(mHandler, this);</span><br><span class="line">         msg.setAsynchronous(true);</span><br><span class="line">         mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>貌似这里的处理只是往Choreographer对象中的mHandler对应的线程Looper中发送一个消息，消息的内容有两个特点： （1）将this，也就是当前的FrameDisplayEventReceiver对象作为参数，后面会回调到FrameDisplayEventReceiver.run方法； （2）为Message设置FLAG_ASYNCHRONOUS属性； 发送这个FLAG_ASYNCHRONOUS消息后，后面会回调到FrameDisplayEventReceiver.run方法，至于为什么，后面再写文章结合View.invalidate方法的过程分析，看一下FrameDisplayEventReceiver.run方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    mHavePendingVsync = false;</span><br><span class="line">    doFrame(mTimestampNanos, mFrame);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用Choreographer.doFrame方法，如果是重绘事件doFrame方法会最终调用到ViewRootImpl.performTraversals方法进入实际的绘制流程。经过上面的分析可以知道，调用一次Choreographer.scheduleVsyncLocked只会请求一次同步信号，也就是回调一次FrameDisplayEventReceiver.onVsync方法，在思考一个问题，一个应用进程需要多次请求Vsync同步信号会不会使用同样的一串对象？多个线程又是怎么样的？ 答：一般绘制操作只能在主线程里面进行，因此一般来说只会在主线程里面去请求同步信号，可以认为不会存在同一个应用的多个线程请求SF的Vsync信号，Choreographer是一个线程内的单例模式，存储在了 ThreadLocal sThreadInstance对象里面，所以主线程多次请求使用的是同一个Choreographer对象，所以后面的一串对象应该都是可以复用的。</p><p>总体架构： 伐木累:::终于完了，由于Android Graphics系统涉及模块代码纵横交叉复杂，其中代码图示有误的地方请见谅，也没有精力一一核对了，还请海涵~~~主要是分析Android Graphics总体的一个流程思想，有需要再一点点深挖。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.graphics/30-Android-Graphics-Arc-flow.png" alt="Markdown"></p><h2 id="（七）、参考文档-特别感谢各位前辈的分析和图示-："><a href="#（七）、参考文档-特别感谢各位前辈的分析和图示-：" class="headerlink" title="（七）、参考文档(特别感谢各位前辈的分析和图示)："></a>（七）、参考文档(特别感谢各位前辈的分析和图示)：</h2><p><a href="http://www.10tiao.com/html/431/201601/401709603/1.html" target="_blank" rel="noopener">Android Vsync 原理</a><br><a href="http://blog.csdn.net/uiop78uiop78/article/category/1390680" target="_blank" rel="noopener">林学森的Android专栏</a><br><a href="http://coderprof.com/android_tutorials_pdf_examples_PDF.php?q=android+graphics+pdf" target="_blank" rel="noopener">Android Graphics</a><br><a href="https://source.android.com/devices/tech/debug/systrace" target="_blank" rel="noopener">了解 Systrace</a><br><a href="http://www.cnblogs.com/samchen2009/category/524173.html" target="_blank" rel="noopener">图解Android - Android GUI 系统</a><br><a href="http://windrunnerlihuan.com/" target="_blank" rel="noopener">Android SurfaceFlinger 学习之路&amp;Android多媒体开发</a><br><a href="http://blog.csdn.net/Gaugamela/article/category/6383486" target="_blank" rel="noopener">Android7.0 基础业务AMS、数据业务、电源管理业务 源码分析</a><br><a href="http://blog.csdn.net/yangwen123/article/category/1647761" target="_blank" rel="noopener">【Android 显示模块】 - 深入剖析Android系统 - CSDN博客</a><br><a href="http://blog.csdn.net/innost/article/details/47208337" target="_blank" rel="noopener">深入理解Android卷一全文-第八章(深入理解Surface系统)</a><br><a href="http://blog.csdn.net/armwind/article/category/6282972" target="_blank" rel="noopener">android系统 - armwind的专栏 - CSDN博客</a><br><a href="http://blog.csdn.net/kc58236582/article/category/6436488" target="_blank" rel="noopener">android显示系统 - kc58236582的博客 - CSDN博客</a><br><a href="http://www.cnblogs.com/wytiger/p/5693569.html" target="_blank" rel="noopener">SurfaceView, TextureView, SurfaceTexture等的区别</a><br><a href="http://blog.csdn.net/armwind/article/details/73436532" target="_blank" rel="noopener">【Demo】Android graphics 学习－生产者、消费者、BufferQueue介绍</a><br><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0421/2765.html" target="_blank" rel="noopener">深入Android Graphics Pipeline：从按钮到帧缓冲（第一部分）</a><br><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0421/2766.html" target="_blank" rel="noopener">深入Android Graphics Pipeline：从按钮到帧缓冲（第二部分）</a><br><a href="https://software.intel.com/en-us/node/713326" target="_blank" rel="noopener">窗口：Profiling 视图（OpenGL/OpenGL ES* 工作负载）</a><br><a href="http://blog.csdn.net/jinzhuojun/article/details/54234354" target="_blank" rel="noopener">Android N中UI硬件渲染（hwui）的HWUI_NEW_OPS(基于Android 7.1)</a><br><a href="https://netaz.blogspot.jp/search/label/gralloc" target="_blank" rel="noopener">Android’s Graphics Buffer Management System (Part I: gralloc)</a><br><a href="https://netaz.blogspot.jp/search/label/Graphics" target="_blank" rel="noopener">Android’s Graphics Buffer Management System (Part II: BufferQueue)</a><br><a href="https://www.kancloud.cn/digest/androidcore/149097" target="_blank" rel="noopener">Android GDI之SurfaceFlinger</a><br><a href="http://windrunnerlihuan.com/" target="_blank" rel="noopener">Android SurfaceFlinger 学习之路(五)—-VSync 工作原理</a><br><a href="http://blog.csdn.net/michaelcao1980/article/details/43233765" target="_blank" rel="noopener">Android 5.1 SurfaceFlinger VSYNC详解</a><br><a href="http://blog.csdn.net/newchenxf/article/details/49131167" target="_blank" rel="noopener">Android 5.1 SurfaceFlinger VSYNC详解</a><br><a href="http://blog.csdn.net/houliang120/article/details/50958212" target="_blank" rel="noopener">Android消息机制Looper与VSync的传播</a><br><a href="http://blog.csdn.net/houliang120/article/details/50908098" target="_blank" rel="noopener">Android垂直同步信号VSync的产生及传播结构详解</a><br><a href="http://blog.csdn.net/jinzhuojun/article/details/17293325" target="_blank" rel="noopener">Android 4.4(KitKat)中VSync信号的虚拟化</a><br><a href="http://blog.csdn.net/jinzhuojun/article/details/37737439" target="_blank" rel="noopener">Android 4.4(KitKat)窗口管理子系统 - 体系框架</a><br><a href="http://blog.csdn.net/ariesjzj/article/category/1087829/2" target="_blank" rel="noopener">Android中用OpenGL ES Tracer分析绘制过程</a><br><a href="https://www.zhihu.com/question/30372696?sort=created" target="_blank" rel="noopener">android view的绘制中，View绘制的时间如何和vsync屏幕刷新频率保持同步的？</a><br><a href="http://blog.csdn.net/innost/article/details/47208337" target="_blank" rel="noopener">【深入理解Android卷一全文-第八章】入理解Surface系统</a><br><a href="http://blog.csdn.net/april_12345/article/details/52933316" target="_blank" rel="noopener">Android 窗口管理：Z-Order管理</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android系统图形框架由下往上主要的包括HAL(HWComposer和Gralloc两个moudle)，SurfaceFlinger（BufferQueue的消费者），WindowManagerService（窗口管理者），View（BufferQueue的生产者）四大模块。&lt;br&gt;● HAL: 包括HWComposer和Gralloc两个moudle，Android N上由SurfaceFlinger打开，因此在同一进程。 gralloc 用于BufferQueue的内存分配，同时也有fb的显示接口，HWComposer作为合成SurfaceFlinger里面的Layer，并显示（通过gralloc的post函数）&lt;br&gt;● SurfaceFlinger可以叫做LayerFlinger，作为Layer的管理者，同是也是BufferQueue的消费者，当每个Layer的生产者draw完完整的一帧时，会通知SurfaceFlinger，通知的方式采用BufferQueue。&lt;br&gt;● WindowManagerService: 作为Window的管理者，掌管着计算窗口大小，窗口切换等任务，同时也会将相应的参数设置给SurfaceFlinger，比如Window的在z-order，和窗口的大小。&lt;br&gt;● View: 作为BufferQueue的生产者，每当执行lockCanvas-&amp;gt;draw-&amp;gt;unlockCanvas，之后会存入一帧数据进入BufferQueue中。 嘿嘿(&lt;em&gt;^▽^&lt;/em&gt;),但这也是无可奈何的事情，毕竟世上不可能有那么多十全十美的好事，做人在某些时候总是要有些取舍的。
    
    </summary>
    
      <category term="Android" scheme="http://zhoujinjian.cc/categories/Android/"/>
    
    
      <category term="Android" scheme="http://zhoujinjian.cc/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android 7.1.2 (Android N) Android Binder 系统 分析</title>
    <link href="http://zhoujinjian.cc/2018/01/01/Android-7-1-2-Android-N-Android-Binder%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/"/>
    <id>http://zhoujinjian.cc/2018/01/01/Android-7-1-2-Android-N-Android-Binder系统分析/</id>
    <published>2017-12-31T16:00:00.000Z</published>
    <updated>2018-04-19T14:29:56.436Z</updated>
    
    <content type="html"><![CDATA[<p>Android Binder系统概述： Binder是Android系统中大量使用的IPC（Inter-process communication，进程间通讯）机制。无论是应用程序对系统服务的请求，还是应用程序自身提供对外服务，都需要使用到Binder。因此，Binder机制在Android系统中的地位非常重要，可以说，理解Binder是理解Android系统的绝对必要前提。</p><a id="more"></a><blockquote><p><strong>framework/base/core/java/ (Java)</strong><br> <strong>framework/base/core/jni/ (JNI)</strong><br> <strong>framework/native/libs/binder (Native)</strong><br> <strong>framework/native/cmds/servicemanager/ (Native)</strong><br> <strong>kernel/drivers/staging/android (Driver)</strong></p></blockquote><hr><blockquote><p><strong>Java framework</strong></p></blockquote><p><strong>framework/base/core/java/android/os/</strong><br>● IInterface.java<br>● IBinder.java<br>● Parcel.java<br>● IServiceManager.java<br>● ServiceManager.java<br>● ServiceManagerNative.java<br>● Binder.java</p><p><strong>framework/base/core/jni/</strong><br>● android_os_Parcel.cpp<br>● AndroidRuntime.cpp<br>● android_util_Binder.cpp (核心类)</p><hr><blockquote><p><strong>Native framework</strong></p></blockquote><p><strong>framework/native/libs/binder</strong><br><br>● IServiceManager.cpp<br>● BpBinder.cpp<br>● Binder.cpp<br>● IPCThreadState.cpp (核心类)<br>● ProcessState.cpp (核心类)</p><p><strong>framework/native/include/binder/</strong><br>● IServiceManager.h<br>● IInterface.h</p><p><strong>framework/native/cmds/servicemanager/</strong><br>● bctest.c<br>● binder.h<br>● binder.c<br>● service_manager.c<br>● servicemanager.rc</p><hr><blockquote><p><strong>Kernel</strong></p></blockquote><p><strong>kernel/drivers/staging/android/</strong></p><p>● binder.c<br>● binder.h</p><h2 id="博客原图链接"><a href="#博客原图链接" class="headerlink" title="博客原图链接"></a><a href="https://github.com/izhoujinjian/zhoujinjian.cc/tree/master/android.binder" target="_blank" rel="noopener">博客原图链接</a></h2><h2 id="一、Android-Binder系统C程序示例"><a href="#一、Android-Binder系统C程序示例" class="headerlink" title="一、Android Binder系统C程序示例"></a>一、Android Binder系统C程序示例</h2><h3 id="（1）、简述Binder跨进程机制"><a href="#（1）、简述Binder跨进程机制" class="headerlink" title="（1）、简述Binder跨进程机制"></a>（1）、简述Binder跨进程机制</h3><p>Android系统中，每个应用程序是由Android的Activity，Service，Broadcast，ContentProvider这四组件的中一个或多个组合而成，这四组件所涉及的多进程间的通信底层都是依赖于Binder IPC机制。</p><p>从进程角度来看IPC机制<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/01-Android-binder-binder_interprocess_communication.png" alt="Markdown"></p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/02-Android-binder-IPC-Binder.jpg" alt="Markdown"></p><p>现在Client进程需要访问Server进程中的服务，会经过以下步骤：<br>1、Server进程首先向ServiceManager注册服务（ServiceManager先于Server启动）<br>2、Client进程向ServiceManager查询服务得到一个句柄Handle（Server进程可能不止一个服务，用Handle区分是哪一个服务）<br>3、Client进程 封装数据Buffer通过Binder驱动发送给Server进程，Server进程取得数据后解析数据，使用Server进程的Handle服务对应的函数处理数据，处理完成后通过Binder驱动传输给Client进程</p><h4 id="1-1、Server进程向ServiceManager注册服务"><a href="#1-1、Server进程向ServiceManager注册服务" class="headerlink" title="1.1、Server进程向ServiceManager注册服务"></a>1.1、Server进程向ServiceManager注册服务</h4><p>ServiceManager是一个守护进程。它的main()函数源码如下：</p><blockquote><p>ServiceManager是如何启动的？ 这里简要介绍一下ServiceManager的启动方式。当Kernel启动加载完驱动之后，会启动Android的init进程，init进程会解析servicemanager.rc，进而启动servicemanager.rc中定义的守护进程。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ServiceManager.c]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_state</span> *<span class="title">bs</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *svcmgr = BINDER_SERVICE_MANAGER;</span><br><span class="line"></span><br><span class="line">    bs = binder_open(<span class="number">128</span>*<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (binder_become_context_manager(bs)) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    svcmgr_handle = svcmgr;</span><br><span class="line">    binder_loop(bs, svcmgr_handler);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binder_loop</span><span class="params">(struct binder_state *bs, binder_handler func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> readbuf[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">    bwr.write_size = <span class="number">0</span>;</span><br><span class="line">    bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.write_buffer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 告诉Kernel，ServiceManager进程进入了消息循环状态。</span></span><br><span class="line">    readbuf[<span class="number">0</span>] = BC_ENTER_LOOPER;</span><br><span class="line">    binder_write(bs, readbuf, <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        bwr.read_size = <span class="keyword">sizeof</span>(readbuf);</span><br><span class="line">        bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">        bwr.read_buffer = (<span class="keyword">unsigned</span>) readbuf;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向Kernel中发送消息(先写后读)。</span></span><br><span class="line">        <span class="comment">// 先将消息传递给Kernel，然后再从Kernel读取消息反馈</span></span><br><span class="line">        res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析读取的消息反馈</span></span><br><span class="line">        res = binder_parse(bs, <span class="number">0</span>, readbuf, bwr.read_consumed, func);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>binder_loop()主要工作： (1)、通过ioctl(,BINDER_WRITE_READ,)进入消息循环，休眠等待Client请求 (2)、当Client通过驱动请求服务时，binder驱动会唤醒ServiceManager，通过binder_parse()解析处理数据，回复信息</p><p>代码调用关系图：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/03-Android-binder-ServiceManager-main.jpg" alt="Markdown"></p><p>时序流程图：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/04-Android-binder-ServiceManager-main-flow.jpg" alt="Markdown"></p><p>main()主要进行了三项工作： (1) 、通过binder_open()打开”/dev/binder”文件，即打开Binder设备文件。 (2) 、调用binder_become_context_manager()，通过ioctl()告诉Binder驱动程序自己是Binder上下文管理者。 (3) 、调用binder_loop()进入消息循环，等待Client的请求。如果没有Client请求，则进入睡眠等待状态；当有Client请求时，就被唤醒，然后读取并处理Client请求。</p><h4 id="1-2、分析Android-binder原生示例程序bctest-c："><a href="#1-2、分析Android-binder原生示例程序bctest-c：" class="headerlink" title="1.2、分析Android binder原生示例程序bctest.c："></a>1.2、分析Android binder原生示例程序bctest.c：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_state</span> *<span class="title">bs</span>;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> svcmgr = BINDER_SERVICE_MANAGER;</span><br><span class="line">    <span class="keyword">uint32_t</span> handle;</span><br><span class="line"></span><br><span class="line">    bs = binder_open(<span class="number">128</span>*<span class="number">1024</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span> (argc &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//svcmgr_lookup方法调用binder_call(bs, &amp;msg, &amp;reply, 0, SVC_MGR_ADD_SERVICE)</span></span><br><span class="line">            handle = svcmgr_lookup(bs, svcmgr, <span class="string">"alt_svc_mgr"</span>);</span><br><span class="line">            <span class="comment">//svcmgr_publish方法调用binder_call(bs, &amp;msg, &amp;reply, 0, SVC_MGR_CHECK_SERVICE)</span></span><br><span class="line">            svcmgr_publish(bs, svcmgr, argv[<span class="number">1</span>], &amp;token);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3、示例程序（bctest-c）注册服务、获取服务过程"><a href="#1-3、示例程序（bctest-c）注册服务、获取服务过程" class="headerlink" title="1.3、示例程序（bctest.c）注册服务、获取服务过程"></a>1.3、示例程序（bctest.c）注册服务、获取服务过程</h4><p>注册服务的过程（bctest.c）:<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/06-Android-binder-ServiceManager-main-SM-Publish.png" alt="Markdown"></p><p>(1) 、bs = binder_open(128*1024) (2) 、binder_call(bs, &amp;msg, &amp;reply, 0, SVC_MGR_ADD_SERVICE) 参数说明： // msg含有服务的名字 // reply它会含有servicemanager回复的数据 // target为0表示servicemanager // code: 表示要调用servicemanager中的”addservice函数”</p><p>获取服务的过程（bctest.c）:<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/05-Android-binder-ServiceManager-LookUp.png" alt="Markdown"></p><p>(1) 、bs = binder_open(128*1024) (2) 、binder_call(bs, &amp;msg, &amp;reply, target, SVC_MGR_CHECK_SERVICE) 参数说明： // msg含有服务的名字 // reply它会含有servicemanager回复的数据, 表示提供服务的进程 // target为0表示servicemanager // code: 表示要调用servicemanager中的”getservice函数”</p><p>binder_call远程实现： 根据msg、target、code就知道需要调用哪个服务的哪一个函数。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/07-Android-binder-Binder_call.png" alt="Markdown"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_call</span><span class="params">(struct binder_state *bs,</span></span></span><br><span class="line"><span class="function"><span class="params">                struct binder_io *msg, struct binder_io *reply,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">uint32_t</span> target, <span class="keyword">uint32_t</span> code)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">uint32_t</span> cmd;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> <span class="title">txn</span>;</span></span><br><span class="line">    &#125; __attribute__((packed)) writebuf;</span><br><span class="line">    <span class="keyword">unsigned</span> readbuf[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">    writebuf.cmd = BC_TRANSACTION;</span><br><span class="line">    writebuf.txn.target.handle = target;</span><br><span class="line">    writebuf.txn.code = code;</span><br><span class="line">    writebuf.txn.flags = <span class="number">0</span>;</span><br><span class="line">    writebuf.txn.data_size = msg-&gt;data - msg-&gt;data0;</span><br><span class="line">    writebuf.txn.offsets_size = ((<span class="keyword">char</span>*) msg-&gt;offs) - ((<span class="keyword">char</span>*) msg-&gt;offs0);</span><br><span class="line">    writebuf.txn.data.ptr.buffer = (<span class="keyword">uintptr_t</span>)msg-&gt;data0;</span><br><span class="line">    writebuf.txn.data.ptr.offsets = (<span class="keyword">uintptr_t</span>)msg-&gt;offs0;</span><br><span class="line"></span><br><span class="line">    bwr.write_size = <span class="keyword">sizeof</span>(writebuf);</span><br><span class="line">    bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.write_buffer = (<span class="keyword">uintptr_t</span>) &amp;writebuf;</span><br><span class="line"></span><br><span class="line">    hexdump(msg-&gt;data0, msg-&gt;data - msg-&gt;data0);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        bwr.read_size = <span class="keyword">sizeof</span>(readbuf);</span><br><span class="line">        bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">        bwr.read_buffer = (<span class="keyword">uintptr_t</span>) readbuf;</span><br><span class="line"></span><br><span class="line">        res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);</span><br><span class="line"></span><br><span class="line">        res = binder_parse(bs, reply, (<span class="keyword">uintptr_t</span>) readbuf, bwr.read_consumed, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注： 结构体简介 binder_io 封装一次发送的数据 binder_write_read 存储一次读写操作的数据 binder_transaction_data 存储一次事务的数据<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/08-Android-binder-binder_io_struct.png" alt="Markdown"><br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/09-Android-binder-binder_write_read.png" alt="Markdown"><br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/10-Android-binder-binder_transaction_data.jpg" alt="Markdown"></p></blockquote><p>（1）构造参数，使用binder_io 描述<br>（2）数据转换binder_io -&gt; binder_write_read；首先根据binder_io 、target、code三者构造binder_transaction_data，然后将binder_write_read.write_buffer指向binder_transaction_data<br>（3）调用ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);发送数据<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/11-Android-Binder-binder_call.png" alt="Markdown"></p><h3 id="（2）、Android-Binder系统-ServiceManager"><a href="#（2）、Android-Binder系统-ServiceManager" class="headerlink" title="（2）、Android Binder系统_ServiceManager"></a>（2）、Android Binder系统_ServiceManager</h3><p>我们先跳过ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr)所涉及的内核知识和流程，稍后再Android Binder系统-Driver层详细介绍。</p><h4 id="2-1、ServiceManager中service句柄如何管理"><a href="#2-1、ServiceManager中service句柄如何管理" class="headerlink" title="2.1、ServiceManager中service句柄如何管理"></a>2.1、ServiceManager中service句柄如何管理</h4><p>前面分析过，ServiceManager开机初始会启动成为一个守护进程， ServiceManager是如何管理service句柄的？ 进程里有一个全局性的svclist变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">svcinfo</span> *<span class="title">svclist</span> = 0;</span></span><br></pre></td></tr></table></figure><p>它记录着所有添加进系统的”Service”信息，这些信息被组织成一条单向链表，我们不妨称这条链表为”Service向量表”。示意图如下：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/12-Android-Binder-SM-svclist.jpg" alt="Markdown"></p><p>链表节点类型为svcinfo</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/13-Android-Binder-SM-svcinfo.png" alt="Markdown"></p><p>添加服务简单理解就是 新建svcinfo节点插入到单链表中，查询服务就是看单链表是否有此服务。</p><h4 id="2-2、解析Binder上传数据-binder-parse函数"><a href="#2-2、解析Binder上传数据-binder-parse函数" class="headerlink" title="2.2、解析Binder上传数据-(binder_parse函数)"></a>2.2、解析Binder上传数据-(binder_parse函数)</h4><p>回到ServiceManager的main()函数。binder_loop()会先向binder驱动发出了BC_ENTER_LOOPER命令，接着进入一个for循环不断调用ioctl()读取发来的数据，接着解析这些数据。假设现在Client有请求，Binder驱动就通过会上传数据。读取数据后会交由binder_parse()解析。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binder_loop(bs, svcmgr_handler);</span><br></pre></td></tr></table></figure><p>注意binder_loop()的参数svcmgr_handler()函数指针。而且这个参数会进一步传递给binder_parse()。binder_parse()负责解析从binder驱动读来的数据，其代码截选如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_parse</span><span class="params">(struct binder_state *bs, struct binder_io *bio,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">uintptr_t</span> ptr, <span class="keyword">size_t</span> size, binder_handler func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">uintptr_t</span> end = ptr + (<span class="keyword">uintptr_t</span>) size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (ptr &lt; end) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> cmd = *(<span class="keyword">uint32_t</span> *) ptr;</span><br><span class="line">        ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">        <span class="keyword">switch</span>(cmd) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//驱动有数据后会返回次cmd</span></span><br><span class="line">        <span class="keyword">case</span> BR_TRANSACTION: &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> *<span class="title">txn</span> = (<span class="title">struct</span> <span class="title">binder_transaction_data</span> *) <span class="title">ptr</span>;</span></span><br><span class="line">            binder_dump_txn(txn);</span><br><span class="line">            <span class="keyword">if</span> (func) &#123;</span><br><span class="line">                <span class="keyword">unsigned</span> rdata[<span class="number">256</span>/<span class="number">4</span>];</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">binder_io</span> <span class="title">msg</span>;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">binder_io</span> <span class="title">reply</span>;</span></span><br><span class="line">                <span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line">                bio_init(&amp;reply, rdata, <span class="keyword">sizeof</span>(rdata), <span class="number">4</span>);</span><br><span class="line">                bio_init_from_txn(&amp;msg, txn);</span><br><span class="line">                res = func(bs, txn, &amp;msg, &amp;reply);</span><br><span class="line">                <span class="keyword">if</span> (txn-&gt;flags &amp; TF_ONE_WAY) &#123;</span><br><span class="line">                    binder_free_buffer(bs, txn-&gt;data.ptr.buffer);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    binder_send_reply(bs, &amp;reply, txn-&gt;data.ptr.buffer, res);</span><br><span class="line">                &#125;              </span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            ptr += <span class="keyword">sizeof</span>(*txn);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从前文的代码我们可以看到，binder_loop()声明了一个128节的buffer（即uint32_t readbuf[32]），每次用BINDER_WRITE_READ命令从驱动读取一些内容，并传入binder_parse()。 binder_parse()在合适的时机，会回调其func参数（binder_handler func）指代的回调函数，即前文说到的svcmgr_handler()函数。</p><p>binder_loop()就这样一直循环下去，完成了整个ServiceManager的工作。</p><h4 id="2-3、数据转换binder-transaction-data-gt-binder-io"><a href="#2-3、数据转换binder-transaction-data-gt-binder-io" class="headerlink" title="2.3、数据转换binder_transaction_data-&gt;binder_io"></a>2.3、数据转换binder_transaction_data-&gt;binder_io</h4><p>初始化reply；根据txt(Binder驱动反馈的信息)初始化msg</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bio_init(&amp;reply, rdata, <span class="keyword">sizeof</span>(rdata), <span class="number">4</span>);</span><br><span class="line">bio_init_from_txn(&amp;msg, txn);</span><br></pre></td></tr></table></figure><h4 id="2-4、如何添加服务SVC-MGR-ADD-SERVICE"><a href="#2-4、如何添加服务SVC-MGR-ADD-SERVICE" class="headerlink" title="2.4、如何添加服务SVC_MGR_ADD_SERVICE"></a>2.4、如何添加服务SVC_MGR_ADD_SERVICE</h4><p>前面讲过 binder_parse()在合适的时机，会回调其func参数（binder_handler func）指代的回调函数，即前文说到的svcmgr_handler()函数。并且会根据binder_transaction_data的code判断具体调用哪一个函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">svcmgr_handler</span><span class="params">(struct binder_state *bs,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_transaction_data *txn,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_io *msg,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_io *reply)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">svcinfo</span> *<span class="title">si</span>;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> *s;</span><br><span class="line">    <span class="keyword">size_t</span> len;</span><br><span class="line">    <span class="keyword">uint32_t</span> handle;</span><br><span class="line">    <span class="keyword">uint32_t</span> strict_policy;</span><br><span class="line">    <span class="keyword">int</span> allow_isolated;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">switch</span>(txn-&gt;code) &#123;</span><br><span class="line">    <span class="keyword">case</span> SVC_MGR_GET_SERVICE:</span><br><span class="line">    <span class="keyword">case</span> SVC_MGR_CHECK_SERVICE:</span><br><span class="line">        s = bio_get_string16(msg, &amp;len);</span><br><span class="line">        handle = do_find_service(s, len, txn-&gt;sender_euid, txn-&gt;sender_pid);</span><br><span class="line">        bio_put_ref(reply, handle);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> SVC_MGR_ADD_SERVICE:</span><br><span class="line">        s = bio_get_string16(msg, &amp;len);</span><br><span class="line">        handle = bio_get_ref(msg);</span><br><span class="line">        allow_isolated = bio_get_uint32(msg) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (do_add_service(bs, s, len, handle, txn-&gt;sender_euid,</span><br><span class="line">            allow_isolated, txn-&gt;sender_pid))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">    bio_put_uint32(reply, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由代码可知code = SVC_MGR_ADD_SERVICE 会调用do_add_service()函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_add_service</span><span class="params">(struct binder_state *bs,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">const</span> <span class="keyword">uint16_t</span> *s, <span class="keyword">size_t</span> len,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">uint32_t</span> handle, <span class="keyword">uid_t</span> uid, <span class="keyword">int</span> allow_isolated,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">pid_t</span> spid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">svcinfo</span> *<span class="title">si</span>;</span></span><br><span class="line">    ...</span><br><span class="line">    si = find_svc(s, len);</span><br><span class="line">    <span class="keyword">if</span> (si) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        si = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*si) + (len + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>));</span><br><span class="line">        ...</span><br><span class="line">        si-&gt;handle = handle;</span><br><span class="line">        si-&gt;len = len;</span><br><span class="line">        <span class="built_in">memcpy</span>(si-&gt;name, s, (len + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>));</span><br><span class="line">        si-&gt;name[len] = <span class="string">'\0'</span>;</span><br><span class="line">        si-&gt;death.func = (<span class="keyword">void</span>*) svcinfo_death;</span><br><span class="line">        si-&gt;death.ptr = si;</span><br><span class="line">        si-&gt;allow_isolated = allow_isolated;</span><br><span class="line">        si-&gt;next = svclist;</span><br><span class="line">        svclist = si;</span><br><span class="line">    &#125;</span><br><span class="line">    binder_acquire(bs, handle);</span><br><span class="line">    binder_link_to_death(bs, handle, &amp;si-&gt;death);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见添加Service只是新建了一个svcinfo然后插入到前面所说的”Service向量表”中。</p><h4 id="2-5、如何获取服务SVC-MGR-CHECK-SERVICE"><a href="#2-5、如何获取服务SVC-MGR-CHECK-SERVICE" class="headerlink" title="2.5、如何获取服务SVC_MGR_CHECK_SERVICE"></a>2.5、如何获取服务SVC_MGR_CHECK_SERVICE</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> do_find_service(<span class="keyword">const</span> <span class="keyword">uint16_t</span> *s, <span class="keyword">size_t</span> len, <span class="keyword">uid_t</span> uid, <span class="keyword">pid_t</span> spid)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">svcinfo</span> *<span class="title">si</span> = <span class="title">find_svc</span>(<span class="title">s</span>, <span class="title">len</span>);</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> si-&gt;handle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取服务会查询”Service向量表”是否有此服务，然后返回Service的句柄handle。</p><h4 id="2-6、ServiceManager回复数据"><a href="#2-6、ServiceManager回复数据" class="headerlink" title="2.6、ServiceManager回复数据"></a>2.6、ServiceManager回复数据</h4><p>前面分析回调svcmgr_handler()函数处理数据后，会调用binder_send_reply()函数 回复消息给驱动。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binder_send_reply(bs, &amp;reply, txn-&gt;data.ptr.buffer, res)</span><br></pre></td></tr></table></figure><h4 id="2-7、总结："><a href="#2-7、总结：" class="headerlink" title="2.7、总结："></a>2.7、总结：</h4><p>示例程序（bctest.c）注册、获取服务一般分以下步骤： （1）源进程通过binder_open()打开”/dev/binder”文件，即打开Binder设备文件。 （2）源进程构造数据：[a].构造binder_io [b].转为binder_transaction_data [c].放入binder_write_read （3）源进程调用ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);发送数据给驱动 （4）驱动上报数据到目的进程ServiceManager （5）目的进程ServiceManager处理完数据，重新构造数据，通过调用ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);发送数据给驱动 （6）驱动然后将数据反馈到源进程</p><h3 id="（3）、Android-Binder系统C程序"><a href="#（3）、Android-Binder系统C程序" class="headerlink" title="（3）、Android Binder系统C程序"></a>（3）、Android Binder系统C程序</h3><h4 id="3-1、Android-Binder系统C程序-框架"><a href="#3-1、Android-Binder系统C程序-框架" class="headerlink" title="3.1、Android Binder系统C程序_框架"></a>3.1、Android Binder系统C程序_框架</h4><p>总结bctest.c注册服务获取服务的一般流程框架：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/14-Android-Binder-binder_C_app_client_server_Arc.png" alt="Markdown"></p><h4 id="3-2、Android-Binder系统C程序-编码"><a href="#3-2、Android-Binder系统C程序-编码" class="headerlink" title="3.2、Android Binder系统C程序_编码"></a>3.2、Android Binder系统C程序_编码</h4><p>参考bctest.c编码： test_server：向ServiceManager添加服务”hello” &amp;&amp; “goodbye” Service test_client ：查询获取服务(ServiceManager) <a href="https://github.com/weidongshan/APP_0003_Binder_C_App" target="_blank" rel="noopener">链接：Binder_C_App</a><br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/15-Android-binder-C-Test-App.png" alt="Markdown"></p><h4 id="3-3、Android-Binder系统C程序-测试"><a href="#3-3、Android-Binder系统C程序-测试" class="headerlink" title="3.3、Android Binder系统C程序_测试"></a>3.3、Android Binder系统C程序_测试</h4><p>./test_server &amp; ./test_client hello ./test_client hello 100ask.taobao.com ./test_client goodbye ./test_client goodbye 100ask.taobao.com</p><h2 id="二、Android-Binder系统-Driver层"><a href="#二、Android-Binder系统-Driver层" class="headerlink" title="二、Android Binder系统-Driver层"></a>二、Android Binder系统-Driver层</h2><p>前面打开驱动binder_open(128*1024)、ServiceManager启动是如何与驱动交互成为管理者的，以及添加服务获取服务 驱动部分都没有详细讲解，现在一起来看下。</p><h3 id="（1）、Binder驱动概述"><a href="#（1）、Binder驱动概述" class="headerlink" title="（1）、Binder驱动概述"></a>（1）、Binder驱动概述</h3><h4 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h4><p>Binder驱动是Android专用的，但底层的驱动架构与Linux驱动一样。binder驱动在以misc设备进行注册，作为虚拟字符设备，没有直接操作硬件，只是对设备内存的处理。主要是驱动设备的初始化(binder_init)，打开 (binder_open)，映射(binder_mmap)，数据操作(binder_ioctl)。如启动ServiceManager调用:<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/16-Android-Binder-start_service_manager.jpg" alt="Markdown"></p><h4 id="1-2-系统调用"><a href="#1-2-系统调用" class="headerlink" title="1.2 系统调用"></a>1.2 系统调用</h4><p>用户态的程序调用Kernel层驱动是需要陷入内核态，进行系统调用(syscall)，比如打开Binder驱动方法的调用链为： open-&gt; <strong>open() -&gt; binder_open()。 open()为用户空间的方法，</strong>open()便是系统调用中相应的处理方法，通过查找，对应调用到内核binder驱动的binder_open()方法，至于其他的从用户态陷入内核态的流程也基本一致。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/17-Android-binder_driver_interface.png" alt="Markdown"></p><h3 id="（2）、Binder核心方法"><a href="#（2）、Binder核心方法" class="headerlink" title="（2）、Binder核心方法"></a>（2）、Binder核心方法</h3><h4 id="2-1、binder-init"><a href="#2-1、binder-init" class="headerlink" title="2.1、binder_init()"></a>2.1、binder_init()</h4><p>主要工作是为了注册misc设备 binder_init函数中最主要的工作其实下面这行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret = misc_register(&amp;binder_miscdev);</span><br></pre></td></tr></table></figure><p>该行代码真正向内核中注册了Binder设备。binder_miscdev的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> <span class="title">binder_miscdev</span> = &#123;</span></span><br><span class="line">    .minor = MISC_DYNAMIC_MINOR,</span><br><span class="line">    .name = <span class="string">"binder"</span>,</span><br><span class="line">    .fops = &amp;binder_fops</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里指定了Binder设备的名称是”binder”。这样，在用户空间便可以通过对/dev/binder文件进行操作来使用Binder。 binder_miscdev同时也指定了该设备的fops。fops是另外一个结构体，这个结构中包含了一系列的函数指针，其定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">binder_fops</span> = &#123;</span></span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .poll = binder_poll,</span><br><span class="line">    .unlocked_ioctl = binder_ioctl,</span><br><span class="line">    .compat_ioctl = binder_ioctl,</span><br><span class="line">    .mmap = binder_mmap,</span><br><span class="line">    .open = binder_open,</span><br><span class="line">    .flush = binder_flush,</span><br><span class="line">    .release = binder_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-2、主要结构"><a href="#2-2、主要结构" class="headerlink" title="2.2、主要结构"></a>2.2、<strong>主要结构</strong></h4><p>Binder驱动中包含了很多的结构体。为了便于下文讲解，这里我们先对这些结构体做一些介绍。</p><p>驱动中的结构体可以分为两类：</p><p>一类是与用户空间共用的，这些结构体在Binder通信协议过程中会用到。因此，这些结构体定义在binder.h中，包括：</p><table><thead><tr><th style="text-align:left">结构体名称</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:left">flat_binder_object</td><td>描述在Binder IPC中传递的对象，见下文</td></tr><tr><td style="text-align:left"><strong>binder_write_read</strong></td><td>存储一次读写操作的数据</td></tr><tr><td style="text-align:left">binder_version</td><td>存储Binder的版本号</td></tr><tr><td style="text-align:left">transaction_flags</td><td>描述事务的flag，例如是否是异步请求，是否支持fd</td></tr><tr><td style="text-align:left"><strong>binder_transaction_data</strong></td><td>存储一次事务的数据</td></tr><tr><td style="text-align:left">binder_ptr_cookie</td><td>包含了一个指针和一个cookie</td></tr><tr><td style="text-align:left">binder_handle_cookie</td><td>包含了一个句柄和一个cookie</td></tr><tr><td style="text-align:left">binder_pri_desc</td><td>暂未用到</td></tr><tr><td style="text-align:left">binder_pri_ptr_cookie</td><td>暂未用到</td></tr></tbody></table><p>从前面Binder系统C程序框架分析，这其中，<strong>binder_write_read</strong>和<strong>binder_transaction_data</strong>这两个结构体最为重要，它们存储了IPC调用过程中的数据。关于这一点，我们在下文中会讲解。</p><p>Binder驱动中，还有一类结构体是仅仅Binder驱动内部实现过程中需要的，它们定义在binder.c中，包括：</p><table><thead><tr><th style="text-align:left">结构体名称</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:left"><strong>binder_node</strong></td><td>描述Binder实体节点，即：对应了一个Server</td></tr><tr><td style="text-align:left"><strong>binder_ref</strong></td><td>描述对于Binder实体的引用</td></tr><tr><td style="text-align:left"><strong>binder_buffer</strong></td><td>描述Binder通信过程中存储数据的Buffer</td></tr><tr><td style="text-align:left"><strong>binder_proc</strong></td><td>描述使用Binder的进程</td></tr><tr><td style="text-align:left"><strong>binder_thread</strong></td><td>描述使用Binder的线程</td></tr><tr><td style="text-align:left">binder_work</td><td>描述通信过程中的一项任务</td></tr><tr><td style="text-align:left">binder_transaction</td><td>描述一次事务的相关信息</td></tr><tr><td style="text-align:left">binder_deferred_state</td><td>描述延迟任务</td></tr><tr><td style="text-align:left">binder_ref_death</td><td>描述Binder实体死亡的信息</td></tr><tr><td style="text-align:left">binder_transaction_log</td><td>debugfs日志</td></tr><tr><td style="text-align:left">binder_transaction_log_entry</td><td>debugfs日志条目</td></tr></tbody></table><p>这里需要读者关注的结构体已经用加粗做了标注。</p><h4 id="2-3、Binder协议"><a href="#2-3、Binder协议" class="headerlink" title="2.3、Binder协议"></a>2.3、<strong>Binder协议</strong></h4><p>Binder协议可以分为控制协议和驱动协议两类。</p><p>控制协议是进程通过ioctl(“/dev/binder”) 与Binder设备进行通讯的协议，该协议包含以下几种命令：</p><table><thead><tr><th style="text-align:left">结构体名称</th><th>说明</th><th style="text-align:center">参数类型</th></tr></thead><tbody><tr><td style="text-align:left"><strong>BINDER_WRITE_READ</strong></td><td>读写操作，最常用的命令。IPC过程就是通过这个命令进行数据传递</td><td style="text-align:center">binder_write_read</td></tr><tr><td style="text-align:left">BINDER_SET_MAX_THREADS</td><td>设置进程支持的最大线程数量</td><td style="text-align:center">size_t</td></tr><tr><td style="text-align:left">BINDER_SET_CONTEXT_MGR</td><td>设置自身为ServiceManager</td><td style="text-align:center">无</td></tr><tr><td style="text-align:left">BINDER_THREAD_EXIT</td><td>通知驱动Binder线程退出</td><td style="text-align:center">无</td></tr><tr><td style="text-align:left">BINDER_VERSION</td><td>获取Binder驱动的版本号</td><td style="text-align:center">binder_version</td></tr><tr><td style="text-align:left">BINDER_SET_IDLE_PRIORITY</td><td>暂未用到</td><td style="text-align:center">-</td></tr><tr><td style="text-align:left">BINDER_SET_IDLE_TIMEOUT</td><td>暂未用到</td><td style="text-align:center">-</td></tr></tbody></table><p>Binder的驱动协议描述了对于Binder驱动的具体使用过程。驱动协议又可以分为两类：</p><p>一类是binder_driver_command_protocol，描述了进程发送给Binder驱动的命令 一类是binder_driver_return_protocol，描述了Binder驱动发送给进程的命令 binder_driver_command_protocol共包含17个命令，分别是：</p><table><thead><tr><th style="text-align:left">结构体名称</th><th>说明</th><th style="text-align:center">参数类型</th></tr></thead><tbody><tr><td style="text-align:left">BC_TRANSACTION</td><td>Binder事务，即：Client对于Server的请求</td><td style="text-align:center">binder_transaction_data</td></tr><tr><td style="text-align:left">BC_REPLY</td><td>事务的应答，即：Server对于Client的回复</td><td style="text-align:center">binder_transaction_data</td></tr><tr><td style="text-align:left">BC_FREE_BUFFER</td><td>通知驱动释放Buffer</td><td style="text-align:center">binder_uintptr_t</td></tr><tr><td style="text-align:left">BC_ACQUIRE</td><td>强引用计数+1</td><td style="text-align:center">__u32</td></tr><tr><td style="text-align:left">BC_RELEASE</td><td>强引用计数-1</td><td style="text-align:center">__u32</td></tr><tr><td style="text-align:left">BC_INCREFS</td><td>弱引用计数+1</td><td style="text-align:center">__u32</td></tr><tr><td style="text-align:left">BC_DECREFS</td><td>弱引用计数-1 __u32</td></tr><tr><td style="text-align:left">BC_ACQUIRE_DONE</td><td>BR_ACQUIRE的回复</td><td style="text-align:center">binder_ptr_cookie</td></tr><tr><td style="text-align:left">BC_INCREFS_DONE</td><td>BR_INCREFS的回复</td><td style="text-align:center">binder_ptr_cookie</td></tr><tr><td style="text-align:left">BC_ENTER_LOOPER</td><td>通知驱动主线程ready</td><td style="text-align:center">void</td></tr><tr><td style="text-align:left">BC_REGISTER_LOOPER</td><td>通知驱动子线程ready</td><td style="text-align:center">void</td></tr><tr><td style="text-align:left">BC_EXIT_LOOPER</td><td>通知驱动线程已经退出</td><td style="text-align:center">void</td></tr><tr><td style="text-align:left">BC_REQUEST_DEATH_NOTIFICATION</td><td>请求接收死亡通知</td><td style="text-align:center">binder_handle_cookie</td></tr><tr><td style="text-align:left">BC_CLEAR_DEATH_NOTIFICATION</td><td>去除接收死亡通知</td><td style="text-align:center">binder_handle_cookie</td></tr><tr><td style="text-align:left">BC_DEAD_BINDER_DONE</td><td>已经处理完死亡通知</td><td style="text-align:center">binder_uintptr_t</td></tr><tr><td style="text-align:left">BC_ATTEMPT_ACQUIRE</td><td>暂未实现</td><td style="text-align:center">-</td></tr><tr><td style="text-align:left">BC_ACQUIRE_RESULT</td><td>暂未实现</td><td style="text-align:center">-</td></tr></tbody></table><p>binder_driver_return_protocol共包含18个命令，分别是：</p><table><thead><tr><th style="text-align:left">结构体名称</th><th>说明</th><th style="text-align:center">参数类型</th></tr></thead><tbody><tr><td style="text-align:left">BR_OK</td><td>操作完成</td><td style="text-align:center">void</td></tr><tr><td style="text-align:left">BR_NOOP</td><td>操作完成</td><td style="text-align:center">void</td></tr><tr><td style="text-align:left">BR_ERROR</td><td>发生错误</td><td style="text-align:center">__s32</td></tr><tr><td style="text-align:left">BR_TRANSACTION</td><td>通知进程收到一次Binder请求（Server端）</td><td style="text-align:center">binder_transaction_data</td></tr><tr><td style="text-align:left">BR_REPLY</td><td>通知进程收到Binder请求的回复（Client）</td><td style="text-align:center">binder_transaction_data</td></tr><tr><td style="text-align:left">BR_TRANSACTION_COMPLETE</td><td>驱动对于接受请求的确认回复</td><td style="text-align:center">void</td></tr><tr><td style="text-align:left">BR_FAILED_REPLY</td><td>告知发送方通信目标不存在</td><td style="text-align:center">void</td></tr><tr><td style="text-align:left">BR_SPAWN_LOOPER</td><td>通知Binder进程创建一个新的线程</td><td style="text-align:center">void</td></tr><tr><td style="text-align:left">BR_ACQUIRE</td><td>强引用计数+1请求</td><td style="text-align:center">binder_ptr_cookie</td></tr><tr><td style="text-align:left">BR_RELEASE</td><td>强引用计数-1请求</td><td style="text-align:center">binder_ptr_cookie</td></tr><tr><td style="text-align:left">BR_INCREFS</td><td>弱引用计数+1请求</td><td style="text-align:center">binder_ptr_cookie</td></tr><tr><td style="text-align:left">BR_DECREFS</td><td>若引用计数-1请求</td><td style="text-align:center">binder_ptr_cookie</td></tr><tr><td style="text-align:left">BR_DEAD_BINDER</td><td>发送死亡通知</td><td style="text-align:center">binder_uintptr_t</td></tr><tr><td style="text-align:left">BR_CLEAR_DEATH_NOTIFICATION_DONE</td><td>清理死亡通知完成</td><td style="text-align:center">binder_uintptr_t</td></tr><tr><td style="text-align:left">BR_DEAD_REPLY</td><td>告知发送方对方已经死亡</td><td style="text-align:center">void</td></tr><tr><td style="text-align:left">BR_ACQUIRE_RESULT</td><td>暂未实现</td><td style="text-align:center">-</td></tr><tr><td style="text-align:left">BR_ATTEMPT_ACQUIRE</td><td>暂未实现</td><td style="text-align:center">-</td></tr><tr><td style="text-align:left">BR_FINISHED</td><td>暂未实现</td><td style="text-align:center">-</td></tr></tbody></table><p>单独看上面的协议可能很难理解，这里我们以一次Binder请求过程来详细看一下Binder协议是如何通信的，就比较好理解了。</p><p>这幅图的说明如下：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/18-Android-binder_transaction_ipc.jpg" alt="Markdown"></p><p>Binder是C/S架构的，通信过程牵涉到：Client，Server以及Binder驱动三个角色 Client对于Server的请求以及Server对于Client回复都需要通过Binder驱动来中转数据 BC_XXX命令是进程发送给驱动的命令 BR_XXX命令是驱动发送给进程的命令 整个通信过程由Binder驱动控制</p><h4 id="2-4、binder-open"><a href="#2-4、binder-open" class="headerlink" title="2.4、binder_open()"></a>2.4、binder_open()</h4><p>任何进程在使用Binder之前，都需要先通过open(“/dev/binder”)打开Binder设备。上文已经提到，用户空间的open系统调用对应了驱动中的binder_open函数。在这个函数，Binder驱动会为调用的进程做一些初始化工作。binder_open函数代码如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_open</span><span class="params">(struct inode *nodp, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span>;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 创建进程对应的binder_proc对象</span></span><br><span class="line">    proc = kzalloc(<span class="keyword">sizeof</span>(*proc), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (proc == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    get_task_struct(current);</span><br><span class="line">    proc-&gt;tsk = current;</span><br><span class="line">    <span class="comment">// 初始化binder_proc</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;proc-&gt;todo);</span><br><span class="line">    init_waitqueue_head(&amp;proc-&gt;wait);</span><br><span class="line">    proc-&gt;default_priority = task_nice(current);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁保护</span></span><br><span class="line">    binder_lock(__func__);</span><br><span class="line"></span><br><span class="line">    binder_stats_created(BINDER_STAT_PROC);</span><br><span class="line">    <span class="comment">// 添加到全局列表binder_procs中</span></span><br><span class="line">    hlist_add_head(&amp;proc-&gt;proc_node, &amp;binder_procs);</span><br><span class="line">    proc-&gt;pid = current-&gt;group_leader-&gt;pid;</span><br><span class="line">    INIT_LIST_HEAD(&amp;proc-&gt;delivered_death);</span><br><span class="line">    filp-&gt;private_data = proc;</span><br><span class="line"></span><br><span class="line">    binder_unlock(__func__);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Binder驱动中，通过binder_procs记录了所有使用Binder的进程。每个初次打开Binder设备的进程都会被添加到这个列表中的。</p><p>另外，请读者回顾一下上文介绍的Binder驱动中的几个关键结构体：</p><blockquote><p>binder_proc binder_node binder_thread binder_ref binder_buffer</p></blockquote><p>在实现过程中，为了便于查找，这些结构体互相之间都留有字段存储关联的结构。</p><p>下面这幅图描述了这里说到的这些内容：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/19-Android-binder_main_struct.png" alt="Markdown"></p><h4 id="2-5、binder-mmap"><a href="#2-5、binder-mmap" class="headerlink" title="2.5、binder_mmap()"></a>2.5、binder_mmap()</h4><p>在打开Binder设备之后，进程还会通过mmap进行内存映射。mmap的作用有如下两个：</p><p>申请一块内存空间，用来接收Binder通信过程中的数据 对这块内存进行地址映射，以便将来访问 binder_mmap函数对应了mmap系统调用的处理，这个函数也是Binder驱动的精华所在（这里说的binder_mmap函数也包括其内部调用的binder_update_page_range函数，见下文）。</p><p>前文我们说到，使用Binder机制，数据只需要经历一次拷贝就可以了，其原理就在这个函数中。</p><p>binder_mmap这个函数中，会申请一块物理内存，然后在用户空间和内核空间同时对应到这块内存上。在这之后，当有Client要发送数据给Server的时候，只需一次，将Client发送过来的数据拷贝到Server端的内核空间指定的内存地址即可，由于这个内存地址在服务端已经同时映射到用户空间，因此无需再做一次复制，Server即可直接访问，整个过程如下图所示：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/20-Android-mmap_and_transaction.png" alt="Markdown"></p><p>这幅图的说明如下：</p><p>Server在启动之后，调用对/dev/binder设备调用mmap 内核中的binder_mmap函数进行对应的处理：申请一块物理内存，然后在用户空间和内核空间同时进行映射 Client通过BINDER_WRITE_READ命令发送请求，这个请求将先到驱动中，同时需要将数据从Client进程的用户空间拷贝到内核空间 驱动通过BR_TRANSACTION通知Server有人发出请求，Server进行处理。由于这块内存也在用户空间进行了映射，因此Server进程的代码可以直接访问 了解原理之后，我们再来看一下Binder驱动的相关源码。这段代码有两个函数：</p><p>binder_mmap函数对应了mmap的系统调用的处理 binder_update_page_range函数真正实现了内存分配和地址映射</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_mmap</span><span class="params">(struct file *filp, struct vm_area_struct *vma)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_struct</span> *<span class="title">area</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *failure_string;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer</span> *<span class="title">buffer</span>;</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">   <span class="comment">// 在内核空间获取一块地址范围</span></span><br><span class="line">    area = get_vm_area(vma-&gt;vm_end - vma-&gt;vm_start, VM_IOREMAP);</span><br><span class="line">    <span class="keyword">if</span> (area == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ret = -ENOMEM;</span><br><span class="line">        failure_string = <span class="string">"get_vm_area"</span>;</span><br><span class="line">        <span class="keyword">goto</span> err_get_vm_area_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    proc-&gt;buffer = area-&gt;addr;</span><br><span class="line">    <span class="comment">// 记录内核空间与用户空间的地址偏移</span></span><br><span class="line">    proc-&gt;user_buffer_offset = vma-&gt;vm_start - (<span class="keyword">uintptr_t</span>)proc-&gt;buffer;</span><br><span class="line">    mutex_unlock(&amp;binder_mmap_lock);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">    proc-&gt;pages = kzalloc(<span class="keyword">sizeof</span>(proc-&gt;pages[<span class="number">0</span>]) * ((vma-&gt;vm_end - vma-&gt;vm_start) / PAGE_SIZE), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;pages == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ret = -ENOMEM;</span><br><span class="line">        failure_string = <span class="string">"alloc page array"</span>;</span><br><span class="line">        <span class="keyword">goto</span> err_alloc_pages_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    proc-&gt;buffer_size = vma-&gt;vm_end - vma-&gt;vm_start;</span><br><span class="line"></span><br><span class="line">    vma-&gt;vm_ops = &amp;binder_vm_ops;</span><br><span class="line">    vma-&gt;vm_private_data = proc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* binder_update_page_range assumes preemption is disabled */</span></span><br><span class="line">    preempt_disable();</span><br><span class="line">    <span class="comment">// 通过下面这个函数真正完成内存的申请和地址的映射</span></span><br><span class="line">    <span class="comment">// 初次使用，先申请一个PAGE_SIZE大小的内存</span></span><br><span class="line">    ret = binder_update_page_range(proc, <span class="number">1</span>, proc-&gt;buffer, proc-&gt;buffer + PAGE_SIZE, vma);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_update_page_range</span><span class="params">(struct binder_proc *proc, <span class="keyword">int</span> allocate,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">void</span> *start, <span class="keyword">void</span> *end,</span></span></span><br><span class="line"><span class="function"><span class="params">                    struct vm_area_struct *vma)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *page_addr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> user_page_addr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_struct</span> <span class="title">tmp_area</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> **<span class="title">page</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (page_addr = start; page_addr &lt; end; page_addr += PAGE_SIZE) &#123;</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> **<span class="title">page_array_ptr</span>;</span></span><br><span class="line">        page = &amp;proc-&gt;pages[(page_addr - proc-&gt;buffer) / PAGE_SIZE];</span><br><span class="line"></span><br><span class="line">        BUG_ON(*page);</span><br><span class="line">        <span class="comment">// 真正进行内存的分配</span></span><br><span class="line">        *page = alloc_page(GFP_KERNEL | __GFP_HIGHMEM | __GFP_ZERO);</span><br><span class="line">        <span class="keyword">if</span> (*page == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            pr_err(<span class="string">"%d: binder_alloc_buf failed for page at %p\n"</span>,</span><br><span class="line">                proc-&gt;pid, page_addr);</span><br><span class="line">            <span class="keyword">goto</span> err_alloc_page_failed;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp_area.addr = page_addr;</span><br><span class="line">        tmp_area.size = PAGE_SIZE + PAGE_SIZE <span class="comment">/* guard page? */</span>;</span><br><span class="line">        page_array_ptr = page;</span><br><span class="line">        <span class="comment">// 在内核空间进行内存映射</span></span><br><span class="line">        ret = map_vm_area(&amp;tmp_area, PAGE_KERNEL, &amp;page_array_ptr);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            pr_err(<span class="string">"%d: binder_alloc_buf failed to map page at %p in kernel\n"</span>,</span><br><span class="line">                   proc-&gt;pid, page_addr);</span><br><span class="line">            <span class="keyword">goto</span> err_map_kernel_failed;</span><br><span class="line">        &#125;</span><br><span class="line">        user_page_addr =</span><br><span class="line">            (<span class="keyword">uintptr_t</span>)page_addr + proc-&gt;user_buffer_offset;</span><br><span class="line">        <span class="comment">// 在用户空间进行内存映射</span></span><br><span class="line">        ret = vm_insert_page(vma, user_page_addr, page[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            pr_err(<span class="string">"%d: binder_alloc_buf failed to map page at %lx in userspace\n"</span>,</span><br><span class="line">                   proc-&gt;pid, user_page_addr);</span><br><span class="line">            <span class="keyword">goto</span> err_vm_insert_page_failed;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* vm_insert_page does not seem to increment the refcount */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mm) &#123;</span><br><span class="line">        up_write(&amp;mm-&gt;mmap_sem);</span><br><span class="line">        mmput(mm);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    preempt_disable();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>binder_update_page_range主要完成工作：分配物理空间，将物理空间映射到内核空间，将物理空间映射到进程空间. 另外，不同参数下该方法也可以释放物理页面。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/21-Android-binder_mmap.png" alt="Markdown"></p><h4 id="2-6、binder-ioctl-内存管理"><a href="#2-6、binder-ioctl-内存管理" class="headerlink" title="2.6、binder_ioctl()内存管理"></a>2.6、binder_ioctl()内存管理</h4><p>上文中，我们看到binder_mmap的时候，会申请一个PAGE_SIZE(通常是4K)的内存。而实际使用过程中，一个PAGE_SIZE的大小通常是不够的。</p><p>在驱动中，会根据实际的使用情况进行内存的分配。有内存的分配，当然也需要内存的释放。这里我们就来看看Binder驱动中是如何进行内存的管理的。</p><p>首先，我们还是从一次IPC请求说起。</p><p>当一个Client想要对Server发出请求时，它首先将请求发送到Binder设备上，由Binder驱动根据请求的信息找到对应的目标节点，然后将请求数据传递过去。</p><p>进程通过ioctl系统调用来发出请求：ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr)</p><p>这里的bs-&gt;fd对应了打开Binder设备时的fd。BINDER_WRITE_READ对应了具体要做的操作码，这个操作码将由Binder驱动解析。bwr存储了请求数据，其类型是binder_write_read。</p><p>binder_write_read其实是一个相对外层的数据结构，其内部会包含一个binder_transaction_data结构的数据。binder_transaction_data包含了发出请求者的标识，请求的目标对象以及请求所需要的参数。它们的关系如下图所示：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/22-Android-binder_write_read.png" alt="Markdown"></p><p>binder_ioctl函数对应了ioctl系统调用的处理。这个函数的逻辑比较简单，就是根据ioctl的命令来确定进一步处理的逻辑，具体如下:</p><p>● 如果命令是BINDER_WRITE_READ，并且<br>● 如果 bwr.write_size &gt; 0，则调用binder_thread_write<br>● 如果 bwr.read_size &gt; 0，则调用binder_thread_read<br>● 如果命令是BINDER_SET_MAX_THREADS，则设置进程的max_threads，即进程支持的最大线程数<br>● 如果命令是BINDER_SET_CONTEXT_MGR，则设置当前进程为ServiceManager，见下文<br>● 如果命令是BINDER_THREAD_EXIT，则调用binder_free_thread，释放binder_thread<br>● 如果命令是BINDER_VERSION，则返回当前的Binder版本号 这其中，最关键的就是binder_thread_write方法。当Client请求Server的时候，便会发送一个BINDER_WRITE_READ命令，同时框架会将将实际的数据包装好。此时，binder_transaction_data中的code将是BC_TRANSACTION，由此便会调用到binder_transaction方法，这个方法是对一次Binder事务的处理，这其中会调用binder_alloc_buf函数为此次事务申请一个缓存。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rb_node</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="built_in">free</span>:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> allow_user_free:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> async_transaction:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> debug_id:<span class="number">29</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">transaction</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">target_node</span>;</span></span><br><span class="line">    <span class="keyword">size_t</span> data_size;</span><br><span class="line">    <span class="keyword">size_t</span> offsets_size;</span><br><span class="line">    <span class="keyword">uint8_t</span> data[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而在binder_proc（描述了使用Binder的进程）中，包含了几个字段用来管理进程在Binder IPC过程中缓存，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">buffers</span>;</span> <span class="comment">// 进程拥有的buffer列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">free_buffers</span>;</span> <span class="comment">// 空闲buffer列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">allocated_buffers</span>;</span> <span class="comment">// 已使用的buffer列表</span></span><br><span class="line">    <span class="keyword">size_t</span> free_async_space; <span class="comment">// 剩余的异步调用的空间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> buffer_size; <span class="comment">// 缓存的上限</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>进程在mmap时，会设定支持的总缓存大小的上限（下文会讲到）。而进程每当收到BC_TRANSACTION，就会判断已使用缓存加本次申请的和有没有超过上限。如果没有，就考虑进行内存的分配。</p><p>进程的空闲缓存记录在binder_proc的free_buffers中，这是一个以红黑树形式存储的结构。每次尝试分配缓存的时候，会从这里面按大小顺序进行查找，找到最接近需要的一块缓存。查找的逻辑如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (n) &#123;</span><br><span class="line">    buffer = rb_entry(n, struct binder_buffer, rb_node);</span><br><span class="line">    BUG_ON(!buffer-&gt;<span class="built_in">free</span>);</span><br><span class="line">    buffer_size = binder_buffer_size(proc, buffer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &lt; buffer_size) &#123;</span><br><span class="line">        best_fit = n;</span><br><span class="line">        n = n-&gt;rb_left;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (size &gt; buffer_size)</span><br><span class="line">        n = n-&gt;rb_right;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        best_fit = n;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到之后，还需要对binder_proc中的字段进行相应的更新：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">rb_erase(best_fit, &amp;proc-&gt;free_buffers);</span><br><span class="line">buffer-&gt;<span class="built_in">free</span> = <span class="number">0</span>;</span><br><span class="line">binder_insert_allocated_buffer(proc, buffer);</span><br><span class="line"><span class="keyword">if</span> (buffer_size != size) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer</span> *<span class="title">new_buffer</span> = (<span class="title">void</span> *)<span class="title">buffer</span>-&gt;<span class="title">data</span> + <span class="title">size</span>;</span></span><br><span class="line">    list_add(&amp;new_buffer-&gt;entry, &amp;buffer-&gt;entry);</span><br><span class="line">    new_buffer-&gt;<span class="built_in">free</span> = <span class="number">1</span>;</span><br><span class="line">    binder_insert_free_buffer(proc, new_buffer);</span><br><span class="line">&#125;</span><br><span class="line">binder_debug(BINDER_DEBUG_BUFFER_ALLOC,</span><br><span class="line">         <span class="string">"%d: binder_alloc_buf size %zd got %p\n"</span>,</span><br><span class="line">          proc-&gt;pid, size, buffer);</span><br><span class="line">buffer-&gt;data_size = data_size;</span><br><span class="line">buffer-&gt;offsets_size = offsets_size;</span><br><span class="line">buffer-&gt;async_transaction = is_async;</span><br><span class="line"><span class="keyword">if</span> (is_async) &#123;</span><br><span class="line">    proc-&gt;free_async_space -= size + <span class="keyword">sizeof</span>(struct binder_buffer);</span><br><span class="line">    binder_debug(BINDER_DEBUG_BUFFER_ALLOC_ASYNC,</span><br><span class="line">             <span class="string">"%d: binder_alloc_buf size %zd async free %zd\n"</span>,</span><br><span class="line">              proc-&gt;pid, size, proc-&gt;free_async_space);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们再来看看内存的释放。</p><p>BC_FREE_BUFFER命令是通知驱动进行内存的释放，binder_free_buf函数是真正实现的逻辑，这个函数与binder_alloc_buf是刚好对应的。在这个函数中，所做的事情包括：</p><p>重新计算进程的空闲缓存大小 通过binder_update_page_range释放内存 更新binder_proc的buffers，free_buffers，allocated_buffers字段</p><h4 id="2-7、Binder中的”面向对象”"><a href="#2-7、Binder中的”面向对象”" class="headerlink" title="2.7、Binder中的”面向对象”"></a>2.7、<strong>Binder中的”面向对象”</strong></h4><p>Binder机制淡化了进程的边界，使得跨越进程也能够调用到指定服务的方法，其原因是因为Binder机制在底层处理了在进程间的”对象”传递。</p><p>在Binder驱动中，并不是真的将对象在进程间来回序列化，而是通过特定的标识来进行对象的传递。Binder驱动中，通过flat_binder_object来描述需要跨越进程传递的对象。其定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flat_binder_object</span> &#123;</span></span><br><span class="line">    __u32        type;</span><br><span class="line">    __u32        flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">binder_uintptr_t</span>    binder; <span class="comment">/* local object */</span></span><br><span class="line">        __u32            handle;    <span class="comment">/* remote object */</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">binder_uintptr_t</span>    cookie;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这其中，type有如下5种类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    BINDER_TYPE_BINDER    = B_PACK_CHARS(<span class="string">'s'</span>, <span class="string">'b'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</span><br><span class="line">    BINDER_TYPE_WEAK_BINDER    = B_PACK_CHARS(<span class="string">'w'</span>, <span class="string">'b'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</span><br><span class="line">    BINDER_TYPE_HANDLE    = B_PACK_CHARS(<span class="string">'s'</span>, <span class="string">'h'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</span><br><span class="line">    BINDER_TYPE_WEAK_HANDLE    = B_PACK_CHARS(<span class="string">'w'</span>, <span class="string">'h'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</span><br><span class="line">    BINDER_TYPE_FD        = B_PACK_CHARS(<span class="string">'f'</span>, <span class="string">'d'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当对象传递到Binder驱动中的时候，由驱动来进行翻译和解释，然后传递到接收的进程。</p><p>例如当Server把Binder实体传递给Client时，在发送数据流中，flat_binder_object中的type是BINDER_TYPE_BINDER，同时binder字段指向Server进程用户空间地址。但这个地址对于Client进程是没有意义的（Linux中，每个进程的地址空间是互相隔离的），驱动必须对数据流中的flat_binder_object做相应的翻译：将type该成BINDER_TYPE_HANDLE；为这个Binder在接收进程中创建位于内核中的引用并将引用号填入handle中。对于发生数据流中引用类型的Binder也要做同样转换。经过处理后接收进程从数据流中取得的Binder引用才是有效的，才可以将其填入数据包binder_transaction_data的target.handle域，向Binder实体发送请求。</p><p>由于每个请求和请求的返回都会经历内核的翻译，因此这个过程从进程的角度来看是完全透明的。进程完全不用感知这个过程，就好像对象真的在进程间来回传递一样。</p><h4 id="2-8、驱动层的线程管理"><a href="#2-8、驱动层的线程管理" class="headerlink" title="2.8、驱动层的线程管理"></a>2.8、<strong>驱动层的线程管理</strong></h4><p>上文多次提到，Binder本身是C/S架构。由Server提供服务，被Client使用。既然是C/S架构，就可能存在多个Client会同时访问Server的情况。 在这种情况下，如果Server只有一个线程处理响应，就会导致客户端的请求可能需要排队而导致响应过慢的现象发生。解决这个问题的方法就是引入多线程。</p><p>Binder机制的设计从最底层–驱动层，就考虑到了对于多线程的支持。具体内容如下：</p><p>使用Binder的进程在启动之后，通过BINDER_SET_MAX_THREADS告知驱动其支持的最大线程数量 驱动会对线程进行管理。在binder_proc结构中，这些字段记录了进程中线程的信息：max_threads，requested_threads，requested_threads_started，ready_threads binder_thread结构对应了Binder进程中的线程 驱动通过BR_SPAWN_LOOPER命令告知进程需要创建一个新的线程 进程通过BC_ENTER_LOOPER命令告知驱动其主线程已经ready 进程通过BC_REGISTER_LOOPER命令告知驱动其子线程（非主线程）已经ready 进程通过BC_EXIT_LOOPER命令告知驱动其线程将要退出 在线程退出之后，通过BINDER_THREAD_EXIT告知Binder驱动。驱动将对应的binder_thread对象销毁</p><h4 id="2-9、再聊ServiceManager"><a href="#2-9、再聊ServiceManager" class="headerlink" title="2.9、再聊ServiceManager"></a>2.9、再聊ServiceManager</h4><p>上文已经说过，每一个Binder Server在驱动中会有一个binder_node进行对应。同时，Binder驱动会负责在进程间传递服务对象，并负责底层的转换。另外，我们也提到，每一个Binder服务都需要有一个唯一的名称。由ServiceManager来管理这些服务的注册和查找。</p><p>而实际上，为了便于使用，ServiceManager本身也实现为一个Server对象。任何进程在使用ServiceManager的时候，都需要先拿到指向它的标识。然后通过这个标识来使用ServiceManager。</p><p>这似乎形成了一个互相矛盾的现象：</p><p>通过ServiceManager我们才能拿到Server的标识 ServiceManager本身也是一个Server 解决这个矛盾的办法其实也很简单：Binder机制为ServiceManager预留了一个特殊的位置。这个位置是预先定好的，任何想要使用ServiceManager的进程只要通过这个特定的位置就可以访问到ServiceManager了（而不用再通过ServiceManager的接口）。</p><p>在Binder驱动中，有一个全局的binder_node 变量：</p><blockquote><p><strong>一般情况下，对于每一个Server驱动层会对应一个binder_node节点，然而binder_context_mgr_node比较特殊，它没有对应的应用层binder实体。在整个系统里，它是如此特殊，以至于系统规定，任何应用都必须使用句柄0来跨进程地访问它。</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">binder_context_mgr_node</span>;</span></span><br></pre></td></tr></table></figure><p>这个变量指向的就是ServiceManager。</p><p>当有进程通过ioctl并指定命令为BINDER_SET_CONTEXT_MGR的时候，驱动被认定这个进程是ServiceManager，binder_ioctl()函数中对应的处理如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> BINDER_SET_CONTEXT_MGR:</span><br><span class="line">    <span class="keyword">if</span> (binder_context_mgr_node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = security_binder_set_context_mgr(proc-&gt;tsk);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    binder_context_mgr_uid = current-&gt;cred-&gt;euid;</span><br><span class="line">    binder_context_mgr_node = binder_new_node(proc, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//在Binder驱动层创建binder_node结构体对象</span></span><br><span class="line">    binder_context_mgr_node-&gt;local_weak_refs++;</span><br><span class="line">    binder_context_mgr_node-&gt;local_strong_refs++;</span><br><span class="line">    binder_context_mgr_node-&gt;has_strong_ref = <span class="number">1</span>;</span><br><span class="line">    binder_context_mgr_node-&gt;has_weak_ref = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>ServiceManager应当要先于所有Binder Server之前启动。在它启动完成并告知Binder驱动之后，驱动便设定好了这个特定的节点。</p><p>在这之后，当有其他模块想要使用ServerManager的时候，只要将请求指向ServiceManager所在的位置即可。</p><p>在Binder驱动中，通过handle = 0这个位置来访问ServiceManager。例如，binder_transaction中，判断如果target.handler为0，则认为这个请求是发送给ServiceManager的，相关代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tr-&gt;target.handle) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_ref</span> *<span class="title">ref</span>;</span></span><br><span class="line">    ref = binder_get_ref(proc, tr-&gt;target.handle, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (ref == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        binder_user_error(<span class="string">"%d:%d got transaction to invalid handle\n"</span>,</span><br><span class="line">            proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">        return_error = BR_FAILED_REPLY;</span><br><span class="line">        <span class="keyword">goto</span> err_invalid_target_handle;</span><br><span class="line">    &#125;</span><br><span class="line">    target_node = ref-&gt;node;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    target_node = binder_context_mgr_node;</span><br><span class="line">    <span class="keyword">if</span> (target_node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        return_error = BR_DEAD_REPLY;</span><br><span class="line">        <span class="keyword">goto</span> err_no_context_mgr_node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-10、binder-node等重要结构体"><a href="#2-10、binder-node等重要结构体" class="headerlink" title="2.10、binder_node等重要结构体"></a>2.10、binder_node等重要结构体</h4><blockquote><p>binder_proc binder_node binder_thread binder_ref binder_buffer</p></blockquote><p><strong>1. Binder实体binder_node</strong></p><p>Binder实体，是各个Server以及ServiceManager在内核中的存在形式。 Binder实体实际上是内核中binder_node结构体的对象，它的作用是在内核中保存Server和ServiceManager的信息(例如，Binder实体中保存了Server对象在用户空间的地址)。简言之，Binder实体是Server在Binder驱动中的存在形式，内核通过Binder实体可以找到用户空间的Server对象。 在上图中，Server和ServiceManager在Binder驱动中都对应的存在一个Binder实体。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/26-Android-Binder_node_struct.png" alt="Markdown"></p><p><strong>2. Binder引用binder_ref</strong></p><p>说到Binder实体，就不得不说”Binder引用”。所谓Binder引用，实际上是内核中binder_ref结构体的对象，它的作用是在表示”Binder实体”的引用。换句话说，每一个Binder引用都是某一个Binder实体的引用，通过Binder引用可以在内核中找到它对应的Binder实体。 如果将Server看作是Binder实体的话，那么Client就好比Binder引用。Client要和Server通信，它就是通过保存一个Server对象的Binder引用，再通过该Binder引用在内核中找到对应的Binder实体，进而找到Server对象，然后将通信内容发送给Server对象。</p><p>Binder实体和Binder引用都是内核(即，Binder驱动)中的数据结构。每一个Server在内核中就表现为一个Binder实体，而每一个Client则表现为一个Binder引用。这样，每个Binder引用都对应一个Binder实体，而每个Binder实体则可以多个Binder引用。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/24-Android-binder_ref.png" alt="Markdown"></p><p><strong>3、Binder buffer：binder_buffer</strong><br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/99-Android-Binder-IPCall.png" alt="Markdown"></p><p><strong>4、Binder进程binder_proc</strong></p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/25-Android-binder_proc.png" alt="Markdown"></p><p><strong>5、Binder线程binder_thread</strong><br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/27-Android-binder_thread.png" alt="Markdown"></p><p>binder机制到底是如何从Binder对象找到其对应的Binder实体呢？<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/28-Android-Bp-Bbinder.png" alt="Markdown"></p><p>注意其中的那4个rb_root域，”rb”的意思是”red black”，可见binder_proc里搞出了4个红黑树。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/29-Android-binder_proc_red_root.png" alt="Markdown"></p><p>其中，nodes树用于记录binder实体，refs_by_desc树和refs_by_node树则用于记录binder代理。之所以会有两个代理树，是为了便于快速查找，我们暂时只关心其中之一就可以了。threads树用于记录执行传输动作的线程信息。</p><p>在一个进程中，有多少”被其他进程进行跨进程调用的”binder实体，就会在该进程对应的nodes树中生成多少个红黑树节点。另一方面，一个进程要访问多少其他进程的binder实体，则必须在其refs_by_desc树中拥有对应的引用节点。</p><p>这4棵树的节点类型是不同的，threads树的节点类型为binder_thread，nodes树的节点类型为binder_node，refs_by_desc树和refs_by_node树的节点类型相同，为binder_ref。这些节点内部都会包含rb_node子结构，该结构专门负责连接节点的工作，和前文的hlist_node有点儿异曲同工，这也是linux上一个常用的小技巧。我们以nodes树为例<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/30-Android-binder_proc_hlist_node.png" alt="Markdown"></p><p>nodes树是用于记录binder实体的，所以nodes树中的每个binder_node节点，必须能够记录下相应binder实体的信息。因此请大家注意binder_node的ptr域和cookie域。</p><p>另一方面，refs_by_desc树和refs_by_node树的每个binder_ref节点则和上层的一个BpBinder对应，而且更重要的是，它必须具有和”目标binder实体的binder_node”进行关联的信息。</p><p>请注意binder_ref的那个node域，它负责和binder_node关联。另外，binder_ref中有两个类型为rb_node的域：rb_node_desc域和rb_node_node域，它们分别用于连接refs_by_desc树和refs_by_node。也就是说虽然binder_proc中有两棵引用树，但这两棵树用到的具体binder_ref节点其实是复用的。</p><blockquote><p>binder_node.ptr对应于flat_binder_object.binder； binder_node.cookie对应于flat_binder_object.cookie。</p></blockquote><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/31-Android-binder_ref-find-binder_node.png" alt="Markdown"><br>OK，现在我们可以更深入地说明binder句柄的作用了，比如进程1的BpBinder在发起跨进程调用时，向binder驱动传入了自己记录的句柄值，binder驱动就会在”进程1对应的binder_proc结构”的引用树中查找和句柄值相符的binder_ref节点，一旦找到binder_ref节点，就可以通过该节点的node域找到对应的binder_node节点，这个目标binder_node当然是从属于进程2的binder_proc啦，不过不要紧，因为binder_ref和binder_node都处于binder驱动的地址空间中，所以是可以用指针直接指向的。目标binder_node节点的cookie域，记录的其实是进程2中BBinder的地址，binder驱动只需把这个值反映给应用层，应用层就可以直接拿到BBinder了。这就是Binder完成精确打击的大体过程。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/32-Android-binder_relationship.jpg" alt="Markdown"></p><h2 id="三、Android-Binder系统驱动情景分析"><a href="#三、Android-Binder系统驱动情景分析" class="headerlink" title="三、Android Binder系统驱动情景分析"></a>三、Android Binder系统驱动情景分析</h2><p>为了更深刻的了解Binder系统 注册服务、获取服务、使用服务的过程，在Driver层(kernel/drivers/staging/android/binder.c)的binder_thread_read()函数、binder_transaction()函数入打印log，让前面编写的C程序示例与binder驱动交互打印更详细的过程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binder_transaction</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_transaction_data *tr, <span class="keyword">int</span> reply)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_thread_write</span><span class="params">(struct binder_proc *proc, struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">void</span> __user *buffer, <span class="keyword">int</span> size, <span class="keyword">signed</span> <span class="keyword">long</span> *consumed)</span></span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/weidongshan/DRV_0003_Binder/" target="_blank" rel="noopener">已添加好打印log的binder.c文件见GitHub（注：搜索[/* print] 关键字）</a> 事先已经准备好打印log，现在结合log和Binder事务处理开始详细分析。注：log稍后分析再贴出。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/33-Android-binder_transaction_ipc.jpg" alt="Markdown"></p><h3 id="（1）、Binder系统驱动情景分析–服务”Hello”注册过程"><a href="#（1）、Binder系统驱动情景分析–服务”Hello”注册过程" class="headerlink" title="（1）、Binder系统驱动情景分析–服务”Hello”注册过程"></a>（1）、Binder系统驱动情景分析–服务”Hello”注册过程</h3><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/35-Android-binder-add_service.png" alt="Markdown"></p><h4 id="1-1、ServiceManager休眠等待"><a href="#1-1、ServiceManager休眠等待" class="headerlink" title="1.1、ServiceManager休眠等待"></a>1.1、ServiceManager休眠等待</h4><p>回顾一下ServiceManager启动流程，ServiceManager进入binder_loop()后 会休眠等待响应client请求。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">binder_loop()&#123;</span><br><span class="line">    <span class="comment">// 告诉Kernel，ServiceManager进程进入了消息循环状态。</span></span><br><span class="line">    readbuf[<span class="number">0</span>] = BC_ENTER_LOOPER;</span><br><span class="line">    binder_write(bs, readbuf, <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span>));</span><br><span class="line"></span><br><span class="line">    bwr.write_size = <span class="number">0</span>;</span><br><span class="line">    bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.write_buffer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        bwr.read_size = <span class="keyword">sizeof</span>(readbuf);</span><br><span class="line">        bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">        bwr.read_buffer = (<span class="keyword">unsigned</span>) readbuf;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向Kernel中发送消息(先写后读)。</span></span><br><span class="line">        <span class="comment">// 先将消息传递给Kernel，然后再从Kernel读取消息反馈</span></span><br><span class="line">        res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);</span><br><span class="line">        <span class="comment">// 解析读取的消息反馈</span></span><br><span class="line">        res = binder_parse(bs, <span class="number">0</span>, readbuf, bwr.read_consumed, func);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>binder_write(bs, readbuf, sizeof(unsigned));会调用ioctl向内核发送数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">binder_write</span><span class="params">(struct binder_state *bs, <span class="keyword">void</span> *data, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line">    bwr.write_size = len;</span><br><span class="line">    bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.write_buffer = (<span class="keyword">uintptr_t</span>) data;</span><br><span class="line">    bwr.read_size = <span class="number">0</span>;</span><br><span class="line">    bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.read_buffer = <span class="number">0</span>;</span><br><span class="line">    res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果 bwr.write_size &gt; 0，则调用binder_thread_write 如果 bwr.read_size &gt;0，则调用binder_thread_read</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">binder_ioctl</span><span class="params">(struct file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">thread</span>;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> size = _IOC_SIZE(cmd);</span><br><span class="line">  <span class="keyword">void</span> __user *ubuf = (<span class="keyword">void</span> __user *)arg;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 中断等待函数。</span></span><br><span class="line">  ret = wait_event_interruptible(...);</span><br><span class="line">  <span class="comment">// 在proc进程中查找该线程对应的binder_thread；若查找失败，则新建一个binder_thread，并添加到proc-&gt;threads中。</span></span><br><span class="line">  thread = binder_get_thread(proc);</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">  <span class="keyword">case</span> BINDER_WRITE_READ: &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">// 将binder_write_read从"用户空间" 拷贝到 "内核空间"</span></span><br><span class="line">      <span class="keyword">if</span> (copy_from_user(&amp;bwr, ubuf, <span class="keyword">sizeof</span>(bwr))) &#123;</span><br><span class="line">          ...</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果write_size&gt;0，则进行写操作</span></span><br><span class="line">      <span class="keyword">if</span> (bwr.write_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          ret = binder_thread_write(proc, thread, (<span class="keyword">void</span> __user *)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed);</span><br><span class="line">          ...</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果read_size&gt;0，则进行读操作</span></span><br><span class="line">      <span class="keyword">if</span> (bwr.read_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          ret = binder_thread_read(proc, thread, (<span class="keyword">void</span> __user *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags   &amp; O_NONBLOCK);</span><br><span class="line">          ...</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr))) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bwr.write_size &gt; 0; 继续查看binder_thread_write()</p><blockquote><p>注：只有BR_TRANSACTION、BR_REPLY、BC_TRANSACTION、BC_REPLY涉及两进程 其他所有BC_XXX、BR_XXX都只是App和驱动交互用于改变报告状态。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_thread_write</span><span class="params">(struct binder_proc *proc, struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">void</span> __user *buffer, <span class="keyword">int</span> size, <span class="keyword">signed</span> <span class="keyword">long</span> *consumed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> cmd;</span><br><span class="line">  <span class="keyword">void</span> __user *ptr = buffer + *consumed;</span><br><span class="line">  <span class="keyword">void</span> __user *end = buffer + size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取binder_write_read.write_buffer中的内容。</span></span><br><span class="line">  <span class="comment">// 每次读取32bit(即4个字节)</span></span><br><span class="line">  <span class="keyword">while</span> (ptr &lt; end &amp;&amp; thread-&gt;return_error == BR_OK) &#123;</span><br><span class="line">      <span class="comment">// 从用户空间读取32bit到内核中，并赋值给cmd。</span></span><br><span class="line">      <span class="keyword">if</span> (get_user(cmd, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">          <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">      ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">      <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> BC_ENTER_LOOPER:</span><br><span class="line">            thread-&gt;looper |= BINDER_LOOPER_STATE_ENTERED;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">      ...</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 更新bwr.write_consumed的值</span></span><br><span class="line">      *consumed = ptr - buffer;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当前线程进入BC_ENTER_LOOPER状态，等待请求。 继续binder_loop()中的for(;;;)循环，bwr.read_size &gt;0;会通过binder_thread_read()读操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_thread_read</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">void</span>  __user *buffer, <span class="keyword">int</span> size,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">signed</span> <span class="keyword">long</span> *consumed, <span class="keyword">int</span> non_block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> __user *ptr = buffer + *consumed;</span><br><span class="line">  <span class="keyword">void</span> __user *end = buffer + size;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> wait_for_proc_work;</span><br><span class="line">  <span class="comment">// 如果*consumed=0，则写入BR_NOOP到用户传进来的bwr.read_buffer缓存区</span></span><br><span class="line">  <span class="keyword">if</span> (*consumed == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (put_user(BR_NOOP, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">          <span class="keyword">return</span> -EFAULT;</span><br><span class="line">      <span class="comment">// 修改指针位置</span></span><br><span class="line">      ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到驱动put_user(BR_NOOP, (uint32_t __user *)ptr)发送BR_NOOP到ServiceManager</p><blockquote><p>对于所有的读操作，数据头都是BR_NOOP，如BR_REPLY<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/36-Android-binder-BWR-read-BR_NOOP.png" alt="Markdown"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;  ./service_manager &amp;</span><br><span class="line">&gt; [   32.566620] service_manager (1362, 1362), binder_thread_write : BC_ENTER_LOOPER</span><br><span class="line">&gt; [   32.566712] service_manager (1362, 1362), binder_thread_read : BR_NOOP</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h4 id="1-2、Clent（此处为Test-server）请求SM添加服务"><a href="#1-2、Clent（此处为Test-server）请求SM添加服务" class="headerlink" title="1.2、Clent（此处为Test_server）请求SM添加服务"></a>1.2、Clent（此处为Test_server）请求SM添加服务</h4><p><strong>构造数据发送给驱动</strong> 我们执行Test_server时，打印了很多数据，我们首先看一下数据的构造过程 和 组织格式，这有助于加深我们对binder系统的理解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">svcmgr_publish</span><span class="params">(struct binder_state *bs, <span class="keyword">uint32_t</span> target, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">unsigned</span> iodata[<span class="number">512</span>/<span class="number">4</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_io</span> <span class="title">msg</span>, <span class="title">reply</span>;</span></span><br><span class="line"></span><br><span class="line">    bio_init(&amp;msg, iodata, <span class="keyword">sizeof</span>(iodata), <span class="number">4</span>);</span><br><span class="line">    bio_put_uint32(&amp;msg, <span class="number">0</span>);  <span class="comment">// strict mode header</span></span><br><span class="line">    bio_put_string16_x(&amp;msg, SVC_MGR_NAME);</span><br><span class="line">    bio_put_string16_x(&amp;msg, name);</span><br><span class="line">    bio_put_obj(&amp;msg, ptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (binder_call(bs, &amp;msg, &amp;reply, target, SVC_MGR_ADD_SERVICE))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    status = bio_get_uint32(&amp;reply);</span><br><span class="line">    binder_done(bs, &amp;msg, &amp;reply);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bio_init()、bio_put_uint32()、bio_put_string16_x()函数比较简洁。我们看下bio_put_obj()函数。 构建初始化flat_binder_object结构体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void bio_put_obj(struct binder_io *bio, void *ptr)</span><br><span class="line">&#123;</span><br><span class="line">    struct flat_binder_object *obj;</span><br><span class="line"></span><br><span class="line">    obj = bio_alloc_obj(bio);</span><br><span class="line">    if (!obj)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    obj-&gt;flags = 0x7f | FLAT_BINDER_FLAG_ACCEPTS_FDS;//</span><br><span class="line">    obj-&gt;type = BINDER_TYPE_BINDER;//</span><br><span class="line">    obj-&gt;binder = (uintptr_t)ptr;//</span><br><span class="line">    obj-&gt;cookie = 0;//0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>数据结构示意图：</strong></p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/37-Android-binder-Binder-io-transaction-data.jpg" alt="Markdown"></p><p>Clent（此处为Test_server），test_server.c调用流程： -&gt;svcmgr_publish() -&gt;binder_call() -&gt;ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr) -&gt;binder_thread_write() -&gt;binder_transaction()</p><p>现在数据构造好了，binder_call()会调用ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_call</span><span class="params">(struct binder_state *bs,</span></span></span><br><span class="line"><span class="function"><span class="params">                struct binder_io *msg, struct binder_io *reply,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">uint32_t</span> target, <span class="keyword">uint32_t</span> code)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">uint32_t</span> cmd;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> <span class="title">txn</span>;</span></span><br><span class="line">    &#125; __attribute__((packed)) writebuf;</span><br><span class="line">    <span class="keyword">unsigned</span> readbuf[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">    writebuf.cmd = BC_TRANSACTION;</span><br><span class="line">    writebuf.txn.target.handle = target;</span><br><span class="line">    writebuf.txn.code = code;</span><br><span class="line">    writebuf.txn.flags = <span class="number">0</span>;</span><br><span class="line">    writebuf.txn.data_size = msg-&gt;data - msg-&gt;data0;</span><br><span class="line">    writebuf.txn.offsets_size = ((<span class="keyword">char</span>*) msg-&gt;offs) - ((<span class="keyword">char</span>*) msg-&gt;offs0);</span><br><span class="line">    writebuf.txn.data.ptr.buffer = (<span class="keyword">uintptr_t</span>)msg-&gt;data0;</span><br><span class="line">    writebuf.txn.data.ptr.offsets = (<span class="keyword">uintptr_t</span>)msg-&gt;offs0;</span><br><span class="line"></span><br><span class="line">    bwr.write_size = <span class="keyword">sizeof</span>(writebuf);</span><br><span class="line">    bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.write_buffer = (<span class="keyword">uintptr_t</span>) &amp;writebuf;</span><br><span class="line"></span><br><span class="line">    hexdump(msg-&gt;data0, msg-&gt;data - msg-&gt;data0);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        bwr.read_size = <span class="keyword">sizeof</span>(readbuf);</span><br><span class="line">        bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">        bwr.read_buffer = (<span class="keyword">uintptr_t</span>) readbuf;</span><br><span class="line"></span><br><span class="line">        res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);</span><br><span class="line">        ...</span><br><span class="line">        res = binder_parse(bs, reply, (<span class="keyword">uintptr_t</span>) readbuf, bwr.read_consumed, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[ 38.320197] test_server (1363, 1363), binder_thread_write : BC_TRANSACTION 发送数据，进而会调用binder_thread_write()处理数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">binder_ioctl(struct file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> ret;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">thread</span>;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> size = _IOC_SIZE(cmd);</span><br><span class="line">  <span class="keyword">void</span> __user *ubuf = (<span class="keyword">void</span> __user *)arg;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 中断等待函数。</span></span><br><span class="line">  ret = wait_event_interruptible(...);</span><br><span class="line">  <span class="comment">// 在proc进程中查找该线程对应的binder_thread；若查找失败，则新建一个binder_thread，并添加到proc-&gt;threads中。</span></span><br><span class="line">  thread = binder_get_thread(proc);</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">  <span class="keyword">case</span> BINDER_WRITE_READ: &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">// 将binder_write_read从"用户空间" 拷贝到 "内核空间"</span></span><br><span class="line">      <span class="keyword">if</span> (copy_from_user(&amp;bwr, ubuf, <span class="keyword">sizeof</span>(bwr))) &#123;</span><br><span class="line">          ...</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果write_size&gt;0，则进行写操作</span></span><br><span class="line">      <span class="keyword">if</span> (bwr.write_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          ret = binder_thread_write(proc, thread, (<span class="keyword">void</span> __user *)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed);</span><br><span class="line">          ...</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果read_size&gt;0，则进行读操作</span></span><br><span class="line">      <span class="keyword">if</span> (bwr.read_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          ret = binder_thread_read(proc, thread, (<span class="keyword">void</span> __user *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags   &amp; O_NONBLOCK);</span><br><span class="line">          ...</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr))) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于write_size&gt;0，调用binder_thread_write()处理数据：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_thread_write</span><span class="params">(struct binder_proc *proc, struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">void</span> __user *buffer, <span class="keyword">int</span> size, <span class="keyword">signed</span> <span class="keyword">long</span> *consumed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> cmd;</span><br><span class="line">  <span class="keyword">void</span> __user *ptr = buffer + *consumed;</span><br><span class="line">  <span class="keyword">void</span> __user *end = buffer + size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取binder_write_read.write_buffer中的内容。</span></span><br><span class="line">  <span class="comment">// 每次读取32bit(即4个字节)</span></span><br><span class="line">  <span class="keyword">while</span> (ptr &lt; end &amp;&amp; thread-&gt;return_error == BR_OK) &#123;</span><br><span class="line">      <span class="comment">// 从用户空间读取32bit到内核中，并赋值给cmd。</span></span><br><span class="line">      <span class="keyword">if</span> (get_user(cmd, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">          <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">      ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">      ...</span><br><span class="line">        <span class="keyword">case</span> BC_TRANSACTION:</span><br><span class="line">        <span class="keyword">case</span> BC_REPLY: &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> <span class="title">tr</span>;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (copy_from_user(&amp;tr, ptr, <span class="keyword">sizeof</span>(tr)))</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">            ptr += <span class="keyword">sizeof</span>(tr);</span><br><span class="line">            binder_transaction(proc, thread, &amp;tr, cmd == BC_REPLY);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      ...</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 更新bwr.write_consumed的值</span></span><br><span class="line">      *consumed = ptr - buffer;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由之前binder_call()分析，writebuf.cmd = BC_TRANSACTION;会执行binder_transaction()函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binder_transaction</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_transaction_data *tr, <span class="keyword">int</span> reply)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">t</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> *<span class="title">tcomplete</span>;</span></span><br><span class="line">    <span class="keyword">size_t</span> *offp, *off_end;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">target_proc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">target_thread</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">target_node</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">target_list</span>;</span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> *target_wait;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">in_reply_to</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_log_entry</span> *<span class="title">e</span>;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> return_error;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tr-&gt;target.handle) &#123;</span><br><span class="line">            target_node = ref-&gt;node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 事务目标对象是ServiceManager的binder实体</span></span><br><span class="line">            <span class="comment">// 即，该事务是交给Service Manager来处理的。</span></span><br><span class="line">            target_node = binder_context_mgr_node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置处理事务的目标进程</span></span><br><span class="line">        target_proc = target_node-&gt;proc;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (target_thread) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        target_list = &amp;target_proc-&gt;todo;</span><br><span class="line">        target_wait = &amp;target_proc-&gt;wait;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配一个待处理的事务t，t是binder事务(binder_transaction对象)</span></span><br><span class="line">    t = kzalloc(<span class="keyword">sizeof</span>(*t), GFP_KERNEL);</span><br><span class="line">    <span class="comment">// 分配一个待完成的工作tcomplete，tcomplete是binder_work对象。</span></span><br><span class="line">    tcomplete = kzalloc(<span class="keyword">sizeof</span>(*tcomplete), GFP_KERNEL);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事务将交给target_proc进程进行处理</span></span><br><span class="line">    t-&gt;to_proc = target_proc;</span><br><span class="line">    <span class="comment">// 事务将交给target_thread线程进行处理</span></span><br><span class="line">    t-&gt;to_thread = target_thread;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配空间,从目的进程映射的空间分配buf</span></span><br><span class="line">    t-&gt;buffer = binder_alloc_buf(target_proc, tr-&gt;data_size,</span><br><span class="line">        tr-&gt;offsets_size, !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY));</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 保存事务</span></span><br><span class="line">    t-&gt;buffer-&gt;transaction = t;</span><br><span class="line">    <span class="comment">// 保存事务的目标对象(即处理该事务的binder对象)</span></span><br><span class="line">    t-&gt;buffer-&gt;target_node = target_node;</span><br><span class="line"></span><br><span class="line">    offp = (<span class="keyword">size_t</span> *)(t-&gt;buffer-&gt;data + ALIGN(tr-&gt;data_size, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *)));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将"用户空间的数据"拷贝到内核中</span></span><br><span class="line">    <span class="comment">// tr-&gt;data.ptr.buffer就是用户空间数据的起始地址，tr-&gt;data_size就是数据大小</span></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(t-&gt;buffer-&gt;data, tr-&gt;data.ptr.buffer, tr-&gt;data_size)) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将"用户空间的数据中所含对象的偏移地址"拷贝到内核中</span></span><br><span class="line">    <span class="comment">// tr-&gt;data.ptr.offsets就是数据中的对象偏移地址数组，tr-&gt;offsets_size就数据中的对象个数</span></span><br><span class="line">    <span class="comment">// 拷贝之后，offp就是flat_binder_object对象数组在内核空间的偏移数组的起始地址</span></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(offp, tr-&gt;data.ptr.offsets, tr-&gt;offsets_size)) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// off_end就是flat_binder_object对象数组在内核空间的偏移地址的结束地址</span></span><br><span class="line">    off_end = (<span class="keyword">void</span> *)offp + tr-&gt;offsets_size;</span><br><span class="line">    <span class="comment">// 将所有的flat_binder_object对象读取出来</span></span><br><span class="line">    <span class="comment">// 对TestServer而言，只有一个flat_binder_object对象。</span></span><br><span class="line">    <span class="keyword">for</span> (; offp &lt; off_end; offp++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">flat_binder_object</span> *<span class="title">fp</span>;</span></span><br><span class="line">        ...</span><br><span class="line">        fp = (struct flat_binder_object *)(t-&gt;buffer-&gt;data + *offp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (fp-&gt;type) &#123;</span><br><span class="line">        <span class="keyword">case</span> BINDER_TYPE_BINDER:</span><br><span class="line">        <span class="keyword">case</span> BINDER_TYPE_WEAK_BINDER: &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_ref</span> *<span class="title">ref</span>;</span></span><br><span class="line">            <span class="comment">// 在proc中查找binder实体对应的binder_node</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">node</span> = <span class="title">binder_get_node</span>(<span class="title">proc</span>, <span class="title">fp</span>-&gt;<span class="title">binder</span>);</span></span><br><span class="line">            <span class="comment">// 若找不到，则新建一个binder_node；下次就可以直接使用了。</span></span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                node = binder_new_node(proc, fp-&gt;binder, fp-&gt;cookie);</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 在target_proc(即，ServiceManager的进程上下文)中查找是否包行"该Binder实体的引用"，</span></span><br><span class="line">            <span class="comment">// 如果没有找到的话，则将"该binder实体的引用"添加到target_proc-&gt;refs_by_node红黑树中。这样，就可以通过Service Manager对该</span></span><br><span class="line">Binder实体进行管理了。</span><br><span class="line">            ref = binder_get_ref_for_node(target_proc, node);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 现在修改目的进程type，表示ServiceManager持有TestServer引用，TestServer进程才能拥有实体。</span></span><br><span class="line">            <span class="keyword">if</span> (fp-&gt;type == BINDER_TYPE_BINDER)</span><br><span class="line">                fp-&gt;type = BINDER_TYPE_HANDLE;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                fp-&gt;type = BINDER_TYPE_WEAK_HANDLE;</span><br><span class="line">            <span class="comment">// 修改handle。handle和binder是联合体，这里将handle设为引用的描述。</span></span><br><span class="line">            <span class="comment">// 根据该handle可以找到"该binder实体在target_proc中的binder引用"；</span></span><br><span class="line">            <span class="comment">// 即，可以根据该handle，可以从Service Manager找到对应的Binder实体的引用，从而获取Binder实体。</span></span><br><span class="line">            fp-&gt;handle = ref-&gt;desc;</span><br><span class="line">            <span class="comment">// 增加引用计数，防止"该binder实体"在使用过程中被销毁。</span></span><br><span class="line">            binder_inc_ref(ref, fp-&gt;type == BINDER_TYPE_HANDLE,</span><br><span class="line">                       &amp;thread-&gt;todo);</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">        ..</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(t-&gt;flags &amp; TF_ONE_WAY)) &#123;</span><br><span class="line">        BUG_ON(t-&gt;buffer-&gt;async_transaction != <span class="number">0</span>);</span><br><span class="line">        t-&gt;need_reply = <span class="number">1</span>;</span><br><span class="line">        t-&gt;from_parent = thread-&gt;transaction_stack;</span><br><span class="line">        <span class="comment">// 将当前事务添加到当前线程的事务栈中</span></span><br><span class="line">        thread-&gt;transaction_stack = t;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置事务的类型为BINDER_WORK_TRANSACTION</span></span><br><span class="line">    t-&gt;work.type = BINDER_WORK_TRANSACTION;</span><br><span class="line">    <span class="comment">// 将事务添加到target_list队列中，即target_list的待处理事务中</span></span><br><span class="line">    list_add_tail(&amp;t-&gt;work.entry, target_list);</span><br><span class="line">    <span class="comment">// 设置待完成工作的类型为BINDER_WORK_TRANSACTION_COMPLETE</span></span><br><span class="line">    tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE;</span><br><span class="line">    <span class="comment">// 将待完成工作添加到thread-&gt;todo队列中，即当前线程的待完成工作中。</span></span><br><span class="line">    list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo);</span><br><span class="line">    <span class="comment">// 唤醒目标进程</span></span><br><span class="line">    <span class="keyword">if</span> (target_wait)</span><br><span class="line">        wake_up_interruptible(target_wait);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：这里的tr-&gt;target.handle=0，因此，会设置target_node为ServiceManager对应的Binder实体。下面是target_node,target_proc等值初始化之后的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">target_node = binder_context_mgr_node; <span class="comment">// 目标节点为Service Manager对应的Binder实体</span></span><br><span class="line">target_proc = target_node-&gt;proc;       <span class="comment">// 目标进程为Service Manager对应的binder_proc进程上下文信息</span></span><br><span class="line">target_list = &amp;target_thread-&gt;todo;    <span class="comment">// 待处理事务队列</span></span><br><span class="line">target_wait = &amp;target_thread-&gt;wait;    <span class="comment">// 等待队列</span></span><br></pre></td></tr></table></figure><p>小结： 驱动接收到TestServer发送的数据后，驱动主要工作： （1）根据Handle = 0 找到目的进程ServiceManager （2）把数据通过copy_from_user()放到目的进程ServiceManager的空间（mmap） （3）处理offs数据，即解析flat_binder_object结构体 a. 为TestServer构造binder_node node = binder_new_node(proc, fp-&gt;binder, fp-&gt;cookie); b.构造binder_ref给目的进程ServiceManager ref = binder_get_ref_for_node(target_proc, node); c.增加引用计数TestServer binder_inc_ref(ref, fp-&gt;type == BINDER_TYPE_HANDLE, &amp;thread-&gt;todo); 增加引用计数会添加work.entry（BR_INCREFS、BR_ACQUIR）到TestServer todod队列 list_add_tail(&amp;node-&gt;work.entry, target_list)</p><p>说明：就新建Binder实体的引用，并将其添加到target_proc-&gt;refs_by_node红黑树 和 target_proc-&gt;refs_by_desc红黑树中。 这样，ServiceManager的进程上下文中就存在Hello Service的Binder引用，ServiceManager也就可以对Hello Service进行管理了！然后，修改fp-&gt;type=BINDER_TYPE_HANDLE，并使fp-&gt;handle = ref-&gt;desc。</p><p>（4)新建一个待处理事务t和待完成的工作tcomplete，并对它们进行初始化。待处理事务t会被提交给目标(即ServiceManager对应的Binder实体)进行处理；而待完成的工作tcomplete则是为了反馈给TestServer服务，告诉TestServer它的请求Binder驱动已经收到了。注意，这里仅仅是告诉TestServer该请求已经被收到，而不是处理完毕！待ServiceManager处理完毕该请求之后，Binder驱动会再次反馈相应的消息给TestServer。 （5）binder_thread_write()中执行binder_transaction()后，会更新*consumed的值，即bwr.write_consumed的值 （6）此时，TestServer进程还会继续运行，而且它也通过wake_up_interruptible()唤醒了ServiceManager进程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新bwr.write_consumed的值</span></span><br><span class="line">*consumed = ptr - buffer;</span><br></pre></td></tr></table></figure><p>接下来，ioctl()会执行binder_thread_read()来设置反馈数据给TestServer进程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_thread_read</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                  struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">void</span>  __user *buffer, <span class="keyword">int</span> size,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">signed</span> <span class="keyword">long</span> *consumed, <span class="keyword">int</span> non_block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果*consumed=0，则写入BR_NOOP到用户传进来的bwr.read_buffer缓存区</span></span><br><span class="line">    <span class="keyword">if</span> (*consumed == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (put_user(BR_NOOP, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> cmd;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> <span class="title">tr</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> *<span class="title">w</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">t</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前线程的"待完成工作"不为空，则取出待完成工作。</span></span><br><span class="line">        <span class="keyword">if</span> (!list_empty(&amp;thread-&gt;todo))</span><br><span class="line">            w = list_first_entry(&amp;thread-&gt;todo, struct binder_work, entry);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">switch</span> (w-&gt;type) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> BINDER_WORK_TRANSACTION_COMPLETE: &#123;</span><br><span class="line">            cmd = BR_TRANSACTION_COMPLETE;</span><br><span class="line">            <span class="comment">// 将BR_TRANSACTION_COMPLETE写入到用户缓冲空间中</span></span><br><span class="line">            <span class="keyword">if</span> (put_user(cmd, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 更新bwr.read_consumed的值</span></span><br><span class="line">    *consumed = ptr - buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先发送BR_NOOP给TestServer，然后处理todo队列，处理完成后会发送BR_TRANSACTION_COMPLETE。</p><p>现在内核已经处理完数据，我们从log看看数据发生了哪些变化： 我们发现flat_binder_object结构体的type值发生了变化，binder变成了Handle，看一下结构体，handler 和 binder是一个union，占用同一个位置；Handle为1代表第一个引用，意思是在ServiceManager进程里面根据1能找到第一个binder_ref，根据binder_ref能找到服务hello的binder_node实体。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/38-Android-binder-flat_binder_object.png" alt="Markdown"></p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/39-Android-binder-Binder-io-transaction-data.jpg" alt="Markdown"></p><p>接下来就等待ServiceManager处理完成后，回复消息。</p><h4 id="1-3、唤醒ServiceManager执行添加”hello”服务"><a href="#1-3、唤醒ServiceManager执行添加”hello”服务" class="headerlink" title="1.3、唤醒ServiceManager执行添加”hello”服务"></a>1.3、唤醒ServiceManager执行添加”hello”服务</h4><p>前面驱动已经创建好TestServer的binder_node，现在唤醒ServiceManager添加svcinfo 看看ServiceManager被唤醒后，会干些什么。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_thread_read</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">void</span>  __user *buffer, <span class="keyword">int</span> size,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">signed</span> <span class="keyword">long</span> *consumed, <span class="keyword">int</span> non_block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    wait_for_proc_work = thread-&gt;transaction_stack == <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">                list_empty(&amp;thread-&gt;todo);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> <span class="title">tr</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> *<span class="title">w</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">t</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前线程的"待完成工作"不为空，则取出待完成工作。</span></span><br><span class="line">        <span class="keyword">if</span> (!list_empty(&amp;thread-&gt;todo))</span><br><span class="line">            w = list_first_entry(&amp;thread-&gt;todo, struct binder_work, entry);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!list_empty(&amp;proc-&gt;todo) &amp;&amp; wait_for_proc_work)</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">switch</span> (w-&gt;type) &#123;</span><br><span class="line">            <span class="keyword">case</span> BINDER_WORK_TRANSACTION: &#123;</span><br><span class="line">                t = container_of(w, struct binder_transaction, work);</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// t-&gt;buffer-&gt;target_node是目标节点。</span></span><br><span class="line">        <span class="comment">// 这里，addService请求的目标是ServiceManager，因此target_node是ServiceManager对应的节点；</span></span><br><span class="line">        <span class="comment">// 它的值在事务交互时(binder_transaction中)，被赋值为ServiceManager对应的Binder实体。  </span></span><br><span class="line">        <span class="keyword">if</span> (t-&gt;buffer-&gt;target_node) &#123;</span><br><span class="line">            <span class="comment">// 事务目标对应的Binder实体(即，ServiceManager对应的Binder实体)</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">target_node</span> = <span class="title">t</span>-&gt;<span class="title">buffer</span>-&gt;<span class="title">target_node</span>;</span></span><br><span class="line">            <span class="comment">// Binder实体在用户空间的地址(ServiceManager的ptr为NULL)</span></span><br><span class="line">            tr.target.ptr = target_node-&gt;ptr;</span><br><span class="line">            <span class="comment">// Binder实体在用户空间的其它数据(ServiceManager的cookie为NULL)</span></span><br><span class="line">            tr.cookie =  target_node-&gt;cookie;</span><br><span class="line">            t-&gt;saved_priority = task_nice(current);</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;priority &lt; target_node-&gt;min_priority &amp;&amp;</span><br><span class="line">                !(t-&gt;flags &amp; TF_ONE_WAY))</span><br><span class="line">                binder_set_nice(t-&gt;priority);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!(t-&gt;flags &amp; TF_ONE_WAY) ||</span><br><span class="line">                 t-&gt;saved_priority &gt; target_node-&gt;min_priority)</span><br><span class="line">                binder_set_nice(target_node-&gt;min_priority);</span><br><span class="line">            **cmd = BR_TRANSACTION;<span class="comment">//将命令改为BR_TRANSACTION</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tr.target.ptr = <span class="literal">NULL</span>;</span><br><span class="line">            tr.cookie = <span class="literal">NULL</span>;</span><br><span class="line">            cmd = BR_REPLY;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交易码</span></span><br><span class="line">        tr.code = t-&gt;code;</span><br><span class="line">        tr.flags = t-&gt;flags;</span><br><span class="line">        tr.sender_euid = t-&gt;sender_euid;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (t-&gt;from) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">sender</span> = <span class="title">t</span>-&gt;<span class="title">from</span>-&gt;<span class="title">proc</span>-&gt;<span class="title">tsk</span>;</span></span><br><span class="line">            tr.sender_pid = task_tgid_nr_ns(sender,</span><br><span class="line">                            current-&gt;nsproxy-&gt;pid_ns);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tr.sender_pid = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数据大小</span></span><br><span class="line">        tr.data_size = t-&gt;buffer-&gt;data_size;</span><br><span class="line">        <span class="comment">// 数据中对象的偏移数组的大小(即对象的个数)</span></span><br><span class="line">        tr.offsets_size = t-&gt;buffer-&gt;offsets_size;</span><br><span class="line">        <span class="comment">// 数据</span></span><br><span class="line">        tr.data.ptr.buffer = (<span class="keyword">void</span> *)t-&gt;buffer-&gt;data +</span><br><span class="line">                    proc-&gt;user_buffer_offset;</span><br><span class="line">        <span class="comment">// 数据中对象的偏移数组</span></span><br><span class="line">        tr.data.ptr.offsets = tr.data.ptr.buffer +</span><br><span class="line">                    ALIGN(t-&gt;buffer-&gt;data_size,</span><br><span class="line">                        <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将cmd指令写入到ptr，即传递到用户空间</span></span><br><span class="line">        <span class="keyword">if</span> (put_user(cmd, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        <span class="comment">// 将tr数据拷贝到用户空间</span></span><br><span class="line">        ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">        <span class="keyword">if</span> (copy_to_user(ptr, &amp;tr, <span class="keyword">sizeof</span>(tr)))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        ptr += <span class="keyword">sizeof</span>(tr);</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 删除已处理的事务</span></span><br><span class="line">        list_del(&amp;t-&gt;work.entry);</span><br><span class="line">        t-&gt;buffer-&gt;allow_user_free = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 设置回复信息</span></span><br><span class="line">        <span class="keyword">if</span> (cmd == BR_TRANSACTION &amp;&amp; !(t-&gt;flags &amp; TF_ONE_WAY)) &#123;</span><br><span class="line">            <span class="comment">// 该事务会发送给Service Manager守护进程进行处理。</span></span><br><span class="line">            <span class="comment">// Service Manager处理之后，还需要给Binder驱动回复处理结果。</span></span><br><span class="line">            <span class="comment">// 这里设置Binder驱动回复信息。</span></span><br><span class="line">            t-&gt;to_parent = thread-&gt;transaction_stack;</span><br><span class="line">            <span class="comment">// to_thread表示Service Manager反馈后，将反馈结果交给当前thread进行处理</span></span><br><span class="line">            t-&gt;to_thread = thread;</span><br><span class="line">            <span class="comment">// transaction_stack交易栈保存当前事务。用于之处反馈是针对哪个事务的。</span></span><br><span class="line">            thread-&gt;transaction_stack = t;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新bwr.read_consumed的值</span></span><br><span class="line">    *consumed = ptr - buffer;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：ServiceManager进程在调用wait_event_interruptible_exclusive(proc-&gt;wait, binder_has_proc_work(proc, thread))进入等待之后，被TestServer进程唤醒。唤醒之后，binder_has_thread_work()为true，因为ServiceManager的待处理事务队列中有个待处理事务(即，TestServer添加服务的请求)。 (01) 进入while循环后，首先取出待处理事务。 (02) 事务的类型是BINDER_WORK_TRANSACTION，得到对应的binder_transaction*类型指针t之后，跳出switch语句。很显然，此时t不为NULL，因此继续往下执行。下面的工作的目的，是将t中的数据转移到tr中(tr是事务交互数据包结构体binder_transaction_data对应的指针)，然后将指令和tr数据都拷贝到用户空间，让ServiceManager读取后进行处理。</p><p>Service Manager守护进程在处理完事务之后，需要反馈结果给Binder驱动。因此，接下来会设置t-&gt;to_thread和t-&gt;transaction_stack等成员。最后，修改*consumed的值，即bwr.read_consumed的值，表示待读取内容的大小。 执行完binder_thread_read()之后，回到binder_ioctl()中，执行copy_to_user()将数据拷贝到用户空间。接下来，就回到了Service Manager的守护进程当中，即回到binder_loop()中。 binder_loop()会将ioctl()反馈的数据发送给binder_parse()进行解析。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_parse</span><span class="params">(struct binder_state *bs, struct binder_io *bio,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">uintptr_t</span> ptr, <span class="keyword">size_t</span> size, binder_handler func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> BR_NOOP:</span><br><span class="line">        <span class="keyword">case</span> BR_TRANSACTION: &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> *<span class="title">txn</span> = (<span class="title">struct</span> <span class="title">binder_transaction_data</span> *) <span class="title">ptr</span>;</span></span><br><span class="line">            <span class="keyword">if</span> ((end - ptr) &lt; <span class="keyword">sizeof</span>(*txn)) &#123;</span><br><span class="line">                ALOGE(<span class="string">"parse: txn too small!\n"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            binder_dump_txn(txn);</span><br><span class="line">            <span class="keyword">if</span> (func) &#123;</span><br><span class="line">                <span class="keyword">unsigned</span> rdata[<span class="number">256</span>/<span class="number">4</span>];</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">binder_io</span> <span class="title">msg</span>;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">binder_io</span> <span class="title">reply</span>;</span></span><br><span class="line">                <span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line">                bio_init(&amp;reply, rdata, <span class="keyword">sizeof</span>(rdata), <span class="number">4</span>);</span><br><span class="line">                bio_init_from_txn(&amp;msg, txn);</span><br><span class="line">                res = func(bs, txn, &amp;msg, &amp;reply);</span><br><span class="line">                binder_send_reply(bs, &amp;reply, txn-&gt;data.ptr.buffer, res);</span><br><span class="line">            &#125;</span><br><span class="line">            ptr += <span class="keyword">sizeof</span>(*txn);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先会调用svcmgr_handler()-&gt;do_add_service()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_add_service</span><span class="params">(struct binder_state *bs,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">const</span> <span class="keyword">uint16_t</span> *s, <span class="keyword">size_t</span> len,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">uint32_t</span> handle, <span class="keyword">uid_t</span> uid, <span class="keyword">int</span> allow_isolated,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">pid_t</span> spid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">svcinfo</span> *<span class="title">si</span>;</span></span><br><span class="line">    si = find_svc(s, len);</span><br><span class="line">    <span class="keyword">if</span> (si) &#123;</span><br><span class="line">        <span class="keyword">if</span> (si-&gt;handle) &#123;</span><br><span class="line">                    svcinfo_death(bs, si);</span><br><span class="line">        &#125;</span><br><span class="line">        si-&gt;handle = handle;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        si = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*si) + (len + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>));</span><br><span class="line">        si-&gt;handle = handle;</span><br><span class="line">        si-&gt;len = len;</span><br><span class="line">        <span class="built_in">memcpy</span>(si-&gt;name, s, (len + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>));</span><br><span class="line">        si-&gt;name[len] = <span class="string">'\0'</span>;</span><br><span class="line">        si-&gt;death.func = (<span class="keyword">void</span>*) svcinfo_death;</span><br><span class="line">        si-&gt;death.ptr = si;</span><br><span class="line">        si-&gt;allow_isolated = allow_isolated;</span><br><span class="line">        si-&gt;next = svclist;</span><br><span class="line">        svclist = si;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    binder_acquire(bs, handle);</span><br><span class="line">    binder_link_to_death(bs, handle, &amp;si-&gt;death);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到首先为hello服务新分配一个结构体svcinfo，然后将handle赋值给svcinfo，这也是以后我们查找服务所得到的handle。 然后调动了binder_acquire、binder_link_to_death发送信息给驱动。 [ 38.467270] service_manager (1362, 1362), binder_thread_write : BC_ACQUIRE [ 38.480122] service_manager (1362, 1362), binder_thread_write : BC_REQUEST_DEATH_NOTIFICATION 接着看binder_send_reply(bs, &amp;reply, txn-&gt;data.ptr.buffer, res);</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binder_send_reply</span><span class="params">(struct binder_state *bs,</span></span></span><br><span class="line"><span class="function"><span class="params">                       struct binder_io *reply,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">binder_uintptr_t</span> buffer_to_free,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">int</span> status)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    data.cmd_free = BC_FREE_BUFFER;</span><br><span class="line">    data.buffer = buffer_to_free;</span><br><span class="line">    data.cmd_reply = BC_REPLY;</span><br><span class="line">    data.txn.target.ptr = <span class="number">0</span>;</span><br><span class="line">    data.txn.cookie = <span class="number">0</span>;</span><br><span class="line">    data.txn.code = <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">    binder_write(bs, &amp;data, <span class="keyword">sizeof</span>(data));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到有BC_FREE_BUFFER、BC_REPLY，通过binder_write(bs, &amp;data, sizeof(data))回复BC_REPLY到驱动。</p><p>驱动处理消息跟之前流程类似，这里不再分析。简单总结： 1、驱动接收到BC_REPLY请求，会新建一个待处理事务t（TestServer处理）和待完成的工作tcomplete（service_manager处理） 2、然后唤醒TestServer处理BC_REPLY请求 至此，已经成功添加Hello Service svcmgr: add_service(‘hello’), handle = 1</p><h3 id="（2）、Binder系统驱动情景分析–TestClent获取”Hello”服务过程"><a href="#（2）、Binder系统驱动情景分析–TestClent获取”Hello”服务过程" class="headerlink" title="（2）、Binder系统驱动情景分析–TestClent获取”Hello”服务过程"></a>（2）、Binder系统驱动情景分析–TestClent获取”Hello”服务过程</h3><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/40-Android-binder-binder_get_service.png" alt="Markdown"></p><h4 id="2-0、构造数据"><a href="#2-0、构造数据" class="headerlink" title="2.0、构造数据"></a>2.0、构造数据</h4><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/41-Android-binder-getSvr-Binder-io-transaction-data.jpg" alt="Markdown"></p><h4 id="2-1、发送数据给ServiceManager"><a href="#2-1、发送数据给ServiceManager" class="headerlink" title="2.1、发送数据给ServiceManager"></a>2.1、发送数据给ServiceManager</h4><p>bwr初始化完成之后，调用ioctl(,BINDER_WRITE_READ,)和Binder驱动进行交互。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">binder_ioctl</span><span class="params">(struct file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">thread</span>;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> size = _IOC_SIZE(cmd);</span><br><span class="line">  <span class="keyword">void</span> __user *ubuf = (<span class="keyword">void</span> __user *)arg;</span><br><span class="line">  <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">  <span class="keyword">case</span> BINDER_WRITE_READ: &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></span><br><span class="line">      <span class="comment">// 将binder_write_read从"用户空间" 拷贝到 "内核空间"</span></span><br><span class="line">      <span class="keyword">if</span> (copy_from_user(&amp;bwr, ubuf, <span class="keyword">sizeof</span>(bwr))) &#123;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果write_size&gt;0，则进行写操作</span></span><br><span class="line">      <span class="keyword">if</span> (bwr.write_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          ret = binder_thread_write(proc, thread, (<span class="keyword">void</span> __user *)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果read_size&gt;0，则进行读操作</span></span><br><span class="line">      <span class="keyword">if</span> (bwr.read_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          ret = binder_thread_read(proc, thread, (<span class="keyword">void</span> __user *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags   &amp; O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr))) &#123;</span><br><span class="line">          ret = -EFAULT;</span><br><span class="line">          <span class="keyword">goto</span> err;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，会将binder_write_read从用户空间拷贝到内核空间之后。拷贝之后，读取出来的bwr.write_size和bwr.read_size都&gt;0，因此先写后读。即，先执行binder_thread_write()，然后执行binder_thread_read()。</p><h4 id="2-2、binder-thread-write-处理数据"><a href="#2-2、binder-thread-write-处理数据" class="headerlink" title="2.2、binder_thread_write()处理数据"></a>2.2、binder_thread_write()处理数据</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_thread_write</span><span class="params">(struct binder_proc *proc, struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">void</span> __user *buffer, <span class="keyword">int</span> size, <span class="keyword">signed</span> <span class="keyword">long</span> *consumed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> cmd;</span><br><span class="line">  <span class="keyword">void</span> __user *ptr = buffer + *consumed;</span><br><span class="line">  <span class="keyword">void</span> __user *end = buffer + size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取binder_write_read.write_buffer中的内容。</span></span><br><span class="line">  <span class="comment">// 每次读取32bit(即4个字节)</span></span><br><span class="line">  <span class="keyword">while</span> (ptr &lt; end &amp;&amp; thread-&gt;return_error == BR_OK) &#123;</span><br><span class="line">      <span class="comment">// 从用户空间读取32bit到内核中，并赋值给cmd。</span></span><br><span class="line">      <span class="keyword">if</span> (get_user(cmd, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">          <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">      ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">      ...</span><br><span class="line">        <span class="keyword">case</span> BC_TRANSACTION:</span><br><span class="line">        <span class="keyword">case</span> BC_REPLY: &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> <span class="title">tr</span>;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (copy_from_user(&amp;tr, ptr, <span class="keyword">sizeof</span>(tr)))</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">            ptr += <span class="keyword">sizeof</span>(tr);</span><br><span class="line">            binder_transaction(proc, thread, &amp;tr, cmd == BC_REPLY);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      ...</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 更新bwr.write_consumed的值</span></span><br><span class="line">      *consumed = ptr - buffer;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：MediaPlayer发送的指令是BC_TRANSACTION，这里只关心与BC_TRANSACTION相关的部分。在通过copy_from_user()将数据拷贝从用户空间拷贝到内核空间之后，就调用binder_transaction()进行处理。</p><h4 id="2-3、Binder驱动中binder-transaction-的源码"><a href="#2-3、Binder驱动中binder-transaction-的源码" class="headerlink" title="2.3、Binder驱动中binder_transaction()的源码"></a>2.3、Binder驱动中binder_transaction()的源码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binder_transaction</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_transaction_data *tr, <span class="keyword">int</span> reply)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">t</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> *<span class="title">tcomplete</span>;</span></span><br><span class="line">    <span class="keyword">size_t</span> *offp, *off_end;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">target_proc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">target_thread</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">target_node</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">target_list</span>;</span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> *target_wait;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">in_reply_to</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_log_entry</span> *<span class="title">e</span>;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> return_error;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tr-&gt;target.handle) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 该getService是从ServiceManager中获取MediaPlayer；</span></span><br><span class="line">            <span class="comment">// 因此事务目标对象是ServiceManager的binder实体。</span></span><br><span class="line">            target_node = binder_context_mgr_node;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 设置处理事务的目标进程</span></span><br><span class="line">        target_proc = target_node-&gt;proc;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (target_thread) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        target_list = &amp;target_proc-&gt;todo;</span><br><span class="line">        target_wait = &amp;target_proc-&gt;wait;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配一个待处理的事务t，t是binder事务(binder_transaction对象)</span></span><br><span class="line">    t = kzalloc(<span class="keyword">sizeof</span>(*t), GFP_KERNEL);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配一个待完成的工作tcomplete，tcomplete是binder_work对象。</span></span><br><span class="line">    tcomplete = kzalloc(<span class="keyword">sizeof</span>(*tcomplete), GFP_KERNEL);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    t-&gt;debug_id = ++binder_last_id;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置from，表示该事务是MediaPlayer线程发起的</span></span><br><span class="line">    <span class="keyword">if</span> (!reply &amp;&amp; !(tr-&gt;flags &amp; TF_ONE_WAY))</span><br><span class="line">        t-&gt;from = thread;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t-&gt;from = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 下面的一些赋值是初始化事务t</span></span><br><span class="line">    t-&gt;sender_euid = proc-&gt;tsk-&gt;cred-&gt;euid;</span><br><span class="line">    <span class="comment">// 事务将交给target_proc进程进行处理</span></span><br><span class="line">    t-&gt;to_proc = target_proc;</span><br><span class="line">    <span class="comment">// 事务将交给target_thread线程进行处理</span></span><br><span class="line">    t-&gt;to_thread = target_thread;</span><br><span class="line">    <span class="comment">// 事务编码</span></span><br><span class="line">    t-&gt;code = tr-&gt;code;</span><br><span class="line">    <span class="comment">// 事务标志</span></span><br><span class="line">    t-&gt;flags = tr-&gt;flags;</span><br><span class="line">    <span class="comment">// 事务优先级</span></span><br><span class="line">    t-&gt;priority = task_nice(current);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配空间</span></span><br><span class="line">    t-&gt;buffer = binder_alloc_buf(target_proc, tr-&gt;data_size,</span><br><span class="line">        tr-&gt;offsets_size, !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY));</span><br><span class="line">    ...</span><br><span class="line">    t-&gt;buffer-&gt;allow_user_free = <span class="number">0</span>;</span><br><span class="line">    t-&gt;buffer-&gt;debug_id = t-&gt;debug_id;</span><br><span class="line">    <span class="comment">// 保存事务</span></span><br><span class="line">    t-&gt;buffer-&gt;transaction = t;</span><br><span class="line">    <span class="comment">// 保存事务的目标对象(即处理该事务的binder对象)</span></span><br><span class="line">    t-&gt;buffer-&gt;target_node = target_node;</span><br><span class="line">    trace_binder_transaction_alloc_buf(t-&gt;buffer);</span><br><span class="line">    <span class="keyword">if</span> (target_node)</span><br><span class="line">        binder_inc_node(target_node, <span class="number">1</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    offp = (<span class="keyword">size_t</span> *)(t-&gt;buffer-&gt;data + ALIGN(tr-&gt;data_size, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将"用户空间的数据"拷贝到内核中</span></span><br><span class="line">    <span class="comment">// tr-&gt;data.ptr.buffer就是用户空间数据的起始地址，tr-&gt;data_size就是数据大小</span></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(t-&gt;buffer-&gt;data, tr-&gt;data.ptr.buffer, tr-&gt;data_size)) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将"用户空间的数据中所含对象的偏移地址"拷贝到内核中</span></span><br><span class="line">    <span class="comment">// MediaPlayer中不包含对象, offp=null</span></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(offp, tr-&gt;data.ptr.offsets, tr-&gt;offsets_size)) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// MediaPlayer中不包含对象, off_end为null</span></span><br><span class="line">    off_end = (<span class="keyword">void</span> *)offp + tr-&gt;offsets_size;</span><br><span class="line">    <span class="comment">// MediaPlayer中不包含对象, offp=off_end</span></span><br><span class="line">    <span class="keyword">for</span> (; offp &lt; off_end; offp++) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">        ..</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(t-&gt;flags &amp; TF_ONE_WAY)) &#123;</span><br><span class="line">        BUG_ON(t-&gt;buffer-&gt;async_transaction != <span class="number">0</span>);</span><br><span class="line">        t-&gt;need_reply = <span class="number">1</span>;</span><br><span class="line">        t-&gt;from_parent = thread-&gt;transaction_stack;</span><br><span class="line">        <span class="comment">// 将当前事务添加到当前线程的事务栈中</span></span><br><span class="line">        thread-&gt;transaction_stack = t;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置事务的类型为BINDER_WORK_TRANSACTION</span></span><br><span class="line">    t-&gt;work.type = BINDER_WORK_TRANSACTION;</span><br><span class="line">    <span class="comment">// 将事务添加到target_list队列中，即target_list的待处理事务中</span></span><br><span class="line">    list_add_tail(&amp;t-&gt;work.entry, target_list);</span><br><span class="line">    <span class="comment">// 设置待完成工作的类型为BINDER_WORK_TRANSACTION_COMPLETE</span></span><br><span class="line">    tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE;</span><br><span class="line">    <span class="comment">// 将待完成工作添加到thread-&gt;todo队列中，即当前线程的待完成工作中。</span></span><br><span class="line">    list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo);</span><br><span class="line">    <span class="comment">// 唤醒目标进程</span></span><br><span class="line">    <span class="keyword">if</span> (target_wait)</span><br><span class="line">        wake_up_interruptible(target_wait);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：参数reply=0，表明这是个请求事务，而不是反馈。binder_transaction新建会新建”一个待处理事务t”和”待完成的工作tcomplete”，并根据请求的数据对它们进行初始化。 (01) TestClent的getService请求是提交给ServiceManager进行处理的，因此，”待处理事务t”会被添加到ServiceManager的待处理事务队列中。此时的target_thread是ServiceManager对应的线程，而target_proc则是ServiceManager对应的进程上下文环境。 (02) 此时，Binder驱动已经收到了TestClent的getService请求；于是，将一个BINDER_WORK_TRANSACTION_COMPLETE类型的”待完成工作tcomplete”添加到当前线程(即，TestClent线程)的待处理事务队列中。目的是告诉TestClent，Binder驱动已经收到它的getService请求了。 (03) 最后，调用wake_up_interruptible(target_wait)将ServiceManager唤醒。</p><p>接下来，还是先分析完TestClent线程，再看ServiceManager被唤醒后做了些什么。</p><p>binder_transaction()执行完毕之后，就会返回到binder_thread_write()中。binder_thread_write()更新bwr.write_consumed的值后，就返回到binder_ioctl()继续执行”读”动作。即执行binder_thread_read()。</p><h4 id="2-4、Binder驱动中binder-thread-read-的源码"><a href="#2-4、Binder驱动中binder-thread-read-的源码" class="headerlink" title="2.4、Binder驱动中binder_thread_read()的源码"></a>2.4、Binder驱动中binder_thread_read()的源码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_thread_read</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                  struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">void</span>  __user *buffer, <span class="keyword">int</span> size,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">signed</span> <span class="keyword">long</span> *consumed, <span class="keyword">int</span> non_block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> __user *ptr = buffer + *consumed;</span><br><span class="line">    <span class="keyword">void</span> __user *end = buffer + size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> wait_for_proc_work;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果*consumed=0，则写入BR_NOOP到用户传进来的bwr.read_buffer缓存区</span></span><br><span class="line">    <span class="keyword">if</span> (*consumed == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (put_user(BR_NOOP, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">    <span class="comment">// 等待proc进程的事务标记。</span></span><br><span class="line">    <span class="comment">// 当线程的事务栈为空 并且 待处理事务队列为空时，该标记位true。</span></span><br><span class="line">    wait_for_proc_work = thread-&gt;transaction_stack == <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">                list_empty(&amp;thread-&gt;todo);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (wait_for_proc_work) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (non_block) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            ret = wait_event_interruptible(thread-&gt;wait, binder_has_thread_work(thread));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> cmd;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> <span class="title">tr</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> *<span class="title">w</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">t</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前线程的"待完成工作"不为空，则取出待完成工作。</span></span><br><span class="line">        <span class="keyword">if</span> (!list_empty(&amp;thread-&gt;todo))</span><br><span class="line">            w = list_first_entry(&amp;thread-&gt;todo, struct binder_work, entry);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!list_empty(&amp;proc-&gt;todo) &amp;&amp; wait_for_proc_work)</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ptr - buffer == <span class="number">4</span> &amp;&amp; !(thread-&gt;looper &amp; BINDER_LOOPER_STATE_NEED_RETURN)) <span class="comment">/* no data added */</span></span><br><span class="line">                <span class="keyword">goto</span> retry;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (w-&gt;type) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> BINDER_WORK_TRANSACTION_COMPLETE: &#123;</span><br><span class="line">            cmd = BR_TRANSACTION_COMPLETE;</span><br><span class="line">            <span class="comment">// 将BR_TRANSACTION_COMPLETE写入到用户缓冲空间中</span></span><br><span class="line">            <span class="keyword">if</span> (put_user(cmd, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">            ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 待完成事务已经处理完毕，将其从待完成事务队列中删除。</span></span><br><span class="line">            list_del(&amp;w-&gt;entry);</span><br><span class="line">            kfree(w);</span><br><span class="line">            binder_stats_deleted(BINDER_STAT_TRANSACTION_COMPLETE);</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!t)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 更新bwr.read_consumed的值</span></span><br><span class="line">    *consumed = ptr - buffer;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明： (01) bwr.read_consumed=0，即if (*consumed == 0)为true。因此，会将BR_NOOP写入到bwr.read_buffer中。 (02) thread-&gt;transaction_stack不为空，thread-&gt;todo也不为空。因为，前面在binder_transaction()中有将一个BINDER_WORK_TRANSACTION_COMPLETE类型的待完成工作添加到thread的待完成工作队列中。因此，wait_for_proc_work为false。 (03) binder_has_thread_work(thread)为true。因此，在调用wait_event_interruptible()时，不会进入等待状态，而是继续运行。 (04) 进入while循环后，通过list_first_entry()取出待完成工作w。w的类型w-&gt;type=BINDER_WORK_TRANSACTION_COMPLETE，进入到对应的switch分支。随后，将BR_TRANSACTION_COMPLETE写入到bwr.read_buffer中。此时，待处理工作已经完成，将其从当前线程的待处理工作队列中删除。 (05) 最后，更新bwr.read_consumed的值。</p><p>经过binder_thread_read()处理之后，bwr.read_buffer中包含了两个指令：BR_NOOP和BR_TRANSACTION_COMPLETE。</p><h4 id="2-5、ServiceManager处理getService请求"><a href="#2-5、ServiceManager处理getService请求" class="headerlink" title="2.5、ServiceManager处理getService请求"></a>2.5、ServiceManager处理getService请求</h4><p>下面看看ServiceManager被唤醒之后，是如何处理getService请求的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">int binder_parse(struct binder_state *bs, struct binder_io *bio,</span><br><span class="line">                 uint32_t *ptr, uint32_t size, binder_handler func)</span><br><span class="line">&#123;</span><br><span class="line">    while (ptr &lt; end) &#123;</span><br><span class="line">        case BR_TRANSACTION: &#123;</span><br><span class="line">            struct binder_txn *txn = (void *) ptr;</span><br><span class="line">            ...</span><br><span class="line">            if (func) &#123;</span><br><span class="line">                unsigned rdata[256/4];</span><br><span class="line">                struct binder_io msg;   // 用于保存&quot;Binder驱动反馈的信息&quot;</span><br><span class="line">                struct binder_io reply; // 用来保存&quot;回复给Binder驱动的信息&quot;</span><br><span class="line">                int res;</span><br><span class="line"></span><br><span class="line">                // 初始化reply</span><br><span class="line">                bio_init(&amp;reply, rdata, sizeof(rdata), 4);</span><br><span class="line">                // 根据txt(Binder驱动反馈的信息)初始化msg</span><br><span class="line">                bio_init_from_txn(&amp;msg, txn);</span><br><span class="line">                // 消息处理</span><br><span class="line">                res = func(bs, txn, &amp;msg, &amp;reply);</span><br><span class="line">                // 反馈消息给Binder驱动。</span><br><span class="line">                binder_send_reply(bs, &amp;reply, txn-&gt;data, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>binder_send_reply(bs, &amp;reply, txn-&gt;data, res);-&gt;binder_write()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">binder_write()</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_write</span><span class="params">(struct binder_state *bs, <span class="keyword">void</span> *data, <span class="keyword">unsigned</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    bwr.write_size = len;</span><br><span class="line">    bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.write_buffer = (<span class="keyword">unsigned</span>) data;</span><br><span class="line">    bwr.read_size = <span class="number">0</span>;</span><br><span class="line">    bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.read_buffer = <span class="number">0</span>;</span><br><span class="line">    res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);</span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"binder_write: ioctl failed (%s)\n"</span>,</span><br><span class="line">                strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：binder_write()会将数据封装到binder_write_read的变量bwr中；其中，bwr.read_size=0，而bwr.write_size&gt;0。接着，便通过ioctl(,BINDER_WRITE_READ,)和Binder驱动交互，将数据反馈给Binder驱动。</p><p>再次回到Binder驱动的binder_ioctl()对应的BINDER_WRITE_READ分支中。此时，由于bwr.read_size=0，而bwr.write_size&gt;0；因此，Binder驱动只调用binder_thread_write进行写操作，而不会进行读。</p><p>返回数据：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/42-Android-binder-Binder-io-transaction-data.jpg" alt="Markdown"></p><p>handle = 1 代表第一个</p><h5 id="2-6、Binder驱动中处理ServiceManager返回数据"><a href="#2-6、Binder驱动中处理ServiceManager返回数据" class="headerlink" title="2.6、Binder驱动中处理ServiceManager返回数据"></a>2.6、Binder驱动中处理ServiceManager返回数据</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_thread_write</span><span class="params">(struct binder_proc *proc, struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">void</span> __user *buffer, <span class="keyword">int</span> size, <span class="keyword">signed</span> <span class="keyword">long</span> *consumed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> cmd;</span><br><span class="line">  <span class="keyword">void</span> __user *ptr = buffer + *consumed;</span><br><span class="line">  <span class="keyword">void</span> __user *end = buffer + size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取binder_write_read.write_buffer中的内容。</span></span><br><span class="line">  <span class="comment">// 每次读取32bit(即4个字节)</span></span><br><span class="line">  <span class="keyword">while</span> (ptr &lt; end &amp;&amp; thread-&gt;return_error == BR_OK) &#123;</span><br><span class="line">      <span class="comment">// 从用户空间读取32bit到内核中，并赋值给cmd。</span></span><br><span class="line">      <span class="keyword">if</span> (get_user(cmd, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">          <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">      ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> BC_FREE_BUFFER:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> BC_TRANSACTION:</span><br><span class="line">        <span class="keyword">case</span> BC_REPLY: &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> <span class="title">tr</span>;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (copy_from_user(&amp;tr, ptr, <span class="keyword">sizeof</span>(tr)))</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">            ptr += <span class="keyword">sizeof</span>(tr);</span><br><span class="line">            binder_transaction(proc, thread, &amp;tr, cmd == BC_REPLY);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      ...</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 更新bwr.write_consumed的值</span></span><br><span class="line">      *consumed = ptr - buffer;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>binder_thread_write()进入BC_REPLY之后，会将数据拷贝到内核空间，然后调用binder_transaction()进行处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binder_transaction</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_transaction_data *tr, <span class="keyword">int</span> reply)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">t</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> *<span class="title">tcomplete</span>;</span></span><br><span class="line">    <span class="keyword">size_t</span> *offp, *off_end;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">target_proc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">target_thread</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">target_node</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">target_list</span>;</span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> *target_wait;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">in_reply_to</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_log_entry</span> *<span class="title">e</span>;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> return_error;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">        <span class="comment">// 事务栈</span></span><br><span class="line">        in_reply_to = thread-&gt;transaction_stack;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 设置优先级</span></span><br><span class="line">        binder_set_nice(in_reply_to-&gt;saved_priority);</span><br><span class="line">        ...</span><br><span class="line">        thread-&gt;transaction_stack = in_reply_to-&gt;to_parent;</span><br><span class="line">        <span class="comment">// 发起请求的线程，即MediaPlayer所在线程。</span></span><br><span class="line">        <span class="comment">// from的值，是MediaPlayer发起请求时在binder_transaction()中赋值的。</span></span><br><span class="line">        target_thread = in_reply_to-&gt;from;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// MediaPlayer对应的进程</span></span><br><span class="line">        target_proc = target_thread-&gt;proc;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (target_thread) &#123;</span><br><span class="line">        e-&gt;to_thread = target_thread-&gt;pid;</span><br><span class="line">        target_list = &amp;target_thread-&gt;todo;</span><br><span class="line">        target_wait = &amp;target_thread-&gt;wait;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    e-&gt;to_proc = target_proc-&gt;pid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配一个待处理的事务t，t是binder事务(binder_transaction对象)</span></span><br><span class="line">    t = kzalloc(<span class="keyword">sizeof</span>(*t), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        return_error = BR_FAILED_REPLY;</span><br><span class="line">        <span class="keyword">goto</span> err_alloc_t_failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配一个待完成的工作tcomplete，tcomplete是binder_work对象。</span></span><br><span class="line">    tcomplete = kzalloc(<span class="keyword">sizeof</span>(*tcomplete), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (tcomplete == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        return_error = BR_FAILED_REPLY;</span><br><span class="line">        <span class="keyword">goto</span> err_alloc_tcomplete_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    binder_stats_created(BINDER_STAT_TRANSACTION_COMPLETE);</span><br><span class="line"></span><br><span class="line">    t-&gt;debug_id = ++binder_last_id;</span><br><span class="line">    e-&gt;debug_id = t-&gt;debug_id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!reply &amp;&amp; !(tr-&gt;flags &amp; TF_ONE_WAY))</span><br><span class="line">        t-&gt;from = thread;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t-&gt;from = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 下面的一些赋值是初始化事务t</span></span><br><span class="line">    t-&gt;sender_euid = proc-&gt;tsk-&gt;cred-&gt;euid;</span><br><span class="line">    <span class="comment">// 事务将交给target_proc进程进行处理</span></span><br><span class="line">    t-&gt;to_proc = target_proc;</span><br><span class="line">    <span class="comment">// 事务将交给target_thread线程进行处理</span></span><br><span class="line">    t-&gt;to_thread = target_thread;</span><br><span class="line">    <span class="comment">// 事务编码</span></span><br><span class="line">    t-&gt;code = tr-&gt;code;</span><br><span class="line">    <span class="comment">// 事务标志</span></span><br><span class="line">    t-&gt;flags = tr-&gt;flags;</span><br><span class="line">    <span class="comment">// 事务优先级</span></span><br><span class="line">    t-&gt;priority = task_nice(current);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配空间</span></span><br><span class="line">    t-&gt;buffer = binder_alloc_buf(target_proc, tr-&gt;data_size,</span><br><span class="line">        tr-&gt;offsets_size, !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY));</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;buffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        return_error = BR_FAILED_REPLY;</span><br><span class="line">        <span class="keyword">goto</span> err_binder_alloc_buf_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    t-&gt;buffer-&gt;allow_user_free = <span class="number">0</span>;</span><br><span class="line">    t-&gt;buffer-&gt;debug_id = t-&gt;debug_id;</span><br><span class="line">    <span class="comment">// 保存事务</span></span><br><span class="line">    t-&gt;buffer-&gt;transaction = t;</span><br><span class="line">    <span class="comment">// target_node为NULL</span></span><br><span class="line">    t-&gt;buffer-&gt;target_node = target_node;</span><br><span class="line">    trace_binder_transaction_alloc_buf(t-&gt;buffer);</span><br><span class="line">    <span class="keyword">if</span> (target_node)</span><br><span class="line">        binder_inc_node(target_node, <span class="number">1</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    offp = (<span class="keyword">size_t</span> *)(t-&gt;buffer-&gt;data + ALIGN(tr-&gt;data_size, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将"用户传入的数据"保存到事务中</span></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(t-&gt;buffer-&gt;data, tr-&gt;data.ptr.buffer, tr-&gt;data_size)) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将"用户传入的数据偏移地址"保存到事务中</span></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(offp, tr-&gt;data.ptr.offsets, tr-&gt;offsets_size)) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    off_end = (<span class="keyword">void</span> *)offp + tr-&gt;offsets_size;</span><br><span class="line">    <span class="comment">// 将flat_binder_object对象读取出来，</span></span><br><span class="line">    <span class="comment">// 这里就是Service Manager中反馈的MediaPlayerService对象。</span></span><br><span class="line">    <span class="keyword">for</span> (; offp &lt; off_end; offp++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">flat_binder_object</span> *<span class="title">fp</span>;</span></span><br><span class="line">        ...</span><br><span class="line">        fp = (struct flat_binder_object *)(t-&gt;buffer-&gt;data + *offp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (fp-&gt;type) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">case</span> BINDER_TYPE_HANDLE:</span><br><span class="line">            <span class="keyword">case</span> BINDER_TYPE_WEAK_HANDLE: &#123;</span><br><span class="line">                <span class="comment">// 根据handle获取对应的Binder引用，即得到MediaPlayerService的Binder引用</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">binder_ref</span> *<span class="title">ref</span> = <span class="title">binder_get_ref</span>(<span class="title">proc</span>, <span class="title">fp</span>-&gt;<span class="title">handle</span>);</span></span><br><span class="line">                <span class="keyword">if</span> (ref == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    ...</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// ref-&gt;node-&gt;proc是MediaPlayerService的进程上下文环境，</span></span><br><span class="line">                <span class="comment">// 而target_proc是MediaPlayer的进程上下文环境</span></span><br><span class="line">                <span class="keyword">if</span> (ref-&gt;node-&gt;proc == target_proc) &#123;</span><br><span class="line">                    ...</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    struct binder_ref *new_ref;</span><br><span class="line">                    <span class="comment">// 在MediaPlayer进程中引用"MediaPlayerService"。</span></span><br><span class="line">                    <span class="comment">// 表现为，执行binder_get_ref_for_node()会，会先在MediaPlayer进程中查找是否存在MediaPlayerService对应的Binder引用；</span></span><br><span class="line">                    <span class="comment">// 很显然是不存在的。于是，并新建MediaPlayerService对应的Binder引用，并将其添加到MediaPlayer的Binder引用红黑树中。</span></span><br><span class="line">                    new_ref = binder_get_ref_for_node(target_proc, ref-&gt;node);</span><br><span class="line">                    <span class="keyword">if</span> (new_ref == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                        ...</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 将new_ref的引用描述复制给fp-&gt;handle。</span></span><br><span class="line">                    fp-&gt;handle = new_ref-&gt;desc;</span><br><span class="line">                    binder_inc_ref(new_ref, fp-&gt;type == BINDER_TYPE_HANDLE, <span class="literal">NULL</span>);</span><br><span class="line">                    ...</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">        binder_pop_transaction(target_thread, in_reply_to);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(t-&gt;flags &amp; TF_ONE_WAY)) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置事务的类型为BINDER_WORK_TRANSACTION</span></span><br><span class="line">    t-&gt;work.type = BINDER_WORK_TRANSACTION;</span><br><span class="line">    <span class="comment">// 将事务添加到target_list队列中，即target_list的待处理事务中</span></span><br><span class="line">    list_add_tail(&amp;t-&gt;work.entry, target_list);</span><br><span class="line">    <span class="comment">// 设置待完成工作的类型为BINDER_WORK_TRANSACTION_COMPLETE</span></span><br><span class="line">    tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE;</span><br><span class="line">    <span class="comment">// 将待完成工作添加到thread-&gt;todo队列中，即当前线程的待完成工作中。</span></span><br><span class="line">    list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo);</span><br><span class="line">    <span class="comment">// 唤醒目标进程</span></span><br><span class="line">    <span class="keyword">if</span> (target_wait)</span><br><span class="line">        wake_up_interruptible(target_wait);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：reply=1，这里只关注reply部分。 (01) 此反馈最终是要回复给TestClient的。因此，target_thread被赋值为TestServer所在的线程，target_proc则是TestClient对应的进程，target_node为null。 (02) 这里，先看看for循环里面的内容，取出BR_REPLY指令所发送的数据，然后获取数据中的flat_binder_object变量fp。因为fp-&gt;type为BINDER_TYPE_HANDLE，因此进入BINDER_TYPE_HANDLE对应的分支。接着，通过binder_get_ref()获取Hello Service对应的Binder引用；很明显，能够正常获取到Hello Service的Binder引用。因为在Hello Service调用addService请求时，已经创建了它的Binder引用。 binder_get_ref_for_node()的作用是在TestClent进程上下文中添加”TestServer对应的Binder引用”。这样，后面就可以根据该Binder引用一步步的获取TestServer对象。 最后，将Binder引用的描述赋值给fp-&gt;handle。 (03) 此时，Service Manager已经处理了getService请求。便调用binder_pop_transaction(target_thread, in_reply_to)将事务从”target_thread的事务栈”中删除，即从MediaPlayer线程的事务栈中删除该事务。 (04) 新建的”待处理事务t”的type为设为BINDER_WORK_TRANSACTION后，会被添加到MediaPlayer的待处理事务队列中。 (05) 此时，Service Manager已经处理了getService请求，而Binder驱动在等待它的回复。于是，将一个BINDER_WORK_TRANSACTION_COMPLETE类型的”待完成工作tcomplete”(作为回复)添加到当前线程(即，Service Manager线程)的待处理事务队列中。 (06) 最后，调用wake_up_interruptible()唤醒TestServer。TestServer被唤醒后，会对事务BINDER_WORK_TRANSACTION进行处理。</p><p>OK，到现在为止，还有两个待处理事务：(01) ServiceManager待处理事务列表中有个BINDER_WORK_TRANSACTION_COMPLETE类型的事务 (02) TestServer待处理事务列表中有个BINDER_WORK_TRANSACTION事务。</p><h4 id="2-7-Testclient获取handle"><a href="#2-7-Testclient获取handle" class="headerlink" title="2.7. Testclient获取handle"></a>2.7. Testclient获取handle</h4><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/43-Android-binder-binder_use_service.png" alt="Markdown"></p><h3 id="（3）、Binder系统驱动情景分析–TestClent使用”Hello”服务过程"><a href="#（3）、Binder系统驱动情景分析–TestClent使用”Hello”服务过程" class="headerlink" title="（3）、Binder系统驱动情景分析–TestClent使用”Hello”服务过程"></a>（3）、Binder系统驱动情景分析–TestClent使用”Hello”服务过程</h3><p>构造数据发送数据”weidongshan”<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/44-Android-binder-Binder-io-transaction-data.jpg" alt="Markdown"></p><h2 id="四、Android-Binder系统-Native层"><a href="#四、Android-Binder系统-Native层" class="headerlink" title="四、Android Binder系统-Native层"></a>四、Android Binder系统-Native层</h2><p>前面我们分析内核驱动Binder使用过程，可以看到，binder系统在内核能正常完成IPC通信，接下来分析Android framwork层，最后是App层。</p><p>Framework是一个中间层，它对接了底层实现，封装了复杂的内部逻辑，并提供供外部使用的接口。Framework层是应用程序开发的基础。</p><p>Binder Framework层分为C++和Java两个部分，为了达到功能的复用，中间通过JNI进行衔接。</p><p>Binder Framework的C++部分，头文件位于这个路径：/frameworks/native/include/binder/，实现位于这个路径：/frameworks/native/libs/binder/ 。Binder库最终会编译成一个动态链接库：libbinder.so，供其他进程链接使用。</p><p>为了便于说明，下文中我们将Binder Framework 的C++部分称之为libbinder。首先说一下ServiceManager，然后详细介绍。</p><h3 id="1-、ServiceManager类图-Native层"><a href="#1-、ServiceManager类图-Native层" class="headerlink" title="(1)、ServiceManager类图(Native层)"></a>(1)、ServiceManager类图(Native层)</h3><p>IServiceManager相关类如下图所示：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/45-Android-native_binder_framework_servicemananger.png" alt="Markdown"></p><p>IServiceManager是表示servicemanager的接口，有如下方法：</p><p>1) getService获得binder service引用，</p><p>2) checkService获得binder service引用，</p><p>3) addService添加binder service，</p><p>4) listServices 列举所有binder service。</p><p>servicemanager的binder service服务端其实是在frameworks/base/cmds/servicemanager 里实现，BnServiceMananger实际上并未使用。BpServiceMananger就是利用获得的IBinder指针建立的IServiceMananger对象的实际类型。</p><h3 id="2-、Binder框架Native层"><a href="#2-、Binder框架Native层" class="headerlink" title="(2)、Binder框架Native层"></a>(2)、Binder框架Native层</h3><p>libbinder中，将实现分为Proxy和Native两端。Proxy对应了上文提到的Client端，是服务对外提供的接口。而Native是服务实现的一端，对应了上文提到的Server端。类名中带有小写字母p的（例如BpInterface），就是指Proxy端。类名带有小写字母n的（例如BnInterface），就是指Native端。</p><p>Proxy代表了调用方，通常与服务的实现不在同一个进程，因此下文中，我们也称Proxy端为”远程”端。Native端是服务实现的自身，因此下文中，我们也称Native端为”本地”端。</p><p>这里，我们先对libbinder中的主要类做一个简要说明，了解一下它们的关系，然后再详细的讲解。</p><table><thead><tr><th style="text-align:left">类名</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">BpRefBase</td><td style="text-align:left">RefBase的子类，提供remote()方法获取远程Binder</td></tr><tr><td style="text-align:left">IInterface</td><td style="text-align:left">Binder服务接口的基类，Binder服务通常需要同时提供本地接口和远程接口</td></tr><tr><td style="text-align:left">BpInterface</td><td style="text-align:left">远程接口的基类，远程接口是供客户端调用的接口集</td></tr><tr><td style="text-align:left">BnInterface</td><td style="text-align:left">本地接口的基类，本地接口是需要服务中真正实现的接口集</td></tr><tr><td style="text-align:left">IBiner</td><td style="text-align:left">Binder对象的基类，BBinder和BpBinder都是这个类的子类</td></tr><tr><td style="text-align:left">BpBinder</td><td style="text-align:left">远程Binder，这个类提供transact方法来发送请求，BpXXX实现中会用到</td></tr><tr><td style="text-align:left">BBinder</td><td style="text-align:left">本地Binder，服务实现方的基类，提供了onTransact接口来接收请求</td></tr><tr><td style="text-align:left">ProcessState</td><td style="text-align:left">代表了使用Binder的进程</td></tr><tr><td style="text-align:left">IPCThreadState</td><td style="text-align:left">代表了使用Binder的线程，这个类中封装了与Binder驱动通信的逻辑</td></tr><tr><td style="text-align:left">Parcel</td><td style="text-align:left">在Binder上传递的数据的包装器</td></tr></tbody></table><p>下图描述了这些类之间的关系：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/46-Androi-binder_middleware.png" alt="Markdown"></p><p>另外说明一下，Binder服务的实现类（图中紫色部分）通常都会遵守下面的命名规则：</p><p>☯ 服务的接口使用I字母作为前缀 ☯ 远程接口使用Bp作为前缀 ☯ 本地接口使用Bn作为前缀</p><p>看了上面这些介绍，你可能还是不太容易理解。不过不要紧，下面我们会逐步拆分讲解这些内容。</p><p>在这幅图中，浅黄色部分的结构是最难理解的，因此我们先从它们着手。</p><p>我们先来看看IBinder这个类。这个类描述了所有在Binder上传递的对象，它既是Binder本地对象BBinder的父类，也是Binder远程对象BpBinder的父类。这个类中的主要方法说明如下：</p><table><thead><tr><th style="text-align:left">方法名</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">localBinder</td><td style="text-align:left">获取本地Binder对象</td></tr><tr><td style="text-align:left">remoteBinder</td><td style="text-align:left">获取远程Binder对象</td></tr><tr><td style="text-align:left">transact</td><td style="text-align:left">进行一次Binder操作</td></tr><tr><td style="text-align:left">queryLocalInterface</td><td style="text-align:left">尝试获取本地Binder，如何失败返回NULL</td></tr><tr><td style="text-align:left">getInterfaceDescriptor</td><td style="text-align:left">获取Binder的服务接口描述，其实就是Binder服务的唯一标识</td></tr><tr><td style="text-align:left">isBinderAlive</td><td style="text-align:left">查询Binder服务是否还活着</td></tr><tr><td style="text-align:left">pingBinder</td><td style="text-align:left">发送PING_TRANSACTION给Binder服务</td></tr></tbody></table><p>BpBinder的实例代表了远程Binder，这个类的对象将被客户端调用。其中handle方法会返回指向Binder服务实现者的句柄，这个类最重要就是提供了transact方法，这个方法会将远程调用的参数封装好发送的Binder驱动。</p><p>由于每个Binder服务通常都会提供多个服务接口，而这个方法中的uint32_t code参数就是用来对服务接口进行编号区分的。Binder服务的每个接口都需要指定一个唯一的code，这个code要在Proxy和Native端配对好。当客户端将请求发送到服务端的时候，服务端根据这个code（onTransact方法中）来区分调用哪个接口方法。</p><p>BBinder的实例代表了本地Binder，它描述了服务的提供方，所有Binder服务的实现者都要继承这个类（的子类），在继承类中，最重要的就是实现onTransact方法，因为这个方法是所有请求的入口。因此，这个方法是和BpBinder中的transact方法对应的，这个方法同样也有一个uint32_t code参数，在这个方法的实现中，由服务提供者通过code对请求的接口进行区分，然后调用具体实现服务的方法。</p><p>IBinder中定义了uint32_t code允许的范围：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FIRST_CALL_TRANSACTION  = <span class="number">0x00000001</span>,</span><br><span class="line">LAST_CALL_TRANSACTION   = <span class="number">0x00ffffff</span>,</span><br></pre></td></tr></table></figure><p>Binder服务要保证自己提供的每个服务接口有一个唯一的code，例如hello服务:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HELLO_SVR_CMD_SAYHELLO     1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HELLO_SVR_CMD_SAYHELLO_TO  2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HELLO_SVR_CMD_GET_FD       3</span></span><br></pre></td></tr></table></figure><p>讲完了IBinder，BpBinder和BBinder三个类，我们再来看看BpReBase，IInterface，BpInterface和BnInterface。</p><p>每个Binder服务都是为了某个功能而实现的，因此其本身会定义一套接口集（通常是C++的一个类）来描述自己提供的所有功能。而Binder服务既有自身实现服务的类，也要有给客户端进程调用的类。为了便于开发，这两中类里面的服务接口应当是一致的，例如：假设服务实现方提供了一个接口为sayhello(void)的服务方法，那么其远程接口中也应当有一个sayhello(void)方法。因此为了实现方便，本地实现类和远程接口类需要有一个公共的描述服务接口的基类（即上图中的IXXXService）来继承。而这个基类通常是IInterface的子类，IInterface的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IInterface</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> RefBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">            IInterface();</span><br><span class="line">            <span class="keyword">static</span> sp&lt;IBinder&gt;  asBinder(<span class="keyword">const</span> IInterface*);</span><br><span class="line">            <span class="keyword">static</span> sp&lt;IBinder&gt;  asBinder(<span class="keyword">const</span> sp&lt;IInterface&gt;&amp;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">virtual</span>                     ~IInterface();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IBinder*            <span class="title">onAsBinder</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>之所以要继承自IInterface类是因为这个类中定义了onAsBinder让子类实现。onAsBinder在本地对象的实现类中返回的是本地对象，在远程对象的实现类中返回的是远程对象。onAsBinder方法被两个静态方法asBinder方法调用。有了这些接口之后，在代码中便可以直接通过IXXX::asBinder方法获取到不用区分本地还是远程的IBinder对象。这个在跨进程传递Binder对象的时候有很大的作用（因为不用区分具体细节，只要直接调用和传递就好）。</p><p>下面，我们来看一下BpInterface和BnInterface的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> INTERFACE&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BnInterface</span> :</span> <span class="keyword">public</span> INTERFACE, <span class="keyword">public</span> BBinder</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> sp&lt;IInterface&gt;      queryLocalInterface(<span class="keyword">const</span> String16&amp; _descriptor);</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> String16&amp;     <span class="title">getInterfaceDescriptor</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IBinder*            <span class="title">onAsBinder</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> INTERFACE&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BpInterface</span> :</span> <span class="keyword">public</span> INTERFACE, <span class="keyword">public</span> BpRefBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">                                BpInterface(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; remote);</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IBinder*            <span class="title">onAsBinder</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这两个类都是模板类，它们在继承自INTERFACE的基础上各自继承了另外一个类。这里的INTERFACE便是我们Binder服务接口的基类。另外，BnInterface继承了BBinder类，由此可以通过复写onTransact方法来提供实现。BpInterface继承了BpRefBase，通过这个类的remote方法可以获取到指向服务实现方的句柄。在客户端接口的实现类中，每个接口在组装好参数之后，都会调用remote()-&gt;transact来发送请求，而这里其实就是调用的BpBinder的transact方法，这样请求便通过Binder到达了服务实现方的onTransact中。这个过程如下图所示：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/47-Android-Binder-IPCall.png" alt="Markdown"></p><p>基于Binder框架开发的服务，除了满足上文提到的类名规则之外，还需要遵守其他一些共同的规约：</p><p>☯为了进行服务的区分，每个Binder服务需要指定一个唯一的标识，这个标识通过getInterfaceDescriptor返回，类型是一个字符串。通常，Binder服务会在类中定义static const android::String16 descriptor;这样一个常量来描述这个标识符，然后在getInterfaceDescriptor方法中返回这个常量。 ☯为了便于调用者获取到调用接口，服务接口的公共基类需要提供一个android::sp</p><ixxx> asInterface方法来返回基类对象指针。<br>由于上面提到的这两点对于所有Binder服务的实现逻辑都是类似的。为了简化开发者的重复工作，在libbinder中，定义了两个宏来简化这些重复工作，它们是：</ixxx><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_META_INTERFACE(INTERFACE)                            \</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> android::String16 descriptor;                       \</span><br><span class="line">    <span class="keyword">static</span> android::sp&lt;I##INTERFACE&gt; asInterface(                    \</span><br><span class="line">            <span class="keyword">const</span> android::sp&lt;android::IBinder&gt;&amp; obj);               \</span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">const</span> android::<span class="function">String16&amp; <span class="title">getInterfaceDescriptor</span><span class="params">()</span> <span class="keyword">const</span></span>; \</span><br><span class="line">    I##INTERFACE();                                                  \</span><br><span class="line">    <span class="keyword">virtual</span> ~I##INTERFACE();                                         \</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPLEMENT_META_INTERFACE(INTERFACE, NAME)                    \</span></span><br><span class="line">    <span class="keyword">const</span> android::String16 I##INTERFACE::descriptor(NAME);          \</span><br><span class="line">    <span class="keyword">const</span> android::String16&amp;                                         \</span><br><span class="line">            I##INTERFACE::getInterfaceDescriptor() <span class="keyword">const</span> &#123;           \</span><br><span class="line">        <span class="keyword">return</span> I##INTERFACE::descriptor;                             \</span><br><span class="line">    &#125;                                                                \</span><br><span class="line">    android::sp&lt;I##INTERFACE&gt; I##INTERFACE::asInterface(             \</span><br><span class="line">            <span class="keyword">const</span> android::sp&lt;android::IBinder&gt;&amp; obj)                \</span><br><span class="line">    &#123;                                                                \</span><br><span class="line">        android::sp&lt;I##INTERFACE&gt; intr;                              \</span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="literal">NULL</span>) &#123;                                           \</span><br><span class="line">            intr = <span class="keyword">static_cast</span>&lt;I##INTERFACE*&gt;(                       \</span><br><span class="line">                obj-&gt;queryLocalInterface(                            \</span><br><span class="line">                        I##INTERFACE::descriptor).get());            \</span><br><span class="line">            <span class="keyword">if</span> (intr == <span class="literal">NULL</span>) &#123;                                      \</span><br><span class="line">                intr = <span class="keyword">new</span> Bp##INTERFACE(obj);                       \</span><br><span class="line">            &#125;                                                        \</span><br><span class="line">        &#125;                                                            \</span><br><span class="line">        <span class="keyword">return</span> intr;                                                 \</span><br><span class="line">    &#125;                                                                \</span><br><span class="line">    I##INTERFACE::I##INTERFACE() &#123; &#125;                                 \</span><br><span class="line">    I##INTERFACE::~I##INTERFACE() &#123; &#125;                                \</span><br></pre></td></tr></table></figure><p>有了这两个宏之后，开发者只要在接口基类（IXXX）头文件中，使用DECLARE_META_INTERFACE宏便完成了需要的组件的声明。然后在cpp文件中使用IMPLEMENT_META_INTERFACE便完成了这些组件的实现。</p><h4 id="2-1、Binder的初始化ProcessState"><a href="#2-1、Binder的初始化ProcessState" class="headerlink" title="2.1、Binder的初始化ProcessState"></a>2.1、<strong>Binder的初始化ProcessState</strong></h4><p>在讲解Binder驱动的时候我们就提到：任何使用Binder机制的进程都必须要对/dev/binder设备进行open以及mmap之后才能使用，这部分逻辑是所有使用Binder机制进程共同的。对于这种共同逻辑的封装便是Framework层的职责之一。libbinder中，ProcessState类封装了这个逻辑，相关代码见下文。</p><p>这里是ProcessState构造函数，在这个函数中，初始化mDriverFD的时候调用了open_driver方法打开binder设备，然后又在函数体中，通过mmap进行内存映射。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ProcessState::ProcessState()</span><br><span class="line">    : mDriverFD(open_driver())</span><br><span class="line">    , mVMStart(MAP_FAILED)</span><br><span class="line">    , mThreadCountLock(PTHREAD_MUTEX_INITIALIZER)</span><br><span class="line">    , mThreadCountDecrement(PTHREAD_COND_INITIALIZER)</span><br><span class="line">    , mExecutingThreadsCount(<span class="number">0</span>)</span><br><span class="line">    , mMaxThreads(DEFAULT_MAX_BINDER_THREADS)</span><br><span class="line">    , mStarvationStartTimeMs(<span class="number">0</span>)</span><br><span class="line">    , mManagesContexts(<span class="literal">false</span>)</span><br><span class="line">    , mBinderContextCheckFunc(<span class="literal">NULL</span>)</span><br><span class="line">    , mBinderContextUserData(<span class="literal">NULL</span>)</span><br><span class="line">    , mThreadPoolStarted(<span class="literal">false</span>)</span><br><span class="line">    , mThreadPoolSeq(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDriverFD &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        mVMStart = mmap(<span class="number">0</span>, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, <span class="number">0</span>);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>open_driver的函数实现如下所示。在这个函数中完成了三个工作：</p><p>☯首先通过open系统调用打开了dev/binder设备 ☯然后通过ioctl获取Binder实现的版本号，并检查是否匹配 ☯最后通过ioctl设置进程支持的最大线程数量 关于这部分逻辑背后的处理，在讲解Binder驱动的时候，我们已经讲解过了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">open_driver</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">"/dev/binder"</span>, O_RDWR | O_CLOEXEC);</span><br><span class="line">    <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> vers = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">status_t</span> result = ioctl(fd, BINDER_VERSION, &amp;vers);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">size_t</span> maxThreads = DEFAULT_MAX_BINDER_THREADS;</span><br><span class="line">        result = ioctl(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ProcessState是一个Singleton（单例）类型的类，在一个进程中，只会存在一个实例。通过ProcessState::self()接口获取这个实例。一旦获取这个实例，便会执行其构造函数，由此完成了对于Binder设备的初始化工作。</p><h4 id="2-2、关于Binder传递数据的大小限制"><a href="#2-2、关于Binder传递数据的大小限制" class="headerlink" title="2.2、关于Binder传递数据的大小限制"></a>2.2、<strong>关于Binder传递数据的大小限制</strong></h4><p>由于Binder的数据需要跨进程传递，并且还需要在内核上开辟空间，因此允许在Binder上传递的数据并不是无无限大的。mmap中指定的大小便是对数据传递的大小限制：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_VM_SIZE ((1*1024*1024) - (4096 *2)) <span class="comment">// 1M - 8k</span></span></span><br><span class="line">mVMStart = mmap(<span class="number">0</span>, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>这里我们看到，在进行mmap的时候，指定了最大size为BINDER_VM_SIZE，即 1M - 8k的大小。 因此我们在开发过程中，一次Binder调用的数据总和不能超过这个大小。</p><p>对于这个区域的大小，我们也可以在设备上进行确认。这里我们还之前提到的system_server为例。上面我们讲解了通过procfs来获取映射的内存地址，除此之外，我们也可以通过showmap命令，来确定这块区域的大小，相关命令如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">angler:/ <span class="meta"># ps  | grep system_server                                            </span></span><br><span class="line">system    <span class="number">1889</span>  <span class="number">526</span>   <span class="number">2353404</span> <span class="number">135968</span> SyS_epoll_ <span class="number">72972</span>eeaf4 S system_server</span><br><span class="line">angler:/ <span class="meta"># showmap 1889 | grep <span class="meta-string">"/dev/binder"</span>                                   </span></span><br><span class="line">    <span class="number">1016</span>        <span class="number">4</span>        <span class="number">4</span>        <span class="number">0</span>        <span class="number">0</span>        <span class="number">4</span>        <span class="number">0</span>        <span class="number">0</span>    <span class="number">1</span> /dev/binder</span><br></pre></td></tr></table></figure><p>这里可以看到，这块区域的大小正是 1M - 8K = 1016k。</p><p>Tips: 通过showmap命令可以看到进程的详细内存占用情况。在实际的开发过程中，当我们要对某个进程做内存占用分析的时候，这个命令是相当有用的。建议读者尝试通过showmap命令查看system_server或其他感兴趣进程的完整map，看看这些进程都依赖了哪些库或者模块，以及内存占用情况是怎样的。</p><h4 id="2-3、与驱动的通信IPCThreadState"><a href="#2-3、与驱动的通信IPCThreadState" class="headerlink" title="2.3、与驱动的通信IPCThreadState"></a>2.3、<strong>与驱动的通信IPCThreadState</strong></h4><p>上文提到ProcessState是一个单例类，一个进程只有一个实例。而负责与Binder驱动通信的IPCThreadState也是一个单例类。但这个类不是一个进程只有一个实例，而是一个线程有一个实例。</p><p>IPCThreadState负责了与驱动通信的细节处理。这个类中的关键几个方法说明如下：</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">transact</td><td style="text-align:left">公开接口。供Proxy发送数据到驱动，并读取返回结果</td></tr><tr><td style="text-align:left">sendReply</td><td style="text-align:left">供Server端写回请求的返回结果</td></tr><tr><td style="text-align:left">waitForResponse</td><td style="text-align:left">发送请求后等待响应结果</td></tr><tr><td style="text-align:left">talkWithDriver</td><td style="text-align:left">通过ioctl BINDER_WRITE_READ来与驱动通信</td></tr><tr><td style="text-align:left">writeTransactionData</td><td style="text-align:left">写入一次事务的数据</td></tr><tr><td style="text-align:left">executeCommand</td><td style="text-align:left">处理binder_driver_return_protocol协议命令</td></tr><tr><td style="text-align:left">freeBuffer</td><td style="text-align:left">通过BC_FREE_BUFFER命令释放Buffer</td></tr></tbody></table><p>BpBinder::transact方法在发送请求的时候，其实就是直接调用了IPCThreadState对应的方法来发送请求到Binder驱动的，相关代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> BpBinder::transact(</span><br><span class="line">    <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mAlive) &#123;</span><br><span class="line">        <span class="keyword">status_t</span> status = IPCThreadState::self()-&gt;transact(</span><br><span class="line">            mHandle, code, data, reply, flags);</span><br><span class="line">        <span class="keyword">if</span> (status == DEAD_OBJECT) mAlive = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DEAD_OBJECT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而IPCThreadState::transact方法主要逻辑如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> IPCThreadState::transact(<span class="keyword">int32_t</span> handle,</span><br><span class="line">                                  <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data,</span><br><span class="line">                                  Parcel* reply, <span class="keyword">uint32_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">status_t</span> err = data.errorCheck();</span><br><span class="line"></span><br><span class="line">    flags |= TF_ACCEPT_FDS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (reply) reply-&gt;setError(err);</span><br><span class="line">        <span class="keyword">return</span> (mLastError = err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; TF_ONE_WAY) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">            err = waitForResponse(reply);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Parcel fakeReply;</span><br><span class="line">            err = waitForResponse(&amp;fakeReply);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        err = waitForResponse(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码应该还是比较好理解的：首先通过writeTransactionData写入数据，然后通过waitForResponse等待返回结果。TF_ONE_WAY表示此次请求是单向的，即：不用真正等待结果即可返回。</p><p>而writeTransactionData方法其实就是在组装binder_transaction_data数据：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> IPCThreadState::writeTransactionData(<span class="keyword">int32_t</span> cmd, <span class="keyword">uint32_t</span> binderFlags,</span><br><span class="line">    <span class="keyword">int32_t</span> handle, <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, <span class="keyword">status_t</span>* statusBuffer)</span><br><span class="line">&#123;</span><br><span class="line">    binder_transaction_data tr;</span><br><span class="line"></span><br><span class="line">    tr.target.ptr = <span class="number">0</span>; <span class="comment">/* Don't pass uninitialized stack data to a remote process */</span></span><br><span class="line">    tr.target.handle = handle;</span><br><span class="line">    tr.code = code;</span><br><span class="line">    tr.flags = binderFlags;</span><br><span class="line">    tr.cookie = <span class="number">0</span>;</span><br><span class="line">    tr.sender_pid = <span class="number">0</span>;</span><br><span class="line">    tr.sender_euid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">status_t</span> err = data.errorCheck();</span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        tr.data_size = data.ipcDataSize();</span><br><span class="line">        tr.data.ptr.buffer = data.ipcData();</span><br><span class="line">        tr.offsets_size = data.ipcObjectsCount()*<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>);</span><br><span class="line">        tr.data.ptr.offsets = data.ipcObjects();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (statusBuffer) &#123;</span><br><span class="line">        tr.flags |= TF_STATUS_CODE;</span><br><span class="line">        *statusBuffer = err;</span><br><span class="line">        tr.data_size = <span class="keyword">sizeof</span>(<span class="keyword">status_t</span>);</span><br><span class="line">        tr.data.ptr.buffer = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(statusBuffer);</span><br><span class="line">        tr.offsets_size = <span class="number">0</span>;</span><br><span class="line">        tr.data.ptr.offsets = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (mLastError = err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mOut.writeInt32(cmd);</span><br><span class="line">    mOut.write(&amp;tr, <span class="keyword">sizeof</span>(tr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于binder_transaction_data在讲解Binder驱动的时候我们已经详细讲解过了。而这里的Parcel我们还不了解，那么接下来我们马上就来看一下这个类。</p><p>数据包装器：Parcel Binder上提供的是跨进程的服务，每个服务包含了不同的接口，每个接口的参数数量和类型都不一样。那么当客户端想要调用服务端的接口，参数是如何跨进程传递给服务端的呢？除此之外，服务端想要给客户端返回结果，结果又是如何传递回来的呢？</p><p>这些问题的答案就是：Parcel。Parcel就像一个包装器，调用者可以以任意顺序往里面放入需要的数据，所有写入的数据就像是被打成一个整体的包，然后可以直接在Binde上传输。</p><p>Parcel提供了所有基本类型的写入和读出接口，下面是其中的一部分：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">status_t</span>            writeInt32(<span class="keyword">int32_t</span> val);</span><br><span class="line"><span class="keyword">status_t</span>            writeUint32(<span class="keyword">uint32_t</span> val);</span><br><span class="line">......</span><br><span class="line"><span class="keyword">status_t</span>            readUtf8FromUtf16(<span class="built_in">std</span>::<span class="built_in">string</span>* str) <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">status_t</span>            readUtf8FromUtf16(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;* str) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>*         <span class="title">readCString</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>因此对于基本类型，开发者可以直接调用接口写入和读出。而对于非基本类型，需要由开发者将其拆分成基本类型然后写入到Parcel中（读出的时候也是一样）。 Parcel会将所有写入的数据进行打包，Parcel本身可以作为一个整体在进程间传递。接收方在收到Parcel之后，只要按写入同样的顺序读出即可。</p><p>这个过程，和我们现实生活中寄送包裹做法是一样的：我们将需要寄送的包裹放到硬纸盒中交给快递公司。快递公司将所有的包裹进行打包，然后集中放到运输车中送到目的地，到了目的地之后然后再进行拆分。</p><p>Parcel既包含C++部分的实现，也同时提供了Java的接口，中间通过JNI衔接。Java层的接口其实仅仅是一层包装，真正的实现都是位于C++部分中。 特别需要说明一下的是，Parcel类除了可以传递基本数据类型，还可以传递Binder对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> Parcel::writeStrongBinder(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; val)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> flatten_binder(ProcessState::self(), val, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法写入的是sp</p><ibinder>类型的对象，而IBinder既可能是本地Binder，也可能是远程Binder，这样我们就不可以不用关心具体细节直接进行Binder对象的传递。</ibinder><p>这也是为什么IInterface中定义了两个asBinder的static方法，如果你不记得了，请回忆一下这两个方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> sp&lt;IBinder&gt;  asBinder(<span class="keyword">const</span> IInterface*);</span><br><span class="line"><span class="keyword">static</span> sp&lt;IBinder&gt;  asBinder(<span class="keyword">const</span> sp&lt;IInterface&gt;&amp;);</span><br></pre></td></tr></table></figure><p>而对于Binder驱动，我们前面已经讲解过：Binder驱动并不是真的将对象在进程间序列化传递，而是由Binder驱动完成了对于Binder对象指针的解释和翻译，使调用者看起来就像在进程间传递对象一样。</p><h4 id="2-4、Framework层的线程管理"><a href="#2-4、Framework层的线程管理" class="headerlink" title="2.4、Framework层的线程管理"></a>2.4、<strong>Framework层的线程管理</strong></h4><p>在讲解Binder驱动的时候，我们就讲解过驱动中对应线程的管理。这里我们再来看看，Framework层是如何与驱动层对接进行线程管理的。</p><p>ProcessState::setThreadPoolMaxThreadCount 方法中，会通过BINDER_SET_MAX_THREADS命令设置进程支持的最大线程数量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_MAX_BINDER_THREADS 15</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> ProcessState::setThreadPoolMaxThreadCount(<span class="keyword">size_t</span> maxThreads) &#123;</span><br><span class="line">    <span class="keyword">status_t</span> result = NO_ERROR;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(mDriverFD, BINDER_SET_MAX_THREADS, &amp;maxThreads) != <span class="number">-1</span>) &#123;</span><br><span class="line">        mMaxThreads = maxThreads;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = -errno;</span><br><span class="line">        ALOGE(<span class="string">"Binder ioctl to set max threads failed: %s"</span>, strerror(-result));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此驱动便知道了该Binder服务支持的最大线程数。驱动在运行过程中，会根据需要，并在没有超过上限的情况下，通过BR_SPAWN_LOOPER命令通知进程创建线程：</p><p>IPCThreadState在收到BR_SPAWN_LOOPER请求之后，便会调用ProcessState::spawnPooledThread来创建线程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> IPCThreadState::executeCommand(<span class="keyword">int32_t</span> cmd)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> BR_SPAWN_LOOPER:</span><br><span class="line">        mProcess-&gt;spawnPooledThread(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ProcessState::spawnPooledThread方法负责为线程设定名称并创建线程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ProcessState::spawnPooledThread(<span class="keyword">bool</span> isMain)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mThreadPoolStarted) &#123;</span><br><span class="line">        String8 name = makeBinderThreadName();</span><br><span class="line">        ALOGV(<span class="string">"Spawning new pooled thread, name=%s\n"</span>, name.<span class="built_in">string</span>());</span><br><span class="line">        sp&lt;Thread&gt; t = <span class="keyword">new</span> PoolThread(isMain);</span><br><span class="line">        t-&gt;run(name.<span class="built_in">string</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程在run之后，会调用threadLoop将自身添加的线程池中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">threadLoop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   IPCThreadState::self()-&gt;joinThreadPool(mIsMain);</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而IPCThreadState::joinThreadPool方法中，会根据当前线程是否是主线程发送BC_ENTER_LOOPER或者BC_REGISTER_LOOPER命令告知驱动线程已经创建完毕。整个调用流程如下图所示：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/48-Android-binder_thread_create.jpg" alt="Markdown"></p><h3 id="（3）、Android-Binder系统-Native层添加hello服务"><a href="#（3）、Android-Binder系统-Native层添加hello服务" class="headerlink" title="（3）、Android Binder系统-Native层添加hello服务"></a>（3）、Android Binder系统-Native层添加hello服务</h3><h4 id="3-1、Client构造数据，发送数据给驱动"><a href="#3-1、Client构造数据，发送数据给驱动" class="headerlink" title="3.1、Client构造数据，发送数据给驱动"></a>3.1、<strong>Client构造数据，发送数据给驱动</strong></h4><p>首先看一下Native ServiceManager架构图</p><p>只讲数据构造过程。。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/49-Android-addService.jpg" alt="Markdown"></p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/50-Android-binder-BpBinder.png" alt="Markdown"></p><p>构造： [-&gt; IServiceManager.cpp ::BpServiceManager]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> status_t <span class="title">addService</span><span class="params">(<span class="keyword">const</span> String16&amp; name, <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; service, <span class="keyword">bool</span> allowIsolated)</span> </span>&#123;</span><br><span class="line">    Parcel data, reply; <span class="comment">//Parcel是数据通信包</span></span><br><span class="line">    <span class="comment">//写入头信息"android.os.IServiceManager"</span></span><br><span class="line">    data.writeInterfaceToken(IServiceManager::getInterfaceDescriptor());   </span><br><span class="line">    data.writeString16(name);        <span class="comment">// name为 "hello"</span></span><br><span class="line">    data.writeStrongBinder(service); <span class="comment">// HelloService对象，把一个binder实体“打扁”并写入parcel</span></span><br><span class="line">    data.writeInt32(allowIsolated ? <span class="number">1</span> : <span class="number">0</span>); <span class="comment">// allowIsolated= false</span></span><br><span class="line">    <span class="comment">//remote()指向的是BpBinder对象</span></span><br><span class="line">    <span class="keyword">status_t</span> err = remote()-&gt;transact(ADD_SERVICE_TRANSACTION, data, &amp;reply);</span><br><span class="line">    <span class="keyword">return</span> err == NO_ERROR ? reply.readExceptionCode() : err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务注册过程：向ServiceManager注册服务hello Service，服务名为”hello”； 请大家注意上面data.writeStrongBinder()一句，它专门负责把一个binder实体”打扁”并写入parcel。其代码如下：</p><h4 id="3-2-1、-writeStrongBinder"><a href="#3-2-1、-writeStrongBinder" class="headerlink" title="3.2.1、* writeStrongBinder()"></a>3.2.1、<em>* writeStrongBinder()</em></h4><p>[-&gt; parcel.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> Parcel::writeStrongBinder(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; val)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> flatten_binder(ProcessState::self(), val, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-2、flatten-binder"><a href="#3-2-2、flatten-binder" class="headerlink" title="3.2.2、flatten_binder()"></a>3.2.2、<strong>flatten_binder()</strong></h4><p>[-&gt; parcel.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> flatten_binder(<span class="keyword">const</span> sp&lt;ProcessState&gt;&amp; <span class="comment">/*proc*/</span>,</span><br><span class="line">    <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; binder, Parcel* out)</span><br><span class="line">&#123;</span><br><span class="line">    flat_binder_object obj;</span><br><span class="line"></span><br><span class="line">    obj.flags = <span class="number">0x7f</span> | FLAT_BINDER_FLAG_ACCEPTS_FDS;</span><br><span class="line">    <span class="keyword">if</span> (binder != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        IBinder *local = binder-&gt;localBinder(); <span class="comment">//本地Binder不为空</span></span><br><span class="line">        <span class="keyword">if</span> (!local) &#123;</span><br><span class="line">            BpBinder *proxy = binder-&gt;remoteBinder();</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int32_t</span> handle = proxy ? proxy-&gt;handle() : <span class="number">0</span>;</span><br><span class="line">            obj.type = BINDER_TYPE_HANDLE;</span><br><span class="line">            obj.binder = <span class="number">0</span>;</span><br><span class="line">            obj.handle = handle;</span><br><span class="line">            obj.cookie = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//进入该分支</span></span><br><span class="line">            obj.type = BINDER_TYPE_BINDER;</span><br><span class="line">            obj.binder = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(local-&gt;getWeakRefs());</span><br><span class="line">            obj.cookie = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(local);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> finish_flatten_binder(binder, obj, out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/51-Android-Binder-flatten_binder.png" alt="Markdown"></p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/52-Android-Binder-flatten_binder.png" alt="Markdown"></p><p>将Binder对象扁平化，转换成flat_binder_object对象。 看到了吗？”打扁”的意思就是把binder对象整理成flat_binder_object变量，如果打扁的是binder实体，那么flat_binder_object用cookie域记录binder实体的指针，即BBinder指针，而如果打扁的是binder代理，那么flat_binder_object用handle域记录的binder代理的句柄值。</p><blockquote><p>总结：Parcel的数据区域分两个部分：mData和mObjects，所有的数据不管是基础数据类型还是对象实体，全都追加到mData里，mObjects是一个偏移量数组，记录所有存放在mData中的flat_binder_object实体的偏移量。</p></blockquote><h4 id="3-2-3、finish-flatten-binder"><a href="#3-2-3、finish-flatten-binder" class="headerlink" title="3.2.3、finish_flatten_binder()"></a>3.2.3、<strong>finish_flatten_binder()</strong></h4><p>将flat_binder_object写入out。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">static</span> status_t <span class="title">finish_flatten_binder</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; , <span class="keyword">const</span> flat_binder_object&amp; flat, Parcel* out)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> out-&gt;writeObject(flat, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后flatten_binder()调用了一个关键的finish_flatten_binder()函数。这个函数内部会记录下刚刚被扁平化的flat_binder_object在parcel中的位置。说得更详细点儿就是，parcel对象内部会有一个buffer，记录着parcel中所有扁平化的数据，有些扁平数据是普通数据，而另一些扁平数据则记录着binder对象。所以parcel中会构造另一个mObjects数组，专门记录那些binder扁平数据所在的位置，示意图如下：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/53-Android-Binder-parcel.png" alt="Markdown"></p><p>一旦到了向驱动层传递数据的时候，IPCThreadState::writeTransactionData()会先把Parcel数据整理成一个binder_transaction_data数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> IPCThreadState::writeTransactionData(<span class="keyword">int32_t</span> cmd, <span class="keyword">uint32_t</span> binderFlags,</span><br><span class="line">    <span class="keyword">int32_t</span> handle, <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, <span class="keyword">status_t</span>* statusBuffer)</span><br><span class="line">&#123;</span><br><span class="line">    binder_transaction_data tr;</span><br><span class="line"></span><br><span class="line">    tr.target.ptr = <span class="number">0</span>; <span class="comment">/* Don't pass uninitialized stack data to a remote process */</span></span><br><span class="line">    tr.target.handle = handle;</span><br><span class="line">    tr.code = code;</span><br><span class="line">    tr.flags = binderFlags;</span><br><span class="line">    tr.cookie = <span class="number">0</span>;</span><br><span class="line">    tr.sender_pid = <span class="number">0</span>;</span><br><span class="line">    tr.sender_euid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">status_t</span> err = data.errorCheck();</span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        tr.data_size = data.ipcDataSize();</span><br><span class="line">        tr.data.ptr.buffer = data.ipcData();</span><br><span class="line">        tr.offsets_size = data.ipcObjectsCount()*<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>);</span><br><span class="line">        tr.data.ptr.offsets = data.ipcObjects();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (statusBuffer) &#123;</span><br><span class="line">        tr.flags |= TF_STATUS_CODE;</span><br><span class="line">        *statusBuffer = err;</span><br><span class="line">        tr.data_size = <span class="keyword">sizeof</span>(<span class="keyword">status_t</span>);</span><br><span class="line">        tr.data.ptr.buffer = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(statusBuffer);</span><br><span class="line">        tr.offsets_size = <span class="number">0</span>;</span><br><span class="line">        tr.data.ptr.offsets = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (mLastError = err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mOut.writeInt32(cmd);</span><br><span class="line">    mOut.write(&amp;tr, <span class="keyword">sizeof</span>(tr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/54-Android-binder-writeTransactionData.png" alt="Markdown"></p><h4 id="3-2-4-、waitForResponse"><a href="#3-2-4-、waitForResponse" class="headerlink" title="3.2.4 、waitForResponse()"></a>3.2.4 、<strong>waitForResponse()</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> IPCThreadState::waitForResponse(Parcel *reply, <span class="keyword">status_t</span> *acquireResult)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> cmd;</span><br><span class="line">    <span class="keyword">int32_t</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((err=talkWithDriver()) &lt; NO_ERROR) <span class="keyword">break</span>;<span class="comment">//目的就是把上面打包的mOut数据给kernel,接着看taklWithDriver();</span></span><br><span class="line">        cmd = mIn.readInt32();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> BR_REPLY:</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">goto</span> finish;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            err = executeCommand(cmd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">finish:</span><br><span class="line">    .....</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数是与serviceManager通信的主要函数，首先会调用talkWithDriver()方法，将之前的打包在mOut中的数据打包成struct binder_write_read 对象，并通过ioctrl发送给kernel。</p><h4 id="3-2-5、-IPCThreadState-talkWithDriver"><a href="#3-2-5、-IPCThreadState-talkWithDriver" class="headerlink" title="3.2.5、 IPCThreadState::talkWithDriver"></a>3.2.5、 <strong>IPCThreadState::talkWithDriver</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> IPCThreadState::talkWithDriver(<span class="keyword">bool</span> doReceive)</span><br><span class="line">&#123;</span><br><span class="line">    binder_write_read bwr;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> needRead = mIn.dataPosition() &gt;= mIn.dataSize();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> outAvail = (!doReceive || needRead) ? mOut.dataSize() : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//doReceive参数，默认是为true,上面我们看到没有传参数，那么doReceive = 1；</span></span><br><span class="line">    bwr.write_size = outAvail;</span><br><span class="line">    bwr.write_buffer = (<span class="keyword">uintptr_t</span>)mOut.data(); <span class="comment">//将mOut数据指针存放到这里,这就是我们上面打包的数据。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is what we'll read.</span></span><br><span class="line">    <span class="keyword">if</span> (doReceive &amp;&amp; needRead) &#123;</span><br><span class="line">        bwr.read_size = mIn.dataCapacity(); <span class="comment">//注意这里数据的大小，在我们new IPCThreadState对象时，已经初始化为256.</span></span><br><span class="line">        bwr.read_buffer = (<span class="keyword">uintptr_t</span>)mIn.data(); <span class="comment">//mIn数据指针，放到这里</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        bwr.read_size = <span class="number">0</span>;</span><br><span class="line">        bwr.read_buffer = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= <span class="number">0</span>) <span class="comment">//这里通过ioctl将数据写给kernel</span></span><br><span class="line">      .....</span><br><span class="line">    &#125; <span class="keyword">while</span> (err == -EINTR);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数的作用就是将之前打包的数据通过系统调用ioctl发送给kernel，最终发送给kernel的数据是struct binder_write_read对象。该对象已经被打包了3次，它们的包含关系如下所示。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/55-Android-binder-Transaction_data.png" alt="Markdown"></p><h4 id="3-2-6、Client获取服务、处理回复数据过程"><a href="#3-2-6、Client获取服务、处理回复数据过程" class="headerlink" title="3.2.6、Client获取服务、处理回复数据过程"></a>3.2.6、<strong>Client获取服务、处理回复数据过程</strong></h4><p>内核会唤醒Client进程处理回复消息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> IPCThreadState::waitForResponse(Parcel *reply, <span class="keyword">status_t</span> *acquireResult)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> cmd;</span><br><span class="line">    <span class="keyword">int32_t</span> err;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((err=talkWithDriver()) &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">        cmd = mIn.readInt32();</span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">          <span class="keyword">case</span> BR_REPLY:</span><br><span class="line">          &#123;</span><br><span class="line">            binder_transaction_data tr;</span><br><span class="line">            err = mIn.read(&amp;tr, <span class="keyword">sizeof</span>(tr));</span><br><span class="line">            <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tr.flags &amp; TF_STATUS_CODE) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//当reply对象回收时，则会调用freeBuffer来回收内存</span></span><br><span class="line">                    reply-&gt;ipcSetDataReference(</span><br><span class="line">                        <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                        tr.data_size,</span><br><span class="line">                        <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">binder_size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                        tr.offsets_size/<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>),</span><br><span class="line">                        freeBuffer, <span class="keyword">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">          ...     </span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-7、Parcel-ipcSetDataReference"><a href="#3-2-7、Parcel-ipcSetDataReference" class="headerlink" title="3.2.7、Parcel::ipcSetDataReference"></a>3.2.7、<strong>Parcel::ipcSetDataReference</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Parcel::ipcSetDataReference(<span class="keyword">const</span> <span class="keyword">uint8_t</span>* data, <span class="keyword">size_t</span> dataSize,</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">binder_size_t</span>* objects, <span class="keyword">size_t</span> objectsCount, release_func relFunc, <span class="keyword">void</span>* relCookie)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">binder_size_t</span> minOffset = <span class="number">0</span>;</span><br><span class="line">    freeDataNoInit();</span><br><span class="line">    mError = NO_ERROR;</span><br><span class="line">    mData = <span class="keyword">const_cast</span>&lt;<span class="keyword">uint8_t</span>*&gt;(data); <span class="comment">//这是有4个字节的buffer。且存放的数据是0</span></span><br><span class="line">    mDataSize = mDataCapacity = dataSize; <span class="comment">//之前申请的大小就是4个字节。</span></span><br><span class="line">    <span class="comment">//ALOGI("setDataReference Setting data size of %p to %lu (pid=%d)", this, mDataSize, getpid());</span></span><br><span class="line">    mDataPos = <span class="number">0</span>;</span><br><span class="line">    ALOGV(<span class="string">"setDataReference Setting data pos of %p to %zu"</span>, <span class="keyword">this</span>, mDataPos);</span><br><span class="line">    mObjects = <span class="keyword">const_cast</span>&lt;<span class="keyword">binder_size_t</span>*&gt;(objects); <span class="comment">//binder对象其实地址</span></span><br><span class="line">    mObjectsSize = mObjectsCapacity = objectsCount; <span class="comment">//binder对象的个数。</span></span><br><span class="line">    mNextObjectHint = <span class="number">0</span>;</span><br><span class="line">    mOwner = relFunc; <span class="comment">//释放内存的函数，后面我们就不进行了。</span></span><br><span class="line">    mOwnerCookie = relCookie;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mObjectsSize; i++) &#123;</span><br><span class="line">        <span class="keyword">binder_size_t</span> offset = mObjects[i];</span><br><span class="line">        <span class="keyword">if</span> (offset &lt; minOffset) &#123;</span><br><span class="line">            ALOGE(<span class="string">"%s: bad object offset %"</span>PRIu64<span class="string">" &lt; %"</span>PRIu64<span class="string">"\n"</span>,</span><br><span class="line">                  __func__, (<span class="keyword">uint64_t</span>)offset, (<span class="keyword">uint64_t</span>)minOffset);</span><br><span class="line">            mObjectsSize = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        minOffset = offset + <span class="keyword">sizeof</span>(flat_binder_object);</span><br><span class="line">    &#125;</span><br><span class="line">    scanForFds();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面做的工作只是将事务数据分别安放到当前Parcel对象的相应位置。其中scanForFds（）是为了查找返回来的数据中是否有binder对象，这个在获取代理对象时有用。</p><h4 id="3-2-8、readStrongBinder"><a href="#3-2-8、readStrongBinder" class="headerlink" title="3.2.8、readStrongBinder()"></a>3.2.8、<strong>readStrongBinder()</strong></h4><p>[-&gt; Parcel.java]</p><p>readStrongBinder的过程基本是writeStrongBinder逆过程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static jobject android_os_Parcel_readStrongBinder(JNIEnv* env, jclass clazz, jlong nativePtr) &#123;</span><br><span class="line">    Parcel* parcel = reinterpret_cast&lt;Parcel*&gt;(nativePtr);</span><br><span class="line">    if (parcel != NULL) &#123;</span><br><span class="line">        return javaObjectForIBinder(env, parcel-&gt;readStrongBinder());</span><br><span class="line">    &#125;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>javaObjectForIBinder 将native层BpBinder对象转换为Java层BinderProxy对象。</p><h4 id="3-2-9、readStrongBinder-C"><a href="#3-2-9、readStrongBinder-C" class="headerlink" title="3.2.9、readStrongBinder(C++)"></a>3.2.9、<strong>readStrongBinder(C++)</strong></h4><p>[-&gt; Parcel.cpp]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IBinder&gt; Parcel::readStrongBinder() const</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;IBinder&gt; val;</span><br><span class="line">    unflatten_binder(ProcessState::self(), *this, &amp;val);</span><br><span class="line">    return val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-10、unflatten-binder"><a href="#3-2-10、unflatten-binder" class="headerlink" title="3.2.10、unflatten_binder()"></a>3.2.10、<strong>unflatten_binder()</strong></h4><p>[-&gt; Parcel.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> unflatten_binder(<span class="keyword">const</span> sp&lt;ProcessState&gt;&amp; proc, <span class="keyword">const</span> Parcel&amp; in, sp&lt;IBinder&gt;* out) &#123;</span><br><span class="line">    <span class="keyword">const</span> flat_binder_object* flat = in.readObject(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (flat) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (flat-&gt;type) &#123;</span><br><span class="line">            <span class="keyword">case</span> BINDER_TYPE_BINDER:</span><br><span class="line">                *out = <span class="keyword">reinterpret_cast</span>&lt;IBinder*&gt;(flat-&gt;cookie);</span><br><span class="line">                <span class="keyword">return</span> finish_unflatten_binder(<span class="literal">NULL</span>, *flat, in);</span><br><span class="line">            <span class="keyword">case</span> BINDER_TYPE_HANDLE:</span><br><span class="line">                *out = proc-&gt;getStrongProxyForHandle(flat-&gt;handle);</span><br><span class="line">                <span class="comment">//创建BpBinder对象</span></span><br><span class="line">                <span class="keyword">return</span> finish_unflatten_binder(</span><br><span class="line">                    <span class="keyword">static_cast</span>&lt;BpBinder*&gt;(out-&gt;get()), *flat, in);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BAD_TYPE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：readObject()的作用是从Parcel中读取出它所保存的flat_binder_object类型的对象。该对象的类型是BINDER_TYPE_HANDLE，因此会指向BINDER_TYPE_HANDLE对应的switch分支。 (01) 这里的proc是ProcessState对象，执行proc-&gt;getStrongProxyForHandle()会将句柄(MediaPlayerService的Binder引用描述)保存到ProcessState的链表中，然后再创建并返回该句柄的BpBinder对象(即Binder的代理)。在Android Binder机制(四) defaultServiceManager()的实现中有getStrongProxyForHandle()的详细说明，下面只给出getStrongProxyForHandle()代码。 (02) finish_unflatten_binder()中只有return NO_ERROR。</p><h4 id="3-2-11、getStrongProxyForHandle"><a href="#3-2-11、getStrongProxyForHandle" class="headerlink" title="3.2.11、getStrongProxyForHandle()"></a>3.2.11、<strong>getStrongProxyForHandle()</strong></h4><p>[-&gt; ProcessState.cpp]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(int32_t handle)</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;IBinder&gt; result;</span><br><span class="line"></span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line">    //查找handle对应的资源项</span><br><span class="line">    handle_entry* e = lookupHandleLocked(handle);</span><br><span class="line"></span><br><span class="line">    if (e != NULL) &#123;</span><br><span class="line">        IBinder* b = e-&gt;binder;</span><br><span class="line">        if (b == NULL || !e-&gt;refs-&gt;attemptIncWeak(this)) &#123;</span><br><span class="line">            ...</span><br><span class="line">            //当handle值所对应的IBinder不存在或弱引用无效时，则创建BpBinder对象</span><br><span class="line">            b = new BpBinder(handle);</span><br><span class="line">            e-&gt;binder = b;</span><br><span class="line">            if (b) e-&gt;refs = b-&gt;getWeakRefs();</span><br><span class="line">            result = b;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            result.force_set(b);</span><br><span class="line">            e-&gt;refs-&gt;decWeak(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过该方法，最终创建了指向Binder服务端的BpBinder代理对象。</p><h3 id="（4）、Android-Binder系统-Native层获取hello服务"><a href="#（4）、Android-Binder系统-Native层获取hello服务" class="headerlink" title="（4）、Android Binder系统-Native层获取hello服务"></a>（4）、Android Binder系统-Native层获取hello服务</h3><p>经过前面的分析，知道流程基本类似，这里不再继续分析获取hello服务</p><h2 id="五、Android-Binder系统-Framwork-Java层"><a href="#五、Android-Binder系统-Framwork-Java层" class="headerlink" title="五、Android Binder系统-Framwork-Java层"></a>五、Android Binder系统-Framwork-Java层</h2><h3 id="（1）、Android-Binder系统Java层"><a href="#（1）、Android-Binder系统Java层" class="headerlink" title="（1）、Android Binder系统Java层"></a>（1）、Android Binder系统Java层</h3><p>主要结构 Android应用程序使用Java语言开发，Binder框架自然也少不了在Java层提供接口。</p><p>前文中我们看到，Binder机制在C++层已经有了完整的实现。因此Java层完全不用重复实现，而是通过JNI衔接了C++层以复用其实现。</p><p>下图描述了Binder Framework Java层到C++层的衔接关系。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/56-Android-Binder_JNI.png" alt="Markdown"></p><p>这里对图中Java层和JNI层的几个类做一下说明( 关于C++层的讲解请看这里 )：</p><p>这里的IInterface，IBinder和C++层的两个类是同名的。这个同名并不是巧合：它们不仅仅同名，它们所起的作用，以及其中包含的接口都是几乎一样的，区别仅仅在于一个是C++层，一个是Java层而已。</p><p>除了IInterface，IBinder之外，这里Binder与BinderProxy类也是与C++的类对应的，下面列出了Java层和C++层类的对应关系：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/57-Android-binder-Java-class.png" alt="Markdown"></p><p>除了IInterface，IBinder之外，这里Binder与BinderProxy类也是与C++的类对应的，下面列出了Java层和C++层类的对应关系：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/58-Android-binder-Java-c-class.png" alt="Markdown"></p><h3 id="（2）、JNI的衔接"><a href="#（2）、JNI的衔接" class="headerlink" title="（2）、JNI的衔接"></a>（2）、JNI的衔接</h3><p>JNI全称是Java Native Interface，这个是由Java虚拟机提供的机制。这个机制使得native代码可以和Java代码互相通讯。简单来说就是：我们可以在C/C++端调用Java代码，也可以在Java端调用C/C++代码。</p><p>关于JNI的详细说明，可以参见Oracle的官方文档：Java Native Interface ，这里不多说明。</p><p>实际上，在Android中很多的服务或者机制都是在C/C++层实现的，想要将这些实现复用到Java层，就必须通过JNI进行衔接。AOSP源码中，/frameworks/base/core/jni/ 目录下的源码就是专门用来对接Framework层的JNI实现的。</p><p>看一下Binder.java的实现就会发现，这里面有不少的方法都是用native关键字修饰的，并且没有方法实现体，这些方法其实都是在C++中android_util_Binder.cpp实现的： 那么，那么，C++是如何调用Java的呢？最关键的，libbinder中的BBinder::onTransact是如何能够调用到Java中的Binder::onTransact的呢？<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/59-Android-binder-JavaBBinder.png" alt="Markdown"></p><p>这段逻辑就是android_util_Binder.cpp中JavaBBinder::onTransact中处理的了。JavaBBinder是BBinder子类，其类结构如下：libbinder中的BBinder::onTransact是如何能够调用到Java中的Binder::onTransact的呢？ JavaBBinder::onTransact关键代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> status_t <span class="title">onTransact</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   JNIEnv* env = javavm_to_jnienv(mVM);</span><br><span class="line"></span><br><span class="line">   IPCThreadState* thread_state = IPCThreadState::self();</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">int32_t</span> strict_policy_before = thread_state-&gt;getStrictModePolicy();</span><br><span class="line"></span><br><span class="line">   jboolean res = env-&gt;CallBooleanMethod(mObject, gBinderOffsets.mExecTransact,</span><br><span class="line">       code, <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(&amp;data), <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(reply), flags);</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意这段代码中的这一行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jboolean res = env-&gt;CallBooleanMethod(mObject, gBinderOffsets.mExecTransact,</span><br><span class="line">  code, <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(&amp;data), <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(reply), flags);</span><br></pre></td></tr></table></figure><p>这一行代码其实是在调用mObject上offset为mExecTransact的方法。这里的几个参数说明如下：</p><p>mObject 指向了Java端的Binder对象 gBinderOffsets.mExecTransact 指向了Binder类的execTransact方法 data 调用execTransact方法的参数 code, data, reply, flags都是传递给调用方法execTransact的参数 而JNIEnv.CallBooleanMethod这个方法是由虚拟机实现的。即：虚拟机会提供native方法来调用一个Java Object上的方法（关于Android上的Java虚拟机，今后我们会专门讲解）。</p><p>这样，就在C++层的JavaBBinder::onTransact中调用了Java层Binder::execTransact方法。而在Binder::execTransact方法中，又调用了自身的onTransact方法，由此保证整个过程串联了起来：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> boolean <span class="title">execTransact</span><span class="params">(<span class="keyword">int</span> code, <span class="keyword">long</span> dataObj, <span class="keyword">long</span> replyObj,</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">   Parcel data = Parcel.obtain(dataObj);</span><br><span class="line">   Parcel reply = Parcel.obtain(replyObj);</span><br><span class="line">   boolean res;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       res = onTransact(code, data, reply, flags);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (RemoteException|RuntimeException e) &#123;</span><br><span class="line">       <span class="keyword">if</span> (LOG_RUNTIME_EXCEPTION) &#123;</span><br><span class="line">           Log.w(TAG, <span class="string">"Caught a RuntimeException from the binder stub implementation."</span>, e);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> ((flags &amp; FLAG_ONEWAY) != <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (e instanceof RemoteException) &#123;</span><br><span class="line">               Log.w(TAG, <span class="string">"Binder call failed."</span>, e);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               Log.w(TAG, <span class="string">"Caught a RuntimeException from the binder stub implementation."</span>, e);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           reply.setDataPosition(<span class="number">0</span>);</span><br><span class="line">           reply.writeException(e);</span><br><span class="line">       &#125;</span><br><span class="line">       res = <span class="literal">true</span>;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (OutOfMemoryError e) &#123;</span><br><span class="line">       RuntimeException re = <span class="keyword">new</span> RuntimeException(<span class="string">"Out of memory"</span>, e);</span><br><span class="line">       reply.setDataPosition(<span class="number">0</span>);</span><br><span class="line">       reply.writeException(re);</span><br><span class="line">       res = <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   checkParcel(<span class="keyword">this</span>, code, reply, <span class="string">"Unreasonably large binder reply buffer"</span>);</span><br><span class="line">   reply.recycle();</span><br><span class="line">   data.recycle();</span><br><span class="line"></span><br><span class="line">   StrictMode.clearGatheredViolations();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（3）、Java层的ServiceManager"><a href="#（3）、Java层的ServiceManager" class="headerlink" title="（3）、Java层的ServiceManager"></a>（3）、Java层的ServiceManager</h3><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/60-Android-binder-class_ServiceManager_java.jpg" alt="Markdown"></p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/61-Android-binder-ServiceManager_Java.png" alt="Markdown"></p><p>通过这个类图我们看到，Java层的ServiceManager和C++层的接口是一样的。</p><p>通过这个类图我们看到，Java层的ServiceManager和C++层的接口是一样的。</p><p>然后我们再选取addService方法看一下实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addService</span><span class="params">(String name, IBinder service, <span class="keyword">boolean</span> allowIsolated)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       getIServiceManager().addService(name, service, allowIsolated);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">       Log.e(TAG, <span class="string">"error in addService"</span>, e);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> IServiceManager <span class="title">getIServiceManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (sServiceManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> sServiceManager;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Find the service manager</span></span><br><span class="line">   sServiceManager = ServiceManagerNative.asInterface(BinderInternal.getContextObject());</span><br><span class="line">   <span class="keyword">return</span> sServiceManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很显然，这段代码中，最关键就是下面这个调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServiceManagerNative.asInterface(BinderInternal.getContextObject());</span><br></pre></td></tr></table></figure><p>然后我们需要再看一下BinderInternal.getContextObject()和ServiceManagerNative.asInterface两个方法。</p><p>BinderInternal.getContextObject()是一个JNI方法，其实现代码在android_util_Binder.cpp中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jobject <span class="title">android_os_BinderInternal_getContextObject</span><span class="params">(JNIEnv* env, jobject clazz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sp&lt;IBinder&gt; b = ProcessState::self()-&gt;getContextObject(NULL);</span><br><span class="line">    <span class="keyword">return</span> javaObjectForIBinder(env, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而ServiceManagerNative.asInterface的实现和其他的Binder服务是一样的套路：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> IServiceManager <span class="title">asInterface</span><span class="params">(IBinder obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   IServiceManager in =</span><br><span class="line">       (IServiceManager)obj.queryLocalInterface(descriptor);</span><br><span class="line">   <span class="keyword">if</span> (in != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> in;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ServiceManagerProxy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先通过queryLocalInterface查看能不能获得本地Binder，如果无法获取，则创建并返回ServiceManagerProxy对象。</p><p>而ServiceManagerProxy自然也是和其他Binder Proxy一样的实现套路：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addService</span><span class="params">(String name, IBinder service, <span class="keyword">boolean</span> allowIsolated)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">   Parcel data = Parcel.obtain();</span><br><span class="line">   Parcel reply = Parcel.obtain();</span><br><span class="line">   data.writeInterfaceToken(IServiceManager.descriptor);</span><br><span class="line">   data.writeString(name);</span><br><span class="line">   data.writeStrongBinder(service);</span><br><span class="line">   data.writeInt(allowIsolated ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">   mRemote.transact(ADD_SERVICE_TRANSACTION, data, reply, <span class="number">0</span>);</span><br><span class="line">   reply.recycle();</span><br><span class="line">   data.recycle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来的调用流程前面已经分析过了，在此就不再分析了。 </p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/62-Android-binder-binder_ipc_process.jpg" alt="Markdown"></p><h2 id="六、Android-Binder系统-AIDL"><a href="#六、Android-Binder系统-AIDL" class="headerlink" title="六、Android Binder系统-AIDL"></a>六、Android Binder系统-AIDL</h2><p>作为Binder机制的最后一个部分内容，我们来讲解一下开发者经常使用的AIDL机制是怎么回事。</p><p>AIDL全称是Android Interface Definition Language，它是Android SDK提供的一种机制。借助这个机制，应用可以提供跨进程的服务供其他应用使用。AIDL的详细说明可以参见官方开发文档：<a href="https://developer.android.com/guide/components/aidl.html" target="_blank" rel="noopener">https://developer.android.com/guide/components/aidl.html</a> 。</p><p>这里，我们就以官方文档上的例子看来一下AIDL与Binder框架的关系。</p><p>开发一个基于AIDL的Service需要三个步骤：</p><p>定义一个.aidl文件 实现接口 暴露接口给客户端使用 aidl文件使用Java语言的语法来定义，每个.aidl文件只能包含一个interface，并且要包含interface的所有方法声明。</p><p>默认情况下，AIDL支持的数据类型包括：</p><p>基本数据类型（即int，long，char，boolean等） String CharSequence List（List的元素类型必须是AIDL支持的） Map（Map中的元素必须是AIDL支持的） 对于AIDL中的接口，可以包含0个或多个参数，可以返回void或一个值。所有非基本类型的参数必须包含一个描述是数据流向的标签，可能的取值是：in，out或者inout。</p><p>下面是一个aidl文件的示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// IRemoteService.aidl</span><br><span class="line">package com.example.android;</span><br><span class="line"></span><br><span class="line">// Declare any non-default types here with import statements</span><br><span class="line"></span><br><span class="line">/** Example service interface */</span><br><span class="line">interface IRemoteService &#123;</span><br><span class="line">    /** Request the process ID of this service, to do evil things with it. */</span><br><span class="line">    int getPid();</span><br><span class="line"></span><br><span class="line">    /** Demonstrates some basic types that you can use as parameters</span><br><span class="line">     * and return values in AIDL.</span><br><span class="line">     */</span><br><span class="line">    void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat,</span><br><span class="line">            double aDouble, String aString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个文件中包含了两个接口 ：</p><p>getPid 一个无参的接口，返回值类型为int basicTypes，包含了几个基本类型作为参数的接口，无返回值 对于包含.aidl文件的工程，Android IDE（以前是Eclipse，现在是Android Studio）在编译项目的时候，会为aidl文件生成对应的Java文件。</p><p>针对上面这个aidl文件生成的java文件中包含的结构如下图所示：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/63-Android-binder-aidl_java.png" alt="Markdown"></p><p>在这个生成的Java文件中，包括了：</p><p>一个名称为IRemoteService的interface，该interface继承自android.os.IInterface并且包含了我们在aidl文件中声明的接口方法 IRemoteService中包含了一个名称为Stub的静态内部类，这个类是一个抽象类，它继承自android.os.Binder并且实现了IRemoteService接口。这个类中包含了一个onTransact方法 Stub内部又包含了一个名称为Proxy的静态内部类，Proxy类同样实现了IRemoteService接口 仔细看一下Stub类和Proxy两个中包含的方法，是不是觉得很熟悉？是的，这里和前面介绍的服务实现是一样的模式。这里我们列一下各层类的对应关系：</p><table><thead><tr><th style="text-align:center">C++层</th><th style="text-align:center">Java层</th><th style="text-align:center">AIDL</th></tr></thead><tbody><tr><td style="text-align:center">BpXXX</td><td style="text-align:center">XXXProxy</td><td style="text-align:center">IXXX.Stub.Proxy</td></tr><tr><td style="text-align:center">BnXXX</td><td style="text-align:center">XXXNative</td><td style="text-align:center">IXXX.Stub</td></tr></tbody></table><p>为了整个结构的完整性，最后我们还是来看一下生成的Stub和Proxy类中的实现逻辑。</p><p>Stub是提供给开发者实现业务的父类，而Proxy的实现了对外提供的接口。Stub和Proxy两个类都有一个asBinder的方法。</p><p>Stub类中的asBinder实现就是返回自身对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Override</span><br><span class="line"><span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而Proxy中asBinder的实现是返回构造函数中获取的mRemote对象，相关代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> android.os.IBinder mRemote;</span><br><span class="line"></span><br><span class="line">Proxy(android.os.IBinder remote) &#123;</span><br><span class="line">    mRemote = remote;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Override</span><br><span class="line"><span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mRemote;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而这里的mRemote对象其实就是远程服务在当前进程的标识。</p><p>上文我们说了，Stub类是用来提供给开发者实现业务逻辑的父类，开发者者继承自Stub然后完成自己的业务逻辑实现，例如这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> IRemoteService.Stub mBinder = <span class="keyword">new</span> IRemoteService.Stub() &#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPid</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> Process.myPid();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">basicTypes</span><span class="params">(<span class="keyword">int</span> anInt, <span class="keyword">long</span> aLong, <span class="keyword">boolean</span> aBoolean,</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">float</span> aFloat, <span class="keyword">double</span> aDouble, String aString)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// Does something</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而这个Proxy类，就是用来给调用者使用的对外接口。我们可以看一下Proxy中的接口到底是如何实现的：</p><p>Proxy中getPid方法实现如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPid</span><span class="params">()</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">    android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">    android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">    <span class="keyword">int</span> _result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">        mRemote.transact(Stub.TRANSACTION_getPid, _data, _reply, <span class="number">0</span>);</span><br><span class="line">        _reply.readException();</span><br><span class="line">        _result = _reply.readInt();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        _reply.recycle();</span><br><span class="line">        _data.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是通过Parcel对象以及transact调用对应远程服务的接口。而在Stub类中，生成的onTransact方法对应的处理了这里的请求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">    <span class="keyword">case</span> INTERFACE_TRANSACTION: &#123;</span><br><span class="line">        reply.writeString(DESCRIPTOR);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> TRANSACTION_getPid: &#123;</span><br><span class="line">        data.enforceInterface(DESCRIPTOR);</span><br><span class="line">        <span class="keyword">int</span> _result = <span class="keyword">this</span>.getPid();</span><br><span class="line">        reply.writeNoException();</span><br><span class="line">        reply.writeInt(_result);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> TRANSACTION_basicTypes: &#123;</span><br><span class="line">        data.enforceInterface(DESCRIPTOR);</span><br><span class="line">        <span class="keyword">int</span> _arg0;</span><br><span class="line">        _arg0 = data.readInt();</span><br><span class="line">        <span class="keyword">long</span> _arg1;</span><br><span class="line">        _arg1 = data.readLong();</span><br><span class="line">        <span class="keyword">boolean</span> _arg2;</span><br><span class="line">        _arg2 = (<span class="number">0</span> != data.readInt());</span><br><span class="line">        <span class="keyword">float</span> _arg3;</span><br><span class="line">        _arg3 = data.readFloat();</span><br><span class="line">        <span class="keyword">double</span> _arg4;</span><br><span class="line">        _arg4 = data.readDouble();</span><br><span class="line">        java.lang.String _arg5;</span><br><span class="line">        _arg5 = data.readString();</span><br><span class="line">        <span class="keyword">this</span>.basicTypes(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5);</span><br><span class="line">        reply.writeNoException();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>onTransact()所要做的就是：</p><p>根据code区分请求的是哪个接口 通过data来获取请求的参数 调用由子类实现的抽象方法 有了前文的讲解，对于这部分内容应当不难理解了。</p><p>到这里，我们终于讲解完Binder了。</p><p>完整框架： </p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/64-Android-Binder-IPCall.png" alt="Markdown"></p><h2 id="七、参考文档-特别感谢各位前辈的分析和图示-："><a href="#七、参考文档-特别感谢各位前辈的分析和图示-：" class="headerlink" title="七、参考文档(特别感谢各位前辈的分析和图示)："></a>七、参考文档(特别感谢各位前辈的分析和图示)：</h2><p><a href="https://github.com/xdtianyu/SourceAnalysis/blob/master/Binder%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.md" target="_blank" rel="noopener">Binder源码分析</a><br><a href="http://blog.csdn.net/yangwen123/article/category/1609389" target="_blank" rel="noopener">深入分析Android Binder</a><br><a href="http://gityuan.com/tags/#binder" target="_blank" rel="noopener">Binder系列 - Gityuan博客 | 袁辉辉博客</a><br><a href="https://wangkuiwu.github.io/page2/" target="_blank" rel="noopener">Android Binder机制(1) ~ (12) - Wangkuiwu.github.io</a><br><a href="http://www.jcodecraeer.com/tags.php?/Binder/" target="_blank" rel="noopener">Binder机制-关于Binder的文章 - 泡在网上的日子</a><br><a href="http://qiangbo.space/tags/#Android" target="_blank" rel="noopener">理解Android Binder机制 - Qiangbo.space博客</a><br><a href="https://my.oschina.net/youranhongcha/blog?catalog=373547&amp;temp=1505099522160" target="_blank" rel="noopener">红茶一杯话Binder - 悠然红茶</a><br><a href="https://github.com/hehonghui/android-tech-frontier/blob/master/issue-22/Binder%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90.md" target="_blank" rel="noopener">Binder框架解析</a><br><a href="https://mr-cao.gitbooks.io/android/content/android-binder.html" target="_blank" rel="noopener">Android Binder详解</a><br><a href="http://blog.csdn.net/carson_ho/article/details/73560642" target="_blank" rel="noopener">图文详解 Android Binder跨进程通信机制 原理</a><br><a href="http://qiangbo.space/2017-01-15/AndroidAnatomy_Binder_Driver/" target="_blank" rel="noopener">理解Android Binder机制(1/3)：驱动篇-qiangbo.space</a><br><a href="http://qiangbo.space/2017-02-12/AndroidAnatomy_Binder_CPP/" target="_blank" rel="noopener">理解Android Binder机制(2/3)：C++层-qiangbo.space</a><br><a href="http://qiangbo.space/2017-03-15/AndroidAnatomy_Binder_Java/" target="_blank" rel="noopener">理解Android Binder机制(3/3)：Java层-qiangbo.space</a><br><a href="http://light3moon.com/1986/12/20/%E6%96%87%E7%AB%A0%E7%B4%A2%E5%BC%95/#" target="_blank" rel="noopener">Android Binder 分析–系列-light3moon</a><br><a href="http://palanceli.com/categories/Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/page/2/" target="_blank" rel="noopener">Android学习笔记-Binder | Palance’s Blog</a><br><a href="http://blog.csdn.net/armwind/article/category/6282972" target="_blank" rel="noopener">android系统 -Binder - armwind的专栏 - CSDN博客</a><br><a href="http://blog.csdn.net/Bettarwang/article/category/2276043" target="_blank" rel="noopener">Bettarwang的专栏 -Android Binder机制</a><br><a href="http://blog.csdn.net/yangwen123/article/category/1609389" target="_blank" rel="noopener">深入剖析Android系统 - binder - CSDN博客</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android Binder系统概述： Binder是Android系统中大量使用的IPC（Inter-process communication，进程间通讯）机制。无论是应用程序对系统服务的请求，还是应用程序自身提供对外服务，都需要使用到Binder。因此，Binder机制在Android系统中的地位非常重要，可以说，理解Binder是理解Android系统的绝对必要前提。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://zhoujinjian.cc/categories/Android/"/>
    
    
      <category term="Android" scheme="http://zhoujinjian.cc/tags/Android/"/>
    
  </entry>
  
</feed>
